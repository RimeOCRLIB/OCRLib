!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	./test_clang.h	8;"	d
ADAM7_DX	./PNG/lodepng.cpp	/^static const unsigned ADAM7_DX[7] = { 8, 8, 4, 4, 2, 2, 1 }; \/*x delta values*\/$/;"	v	file:
ADAM7_DY	./PNG/lodepng.cpp	/^static const unsigned ADAM7_DY[7] = { 8, 8, 8, 4, 4, 2, 2 }; \/*y delta values*\/$/;"	v	file:
ADAM7_IX	./PNG/lodepng.cpp	/^static const unsigned ADAM7_IX[7] = { 0, 4, 0, 2, 0, 1, 0 }; \/*x start values*\/$/;"	v	file:
ADAM7_IY	./PNG/lodepng.cpp	/^static const unsigned ADAM7_IY[7] = { 0, 0, 4, 0, 2, 0, 1 }; \/*y start values*\/$/;"	v	file:
ADD_MODE	./OCRTypes/OCRTypes.h	/^  ADD_MODE = 1,$/;"	e	enum:ocr::drawConst
ADD_MODE	./OCRTypes/OCRTypes_www.h	/^                ADD_MODE=1,$/;"	e	enum:ocr::drawConst
ADD_TO_GMAP	./OCRTypes/OCRTypes.h	/^  ADD_TO_GMAP = 22,$/;"	e	enum:ocr::dataConst
ALL_FIELD	./OCRTypes/OCRTypes.h	/^  ALL_FIELD = 1024,$/;"	e	enum:ocr::searchModeConst
ALL_LETTER	./OCRTypes/OCRTypes.h	/^  ALL_LETTER = 1,$/;"	e	enum:ocr::drawConst
ALL_LETTER	./OCRTypes/OCRTypes_www.h	/^				ALL_LETTER=1,$/;"	e	enum:ocr::drawConst
ALPHABET_SIZE	./GMemory/GMap/GMap.h	39;"	d
AMD	./OCRTypes/OCRTypes.h	/^enum CpuType { CpuTypeUnknown = 0, Intel, AMD };$/;"	e	enum:ocr::CpuType
AMD	./OCRTypes/OCRTypes_www.h	/^    enum CpuType		{ CpuTypeUnknown=0, Intel, AMD };$/;"	e	enum:ocr::CpuType
ANY_MATCH	./GMemory/GMap/GMap.h	/^		ANY_MATCH=2$/;"	e	enum:ocr::searchParam
ARC	./OCRTypes/OCRTypes.h	/^  ARC = 2,$/;"	e	enum:ocr::__anon11
ASCIToUni	./GLogicProcessor/GLogicProcessor.h	/^	map<string,string>ASCIToUni;    \/\/\/<map of tibetan letters in Unicode and ASCI keyboard layout$/;"	m	class:ocr::GLogicProcessor
ASM_ATT	./config.h	146;"	d
A_LIMIT	./GGraphOCR/GGraphOCR.h	29;"	d
AccurateLetFunction	./GBitset/GBitsetWordTib.cpp	/^  void GBitset::AccurateLetFunction() {$/;"	f	class:GBitset
AccurateLetterDetector	./GBitset/GBitsetWordTib.cpp	/^void GBitset::AccurateLetterDetector() {$/;"	f	class:GBitset
Adam7_deinterlace	./PNG/lodepng.cpp	/^static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)$/;"	f	file:
Adam7_getpassvalues	./PNG/lodepng.cpp	/^static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],$/;"	f	file:
Adam7_interlace	./PNG/lodepng.cpp	/^static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)$/;"	f	file:
Altivec	./OCRTypes/OCRTypes.h	/^  Altivec$/;"	e	enum:ocr::SIMDType
Altivec	./OCRTypes/OCRTypes_www.h	/^    enum SIMDType		{ SIMDUnknown=0, NoSIMD, MMX, SSE, SSE2, SSE3, SSE41, SSE42, Altivec }; $/;"	e	enum:ocr::SIMDType
AmplitudeFilteringDetector	./GBitset/GBitsetNet.cpp	/^void GBitset::AmplitudeFilteringDetector( vector<int> &BufL,$/;"	f	class:GBitset
AmplitudeFrequency	./GBitset/GBitset_algorithm.cpp	/^void GBitset::AmplitudeFrequency(vector<int> &GBuf,int smX,int smY,int scope,int color){$/;"	f	class:GBitset
AmplitudeS	./GBitset/GBitset_algorithm.cpp	/^   void GBitset::AmplitudeS(vector<int> &GBuf, int ms, int &AmSum) {$/;"	f	class:GBitset
Angel	./config.h	/^	void *Angel;$/;"	m	struct:commandData
AutoBorderBtn	./GBitset/GBitset.h	/^ int AutoBorderBtn;  \/\/\/< обработка скана в виде ОДНОГО БЛОКА.$/;"	m	class:ocr::GBitset
AutodetectGradations	./GBitmap/GBitmap.cpp	/^void GBitmap::AutodetectGradations(int invert) {$/;"	f	class:ocr::GBitmap
B	./GBitset/GBitset_Starting.cpp	16;"	d	file:
BASE_LINE	./OCRTypes/OCRTypes.h	/^  BASE_LINE = 1,    \/\/\/< базовая линия в которой проводится поиск точек экстремума$/;"	e	enum:ocr::graphConst
BIGMASK	./OCRTypes/OCRTypes.h	/^  BIGMASK = 10,$/;"	e	enum:ocr::drawConst
BIGMASK	./OCRTypes/OCRTypes_www.h	/^				BIGMASK=10,$/;"	e	enum:ocr::drawConst
BITMAP_32	./OCRTypes/OCRTypes.h	/^  BITMAP_32 = 32,$/;"	e	enum:ocr::drawConst
BITMAP_32	./OCRTypes/OCRTypes_www.h	/^                BITMAP_32=32,$/;"	e	enum:ocr::drawConst
BPMLists	./PNG/lodepng.cpp	/^typedef struct BPMLists$/;"	s	file:
BPMLists	./PNG/lodepng.cpp	/^} BPMLists;$/;"	t	typeref:struct:BPMLists	file:
BPMNode	./PNG/lodepng.cpp	/^typedef struct BPMNode$/;"	s	file:
BPMNode	./PNG/lodepng.cpp	/^} BPMNode;$/;"	t	typeref:struct:BPMNode	file:
BUFF_DICT_SIZE	./GMemory/GMap/GMap.h	/^        ulong BUFF_DICT_SIZE;      \/\/ количество пар букв в словаре. Вычисляется в момент создания словаря$/;"	m	class:ocr::GMap
BezierLength	./GGraphBezier/GGraphFocalLineBezier.cpp	/^    void GGraphBezier::BezierLength(OCRFocalLineBezier &line){$/;"	f	class:ocr::GGraphBezier
BezierLengthApproximate	./GGraphBezier/GGraphFocalLineBezier.cpp	/^    void GGraphBezier::BezierLengthApproximate(OCRFocalLineBezier &line){$/;"	f	class:ocr::GGraphBezier
BezierRasterisation	./GGraphBezier/GGraphFocalLineBezier.cpp	/^    void GGraphBezier::BezierRasterisation(OCRFocalLineBezier &line, vector<OCRPointFloat>&lineBezierPoints){$/;"	f	class:ocr::GGraphBezier
BfIn	./GBitset/GBitset.h	/^ int BfIn;      \/\/\/< текущий размер массива ImBuf$/;"	m	class:ocr::GBitset
BfIn	./OCRAlgorithm/OCRAlgorithm.h	/^		 int BfIn;      \/\/\/< текущий размер массива ImBuf$/;"	m	class:ocr::OCRFilter
BfOu	./GBitset/GBitset.h	/^ int BfOu;      \/\/\/< текущий размер массива ImBuf$/;"	m	class:ocr::GBitset
BfOu	./OCRAlgorithm/OCRAlgorithm.h	/^		 int BfOu;      \/\/\/< текущий размер массива ImBuf$/;"	m	class:ocr::OCRFilter
BilinearGrayRotate	./GBitmap/GBitmapRotate.cpp	/^  void GBitmap::BilinearGrayRotate(double angle){$/;"	f	class:ocr::GBitmap
BitsBuf	./GBitset/GBitset.h	/^ bool *BitsBuf; \/\/\/< bool *B;$/;"	m	class:ocr::GBitset
BitsSummmyWH	./GBitset/GBitset_algorithm.cpp	/^void GBitset::BitsSummmyWH(int NSumm){$/;"	f	class:GBitset
BlockDetector	./GBitset/GBitsetWord.cpp	/^void GBitset::BlockDetector() {$/;"	f	class:GBitset
BlockSum	./GBitset/GBitsetWord.cpp	/^void GBitset::BlockSum() {$/;"	f	class:GBitset
BonPDFToUni	./GLogicProcessor/codePagesConverter.cpp	/^void GLogicProcessor::BonPDFToUni(string &srcStr){$/;"	f	class:GLogicProcessor
BorderWorking	./GBitset/GBitsetPageSegmentation.cpp	/^void GBitset::BorderWorking() {$/;"	f	class:GBitset
Brd	./GBitset/GBitset.h	/^ int Brd;    \/\/\/< аналоги кнопок   ( 1 - кнопока нажата ).$/;"	m	class:ocr::GBitset
BufD	./GMemory/GMap/GMap.h	/^        ulong  *BufD;         \/\/массив адресов разделителей в строках словаря$/;"	m	class:ocr::GMap
BufDR	./GMemory/GMap/GMap.h	/^        ulong  *BufDR;         \/\/массив адресов строк BuffD$/;"	m	class:ocr::GMap
BufDR_vector	./GMemory/GMap/GMap.h	/^        GStr<ulong>*BufDR_vector;$/;"	m	class:ocr::GMap
BufD_vector	./GMemory/GMap/GMap.h	/^        GStr<ulong>*BufD_vector;$/;"	m	class:ocr::GMap
BufDictStr	./GMemory/GMap/GMap.h	/^        vector<int> BufDictStr;$/;"	m	class:ocr::GMap
BufE	./GLogicProcessor/GLogicProcessor.h	/^    unsigned int *BufE;            \/\/ массив (int) для хранения адресов перевода каретки Enter словаря$/;"	m	class:ocr::GLogicProcessor
BufE	./GMemory/GMap/GMap.h	/^        ulong *BufE;            \/\/ массив (int) для хранения адресов перевода каретки Enter словаря$/;"	m	class:ocr::GMap
BufET	./GLogicProcessor/GLogicProcessor.h	/^    unsigned int *BufET;           \/\/ массив (int) для хранения адресов перевода каретки Enter текста$/;"	m	class:ocr::GLogicProcessor
BufET	./GMemory/GMap/GMap.h	/^        ulong *BufET;           \/\/ массив (int) для хранения адресов перевода каретки Enter текста$/;"	m	class:ocr::GMap
BufET_vector	./GMemory/GMap/GMap.h	/^        GStr<ulong>*BufET_vector;$/;"	m	class:ocr::GMap
BufE_vector	./GMemory/GMap/GMap.h	/^        GStr<ulong>*BufE_vector;$/;"	m	class:ocr::GMap
BufHelp	./GBitset/GBitset.h	/^  vector<int> BufHelp;\/\/\/< текущий массив$/;"	m	class:ocr::GBitset
BufIn	./GBitset/GBitset.h	/^ int *BufIn;    \/\/\/< запрос памяти с очисткой 0$/;"	m	class:ocr::GBitset
BufIn	./OCRAlgorithm/OCRAlgorithm.h	/^		 int *BufIn;    \/\/\/< запрос памяти с очисткой 0$/;"	m	class:ocr::OCRFilter
BufL	./GBitset/GBitset.h	/^  vector<int> BufL;   \/\/\/< текущий массив$/;"	m	class:ocr::GBitset
BufLpT	./GMemory/GMap/GMap.h	/^        mSIZE  *BufLpT;$/;"	m	class:ocr::GMap
BufLpT_vector	./GMemory/GMap/GMap.h	/^        GStr<mSIZE>*BufLpT_vector;$/;"	m	class:ocr::GMap
BufM	./GLogicProcessor/GLogicProcessor.h	/^    unsigned short *BufM;          \/\/ зеркальный массив BufM $/;"	m	class:ocr::GLogicProcessor
BufM	./GMemory/GMap/GMap.h	/^        mSIZE *BufM;          \/\/ массив предназначен для получения упакованного кода из исходного кода буквы.$/;"	m	class:ocr::GMap
BufM_vector	./GMemory/GMap/GMap.h	/^        GStr<mSIZE>*BufM_vector;$/;"	m	class:ocr::GMap
BufMp	./GLogicProcessor/GLogicProcessor.h	/^    unsigned short *BufMp;         \/\/ зеркальный массив пар букв BufMp словаря$/;"	m	class:ocr::GLogicProcessor
BufMp	./GMemory/GMap/GMap.h	/^        mSIZE *BufMp;         \/\/ массив BufMp упакованного кода пар букв$/;"	m	class:ocr::GMap
BufMpT	./GLogicProcessor/GLogicProcessor.h	/^    unsigned short *BufMpT;        \/\/ зеркальный массив пар букв BufMpT текста$/;"	m	class:ocr::GLogicProcessor
BufMpT	./GMemory/GMap/GMap.h	/^        mSIZE *BufMpT;        \/\/ массив BufMpT пар букв текста. То же, что и BuffMp для словаря.$/;"	m	class:ocr::GMap
BufMpT_vector	./GMemory/GMap/GMap.h	/^        GStr<mSIZE>*BufMpT_vector;$/;"	m	class:ocr::GMap
BufMp_vector	./GMemory/GMap/GMap.h	/^        GStr<mSIZE>*BufMp_vector;$/;"	m	class:ocr::GMap
BufOu	./GBitset/GBitset.h	/^ int *BufOu;    \/\/\/< запрос памяти с очисткой 0$/;"	m	class:ocr::GBitset
BufOu	./OCRAlgorithm/OCRAlgorithm.h	/^		 int *BufOu;    \/\/\/< запрос памяти с очисткой 0$/;"	m	class:ocr::OCRFilter
BufR	./GBitset/GBitset.h	/^  vector<int> BufR;   \/\/\/< текущий массив$/;"	m	class:ocr::GBitset
BufS	./GBitset/GBitset.h	/^  vector<int> BufS;   \/\/\/< текущий массив$/;"	m	class:ocr::GBitset
BufS	./GGraph/GGraph.h	/^	uint *BufS; \/\/\/<массив адресов начала и конца слайсов (slice)$/;"	m	class:ocr::GGraph
BufT	./GBitset/GBitset.h	/^  vector<int> BufT;   \/\/\/< текущий массив$/;"	m	class:ocr::GBitset
BufTxt	./GMemory/GMap/GMap.h	/^        mSIZE *BufTxt;        \/\/ восстановленная через словарь копия массива распознаваемого текста$/;"	m	class:ocr::GMap
BufTxt_vector	./GMemory/GMap/GMap.h	/^        GStr<mSIZE>*BufTxt_vector;$/;"	m	class:ocr::GMap
BufU	./GLogicProcessor/GLogicProcessor.h	/^    unsigned short *BufU;          \/\/ массив для восстановления исходного кода буквы (разреженного кода)$/;"	m	class:ocr::GLogicProcessor
BufU	./GMemory/GMap/GMap.h	/^        mSIZE *BufU;          \/\/ массив для восстановления исходного кода буквы (разреженного кода)$/;"	m	class:ocr::GMap
BufU_vector	./GMemory/GMap/GMap.h	/^        GStr<mSIZE>*BufU_vector;$/;"	m	class:ocr::GMap
BufUp	./GLogicProcessor/GLogicProcessor.h	/^    unsigned short *BufUp;         \/\/ массив для восстановления исходного кода первой буквы пары    $/;"	m	class:ocr::GLogicProcessor
BufUp	./GMemory/GMap/GMap.h	/^        mSIZE *BufUp;         \/\/ массив для восстановления исходного кода первой буквы пары$/;"	m	class:ocr::GMap
BufUpData	./GMemory/GMap/GMap.h	/^        mSIZE* BufUpData(){ return BufUp;}$/;"	f	class:ocr::GMap
BufUpT	./GLogicProcessor/GLogicProcessor.h	/^    unsigned short *BufUpT;        \/\/ массив для восстановления исходного кода первой буквы пары    $/;"	m	class:ocr::GLogicProcessor
BufUpT	./GMemory/GMap/GMap.h	/^        mSIZE *BufUpT;        \/\/ массив для восстановления исходного кода первой буквы пары$/;"	m	class:ocr::GMap
BufUpT1	./GMemory/GMap/GMap.h	/^        mSIZE *BufUpT1;        \/\/ тоже что и массив BufUpT но состоит из int и служит для вычисление Max длины$/;"	m	class:ocr::GMap
BufUpT1_vector	./GMemory/GMap/GMap.h	/^        GStr<mSIZE>*BufUpT1_vector;$/;"	m	class:ocr::GMap
BufUpT_vector	./GMemory/GMap/GMap.h	/^        GStr<mSIZE>*BufUpT_vector;$/;"	m	class:ocr::GMap
BufUp_vector	./GMemory/GMap/GMap.h	/^        GStr<mSIZE>*BufUp_vector;$/;"	m	class:ocr::GMap
CB_64BIT	./OCRTypes/OCRTypes.h	15;"	d
CB_64BIT	./OCRTypes/OCRTypes_www.h	17;"	d
CB_ASM	./OCRString/cpuTest.cpp	37;"	d	file:
CB_ASM_popfl	./OCRString/cpuTest.cpp	39;"	d	file:
CB_ASM_pushfl	./OCRString/cpuTest.cpp	38;"	d	file:
CERROR_BREAK	./PNG/lodepng.cpp	105;"	d	file:
CERROR_RETURN	./PNG/lodepng.cpp	129;"	d	file:
CERROR_RETURN_ERROR	./PNG/lodepng.cpp	115;"	d	file:
CERROR_TRY_RETURN	./PNG/lodepng.cpp	122;"	d	file:
CGImageWriteToFile	./GPDF/drawPDF.h	/^void CGImageWriteToFile(CGImageRef image, NSString *path) {$/;"	f
CHAT	./OCRTypes/OCRTypes.h	/^  CHAT = 21,$/;"	e	enum:ocr::dataConst
CHAT	./OCRTypes/OCRTypes_www.h	/^        CHAT=21$/;"	e	enum:ocr::dataConst
CIRCLE	./OCRTypes/OCRTypes.h	/^  CIRCLE = 4,$/;"	e	enum:ocr::__anon11
CIRCLE_LINE	./OCRTypes/OCRTypes.h	/^  CIRCLE_LINE = 4$/;"	e	enum:ocr::graphConst
CLCL_ORDER	./PNG/lodepng.cpp	/^static const unsigned CLCL_ORDER[NUM_CODE_LENGTH_CODES]$/;"	v	file:
CLOSE_SOCKET	./OCRTypes/OCRTypes.h	/^  CLOSE_SOCKET = 0,$/;"	e	enum:ocr::dataConst
CLOSE_SOCKET	./OCRTypes/OCRTypes_www.h	/^		CLOSE_SOCKET=0,$/;"	e	enum:ocr::dataConst
CONFIG_H	./config.h	2;"	d
CORPUS_HTML	./OCRTypes/OCRTypes.h	/^  CORPUS_HTML = 18,$/;"	e	enum:ocr::dataConst
CORPUS_HTML	./OCRTypes/OCRTypes_www.h	/^        CORPUS_HTML=18,$/;"	e	enum:ocr::dataConst
CPU_OS32_64	./config.h	91;"	d
CREATOR	./GBitmap/ppm.h	30;"	d
C_f	./OCRAlgorithm/f2c.h	/^typedef VOID C_f;	\/* complex function *\/$/;"	t
C_fp	./OCRAlgorithm/f2c.h	/^typedef \/* Complex *\/ VOID (*C_fp)();$/;"	t
C_fp	./OCRAlgorithm/f2c.h	/^typedef \/* Complex *\/ VOID (*C_fp)(...);$/;"	t
CalculatAmplitude	./GBitset/GBitset.cpp	/^void GBitset::CalculatAmplitude(vector<vector<int> > &INFase,vector<vector<int> > &INGilb){$/;"	f	class:ocr::GBitset
CalculateRotatedSize	./GBitmap/GBitmapRotate.cpp	/^  void GBitmap::CalculateRotatedSize(double angle, int *new_width, int *new_height) {$/;"	f	class:ocr::GBitmap
Character	./GFontEditor/GLetter.h	/^  int Character;$/;"	m	class:ocr::GLetter
Character	./GFontEditor/GLetter.h	/^  int Character;$/;"	m	class:ocr::OCRMatch
Character	./GFontEditor/GLetter.h	/^  int Character;$/;"	m	class:ocr::OCRMatchConst
ClusterMatch	./GGraphOCR/GGraphOCR.h	/^} ClusterMatch;$/;"	t	typeref:struct:ClusterMatchStruct
ClusterMatchStruct	./GGraphOCR/GGraphOCR.h	/^typedef struct ClusterMatchStruct {$/;"	s
ColorTree	./PNG/lodepng.cpp	/^struct ColorTree$/;"	s	file:
ColorTree	./PNG/lodepng.cpp	/^typedef struct ColorTree ColorTree;$/;"	t	typeref:struct:ColorTree	file:
ColumnDetector	./GBitset/GBitsetPageSegmentation.cpp	/^void GBitset::ColumnDetector() {$/;"	f	class:GBitset
ColumnWorking	./GBitset/GBitsetPageSegmentation.cpp	/^void GBitset::ColumnWorking() {$/;"	f	class:GBitset
CombFilter	./GBitset/GBitset_algorithm.cpp	/^  void GBitset::CombFilter(vector<int> &GBuf, int dt, int g) {$/;"	f	class:GBitset
CopyBlock	./GBitset/GBitsetPageSegmentation.cpp	/^void GBitset::CopyBlock() {$/;"	f	class:GBitset
Cor	./OCRAlgorithm/OCRAlgorithm.cpp	/^    float  Cor(float x) {$/;"	f	namespace:ocr
Core	./config.h	/^	void *Core;$/;"	m	struct:commandData
CorePointLocal	./GBitset/GBitsetPoint.cpp	/^void GBitset::CorePointLocal( int xp0, int xp1, int yp0, int yp1 ){$/;"	f	class:GBitset
CoreProcessing	./config.h	/^	int CoreProcessing;$/;"	m	struct:commandData
Cores	./OCRTypes/OCRTypes.h	/^  uint32 Cores;   \/\/ !< Number of cores$/;"	m	struct:ocr::SCpuInfo
Cores	./OCRTypes/OCRTypes_www.h	/^        uint32          Cores;				\/\/ !< Number of cores$/;"	m	struct:ocr::SCpuInfo
CoresSysconf	./OCRTypes/OCRTypes.h	/^  uint32 CoresSysconf; \/\/ !< Number of cores, using the sysconf function$/;"	m	struct:ocr::SCpuInfo
CoresSysconf	./OCRTypes/OCRTypes_www.h	/^        uint32          CoresSysconf;		\/\/ !< Number of cores, using the sysconf function$/;"	m	struct:ocr::SCpuInfo
CorrectLetterH	./GBitset/GBitsetCorrectSqH.cpp	/^void GBitset::CorrectLetterH(){$/;"	f	class:GBitset
CorrectLetterL	./GBitset/GBitsetCorrectSqL.cpp	/^void GBitset::CorrectLetterL(){$/;"	f	class:GBitset
CorrectLetterLH	./GBitset/GBitsetCorrectSqL.cpp	/^void GBitset::CorrectLetterLH(){$/;"	f	class:GBitset
CorrectSqH	./GBitset/GBitsetCorrectSqH.cpp	/^void GBitset::CorrectSqH(){$/;"	f	class:GBitset
CorrectSqL	./GBitset/GBitsetCorrectSqL.cpp	/^void GBitset::CorrectSqL(){$/;"	f	class:GBitset
CorrelationBezierA	./GGraphBezier/GGraphCorrelationBezierFullBezier.cpp	/^    float GGraphBezier::CorrelationBezierA(OCRFocalLineBezier &line1, OCRFocalLineBezier &line2, int pCor){$/;"	f	class:ocr::GGraphBezier
CorrelationBezierB	./GGraphBezier/GGraphCorrelationBezierFullBezier.cpp	/^    float GGraphBezier::CorrelationBezierB(OCRFocalLineBezier &line1, OCRFocalLineBezier &line2, int mirror, int ln, int p1, int p1p2, int p2){$/;"	f	class:ocr::GGraphBezier
CorrelationBezierPart	./GGraphBezier/GGraphCorrelationBezierPartBezier.cpp	/^    float GGraphBezier::CorrelationBezierPart(OCRFocalLineBezier &line1, OCRFocalLineBezier &line2, OCRFocalLineBezier &line3){$/;"	f	class:ocr::GGraphBezier
CorrelationBezierT	./GGraphBezier/GGraphCorrelationBezierFullBezier.cpp	/^    float GGraphBezier::CorrelationBezierT(OCRFocalLineBezier &line1, OCRFocalLineBezier &line2){$/;"	f	class:ocr::GGraphBezier
CpuType	./OCRTypes/OCRTypes.h	/^enum CpuType { CpuTypeUnknown = 0, Intel, AMD };$/;"	g	namespace:ocr
CpuType	./OCRTypes/OCRTypes_www.h	/^    enum CpuType		{ CpuTypeUnknown=0, Intel, AMD };$/;"	g	namespace:ocr
CpuTypeUnknown	./OCRTypes/OCRTypes.h	/^enum CpuType { CpuTypeUnknown = 0, Intel, AMD };$/;"	e	enum:ocr::CpuType
CpuTypeUnknown	./OCRTypes/OCRTypes_www.h	/^    enum CpuType		{ CpuTypeUnknown=0, Intel, AMD };$/;"	e	enum:ocr::CpuType
DA	./config.h	172;"	d
DA	./config.h	181;"	d
DATADIR	./config.h	12;"	d
DC	./config.h	154;"	d
DC	./config.h	178;"	d
DD	./GMemory/GMap/GMap.cpp	595;"	d	file:
DD	./GMemory/GMap/lookupProcessFontMatch3.cpp	6;"	d	file:
DD	./GMemory/GMap/lookupProcessFontMatch3.cpp	8;"	d	file:
DEFAULT_WINDOWSIZE	./PNG/lodepng.cpp	2267;"	d	file:
DG	./config.h	157;"	d
DICT_REPORT_SIZE	./config.h	67;"	d
DICT_REPORT_TEXT	./OCRTypes/OCRTypes.h	/^  DICT_REPORT_TEXT = 2,$/;"	e	enum:ocr::dataConst
DICT_REPORT_USER	./OCRTypes/OCRTypes.h	/^  DICT_REPORT_USER = 3,$/;"	e	enum:ocr::dataConst
DISTANCEBASE	./PNG/lodepng.cpp	/^static const unsigned DISTANCEBASE[30]$/;"	v	file:
DISTANCEEXTRA	./PNG/lodepng.cpp	/^static const unsigned DISTANCEEXTRA[30]$/;"	v	file:
DL	./config.h	153;"	d
DM	./config.h	151;"	d
DM	./config.h	176;"	d
DMAGICKCORE_HDRI_ENABLE	./config.h	300;"	d
DMAGICKCORE_QUANTUM_DEPTH	./config.h	301;"	d
DN	./GLogicProcessor/buidSearchString.cpp	11;"	d	file:
DN	./GLogicProcessor/buidSearchString.cpp	9;"	d	file:
DN	./GMemory/GMap/lookupProcess3.cpp	5;"	d	file:
DN	./GMemory/GMap/lookupProcess3.cpp	7;"	d	file:
DN	./GMemory/GMap/tableDict.cpp	7;"	d	file:
DN	./GMemory/GMap/tableDict.cpp	9;"	d	file:
DN	./GMemory/GMap/tableLetters.cpp	5;"	d	file:
DN	./GMemory/GMap/tableLetters.cpp	7;"	d	file:
DN	./GMemory/GMap/tableProcessingDict.cpp	10;"	d	file:
DN	./GMemory/GMap/tableProcessingDict.cpp	8;"	d	file:
DN	./GMemory/GMap/tableProcessingID.cpp	11;"	d	file:
DN	./GMemory/GMap/tableProcessingID.cpp	9;"	d	file:
DN	./GMemory/GMap/tableText.cpp	5;"	d	file:
DN	./GMemory/GMap/tableText.cpp	7;"	d	file:
DP	./config.h	152;"	d
DP	./config.h	177;"	d
DR	./config.h	166;"	d
DR2	./config.h	168;"	d
DRAW1	./GBitsetContour/GBitsetContour.h	13;"	d
DRAW1	./GBitsetOCR/GBitsetOCR.h	16;"	d
DRAW1	./config.h	57;"	d
DRAW_BASE	./OCRTypes/OCRTypes.h	/^  DRAW_BASE = 0,$/;"	e	enum:ocr::drawConst
DRAW_BASE	./OCRTypes/OCRTypes_www.h	/^				DRAW_BASE=0,$/;"	e	enum:ocr::drawConst
DRAW_BLACK	./OCRTypes/OCRTypes.h	/^  DRAW_BLACK = 1,$/;"	e	enum:ocr::drawConst
DRAW_BLACK	./OCRTypes/OCRTypes_www.h	/^                DRAW_BLACK=1,$/;"	e	enum:ocr::drawConst
DRAW_PC	./config.h	58;"	d
DR_	./config.h	165;"	d
DS	./config.h	170;"	d
DS	./config.h	180;"	d
DS1	./config.h	171;"	d
DT	./config.h	155;"	d
DT	./config.h	179;"	d
DT2	./config.h	159;"	d
DT3	./config.h	161;"	d
DT4	./config.h	163;"	d
D_	./GMemory/GMap/lookupProcessFontMatch3.cpp	34;"	d	file:
D_fp	./OCRAlgorithm/f2c.h	/^typedef doublereal (*D_fp)(), (*E_fp)();$/;"	t
D_fp	./OCRAlgorithm/f2c.h	/^typedef doublereal (*D_fp)(...), (*E_fp)(...);$/;"	t
DeltaKh	./GBitset/GBitset.h	/^  int DeltaKh;     \/\/\/< коэффициент формы страници (100*ncolumns\/srcW*srcH\/nrows;)$/;"	m	class:ocr::GBitset
DeltaNstr	./GBitset/GBitset.h	/^  int DeltaNstr;   \/\/\/< вычисленная высота строки$/;"	m	class:ocr::GBitset
DeltaNstrKH	./GBitset/GBitset.h	/^  int DeltaNstrKH; \/\/\/< вычисленная высота строки с учетом коэффициентов$/;"	m	class:ocr::GBitset
DetectGradations	./GBitmap/GBitmap.cpp	/^  int  GBitmap::DetectGradations() {$/;"	f	class:ocr::GBitmap
DiffLineDetector	./GBitset/GBitsetNet.cpp	/^void GBitset::DiffLineDetector() {$/;"	f	class:GBitset
END	./config.h	187;"	d
ERROR_BREAK	./PNG/lodepng.cpp	112;"	d	file:
EXPORT_FROM_DB	./OCRTypes/OCRTypes.h	/^  EXPORT_FROM_DB = 10,$/;"	e	enum:ocr::dataConst
EXPORT_FROM_DB	./OCRTypes/OCRTypes_www.h	/^        EXPORT_FROM_DB=10,$/;"	e	enum:ocr::dataConst
EXTREM_LINE	./OCRTypes/OCRTypes.h	/^  EXTREM_LINE = 2,  \/\/\/< кривая Bezier между точками экстремума$/;"	e	enum:ocr::graphConst
E_POINT	./OCRTypes/OCRTypes.h	/^  E_POINT = 5,      \/\/\/< точки максимума кривизны кривой$/;"	e	enum:ocr::graphConst
E_f	./OCRAlgorithm/f2c.h	/^typedef doublereal E_f;	\/* real function with -R not specified *\/$/;"	t
E_fp	./OCRAlgorithm/f2c.h	/^typedef doublereal (*D_fp)(), (*E_fp)();$/;"	t
E_fp	./OCRAlgorithm/f2c.h	/^typedef doublereal (*D_fp)(...), (*E_fp)(...);$/;"	t
ExtendedPrecision	./OCRString/cpuTest.cpp	/^static const int16 ExtendedPrecision = 0x300;$/;"	v	file:
Extern	./OCRAlgorithm/f2c.h	35;"	d
F2C_INCLUDE	./OCRAlgorithm/f2c.h	8;"	d
F2C_proc_par_types	./OCRAlgorithm/f2c.h	170;"	d
FALSE_	./OCRAlgorithm/f2c.h	31;"	d
FILE_RESIZE	./GMemory/GVector.h	13;"	d
FIRST_LENGTH_CODE_INDEX	./PNG/lodepng.cpp	466;"	d	file:
FORK	./config.h	27;"	d
FORK	./config.h	44;"	d
FPUDouble	./OCRString/cpuTest.cpp	/^	FPUDouble$/;"	e	enum:FPUState	file:
FPUSingle	./OCRString/cpuTest.cpp	/^	FPUSingle,$/;"	e	enum:FPUState	file:
FPUState	./OCRString/cpuTest.cpp	/^enum FPUState$/;"	g	file:
FPUUnknown	./OCRString/cpuTest.cpp	/^	FPUUnknown = 0,$/;"	e	enum:FPUState	file:
FSIZE	./config.h	16;"	d
FULL_MATCH	./GMemory/GMap/GMap.h	/^		FULL_MATCH=0,$/;"	e	enum:ocr::searchParam
FULL_REPORT	./OCRTypes/OCRTypes.h	/^  FULL_REPORT = 4,$/;"	e	enum:ocr::dataConst
FULL_TEXT_SEARCH	./OCRTypes/OCRTypes.h	/^  FULL_TEXT_SEARCH = 6,$/;"	e	enum:ocr::searchModeConst
FilterIntegral	./GBitmap/GBitmapFilter.cpp	/^  void  GBitmap::FilterIntegral(int BASE) {$/;"	f	class:ocr::GBitmap
FlushMMXRegister	./OCRString/cpuTest.cpp	/^void FlushMMXRegister()$/;"	f	namespace:x86
FrameDetectorL	./GBitset/GBitsetPageSegmentation.cpp	/^void GBitset::FrameDetectorL() {$/;"	f	class:GBitset
FrameDetectorLBase	./GBitset/GBitsetPageSegmentation.cpp	/^void GBitset::FrameDetectorLBase() {$/;"	f	class:GBitset
FunctionSpectrSt	./GBitset/GBitset_algorithm.cpp	/^  void GBitset::FunctionSpectrSt( int *Buf2, int size,  int dt, int &AmSum) {$/;"	f	class:GBitset
FunctionSpectrum	./GBitset/GBitset_algorithm.cpp	/^  void GBitset::FunctionSpectrum( vector<int> &HBuf, int dt, int &AmSum) {$/;"	f	class:GBitset
Function_Lion	./OCRAlgorithm/OCRAlgorithm.cpp	/^void Function_Lion() {$/;"	f	namespace:ocr
GBitMask128	./GBitMask/GBitMask.h	/^class GBitMask128 {$/;"	c	namespace:ocr
GBitMask128	./GBitMask/GBitmask.cpp	/^GBitMask128::GBitMask128(){$/;"	f	class:ocr::GBitMask128
GBitMask32	./GBitMask/GBitMask.h	/^	class GBitMask32 {$/;"	c	namespace:ocr
GBitMask32	./GBitMask/GBitmask.cpp	/^GBitMask32::GBitMask32(){$/;"	f	class:ocr::GBitMask32
GBitMask_H	./GBitMask/GBitMask.h	15;"	d
GBitmap	./GBitmap/GBitmap.cpp	/^GBitmap::GBitmap()$/;"	f	class:ocr::GBitmap
GBitmap	./GBitmap/GBitmap.cpp	/^GBitmap::GBitmap(const GBitmap *ref)$/;"	f	class:ocr::GBitmap
GBitmap	./GBitmap/GBitmap.cpp	/^GBitmap::GBitmap(const GBitmap *ref, float scale, float rotation, int mode)$/;"	f	class:ocr::GBitmap
GBitmap	./GBitmap/GBitmap.cpp	/^GBitmap::GBitmap(const GBitmap *ref, int x0, int y0, int w, int h)$/;"	f	class:ocr::GBitmap
GBitmap	./GBitmap/GBitmap.cpp	/^GBitmap::GBitmap(const char *path)$/;"	f	class:ocr::GBitmap
GBitmap	./GBitmap/GBitmap.cpp	/^GBitmap::GBitmap(int ncolumns, int nrows)$/;"	f	class:ocr::GBitmap
GBitmap	./GBitmap/GBitmap.cpp	/^GBitmap::GBitmap(int ncolumns, int nrows, int mode)$/;"	f	class:ocr::GBitmap
GBitmap	./GBitmap/GBitmap.cpp	/^GBitmap::GBitmap(unsigned char *dataPNG, uint size)$/;"	f	class:ocr::GBitmap
GBitmap	./GBitmap/GBitmap.h	/^class GBitmap {$/;"	c	namespace:ocr
GBitset	./GBitset/GBitset.h	/^class GBitset{$/;"	c	namespace:ocr
GBitset	./GBitset/GBitset_base.cpp	/^GBitset::GBitset()$/;"	f	class:GBitset
GBitset	./GBitset/GBitset_base.cpp	/^GBitset::GBitset(const GBitmap *ref, const GBitmap *ref1)$/;"	f	class:GBitset
GBitset	./GBitset/GBitset_base.cpp	/^GBitset::GBitset(const GBitmap *ref, short stepW, short stepH, short flipV)$/;"	f	class:GBitset
GBitset	./GBitset/GBitset_base.cpp	/^GBitset::GBitset(const GBitset *ref)$/;"	f	class:GBitset
GBitset	./GBitset/GBitset_base.cpp	/^GBitset::GBitset(const GBitset *ref, int border)$/;"	f	class:GBitset
GBitset	./GBitset/GBitset_base.cpp	/^GBitset::GBitset(int nrows, int ncolumns, int border)$/;"	f	class:GBitset
GBitsetContour	./GBitsetContour/GBitsetContour.cpp	/^GBitsetContour::GBitsetContour()$/;"	f	class:GBitsetContour
GBitsetContour	./GBitsetContour/GBitsetContour.cpp	/^GBitsetContour::GBitsetContour(const GBitmap *ref, short stepW, short stepH, short flipV)$/;"	f	class:GBitsetContour
GBitsetContour	./GBitsetContour/GBitsetContour.cpp	/^GBitsetContour::GBitsetContour(const GBitsetContour *ref)$/;"	f	class:GBitsetContour
GBitsetContour	./GBitsetContour/GBitsetContour.cpp	/^GBitsetContour::GBitsetContour(int nrows, int ncolumns)$/;"	f	class:GBitsetContour
GBitsetContour	./GBitsetContour/GBitsetContour.h	/^class GBitsetContour{$/;"	c	namespace:ocr
GBitsetMatrix	./GBitsetMatrix/GBitsetMatrix.h	/^class GBitsetMatrix{$/;"	c	namespace:ocr
GBitsetMatrix	./GBitsetMatrix/GBitsetMatrix_base.cpp	/^GBitsetMatrix::GBitsetMatrix()$/;"	f	class:GBitsetMatrix
GBitsetMatrix	./GBitsetMatrix/GBitsetMatrix_base.cpp	/^GBitsetMatrix::GBitsetMatrix(const GBitmap *ref, short stepW, short stepH, short flipV)$/;"	f	class:GBitsetMatrix
GBitsetMatrix	./GBitsetMatrix/GBitsetMatrix_base.cpp	/^GBitsetMatrix::GBitsetMatrix(const GBitmap *ref, short x, short y, short w, short h, short stepW, short stepH, short flipV)$/;"	f	class:GBitsetMatrix
GBitsetMatrix	./GBitsetMatrix/GBitsetMatrix_base.cpp	/^GBitsetMatrix::GBitsetMatrix(const GBitsetMatrix *ref)$/;"	f	class:GBitsetMatrix
GBitsetMatrix	./GBitsetMatrix/GBitsetMatrix_base.cpp	/^GBitsetMatrix::GBitsetMatrix(const GBitsetMatrix *ref, int border)$/;"	f	class:GBitsetMatrix
GBitsetMatrix	./GBitsetMatrix/GBitsetMatrix_base.cpp	/^GBitsetMatrix::GBitsetMatrix(int nrows, int ncolumns, int border)$/;"	f	class:GBitsetMatrix
GBitsetNet	./GBitset/GBitsetNet.cpp	/^void GBitset::GBitsetNet() {$/;"	f	class:GBitset
GBitsetOCR	./GBitsetOCR/GBitsetOCR.h	/^class GBitsetOCR{$/;"	c	namespace:ocr
GBitsetOCR	./GBitsetOCR/GBitset_baseOCR.cpp	/^GBitsetOCR::GBitsetOCR(const GBitmap *ref, short stepW, short stepH)$/;"	f	class:GBitsetOCR
GBitsetOCR	./GBitsetOCR/GBitset_baseOCR.cpp	/^GBitsetOCR::GBitsetOCR(const GBitsetOCR *ref)$/;"	f	class:GBitsetOCR
GBitsetOCR	./GBitsetOCR/GBitset_baseOCR.cpp	/^GBitsetOCR::GBitsetOCR(const GBitsetOCR *ref, int border)$/;"	f	class:GBitsetOCR
GBitsetOCR	./GBitsetOCR/GBitset_baseOCR.cpp	/^GBitsetOCR::GBitsetOCR(int nrows, int ncolumns, int border)$/;"	f	class:GBitsetOCR
GBuf	./GBitset/GBitset.h	/^  vector<int> GBuf;   \/\/\/< базовый массив$/;"	m	class:ocr::GBitset
GContour	./GFontEditor/GContour.cpp	/^GContour::GContour(){$/;"	f	class:ocr::GContour
GContour	./GFontEditor/GContour.cpp	/^GContour::GContour(int *angX,int *angY,int *andData,int length_,int dir){$/;"	f	class:ocr::GContour
GContour	./GFontEditor/GContour.cpp	/^GContour::GContour(int length_,int dir){$/;"	f	class:ocr::GContour
GContour	./GFontEditor/GContour.h	/^class GContour {$/;"	c	namespace:ocr
GET_LETTERS	./OCRTypes/OCRTypes.h	/^  GET_LETTERS = 4,$/;"	e	enum:ocr::drawConst
GET_LETTERS	./OCRTypes/OCRTypes_www.h	/^				GET_LETTERS=4,$/;"	e	enum:ocr::drawConst
GFont	./GFontEditor/GFont.cpp	/^    GFont::GFont(){$/;"	f	class:ocr::GFont
GFont	./GFontEditor/GFont.cpp	/^    GFont::GFont(const char *path){$/;"	f	class:ocr::GFont
GFont	./GFontEditor/GFont.h	/^    class GFont: public GVector{$/;"	c	namespace:ocr
GFontCount	./GFontEditor/GFontEditor.h	/^        int GFontCount;$/;"	m	class:ocr::GFontEditor
GFontEditor	./GFontEditor/GFontEditor.cpp	/^GFontEditor::GFontEditor(void){$/;"	f	class:GFontEditor
GFontEditor	./GFontEditor/GFontEditor.h	/^    class GFontEditor:public GImageEditor{$/;"	c	namespace:ocr
GFontImg	./GBitsetOCR/GBitsetOCR.h	/^  const GBitmap  *inputBitmap, *GFontImg;               \/\/actual bitmap pointer for input data$/;"	m	class:ocr::GBitsetOCR
GFontSize	./GFontEditor/GLetter.h	/^  int GFontSize;$/;"	m	class:ocr::GLetter
GGraph	./GGraph/GGraph.cpp	/^GGraph::GGraph(const GBitmap *ref) {$/;"	f	class:ocr::GGraph
GGraph	./GGraph/GGraph.cpp	/^GGraph::GGraph(int acolumns, int arows) {$/;"	f	class:ocr::GGraph
GGraph	./GGraph/GGraph.cpp	/^GGraph::GGraph(int acolumns, int arows, int mode) {$/;"	f	class:ocr::GGraph
GGraph	./GGraph/GGraph.h	/^class GGraph : public GBitmap {$/;"	c	namespace:ocr
GGraphBezier	./GGraphBezier/GGraphBezier.cpp	/^GGraphBezier::GGraphBezier(){$/;"	f	class:ocr::GGraphBezier
GGraphBezier	./GGraphBezier/GGraphBezier.cpp	/^GGraphBezier::GGraphBezier(const GBitmap* ref){$/;"	f	class:ocr::GGraphBezier
GGraphBezier	./GGraphBezier/GGraphBezier.cpp	/^GGraphBezier::GGraphBezier(const GBitmap* ref, float scale, float rotation,int mode){$/;"	f	class:ocr::GGraphBezier
GGraphBezier	./GGraphBezier/GGraphBezier.cpp	/^GGraphBezier::GGraphBezier(const GBitmap* ref, int x0,int y0, int w, int h){$/;"	f	class:ocr::GGraphBezier
GGraphBezier	./GGraphBezier/GGraphBezier.cpp	/^GGraphBezier::GGraphBezier(int acolumns, int arows){$/;"	f	class:ocr::GGraphBezier
GGraphBezier	./GGraphBezier/GGraphBezier.cpp	/^GGraphBezier::GGraphBezier(int acolumns, int arows,int mode){$/;"	f	class:ocr::GGraphBezier
GGraphBezier	./GGraphBezier/GGraphBezier.cpp	/^GGraphBezier::GGraphBezier(string &inputData,int invert_){$/;"	f	class:ocr::GGraphBezier
GGraphBezier	./GGraphBezier/GGraphBezier.h	/^    class  GGraphBezier : public GBitmap{$/;"	c	namespace:ocr
GGraphOCR	./GGraphOCR/GGraphOCR.cpp	/^GGraphOCR::GGraphOCR(void) {$/;"	f	class:ocr::GGraphOCR
GGraphOCR	./GGraphOCR/GGraphOCR.h	/^class GGraphOCR {$/;"	c	namespace:ocr
GIF	./OCRTypes/OCRTypes.h	/^  GIF = 1,$/;"	e	enum:ocr::drawConst
GIF	./OCRTypes/OCRTypes_www.h	/^				GIF=1,$/;"	e	enum:ocr::drawConst
GLetter	./GFontEditor/GLetter.cpp	/^GLetter::GLetter(){$/;"	f	class:GLetter
GLetter	./GFontEditor/GLetter.h	/^class GLetter {$/;"	c	namespace:ocr
GLogicProcessor	./GLogicProcessor/GLogicProcessor.cpp	/^    GLogicProcessor::GLogicProcessor(){$/;"	f	class:ocr::GLogicProcessor
GLogicProcessor	./GLogicProcessor/GLogicProcessor.h	/^class  GLogicProcessor {$/;"	c	namespace:ocr
GMainEditor	./GMainEditor/GMainEditor.cpp	/^	GMainEditor::GMainEditor(){$/;"	f	class:ocr::GMainEditor
GMainEditor	./GMainEditor/GMainEditor.h	/^    class  GMainEditor{$/;"	c	namespace:ocr
GMap	./GMemory/GMap/GMap.cpp	/^GMap::GMap(string &path){$/;"	f	class:GMap
GMap	./GMemory/GMap/GMap.cpp	/^GMap::GMap(string &path,GVector *data){$/;"	f	class:GMap
GMap	./GMemory/GMap/GMap.cpp	/^GMap::GMap(string &path,GVector *dataText,GStr<mSIZE> *dataDict){$/;"	f	class:GMap
GMap	./GMemory/GMap/GMap.h	/^    class  GMap{$/;"	c	namespace:ocr
GMemory	./GMemory/GMemory.cpp	/^GMemory::GMemory()$/;"	f	class:ocr::GMemory
GMemory	./GMemory/GMemory.h	/^class GMemory$/;"	c	namespace:ocr
GPDF	./GPDF/GPDF.h	/^class  GPDF {$/;"	c	namespace:ocr
GRAMMAR_LOG	./config.h	71;"	d
GStr	./GMemory/GVector.h	/^GStr<T>::GStr() {$/;"	f	class:ocr::GStr
GStr	./GMemory/GVector.h	/^GStr<T>::GStr(GVector *parentVector, cstr name) {$/;"	f	class:ocr::GStr
GStr	./GMemory/GVector.h	/^GStr<T>::GStr(cstr path) {$/;"	f	class:ocr::GStr
GStr	./GMemory/GVector.h	/^GStr<T>::GStr(int sizePool) {$/;"	f	class:ocr::GStr
GStr	./GMemory/GVector.h	/^class GStr$/;"	c	namespace:ocr
GStr2D	./GMemory/GVector.h	/^GStr2D<T>::GStr2D() {$/;"	f	class:ocr::GStr2D
GStr2D	./GMemory/GVector.h	/^class GStr2D: public GStr<T>$/;"	c	namespace:ocr
GString	./OCRTypes/OCRTypes.cpp	/^GString::GString() {$/;"	f	class:ocr::GString
GString	./OCRTypes/OCRTypes.h	/^class GString {$/;"	c	namespace:ocr
GTextBufer	./OCRTypes/OCRTypes.h	/^class GTextBufer {$/;"	c	namespace:ocr
GTextBufer	./OCRTypes/OCRTypes_www.h	/^class GTextBufer {$/;"	c	namespace:ocr
GVector	./GMemory/GVector.cpp	/^GVector::GVector(GVector *parentVector, cstr name) {$/;"	f	class:GVector
GVector	./GMemory/GVector.cpp	/^GVector::GVector(char *data_, int mode) {$/;"	f	class:GVector
GVector	./GMemory/GVector.cpp	/^GVector::GVector(const char *path) {$/;"	f	class:GVector
GVector	./GMemory/GVector.cpp	/^GVector::GVector(string &path) {$/;"	f	class:GVector
GVector	./GMemory/GVector.cpp	/^GVector::GVector(void) {$/;"	f	class:GVector
GVector	./GMemory/GVector.h	/^class GVector$/;"	c	namespace:ocr
GenerateFullTibetanNameSpace	./TibetanNameSpace/TibNameSpaceGenerator.h	/^void GenerateFullTibetanNameSpace($/;"	f
GetCpuInfo	./OCRString/cpuTest.cpp	/^const SCpuInfo &GetCpuInfo()$/;"	f
GetFPUState	./OCRString/cpuTest.cpp	/^static inline int32 GetFPUState()$/;"	f	file:
GetFlags	./OCRString/cpuTest.cpp	/^inline uint16 GetFlags()$/;"	f
GetNumLinuxKernel	./OCRString/cpuTest.cpp	/^void GetNumLinuxKernel()$/;"	f
GetNumPhysicalCpus	./OCRString/cpuTest.cpp	/^inline uint32 GetNumPhysicalCpus()$/;"	f
GrafT	./GBitset/GBitset.h	/^  signed  char GrafT[32][16]; \/\/\/< массив управления графикой во всех подпрограммах$/;"	m	class:ocr::GBitset
GravTxt	./GMemory/GMap/GMap.h	/^        mSIZE *GravTxt;       \/\/ буферный массив суммарных весов пар букв текста во всех легитимных фрагментах фраз словаря.$/;"	m	class:ocr::GMap
GravTxt_vector	./GMemory/GMap/GMap.h	/^        GStr<mSIZE>*GravTxt_vector;$/;"	m	class:ocr::GMap
HANDLE	./GMemory/MmapFile.h	/^	typedef void *HANDLE;$/;"	t	class:InputMemoryFile
HANDLE	./GMemory/MmapFile.h	/^	typedef void *HANDLE;$/;"	t	class:MemoryFile
HASH_BIT_MASK	./PNG/lodepng.cpp	/^static const unsigned HASH_BIT_MASK = 65535; \/*HASH_NUM_VALUES - 1, but C90 does not like that as initializer*\/$/;"	v	file:
HASH_DICTIONARY	./config.h	76;"	d
HASH_FIND	./OCRTypes/OCRTypes.h	/^  HASH_FIND = 5,$/;"	e	enum:ocr::dataConst
HASH_FIND	./OCRTypes/OCRTypes_www.h	/^		HASH_FIND=5,$/;"	e	enum:ocr::dataConst
HASH_NUM_VALUES	./PNG/lodepng.cpp	/^static const unsigned HASH_NUM_VALUES = 65536;$/;"	v	file:
HASH_PATH	./config.h	11;"	d
HASH_SEARCH	./OCRTypes/OCRTypes.h	/^  HASH_SEARCH = 1,$/;"	e	enum:ocr::searchModeConst
HBuf	./GBitset/GBitset.h	/^  vector<int> HBuf;   \/\/\/< базовый массив$/;"	m	class:ocr::GBitset
HEADER_GBITSETOCR	./GBitsetOCR/GBitsetOCR.h	2;"	d
HEADER_GContour	./GFontEditor/GContour.h	2;"	d
HEADER_GFont	./GFontEditor/GFont.h	2;"	d
HEADER_GFontEditor	./GFontEditor/GFontEditor.h	2;"	d
HEADER_GLetter	./GFontEditor/GLetter.h	2;"	d
HEADER_OCRALGORITHM	./OCRAlgorithm/OCRAlgorithm.h	16;"	d
HEADER_OCRTYPES	./OCRTypes/OCRTypes.h	2;"	d
HEADER_OCRTYPES	./OCRTypes/OCRTypes_www.h	2;"	d
HStS	./GBitset/GBitset.h	/^  vector<int> HStS;   \/\/\/ массив заполненный горизонтальными дифференциальными суммами$/;"	m	class:ocr::GBitset
HStr	./GBitset/GBitset.h	/^  vector<int> HStr;   \/\/\/< массив заполненный горизонтальными суммами$/;"	m	class:ocr::GBitset
HTML	./OCRTypes/OCRTypes.h	/^  HTML = 19,$/;"	e	enum:ocr::dataConst
HTML	./OCRTypes/OCRTypes_www.h	/^        HTML=19,$/;"	e	enum:ocr::dataConst
HTMLtoTxt	./OCRString/php2stl.cpp	/^string HTMLtoTxt(string &input) {$/;"	f
H_f	./OCRAlgorithm/f2c.h	/^typedef VOID H_f;	\/* character function *\/$/;"	t
H_fp	./OCRAlgorithm/f2c.h	/^typedef \/* Character *\/ VOID (*H_fp)();$/;"	t
H_fp	./OCRAlgorithm/f2c.h	/^typedef \/* Character *\/ VOID (*H_fp)(...);$/;"	t
Hash	./PNG/lodepng.cpp	/^typedef struct Hash$/;"	s	file:
Hash	./PNG/lodepng.cpp	/^} Hash;$/;"	t	typeref:struct:Hash	file:
HuffmanTree	./PNG/lodepng.cpp	/^typedef struct HuffmanTree$/;"	s	file:
HuffmanTree	./PNG/lodepng.cpp	/^} HuffmanTree;$/;"	t	typeref:struct:HuffmanTree	file:
HuffmanTree_cleanup	./PNG/lodepng.cpp	/^static void HuffmanTree_cleanup(HuffmanTree* tree)$/;"	f	file:
HuffmanTree_getCode	./PNG/lodepng.cpp	/^static unsigned HuffmanTree_getCode(const HuffmanTree* tree, unsigned index)$/;"	f	file:
HuffmanTree_getLength	./PNG/lodepng.cpp	/^static unsigned HuffmanTree_getLength(const HuffmanTree* tree, unsigned index)$/;"	f	file:
HuffmanTree_init	./PNG/lodepng.cpp	/^static void HuffmanTree_init(HuffmanTree* tree)$/;"	f	file:
HuffmanTree_make2DTree	./PNG/lodepng.cpp	/^static unsigned HuffmanTree_make2DTree(HuffmanTree* tree)$/;"	f	file:
HuffmanTree_makeFromFrequencies	./PNG/lodepng.cpp	/^static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,$/;"	f	file:
HuffmanTree_makeFromLengths	./PNG/lodepng.cpp	/^static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,$/;"	f	file:
HuffmanTree_makeFromLengths2	./PNG/lodepng.cpp	/^static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree)$/;"	f	file:
ID	./GGraph/GGraph.h	/^	uint ID;$/;"	m	struct:ocr::OCRMaskStruct
ID	./GGraph/GGraph.h	/^	uint ID;$/;"	m	struct:ocr::OCRRegisterStruct
ID	./OCRTypes/OCRTypes.h	/^  int ID;$/;"	m	struct:ocr::sData
ID	./OCRTypes/OCRTypes_www.h	/^        int ID;$/;"	m	struct:ocr::sData
ID_SEARCH	./OCRTypes/OCRTypes.h	/^  ID_SEARCH = 9,$/;"	e	enum:ocr::searchModeConst
ID_SEARCH_DATA	./OCRTypes/OCRTypes.h	/^  ID_SEARCH_DATA = 10,$/;"	e	enum:ocr::searchModeConst
IMGBW	./OCRTypes/OCRTypes.h	/^  IMGBW = 0,$/;"	e	enum:ocr::drawConst
IMGBW	./OCRTypes/OCRTypes_www.h	/^				IMGBW=0,$/;"	e	enum:ocr::drawConst
IMGFLIP	./OCRTypes/OCRTypes.h	/^  IMGFLIP = 1,$/;"	e	enum:ocr::drawConst
IMGFLIP	./OCRTypes/OCRTypes_www.h	/^				IMGFLIP=1,$/;"	e	enum:ocr::drawConst
IMGNOFLIP	./OCRTypes/OCRTypes.h	/^  IMGNOFLIP = 0,$/;"	e	enum:ocr::drawConst
IMGNOFLIP	./OCRTypes/OCRTypes_www.h	/^				IMGNOFLIP=0,$/;"	e	enum:ocr::drawConst
IMGRGB	./OCRTypes/OCRTypes.h	/^  IMGRGB = 1,$/;"	e	enum:ocr::drawConst
IMGRGB	./OCRTypes/OCRTypes_www.h	/^				IMGRGB=1,$/;"	e	enum:ocr::drawConst
IMPORT_TO_DB	./OCRTypes/OCRTypes.h	/^  IMPORT_TO_DB = 9,$/;"	e	enum:ocr::dataConst
IMPORT_TO_DB	./OCRTypes/OCRTypes_www.h	/^        IMPORT_TO_DB=9,$/;"	e	enum:ocr::dataConst
INDEX_COUNT	./OCRTypes/OCRTypes.h	/^  INDEX_COUNT = 10,$/;"	e	enum:ocr::searchModeConst
INDEX_RESIZE	./GMemory/GVector.h	12;"	d
INIT_SOCKET	./OCRTypes/OCRTypes.h	/^  INIT_SOCKET = 1,$/;"	e	enum:ocr::dataConst
INIT_SOCKET	./OCRTypes/OCRTypes_www.h	/^		INIT_SOCKET=1,$/;"	e	enum:ocr::dataConst
I_POINT	./OCRTypes/OCRTypes.h	/^  I_POINT = 6,      \/\/\/< точки перегиба кривой$/;"	e	enum:ocr::graphConst
I_fp	./OCRAlgorithm/f2c.h	/^typedef integer (*I_fp)();$/;"	t
I_fp	./OCRAlgorithm/f2c.h	/^typedef integer (*I_fp)(...);$/;"	t
ImBf	./GBitset/GBitset.h	/^ int ImBf;      \/\/\/< текущий размер массива ImBuf$/;"	m	class:ocr::GBitset
ImBf	./OCRAlgorithm/OCRAlgorithm.h	/^		 int ImBf;      \/\/\/< текущий размер массива ImBuf$/;"	m	class:ocr::OCRFilter
ImBuf	./GBitset/GBitset.h	/^ int *ImBuf;    \/\/\/< запрос памяти с очисткой 0$/;"	m	class:ocr::GBitset
ImBuf	./OCRAlgorithm/OCRAlgorithm.h	/^		 int *ImBuf;    \/\/\/< запрос памяти с очисткой 0$/;"	m	class:ocr::OCRFilter
Image2OCR_ppm_h	./GBitmap/ppm.h	15;"	d
ImgArrRef	./GPDF/CGImageFromPDF.h	/^NSMutableArray* ImgArrRef(){$/;"	f
InputMemoryFile	./GMemory/MmapFile.cpp	/^InputMemoryFile::InputMemoryFile(const char *pathname) : data_(0),$/;"	f	class:InputMemoryFile
InputMemoryFile	./GMemory/MmapFile.h	/^class InputMemoryFile$/;"	c
Intel	./OCRTypes/OCRTypes.h	/^enum CpuType { CpuTypeUnknown = 0, Intel, AMD };$/;"	e	enum:ocr::CpuType
Intel	./OCRTypes/OCRTypes_www.h	/^    enum CpuType		{ CpuTypeUnknown=0, Intel, AMD };$/;"	e	enum:ocr::CpuType
IsAMDExtraFunctionSupported	./OCRString/cpuTest.cpp	/^static inline bool IsAMDExtraFunctionSupported(uint32 _FunctionMask)$/;"	f	file:
IsCpuIDBitSet	./OCRString/cpuTest.cpp	/^static inline bool IsCpuIDBitSet(uint32 _EAX, uint32 _EBX, uint32 _ECX, uint32 _EDX, uint32 _Bit, X86Registers _Register)$/;"	f	file:
IsCpuIDSupported	./OCRString/cpuTest.cpp	/^static inline bool IsCpuIDSupported()$/;"	f	file:
JPEG	./OCRTypes/OCRTypes.h	/^  JPEG = 2,$/;"	e	enum:ocr::drawConst
JPEG	./OCRTypes/OCRTypes_www.h	/^				JPEG=2,$/;"	e	enum:ocr::drawConst
J_fp	./OCRAlgorithm/f2c.h	/^typedef shortint (*J_fp)();$/;"	t
J_fp	./OCRAlgorithm/f2c.h	/^typedef shortint (*J_fp)(...);$/;"	t
KFStrok	./GBitset/GBitset.h	/^  int KFStrok;     \/\/\/< номер оптимального коэффициента фильтрации строк$/;"	m	class:ocr::GBitset
KHig	./GBitset/GBitset.h	/^		int KHig;    \/\/\/< порядок высокочастотного фильтра  2< KHig =<63; вычисляемое значение 8 или 16$/;"	m	class:ocr::GBitset
KHigS	./GBitset/GBitset.h	/^  int KHigS;       \/\/\/< оптимальный параметр фильтрации строк$/;"	m	class:ocr::GBitset
KLow	./GBitset/GBitset.h	/^		int KLow;    \/\/\/< порядок низкочастотного фильтра  2< KLow =<63; вычисляемое значение 8 или 16$/;"	m	class:ocr::GBitset
K_fp	./OCRAlgorithm/f2c.h	/^typedef shortlogical (*K_fp)();$/;"	t
K_fp	./OCRAlgorithm/f2c.h	/^typedef shortlogical (*K_fp)(...);$/;"	t
KeySMP	./OCRTypes/OCRTypes.h	/^  uint32 KeySMP; \/\/ описание смотри ниже по тексту$/;"	m	struct:ocr::SCpuInfo
KeySMP	./OCRTypes/OCRTypes_www.h	/^        uint32          KeySMP;             \/\/ описание смотри ниже по тексту$/;"	m	struct:ocr::SCpuInfo
LAST_LENGTH_CODE_INDEX	./PNG/lodepng.cpp	467;"	d	file:
LCT_GREY	./PNG/lodepng.h	/^  LCT_GREY = 0, \/*greyscale: 1,2,4,8,16 bit*\/$/;"	e	enum:LodePNGColorType
LCT_GREY_ALPHA	./PNG/lodepng.h	/^  LCT_GREY_ALPHA = 4, \/*greyscale with alpha: 8,16 bit*\/$/;"	e	enum:LodePNGColorType
LCT_PALETTE	./PNG/lodepng.h	/^  LCT_PALETTE = 3, \/*palette: 1,2,4,8 bit*\/$/;"	e	enum:LodePNGColorType
LCT_RGB	./PNG/lodepng.h	/^  LCT_RGB = 2, \/*RGB: 8,16 bit*\/$/;"	e	enum:LodePNGColorType
LCT_RGBA	./PNG/lodepng.h	/^  LCT_RGBA = 6 \/*RGB with alpha: 8,16 bit*\/$/;"	e	enum:LodePNGColorType
LDraw	./GBitset/GBitset_algorithm.cpp	/^void GBitset::LDraw(vector<int> &HBuf, int sm, int color){$/;"	f	class:GBitset
LDrawVar	./GBitset/GBitset_algorithm.cpp	/^void GBitset::LDrawVar(vector<int> &HBuf, int HDrawSize, int sm, int scope, int color){$/;"	f	class:GBitset
LENGTHBASE	./PNG/lodepng.cpp	/^static const unsigned LENGTHBASE[29]$/;"	v	file:
LENGTHEXTRA	./PNG/lodepng.cpp	/^static const unsigned LENGTHEXTRA[29]$/;"	v	file:
LETTER_ADD	./OCRTypes/OCRTypes.h	/^  LETTER_ADD = 1,$/;"	e	enum:ocr::drawConst
LETTER_ADD	./OCRTypes/OCRTypes_www.h	/^				LETTER_ADD=1,$/;"	e	enum:ocr::drawConst
LETTER_SEARCH	./OCRTypes/OCRTypes.h	/^  LETTER_SEARCH = 11,$/;"	e	enum:ocr::searchModeConst
LETTER_TABLE_HTML	./OCRTypes/OCRTypes.h	/^  LETTER_TABLE_HTML = 20,$/;"	e	enum:ocr::dataConst
LETTER_TABLE_HTML	./OCRTypes/OCRTypes_www.h	/^        LETTER_TABLE_HTML=20,$/;"	e	enum:ocr::dataConst
LFS_BRUTE_FORCE	./PNG/lodepng.h	/^  LFS_BRUTE_FORCE,$/;"	e	enum:LodePNGFilterStrategy
LFS_ENTROPY	./PNG/lodepng.h	/^  LFS_ENTROPY,$/;"	e	enum:LodePNGFilterStrategy
LFS_MINSUM	./PNG/lodepng.h	/^  LFS_MINSUM,$/;"	e	enum:LodePNGFilterStrategy
LFS_PREDEFINED	./PNG/lodepng.h	/^  LFS_PREDEFINED$/;"	e	enum:LodePNGFilterStrategy
LFS_ZERO	./PNG/lodepng.h	/^  LFS_ZERO,$/;"	e	enum:LodePNGFilterStrategy
LINE	./OCRTypes/OCRTypes.h	/^  LINE = 1,$/;"	e	enum:ocr::__anon11
LINE_SIZE	./GGraph/GGraph.h	36;"	d
LINE_SIZE	./GGraphBezier/GGraphBezier.h	32;"	d
LINE_SIZE_W	./GGraph/GGraph.h	37;"	d
LIST_SEARCH	./OCRTypes/OCRTypes.h	/^  LIST_SEARCH = 5,$/;"	e	enum:ocr::searchModeConst
LOAD_PTR	./config.h	50;"	d
LOAD_PTR	./config.h	53;"	d
LOCAL_MODE	./OCRTypes/OCRTypes.h	/^  LOCAL_MODE = 7,$/;"	e	enum:ocr::dataConst
LOCAL_MODE	./OCRTypes/OCRTypes_www.h	/^		LOCAL_MODE=7,$/;"	e	enum:ocr::dataConst
LODEPNG_COMPILE_ALLOCATORS	./PNG/lodepng.h	80;"	d
LODEPNG_COMPILE_ANCILLARY_CHUNKS	./PNG/lodepng.h	70;"	d
LODEPNG_COMPILE_CPP	./PNG/lodepng.h	85;"	d
LODEPNG_COMPILE_DECODER	./PNG/lodepng.h	58;"	d
LODEPNG_COMPILE_DISK	./PNG/lodepng.h	66;"	d
LODEPNG_COMPILE_ENCODER	./PNG/lodepng.h	62;"	d
LODEPNG_COMPILE_ERROR_TEXT	./PNG/lodepng.h	74;"	d
LODEPNG_COMPILE_PNG	./PNG/lodepng.h	54;"	d
LODEPNG_COMPILE_ZLIB	./PNG/lodepng.h	50;"	d
LODEPNG_H	./PNG/lodepng.h	27;"	d
LODEPNG_MAX	./PNG/lodepng.cpp	95;"	d	file:
LODEPNG_MIN	./PNG/lodepng.cpp	96;"	d	file:
LODEPNG_NO_COMPILE_CPP	./PNG/lodepng.h	33;"	d
LStS	./GBitset/GBitset.h	/^  vector<int> LStS;   \/\/\/< массив заполненный вертикальными суммами по всей странице$/;"	m	class:ocr::GBitset
LStr	./GBitset/GBitset.h	/^  vector<int> LStr;   \/\/\/< массив заполненный вертикальными суммами$/;"	m	class:ocr::GBitset
L_POINT	./OCRTypes/OCRTypes.h	/^  L_POINT = 1,      \/\/\/< конечные точки линий$/;"	e	enum:ocr::graphConst
L_POINT	./OCRTypes/OCRTypes_www.h	/^                L_POINT=4,$/;"	e	enum:ocr::drawConst
L_fp	./OCRAlgorithm/f2c.h	/^typedef logical (*L_fp)();$/;"	t
L_fp	./OCRAlgorithm/f2c.h	/^typedef logical (*L_fp)(...);$/;"	t
LimY0	./GFontEditor/GLetter.h	/^  int LimY0; \/\/\/ верхний лимит строки               \/\/upper y limit$/;"	m	class:ocr::stringOCR
LimY1	./GFontEditor/GLetter.h	/^  int LimY1; \/\/\/ нижний лимит строки                \/\/doun y limit$/;"	m	class:ocr::stringOCR
LineAngleLength	./GGraphBezier/GGraphFocalLineBezier.cpp	/^void GGraphBezier::LineAngleLength(float delta_x, float delta_y, float &alpha, float &length ){$/;"	f	class:ocr::GGraphBezier
LineBlockStart	./GBitset/GBitsetWord.cpp	/^void GBitset::LineBlockStart() {$/;"	f	class:GBitset
LineDetectArray	./GBitset/GBitset.h	/^  vector<int> LineDetectArray; \/\/\/< массив вертикальных сумм в интервалах между колонками (не маскированный)$/;"	m	class:ocr::GBitset
LineDetector	./GBitset/GBitsetWord.cpp	/^void GBitset::LineDetector() {$/;"	f	class:GBitset
LineLetterStart	./GBitset/GBitsetWordTib.cpp	/^void GBitset::LineLetterStart() {$/;"	f	class:GBitset
LineVertical	./GBitset/GBitset_algorithm.cpp	/^void GBitset::LineVertical(int sm, int color){$/;"	f	class:GBitset
LineWidthImg	./GBitmap/GBitmapPenWidth.cpp	/^  float GBitmap::LineWidthImg () {$/;"	f	class:ocr::GBitmap
LineWidthRegion	./GBitmap/GBitmapPenWidth.cpp	/^  void  GBitmap::LineWidthRegion(int BASE) {$/;"	f	class:ocr::GBitmap
LinuxKernel	./OCRTypes/OCRTypes.h	/^  string LinuxKernel; \/\/ !< версия ядра Linux в системе$/;"	m	struct:ocr::SCpuInfo
LinuxKernel	./OCRTypes/OCRTypes_www.h	/^        string          LinuxKernel;        \/\/ !< версия ядра Linux в системе$/;"	m	struct:ocr::SCpuInfo
LoadASCIToUniMap	./TibetanNameSpace/readTable.h	/^bool LoadASCIToUniMap(){$/;"	f
LoadFontMap	./GLogicProcessor/LoadFontMaps.cpp	/^void GLogicProcessor::LoadFontMap(map<string,uniRecord>&fMap,string &fileName){$/;"	f	class:GLogicProcessor
LoadFontNameMap	./GLogicProcessor/LoadFontMaps.cpp	/^void  GLogicProcessor::LoadFontNameMap(){$/;"	f	class:GLogicProcessor
LoadMapXML	./GLogicProcessor/LoadFontMaps.cpp	/^void GLogicProcessor::LoadMapXML(){$/;"	f	class:GLogicProcessor
LoadUniToTibetanMapUTF	./GLogicProcessor/LoadFontMaps.cpp	/^void  GLogicProcessor::LoadUniToTibetanMapUTF(){$/;"	f	class:GLogicProcessor
LoadYagpoToWylieMap	./GLogicProcessor/LoadFontMaps.cpp	/^void GLogicProcessor::LoadYagpoToWylieMap(){$/;"	f	class:GLogicProcessor
LodePNGColorMode	./PNG/lodepng.h	/^typedef struct LodePNGColorMode$/;"	s
LodePNGColorMode	./PNG/lodepng.h	/^} LodePNGColorMode;$/;"	t	typeref:struct:LodePNGColorMode
LodePNGColorProfile	./PNG/lodepng.h	/^typedef struct LodePNGColorProfile$/;"	s
LodePNGColorProfile	./PNG/lodepng.h	/^} LodePNGColorProfile;$/;"	t	typeref:struct:LodePNGColorProfile
LodePNGColorType	./PNG/lodepng.h	/^typedef enum LodePNGColorType$/;"	g
LodePNGColorType	./PNG/lodepng.h	/^} LodePNGColorType;$/;"	t	typeref:enum:LodePNGColorType
LodePNGCompressSettings	./PNG/lodepng.h	/^struct LodePNGCompressSettings \/*deflate = compress*\/$/;"	s
LodePNGCompressSettings	./PNG/lodepng.h	/^typedef struct LodePNGCompressSettings LodePNGCompressSettings;$/;"	t	typeref:struct:LodePNGCompressSettings
LodePNGDecoderSettings	./PNG/lodepng.h	/^typedef struct LodePNGDecoderSettings$/;"	s
LodePNGDecoderSettings	./PNG/lodepng.h	/^} LodePNGDecoderSettings;$/;"	t	typeref:struct:LodePNGDecoderSettings
LodePNGDecompressSettings	./PNG/lodepng.h	/^struct LodePNGDecompressSettings$/;"	s
LodePNGDecompressSettings	./PNG/lodepng.h	/^typedef struct LodePNGDecompressSettings LodePNGDecompressSettings;$/;"	t	typeref:struct:LodePNGDecompressSettings
LodePNGEncoderSettings	./PNG/lodepng.h	/^typedef struct LodePNGEncoderSettings$/;"	s
LodePNGEncoderSettings	./PNG/lodepng.h	/^} LodePNGEncoderSettings;$/;"	t	typeref:struct:LodePNGEncoderSettings
LodePNGFilterStrategy	./PNG/lodepng.h	/^typedef enum LodePNGFilterStrategy$/;"	g
LodePNGFilterStrategy	./PNG/lodepng.h	/^} LodePNGFilterStrategy;$/;"	t	typeref:enum:LodePNGFilterStrategy
LodePNGIText_cleanup	./PNG/lodepng.cpp	/^static void LodePNGIText_cleanup(LodePNGInfo* info)$/;"	f	file:
LodePNGIText_copy	./PNG/lodepng.cpp	/^static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source)$/;"	f	file:
LodePNGIText_init	./PNG/lodepng.cpp	/^static void LodePNGIText_init(LodePNGInfo* info)$/;"	f	file:
LodePNGInfo	./PNG/lodepng.h	/^typedef struct LodePNGInfo$/;"	s
LodePNGInfo	./PNG/lodepng.h	/^} LodePNGInfo;$/;"	t	typeref:struct:LodePNGInfo
LodePNGState	./PNG/lodepng.h	/^typedef struct LodePNGState$/;"	s
LodePNGState	./PNG/lodepng.h	/^} LodePNGState;$/;"	t	typeref:struct:LodePNGState
LodePNGText_cleanup	./PNG/lodepng.cpp	/^static void LodePNGText_cleanup(LodePNGInfo* info)$/;"	f	file:
LodePNGText_copy	./PNG/lodepng.cpp	/^static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source)$/;"	f	file:
LodePNGText_init	./PNG/lodepng.cpp	/^static void LodePNGText_init(LodePNGInfo* info)$/;"	f	file:
LodePNGTime	./PNG/lodepng.h	/^typedef struct LodePNGTime$/;"	s
LodePNGTime	./PNG/lodepng.h	/^} LodePNGTime;$/;"	t	typeref:struct:LodePNGTime
LodePNGUnknownChunks_cleanup	./PNG/lodepng.cpp	/^static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info)$/;"	f	file:
LodePNGUnknownChunks_copy	./PNG/lodepng.cpp	/^static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src)$/;"	f	file:
LodePNGUnknownChunks_init	./PNG/lodepng.cpp	/^static void LodePNGUnknownChunks_init(LodePNGInfo* info)$/;"	f	file:
LogicalUnits	./OCRTypes/OCRTypes.h	/^  uint32 LogicalUnits; \/\/ !< e.g. hyper threading$/;"	m	struct:ocr::SCpuInfo
LogicalUnits	./OCRTypes/OCRTypes_www.h	/^        uint32          LogicalUnits;		\/\/ !< e.g. hyper threading$/;"	m	struct:ocr::SCpuInfo
MACOS	./config.h	20;"	d
MAGICKCORE_QUANTUM_DEPTH	./config.h	302;"	d
MAIN_HOST	./config.h	14;"	d
MATRIX_BORDER	./OCRTypes/OCRTypes.h	/^  MATRIX_BORDER = 128,$/;"	e	enum:ocr::drawConst
MATRIX_BORDER	./OCRTypes/OCRTypes_www.h	/^                MATRIX_BORDER=128,$/;"	e	enum:ocr::drawConst
MAXREQUEST	./config.h	258;"	d
MAX_CLUSTER	./GGraph/GGraph.h	44;"	d
MAX_EXTREM	./GGraph/GGraph.h	38;"	d
MAX_H	./GGraph/GGraph.h	40;"	d
MAX_OCR_LINE	./config.h	259;"	d
MAX_SUPPORTED_DEFLATE_LENGTH	./PNG/lodepng.cpp	/^static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;$/;"	v	file:
MEMORY_FILE_HPP	./GMemory/MmapFile.h	2;"	d
MEMORY_LOCATION	./OCRTypes/OCRTypes.h	/^  MEMORY_LOCATION = 16,$/;"	e	enum:ocr::dataConst
MEMORY_LOCATION	./OCRTypes/OCRTypes_www.h	/^        MEMORY_LOCATION=16,$/;"	e	enum:ocr::dataConst
MEM_CHINK_CHAR	./GLogicProcessor/loadDictionary.cpp	114;"	d	file:
MEM_CHINK_INT	./GLogicProcessor/loadDictionary.cpp	113;"	d	file:
MIDDLEMASK	./OCRTypes/OCRTypes.h	/^  MIDDLEMASK = 9,$/;"	e	enum:ocr::drawConst
MIDDLEMASK	./OCRTypes/OCRTypes_www.h	/^				MIDDLEMASK=9,$/;"	e	enum:ocr::drawConst
MMAP_GVECTOR_H	./GMemory/GVector.h	2;"	d
MMAP_IN_MEMORY	./config.h	73;"	d
MMAP_LOCATION	./OCRTypes/OCRTypes.h	/^  MMAP_LOCATION = 17,$/;"	e	enum:ocr::dataConst
MMAP_LOCATION	./OCRTypes/OCRTypes_www.h	/^        MMAP_LOCATION=17,$/;"	e	enum:ocr::dataConst
MMX	./OCRTypes/OCRTypes.h	/^  MMX,$/;"	e	enum:ocr::SIMDType
MMX	./OCRTypes/OCRTypes_www.h	/^    enum SIMDType		{ SIMDUnknown=0, NoSIMD, MMX, SSE, SSE2, SSE3, SSE41, SSE42, Altivec }; $/;"	e	enum:ocr::SIMDType
MOV_PTR	./config.h	51;"	d
MOV_PTR	./config.h	54;"	d
MULTY_LINE	./OCRTypes/OCRTypes.h	/^  MULTY_LINE = 25,$/;"	e	enum:ocr::dataConst
MakePDF	./GPDF/drawPDF.h	/^void MakePDF(){$/;"	f
MatrixDltOff	./GBitMask/matrixT.cpp	/^	void GBitMask32::MatrixDltOff(int dlt) {$/;"	f	class:ocr::GBitMask32
MatrixDltOn	./GBitMask/matrixT.cpp	/^	void GBitMask32::MatrixDltOn(int dlt) {$/;"	f	class:ocr::GBitMask32
MatrixOff	./GBitMask/matrixT.cpp	/^	void GBitMask32::MatrixOff(int dlt) {$/;"	f	class:ocr::GBitMask32
MatrixPoint	./GBitset/GBitsetPoint.cpp	/^void GBitset::MatrixPoint( int WPnt, int HPnt ){$/;"	f	class:GBitset
MatrixPointA	./GBitset/GBitsetPoint.cpp	/^void GBitset::MatrixPointA( int MPoint, int ms, int ns ){$/;"	f	class:GBitset
MatrixPointB	./GBitset/GBitsetPoint.cpp	/^void GBitset::MatrixPointB(){$/;"	f	class:GBitset
MeanCol	./GBitset/GBitset.h	/^  int MeanCol;     \/\/\/< вычисленный средний по странице период букв умноженный на 10$/;"	m	class:ocr::GBitset
MeanSA	./GBitset/GBitset.h	/^  int MeanSA;      \/\/\/< вычисленный средний по строке период букв умноженный на 10$/;"	m	class:ocr::GBitset
MeanSA	./GFontEditor/GLetter.h	/^  int MeanSA; \/\/\/ средее, по всей строке, расстояние между центрами масс букв$/;"	m	class:ocr::stringOCR
MemoryFile	./GMemory/MmapFile.cpp	/^MemoryFile::MemoryFile(const char *pathname, e_open_mode open_mode) : data_(0),$/;"	f	class:MemoryFile
MemoryFile	./GMemory/MmapFile.h	/^class MemoryFile$/;"	c
MonoBookDetector	./GBitset/GBitsetPageSegmentation.cpp	/^void GBitset::MonoBookDetector() {$/;"	f	class:GBitset
Multitype	./OCRAlgorithm/f2c.h	/^typedef union Multitype Multitype;$/;"	t	typeref:union:Multitype
Multitype	./OCRAlgorithm/f2c.h	/^union Multitype {	\/* for multiple entry points *\/$/;"	u
MyCreatePDFFile	./GPDF/drawPDF.h	/^void MyCreatePDFFile (CGRect pageRect, const char *filename)\/\/ 1$/;"	f
MyDisplayPDFPage	./GPDF/drawPDF.h	/^void MyDisplayPDFPage (CGContextRef myContext,$/;"	f
MyDrawPDFPageInRect	./GPDF/drawPDF.h	/^void MyDrawPDFPageInRect (CGContextRef context,$/;"	f
MyGetPDFDocumentRef	./GPDF/CGImageFromPDF.h	/^CGPDFDocumentRef MyGetPDFDocumentRef (const char *filename) {$/;"	f
N0Fase	./GBitset/GBitset.h	/^		int N0Fase;  \/\/\/< количество данных в нолевом слайсе массива INFase$/;"	m	class:ocr::GBitset
N0Gilb	./GBitset/GBitset.h	/^		int N0Gilb;  \/\/\/< количество данных в нолевом слайсе массива INGilb$/;"	m	class:ocr::GBitset
NBlockP	./GBitset/GBitset.h	/^  int NBlockP;     \/\/\/< вычисленное колличество блоков букв в печа$/;"	m	class:ocr::GBitset
NEW_LINE	./OCRTypes/OCRTypes.h	/^  NEW_LINE = 3,     \/\/\/< относительно прямая линия между точками экстремума$/;"	e	enum:ocr::graphConst
NLet	./GBitset/GBitset.h	/^  int NLet;        \/\/\/< вычисленное колличество букв в строке, умноженное на 4$/;"	m	class:ocr::GBitset
NLetter	./GFontEditor/GLetter.h	/^  int NLetter; \/\/\/ примерная длина строки (оценка)   \/\/letter count$/;"	m	class:ocr::stringOCR
NMask	./GBitMask/GBitMask.h	/^		int NMask,NMask_prim;       \/\/\/< площадь (количество единиц) центральной маски On$/;"	m	class:ocr::GBitMask32
NMask	./GBitMask/GBitMask.h	/^		int NMask;       \/\/ площадь (количество единиц) центральной маски On$/;"	m	class:ocr::GBitMask128
NMask_prim	./GBitMask/GBitMask.h	/^		int NMask,NMask_prim;       \/\/\/< площадь (количество единиц) центральной маски On$/;"	m	class:ocr::GBitMask32
NO_REMOVE_DELIMETERS	./OCRTypes/OCRTypes.h	/^  NO_REMOVE_DELIMETERS = 12,$/;"	e	enum:ocr::OCRConst
NStrok	./GBitset/GBitset.h	/^  int NStrok;      \/\/\/< вычисленное колличество строк в печа$/;"	m	class:ocr::GBitset
NUM_CODE_LENGTH_CODES	./PNG/lodepng.cpp	473;"	d	file:
NUM_DEFLATE_CODE_SYMBOLS	./PNG/lodepng.cpp	469;"	d	file:
NUM_DISTANCE_SYMBOLS	./PNG/lodepng.cpp	471;"	d	file:
Namelist	./OCRAlgorithm/f2c.h	/^struct Namelist {$/;"	s
Namelist	./OCRAlgorithm/f2c.h	/^typedef struct Namelist Namelist;$/;"	t	typeref:struct:Namelist
NoSIMD	./OCRTypes/OCRTypes.h	/^  NoSIMD,$/;"	e	enum:ocr::SIMDType
NoSIMD	./OCRTypes/OCRTypes_www.h	/^    enum SIMDType		{ SIMDUnknown=0, NoSIMD, MMX, SSE, SSE2, SSE3, SSE41, SSE42, Altivec }; $/;"	e	enum:ocr::SIMDType
NormalT	./GBitMask/algorithmOCR_32.cpp	/^    void GBitMask32::NormalT() {$/;"	f	class:ocr::GBitMask32
Nstr	./GBitset/GBitset.h	/^  int Nstr;        \/\/\/< номер текущей обрабатываемой строки$/;"	m	class:ocr::GBitset
Nwrd	./GBitset/GBitset.h	/^  int Nwrd;        \/\/\/< номер текущей обрабатываемой буквы$/;"	m	class:ocr::GBitset
OCRBox	./OCRTypes/OCRTypes.h	/^}OCRBox;$/;"	t	namespace:ocr	typeref:struct:ocr::OCRBoxStruct
OCRBox	./OCRTypes/OCRTypes_www.h	/^    class OCRBox {$/;"	c	namespace:ocr
OCRBoxStruct	./OCRTypes/OCRTypes.h	/^typedef struct OCRBoxStruct {$/;"	s	namespace:ocr
OCRCluster	./GGraph/GGraph.h	/^} OCRCluster;$/;"	t	namespace:ocr	typeref:struct:ocr::OCRClusterStruct
OCRClusterStruct	./GGraph/GGraph.h	/^typedef struct OCRClusterStruct {$/;"	s	namespace:ocr
OCRConst	./OCRTypes/OCRTypes.h	/^enum OCRConst {$/;"	g	namespace:ocr
OCRConst	./OCRTypes/OCRTypes_www.h	/^    enum OCRConst{$/;"	g	namespace:ocr
OCRData	./OCRTypes/OCRTypes.h	/^} OCRData;$/;"	t	namespace:ocr	typeref:struct:ocr::OCRDataStruct
OCRDataStruct	./OCRTypes/OCRTypes.h	/^typedef struct OCRDataStruct {$/;"	s	namespace:ocr
OCRDictRecord	./OCRTypes/OCRTypes.cpp	/^OCRDictRecord::OCRDictRecord() { wordCount = 0; }$/;"	f	class:ocr::OCRDictRecord
OCRDictRecord	./OCRTypes/OCRTypes.h	/^class OCRDictRecord {$/;"	c	namespace:ocr
OCRDictRecord	./OCRTypes/OCRTypes_www.h	/^	class OCRDictRecord {$/;"	c	namespace:ocr
OCRFilter	./OCRAlgorithm/OCRAlgorithm.cpp	/^OCRFilter::OCRFilter(int size){$/;"	f	class:ocr::OCRFilter
OCRFilter	./OCRAlgorithm/OCRAlgorithm.h	/^class OCRFilter{$/;"	c	namespace:ocr
OCRFocalLineBezier	./GGraphBezier/GGraphBezier.cpp	/^OCRFocalLineBezier::OCRFocalLineBezier(){$/;"	f	class:ocr::OCRFocalLineBezier
OCRFocalLineBezier	./GGraphBezier/GGraphBezier.h	/^    class OCRFocalLineBezier{$/;"	c	namespace:ocr
OCRIndex	./GFontEditor/GLetter.h	/^  int OCRIndex;$/;"	m	class:ocr::GLetter
OCRIndex	./GFontEditor/GLetter.h	/^  int OCRIndex;$/;"	m	class:ocr::OCRMatch
OCRIndex	./GFontEditor/GLetter.h	/^  int OCRIndex;$/;"	m	class:ocr::OCRMatchConst
OCRIndex	./GFontEditor/GLetter.h	/^  int OCRIndex;$/;"	m	class:ocr::wordOCR
OCRIndex	./GGraph/GGraph.h	/^	ushort OCRIndex;$/;"	m	struct:ocr::OCRLetterStruct
OCRIndex	./OCRTypes/OCRTypes.h	/^  int OCRIndex;$/;"	m	struct:ocr::uniLetterRecord
OCRIndex	./OCRTypes/OCRTypes_www.h	/^		int OCRIndex;$/;"	m	struct:ocr::uniLetterRecord
OCRKey	./GFontEditor/GLetter.h	/^  string OCRKey;$/;"	m	class:ocr::GLetter
OCRKey	./OCRTypes/OCRTypes.h	/^  string OCRKey;             \/\/ self letter code in UTF$/;"	m	struct:ocr::uniLetterRecord
OCRKey	./OCRTypes/OCRTypes_www.h	/^		string OCRKey; \/\/self letter code in UTF$/;"	m	struct:ocr::uniLetterRecord
OCRKeyHex	./OCRTypes/OCRTypes.h	/^  string OCRKeyHex;          \/\/ self letter code in hex$/;"	m	struct:ocr::uniLetterRecord
OCRKeyHex	./OCRTypes/OCRTypes_www.h	/^		string OCRKeyHex; \/\/self letter code in hex$/;"	m	struct:ocr::uniLetterRecord
OCRLIB_H	./ocrlib_.h	2;"	d
OCRLIB_H	./ocrlib_www.h	2;"	d
OCRLanguage	./GFontEditor/GFont.h	/^        ulong *OCRLanguage;                           \/\/\/язык распознавания$/;"	m	class:ocr::GFont
OCRLetter	./GGraph/GGraph.h	/^} OCRLetter;$/;"	t	namespace:ocr	typeref:struct:ocr::OCRLetterStruct
OCRLetterStruct	./GGraph/GGraph.h	/^typedef struct OCRLetterStruct {$/;"	s	namespace:ocr
OCRLib_CGImageFromPDF_h	./GPDF/CGImageFromPDF.h	9;"	d
OCRLib_DLIB	./config.h	24;"	d
OCRLine	./GGraph/GGraph.h	/^} OCRLine;$/;"	t	namespace:ocr	typeref:struct:ocr::OCRLineStruct
OCRLineCorrelationLookup4	./GGraphOCR/GGraphOCRCorrelationLookup4.cpp	/^int GGraphOCR::OCRLineCorrelationLookup4($/;"	f	class:ocr::GGraphOCR
OCRLineCorrelationVoronov	./GGraphOCR/GGraphOCRCorrelationLookup4.cpp	/^void GGraphOCR::OCRLineCorrelationVoronov($/;"	f	class:ocr::GGraphOCR
OCRLineMaskAffineCorrelation	./GGraphOCR/GGraphOCRCorrelationLookup2.cpp	/^int GGraphOCR::OCRLineMaskAffineCorrelation(OCRLine &lineT, OCRLine &line, int dir) {$/;"	f	class:ocr::GGraphOCR
OCRLineMaskCorrelation	./GGraphOCR/GGraphOCRCorrelationLookup2.cpp	/^int GGraphOCR::OCRLineMaskCorrelation(OCRLine &lineT, OCRLine &line) {$/;"	f	class:ocr::GGraphOCR
OCRLineRef	./GGraphBezier/GGraphBezier.cpp	/^OCRLineRef::OCRLineRef(){$/;"	f	class:ocr::OCRLineRef
OCRLineRef	./GGraphBezier/GGraphBezier.cpp	/^OCRLineRef::OCRLineRef(OCRFocalLineBezier &ref,uint len_){$/;"	f	class:ocr::OCRLineRef
OCRLineRef	./GGraphBezier/GGraphBezier.h	/^    class OCRLineRef{$/;"	c	namespace:ocr
OCRLineStruct	./GGraph/GGraph.h	/^typedef struct OCRLineStruct {$/;"	s	namespace:ocr
OCRMask	./GGraph/GGraph.h	/^}OCRMask;$/;"	t	namespace:ocr	typeref:struct:ocr::OCRMaskStruct
OCRMaskStruct	./GGraph/GGraph.h	/^typedef struct OCRMaskStruct {$/;"	s	namespace:ocr
OCRMatch	./GFontEditor/GLetter.cpp	/^OCRMatch::OCRMatch(){$/;"	f	class:OCRMatch
OCRMatch	./GFontEditor/GLetter.h	/^class OCRMatch {$/;"	c	namespace:ocr
OCRMatchConst	./GFontEditor/GLetter.cpp	/^OCRMatchConst::OCRMatchConst(){};$/;"	f	class:OCRMatchConst
OCRMatchConst	./GFontEditor/GLetter.h	/^class OCRMatchConst {$/;"	c	namespace:ocr
OCRMode	./config.h	/^	int OCRMode;$/;"	m	struct:commandData
OCRPoint	./OCRTypes/OCRTypes.h	/^} OCRPoint;$/;"	t	namespace:ocr	typeref:struct:ocr::OCRPointStruct
OCRPointFloat	./OCRTypes/OCRTypes.cpp	/^OCRPointFloat::OCRPointFloat() {$/;"	f	class:ocr::OCRPointFloat
OCRPointFloat	./OCRTypes/OCRTypes.cpp	/^OCRPointFloat::OCRPointFloat(float x_, float y_) {$/;"	f	class:ocr::OCRPointFloat
OCRPointFloat	./OCRTypes/OCRTypes.h	/^class OCRPointFloat {$/;"	c	namespace:ocr
OCRPointFloat	./OCRTypes/OCRTypes_www.h	/^    class OCRPointFloat {$/;"	c	namespace:ocr
OCRPointStruct	./OCRTypes/OCRTypes.h	/^typedef struct OCRPointStruct {$/;"	s	namespace:ocr
OCRRegister	./GGraph/GGraph.h	/^}OCRRegister;$/;"	t	namespace:ocr	typeref:struct:ocr::OCRRegisterStruct
OCRRegisterStruct	./GGraph/GGraph.h	/^typedef struct OCRRegisterStruct {$/;"	s	namespace:ocr
OCRStar	./GGraph/GGraph.h	/^} OCRStar;$/;"	t	namespace:ocr	typeref:struct:ocr::OCRStarStruct
OCRStarCorrelation	./GGraphOCR/GGraphOCRStarCorrelation.cpp	/^int GGraphOCR::OCRStarCorrelation(OCRStar &starT, OCRStar &star, OCRLine *linesT, OCRLine *lines) {$/;"	f	class:ocr::GGraphOCR
OCRStarCorrelationAffineLookup2	./GGraphOCR/GGraphOCRCorrelationLookup2.cpp	/^int GGraphOCR::OCRStarCorrelationAffineLookup2(OCRStar &starT, OCRStar &star, OCRLine *linesT, OCRLine *lines,uchar *lineCorr, uchar *sMatch) {$/;"	f	class:ocr::GGraphOCR
OCRStarCorrelationLetterLookup3	./GGraphOCR/GGraphOCRCorrelationLookup3.cpp	/^int GGraphOCR::OCRStarCorrelationLetterLookup3($/;"	f	class:ocr::GGraphOCR
OCRStarCorrelationLookup1	./GGraphOCR/GGraphOCRStarCorrelation.cpp	/^int GGraphOCR::OCRStarCorrelationLookup1(OCRRegister &regT, OCRRegister &reg) {$/;"	f	class:ocr::GGraphOCR
OCRStarCorrelationLookup2	./GGraphOCR/GGraphOCRCorrelationLookup2.cpp	/^int GGraphOCR::OCRStarCorrelationLookup2($/;"	f	class:ocr::GGraphOCR
OCRStarCorrelationLookup4	./GGraphOCR/GGraphOCRCorrelationLookup4.cpp	/^int GGraphOCR::OCRStarCorrelationLookup4(OCRStar &star, GGraph &graph, OCRLetter &letter) {$/;"	f	class:ocr::GGraphOCR
OCRStarCorrelationLookup5	./GGraphOCR/GGraphOCRStarCorrelation.cpp	/^int GGraphOCR::OCRStarCorrelationLookup5(OCRStar &starT, OCRStar &star, OCRLine *linesT, OCRLine *lines) {$/;"	f	class:ocr::GGraphOCR
OCRStarStruct	./GGraph/GGraph.h	/^typedef struct OCRStarStruct {$/;"	s	namespace:ocr
OCRStatus	./GFontEditor/GLetter.h	/^  int OCRStatus;$/;"	m	class:ocr::GLetter
OCRTYPES_H	./OCRTypes/OCRTypes.cpp	15;"	d	file:
OCRTextData	./OCRTypes/OCRTypes.h	/^class OCRTextData {$/;"	c	namespace:ocr
OCRTextData	./OCRTypes/OCRTypes_www.h	/^	class OCRTextData {$/;"	c	namespace:ocr
OCRZone	./GBitsetContour/GBitsetContour.h	/^    char OCRZone[20000];$/;"	m	class:ocr::GBitsetContour
OCR_DICT_HASH	./OCRTypes/OCRTypes.h	/^  OCR_DICT_HASH = 13,$/;"	e	enum:ocr::OCRConst
OCR_IMAGE_PARAMETERS	./OCRTypes/OCRTypes.h	/^  OCR_IMAGE_PARAMETERS = 101,$/;"	e	enum:ocr::dataConst
OCR_KANNADA	./OCRTypes/OCRTypes.h	/^  OCR_KANNADA = 7,$/;"	e	enum:ocr::OCRConst
OCR_KANNADA	./OCRTypes/OCRTypes_www.h	/^        OCR_KANNADA=7,$/;"	e	enum:ocr::OCRConst
OCR_NORMALISATION	./OCRTypes/OCRTypes.h	/^  OCR_NORMALISATION = 100,$/;"	e	enum:ocr::dataConst
OCR_SANSKRIT	./OCRTypes/OCRTypes.h	/^  OCR_SANSKRIT = 5,$/;"	e	enum:ocr::OCRConst
OCR_SANSKRIT	./OCRTypes/OCRTypes_www.h	/^        OCR_SANSKRIT=5,$/;"	e	enum:ocr::OCRConst
OCR_SANSKRIT_ENG	./OCRTypes/OCRTypes.h	/^  OCR_SANSKRIT_ENG = 6,$/;"	e	enum:ocr::OCRConst
OCR_SANSKRIT_ENG	./OCRTypes/OCRTypes_www.h	/^        OCR_SANSKRIT_ENG=6,$/;"	e	enum:ocr::OCRConst
OCR_SEARCH	./OCRTypes/OCRTypes.h	/^  OCR_SEARCH = 2,$/;"	e	enum:ocr::searchModeConst
OCR_SINHALA	./OCRTypes/OCRTypes.h	/^  OCR_SINHALA = 8,$/;"	e	enum:ocr::OCRConst
OCR_SINHALA	./OCRTypes/OCRTypes_www.h	/^        OCR_SINHALA=8,$/;"	e	enum:ocr::OCRConst
OCR_SINHALA_ENG	./OCRTypes/OCRTypes.h	/^  OCR_SINHALA_ENG = 10,$/;"	e	enum:ocr::OCRConst
OCR_SINHALA_ENG	./OCRTypes/OCRTypes_www.h	/^        OCR_SINHALA_ENG=10        $/;"	e	enum:ocr::OCRConst
OCR_SINHALA_RUS	./OCRTypes/OCRTypes.h	/^  OCR_SINHALA_RUS = 9,$/;"	e	enum:ocr::OCRConst
OCR_SINHALA_RUS	./OCRTypes/OCRTypes_www.h	/^        OCR_SINHALA_RUS=9,$/;"	e	enum:ocr::OCRConst
OCR_TIBETAN	./OCRTypes/OCRTypes.h	/^  OCR_TIBETAN = 1,$/;"	e	enum:ocr::OCRConst
OCR_TIBETAN	./OCRTypes/OCRTypes_www.h	/^		OCR_TIBETAN=1,$/;"	e	enum:ocr::OCRConst
OCR_TIBETAN_ENG	./OCRTypes/OCRTypes.h	/^  OCR_TIBETAN_ENG = 2,$/;"	e	enum:ocr::OCRConst
OCR_TIBETAN_ENG	./OCRTypes/OCRTypes_www.h	/^        OCR_TIBETAN_ENG=2,$/;"	e	enum:ocr::OCRConst
OCR_TIBETAN_RUS	./OCRTypes/OCRTypes.h	/^  OCR_TIBETAN_RUS = 3,$/;"	e	enum:ocr::OCRConst
OCR_TIBETAN_RUS	./OCRTypes/OCRTypes_www.h	/^        OCR_TIBETAN_RUS=3,$/;"	e	enum:ocr::OCRConst
OCR_TIBETAN_SKT	./OCRTypes/OCRTypes.h	/^  OCR_TIBETAN_SKT = 4,$/;"	e	enum:ocr::OCRConst
OCR_TIBETAN_SKT	./OCRTypes/OCRTypes_www.h	/^        OCR_TIBETAN_SKT=4,$/;"	e	enum:ocr::OCRConst
OR_MODE	./OCRTypes/OCRTypes.h	/^  OR_MODE = 3,$/;"	e	enum:ocr::drawConst
OR_MODE	./OCRTypes/OCRTypes_www.h	/^                OR_MODE=3,$/;"	e	enum:ocr::drawConst
OUT_C	./config.h	193;"	d
OUT_S	./config.h	189;"	d
O_POINT	./OCRTypes/OCRTypes.h	/^  O_POINT = 0,      \/\/\/< круги$/;"	e	enum:ocr::graphConst
Off	./GBitMask/GBitMask.h	/^		unsigned int Off[128];     \/\/\/< переферийная маска Off$/;"	m	class:ocr::GBitMask32
On	./GBitMask/GBitMask.h	/^		unsigned int On[128];      \/\/\/< центральная маска On$/;"	m	class:ocr::GBitMask32
On	./GBitMask/GBitMask.h	/^		unsigned int On[512];    \/\/ центральная маска On$/;"	m	class:ocr::GBitMask128
PHP2STL_HEADER	./OCRString/php2stl.h	2;"	d
PI	./OCRAlgorithm/OCRAlgorithm.h	28;"	d
PICT_SIZE	./config.h	257;"	d
PLETTER	./OCRTypes/OCRTypes.h	/^  PLETTER = 0,$/;"	e	enum:ocr::drawConst
PLETTER	./OCRTypes/OCRTypes_www.h	/^                PLETTER=0,$/;"	e	enum:ocr::drawConst
POOL_SIZE	./GMemory/GVector.h	14;"	d
PPMImage	./GBitmap/ppm.h	/^} PPMImage;$/;"	t	typeref:struct:__anon2
PPMPixel	./GBitmap/ppm.h	/^} PPMPixel;$/;"	t	typeref:struct:__anon1
PR	./config.h	173;"	d
PRINT	./config.h	64;"	d
PV	./GGraphOCR/GGraphOCR.h	30;"	d
P_POINT	./OCRTypes/OCRTypes.h	/^  P_POINT = 2,      \/\/\/< точки экстремума кривой и неустойчивые T и X точки$/;"	e	enum:ocr::graphConst
P_POINT	./OCRTypes/OCRTypes_www.h	/^                P_POINT=8$/;"	e	enum:ocr::drawConst
PageWordDet	./GBitset/GBitsetWord.cpp	/^void GBitset::PageWordDet() {$/;"	f	class:GBitset
PageWordDetEng	./GBitset/GBitsetWordEng.cpp	/^void GBitset::PageWordDetEng() {$/;"	f	class:GBitset
PageWordDetTib	./GBitset/GBitsetWordTib.cpp	/^void GBitset::PageWordDetTib() {$/;"	f	class:GBitset
PaliRusDictRE	./GLogicProcessor/dictReport.cpp	/^void GLogicProcessor::PaliRusDictRE(vector<string>&text,int print){$/;"	f	class:GLogicProcessor
Param1	./GFontEditor/GLetter.h	/^  int Param1, Param2;$/;"	m	class:ocr::wordOCR
Param2	./GFontEditor/GLetter.h	/^  int Param1, Param2;$/;"	m	class:ocr::wordOCR
ParameterFilteringDetector	./GBitset/GBitset_Letter.cpp	/^void GBitset::ParameterFilteringDetector(int* Pv1) {$/;"	f	class:GBitset
ParameterMeanDetector	./GBitset/GBitsetWordTib.cpp	/^void GBitset::ParameterMeanDetector() {$/;"	f	class:GBitset
PechaLoaded	./GMainEditor/GMainEditor.h	/^		short PechaLoaded;$/;"	m	class:ocr::GMainEditor
PeriodBlock	./GBitset/GBitsetWord.cpp	/^void GBitset::PeriodBlock() {$/;"	f	class:GBitset
PeriodLetters	./GBitset/GBitsetWordTib.cpp	/^void GBitset::PeriodLetters() {$/;"	f	class:GBitset
PolarCoordinates	./GBitset/GBitset_algorithm.cpp	/^void GBitset::PolarCoordinates(vector<int> &HBuf,$/;"	f	class:GBitset
Popcnt	./OCRTypes/OCRTypes.h	/^  uint32 Popcnt; \/\/ !< поддержка процессором суммирования единиц в регистре$/;"	m	struct:ocr::SCpuInfo
Popcnt	./OCRTypes/OCRTypes_www.h	/^        uint32          Popcnt;             \/\/ !< поддержка процессором суммирования единиц в регистре$/;"	m	struct:ocr::SCpuInfo
PrimaryStringDetector	./GBitset/GBitset_Letter.cpp	/^void GBitset::PrimaryStringDetector(){$/;"	f	class:GBitset
Processors	./OCRTypes/OCRTypes.h	/^      Processors; \/\/ !< Number of physical processors, using the cpuid function$/;"	m	struct:ocr::SCpuInfo
Processors	./OCRTypes/OCRTypes_www.h	/^        uint32          Processors;			\/\/ !< Number of physical processors, using the cpuid function$/;"	m	struct:ocr::SCpuInfo
QueryCpuID	./OCRString/cpuTest.cpp	/^static inline void QueryCpuID(uint32 _EAX, uint32 _EBX, uint32 _ECX, uint32 _EDX, uint32 *_pRegisters)$/;"	f	file:
READBIT	./PNG/lodepng.cpp	441;"	d	file:
READ_FROM_BIN	./OCRTypes/OCRTypes.h	/^  READ_FROM_BIN = 12,$/;"	e	enum:ocr::dataConst
READ_FROM_BIN	./OCRTypes/OCRTypes_www.h	/^        READ_FROM_BIN=12,$/;"	e	enum:ocr::dataConst
READ_FROM_DB	./OCRTypes/OCRTypes.h	/^  READ_FROM_DB = 11,$/;"	e	enum:ocr::dataConst
READ_FROM_DB	./OCRTypes/OCRTypes_www.h	/^        READ_FROM_DB=11,$/;"	e	enum:ocr::dataConst
READ_FROM_TAB	./OCRTypes/OCRTypes.h	/^  READ_FROM_TAB = 13,$/;"	e	enum:ocr::dataConst
READ_FROM_TAB	./OCRTypes/OCRTypes_www.h	/^        READ_FROM_TAB=13,$/;"	e	enum:ocr::dataConst
READ_FROM_TXT	./OCRTypes/OCRTypes.h	/^  READ_FROM_TXT = 15,$/;"	e	enum:ocr::dataConst
READ_FROM_TXT	./OCRTypes/OCRTypes_www.h	/^        READ_FROM_TXT=15,$/;"	e	enum:ocr::dataConst
READ_FROM_XML	./OCRTypes/OCRTypes.h	/^  READ_FROM_XML = 14,$/;"	e	enum:ocr::dataConst
READ_FROM_XML	./OCRTypes/OCRTypes_www.h	/^        READ_FROM_XML=14,$/;"	e	enum:ocr::dataConst
REMAP_STRING_TIB	./OCRTypes/OCRTypes.h	/^  REMAP_STRING_TIB = 4,$/;"	e	enum:ocr::dataConst
REMAP_STRING_TIB	./OCRTypes/OCRTypes_www.h	/^		REMAP_STRING_TIB=4,$/;"	e	enum:ocr::dataConst
REMOVE_DELIMETERS	./OCRTypes/OCRTypes.h	/^  REMOVE_DELIMETERS = 11,$/;"	e	enum:ocr::OCRConst
REPLACE_IN_GMAP	./OCRTypes/OCRTypes.h	/^  REPLACE_IN_GMAP = 23,$/;"	e	enum:ocr::dataConst
REPORT	./GBitsetOCR/pageOCR.cpp	4;"	d	file:
REPORT	./GBitsetOCR/textOCR.cpp	3;"	d	file:
REPORT	./config.h	65;"	d
RGB_COMPONENT_COLOR	./GBitmap/ppm.h	31;"	d
ROOT_LETTER	./OCRTypes/OCRTypes.h	/^  ROOT_LETTER = 1,$/;"	e	enum:ocr::stackFlag
ROOT_LETTER	./OCRTypes/OCRTypes_www.h	/^                ROOT_LETTER = 1,$/;"	e	enum:ocr::stackFlag
ROOT_LETTER_DOWN_VOWEL	./OCRTypes/OCRTypes.h	/^  ROOT_LETTER_DOWN_VOWEL = 5,$/;"	e	enum:ocr::stackFlag
ROOT_LETTER_DOWN_VOWEL	./OCRTypes/OCRTypes_www.h	/^                ROOT_LETTER_DOWN_VOWEL = 5,$/;"	e	enum:ocr::stackFlag
ROOT_LETTER_UP_DOWN_VOWEL	./OCRTypes/OCRTypes.h	/^  ROOT_LETTER_UP_DOWN_VOWEL = 6,$/;"	e	enum:ocr::stackFlag
ROOT_LETTER_UP_DOWN_VOWEL	./OCRTypes/OCRTypes_www.h	/^                ROOT_LETTER_UP_DOWN_VOWEL = 6,$/;"	e	enum:ocr::stackFlag
ROOT_LETTER_VOWEL	./OCRTypes/OCRTypes.h	/^  ROOT_LETTER_VOWEL = 3,$/;"	e	enum:ocr::stackFlag
ROOT_LETTER_VOWEL	./OCRTypes/OCRTypes_www.h	/^                ROOT_LETTER_VOWEL = 3,$/;"	e	enum:ocr::stackFlag
ROOT_PATH	./config.h	33;"	d
ROOT_PATH	./config.h	37;"	d
ROOT_PATH	./config.h	41;"	d
RSHash	./OCRString/php2stl.cpp	/^unsigned int RSHash(cstr str, unsigned int len) {$/;"	f
R_fp	./OCRAlgorithm/f2c.h	/^typedef real (*R_fp)();$/;"	t
R_fp	./OCRAlgorithm/f2c.h	/^typedef real (*R_fp)(...);$/;"	t
Radius	./OCRTypes/OCRTypes.h	/^const short Radius = 15;$/;"	m	namespace:ocr
Radius	./OCRTypes/OCRTypes_www.h	/^	const short Radius=15;$/;"	m	namespace:ocr
ReBf	./GBitset/GBitset.h	/^ int ReBf;      \/\/\/< текущий размер массива ReBuf$/;"	m	class:ocr::GBitset
ReBf	./OCRAlgorithm/OCRAlgorithm.h	/^		 int ReBf;      \/\/\/< текущий размер массива ReBuf$/;"	m	class:ocr::OCRFilter
ReBuf	./GBitset/GBitset.h	/^ int *ReBuf;    \/\/\/< запрос памяти с очисткой 0$/;"	m	class:ocr::GBitset
ReBuf	./OCRAlgorithm/OCRAlgorithm.h	/^		 int *ReBuf;    \/\/\/< запрос памяти с очисткой 0$/;"	m	class:ocr::OCRFilter
RecognitionPoint	./GBitset/GBitsetPoint.cpp	/^void GBitset::RecognitionPoint(){$/;"	f	class:GBitset
RegEAX	./OCRString/cpuTest.cpp	/^	RegEAX = 0,$/;"	e	enum:X86Registers	file:
RegEBX	./OCRString/cpuTest.cpp	/^	RegEBX,$/;"	e	enum:X86Registers	file:
RegECX	./OCRString/cpuTest.cpp	/^	RegECX$/;"	e	enum:X86Registers	file:
RegEDX	./OCRString/cpuTest.cpp	/^	RegEDX,$/;"	e	enum:X86Registers	file:
RemoveBorder	./GImageEditor/GImageEditor_functions.cpp	/^GBitmap* RemoveBorder(GBitmap *data,$/;"	f
RepeatLetterDetector	./GBitset/GBitsetWordTib.cpp	/^void GBitset::RepeatLetterDetector() {$/;"	f	class:GBitset
RepeatStringDetector	./GBitset/GBitset_Letter.cpp	/^void GBitset::RepeatStringDetector() {$/;"	f	class:GBitset
SCALE	./GBitmap/GBitmapRotate.cpp	74;"	d	file:
SCpuInfo	./OCRTypes/OCRTypes.h	/^  SCpuInfo()$/;"	f	struct:ocr::SCpuInfo
SCpuInfo	./OCRTypes/OCRTypes.h	/^struct SCpuInfo \/\/ добавлено CoresSysconf, Popcnt, LinuxKernel, KeySMP$/;"	s	namespace:ocr
SCpuInfo	./OCRTypes/OCRTypes_www.h	/^        SCpuInfo()$/;"	f	struct:ocr::SCpuInfo
SCpuInfo	./OCRTypes/OCRTypes_www.h	/^    struct SCpuInfo     \/\/ добавлено CoresSysconf, Popcnt, LinuxKernel, KeySMP$/;"	s	namespace:ocr
SERIF_LIMIT	./GGraph/GGraph.h	39;"	d
SH	./config.h	188;"	d
SIMD	./OCRTypes/OCRTypes.h	/^  SIMDType SIMD; \/\/ !< SIMD type supported by this procesor$/;"	m	struct:ocr::SCpuInfo
SIMD	./OCRTypes/OCRTypes_www.h	/^        SIMDType        SIMD;				\/\/ !< SIMD type supported by this procesor$/;"	m	struct:ocr::SCpuInfo
SIMDType	./OCRTypes/OCRTypes.h	/^enum SIMDType {$/;"	g	namespace:ocr
SIMDType	./OCRTypes/OCRTypes_www.h	/^    enum SIMDType		{ SIMDUnknown=0, NoSIMD, MMX, SSE, SSE2, SSE3, SSE41, SSE42, Altivec }; $/;"	g	namespace:ocr
SIMDUnknown	./OCRTypes/OCRTypes.h	/^  SIMDUnknown = 0,$/;"	e	enum:ocr::SIMDType
SIMDUnknown	./OCRTypes/OCRTypes_www.h	/^    enum SIMDType		{ SIMDUnknown=0, NoSIMD, MMX, SSE, SSE2, SSE3, SSE41, SSE42, Altivec }; $/;"	e	enum:ocr::SIMDType
SINGLE_LINE	./OCRTypes/OCRTypes.h	/^  SINGLE_LINE = 24,$/;"	e	enum:ocr::dataConst
SMALLMASK	./OCRTypes/OCRTypes.h	/^  SMALLMASK = 8,$/;"	e	enum:ocr::drawConst
SMALLMASK	./OCRTypes/OCRTypes_www.h	/^				SMALLMASK=8,$/;"	e	enum:ocr::drawConst
SOCKET_MODE	./OCRTypes/OCRTypes.h	/^  SOCKET_MODE = 8,$/;"	e	enum:ocr::dataConst
SOCKET_MODE	./OCRTypes/OCRTypes_www.h	/^		SOCKET_MODE=8,$/;"	e	enum:ocr::dataConst
SP	./GBitset/GBitset.h	/^ OCRFilter *SP;     \/\/\/<объект блока фильтров сигналов и буферных массивов фильтрации$/;"	m	class:ocr::GBitset
SPIRAL	./OCRTypes/OCRTypes.h	/^  SPIRAL = 3,$/;"	e	enum:ocr::__anon11
SSE	./OCRTypes/OCRTypes.h	/^  SSE,$/;"	e	enum:ocr::SIMDType
SSE	./OCRTypes/OCRTypes_www.h	/^    enum SIMDType		{ SIMDUnknown=0, NoSIMD, MMX, SSE, SSE2, SSE3, SSE41, SSE42, Altivec }; $/;"	e	enum:ocr::SIMDType
SSE2	./OCRTypes/OCRTypes.h	/^  SSE2,$/;"	e	enum:ocr::SIMDType
SSE2	./OCRTypes/OCRTypes_www.h	/^    enum SIMDType		{ SIMDUnknown=0, NoSIMD, MMX, SSE, SSE2, SSE3, SSE41, SSE42, Altivec }; $/;"	e	enum:ocr::SIMDType
SSE3	./OCRTypes/OCRTypes.h	/^  SSE3,$/;"	e	enum:ocr::SIMDType
SSE3	./OCRTypes/OCRTypes_www.h	/^    enum SIMDType		{ SIMDUnknown=0, NoSIMD, MMX, SSE, SSE2, SSE3, SSE41, SSE42, Altivec }; $/;"	e	enum:ocr::SIMDType
SSE41	./OCRTypes/OCRTypes.h	/^  SSE41,$/;"	e	enum:ocr::SIMDType
SSE41	./OCRTypes/OCRTypes_www.h	/^    enum SIMDType		{ SIMDUnknown=0, NoSIMD, MMX, SSE, SSE2, SSE3, SSE41, SSE42, Altivec }; $/;"	e	enum:ocr::SIMDType
SSE42	./OCRTypes/OCRTypes.h	/^  SSE42,$/;"	e	enum:ocr::SIMDType
SSE42	./OCRTypes/OCRTypes_www.h	/^    enum SIMDType		{ SIMDUnknown=0, NoSIMD, MMX, SSE, SSE2, SSE3, SSE41, SSE42, Altivec }; $/;"	e	enum:ocr::SIMDType
STACK_2LETTER	./OCRTypes/OCRTypes.h	/^  STACK_2LETTER = 7,$/;"	e	enum:ocr::stackFlag
STACK_2LETTER	./OCRTypes/OCRTypes_www.h	/^                STACK_2LETTER = 7,$/;"	e	enum:ocr::stackFlag
STACK_2LETTER_DOWN_VOWEL	./OCRTypes/OCRTypes.h	/^  STACK_2LETTER_DOWN_VOWEL = 11,$/;"	e	enum:ocr::stackFlag
STACK_2LETTER_DOWN_VOWEL	./OCRTypes/OCRTypes_www.h	/^                STACK_2LETTER_DOWN_VOWEL = 11,$/;"	e	enum:ocr::stackFlag
STACK_2LETTER_UP_DOWN_VOWEL	./OCRTypes/OCRTypes.h	/^  STACK_2LETTER_UP_DOWN_VOWEL = 12,$/;"	e	enum:ocr::stackFlag
STACK_2LETTER_UP_DOWN_VOWEL	./OCRTypes/OCRTypes_www.h	/^                STACK_2LETTER_UP_DOWN_VOWEL = 12,$/;"	e	enum:ocr::stackFlag
STACK_2LETTER_VOWEL	./OCRTypes/OCRTypes.h	/^  STACK_2LETTER_VOWEL = 9,$/;"	e	enum:ocr::stackFlag
STACK_2LETTER_VOWEL	./OCRTypes/OCRTypes_www.h	/^                STACK_2LETTER_VOWEL = 9,$/;"	e	enum:ocr::stackFlag
STACK_3LETTER	./OCRTypes/OCRTypes.h	/^  STACK_3LETTER = 13, \/\/:)$/;"	e	enum:ocr::stackFlag
STACK_3LETTER	./OCRTypes/OCRTypes_www.h	/^                STACK_3LETTER = 13,   \/\/:)$/;"	e	enum:ocr::stackFlag
STACK_3LETTER_DOWN_VOWEL	./OCRTypes/OCRTypes.h	/^  STACK_3LETTER_DOWN_VOWEL = 17,$/;"	e	enum:ocr::stackFlag
STACK_3LETTER_DOWN_VOWEL	./OCRTypes/OCRTypes_www.h	/^                STACK_3LETTER_DOWN_VOWEL = 17,$/;"	e	enum:ocr::stackFlag
STACK_3LETTER_UP_DOWN_VOWEL	./OCRTypes/OCRTypes.h	/^  STACK_3LETTER_UP_DOWN_VOWEL = 19,$/;"	e	enum:ocr::stackFlag
STACK_3LETTER_UP_DOWN_VOWEL	./OCRTypes/OCRTypes_www.h	/^                STACK_3LETTER_UP_DOWN_VOWEL = 19,$/;"	e	enum:ocr::stackFlag
STACK_3LETTER_VOWEL	./OCRTypes/OCRTypes.h	/^  STACK_3LETTER_VOWEL = 15,$/;"	e	enum:ocr::stackFlag
STACK_3LETTER_VOWEL	./OCRTypes/OCRTypes_www.h	/^                STACK_3LETTER_VOWEL = 15,$/;"	e	enum:ocr::stackFlag
STACK_4LETTER	./OCRTypes/OCRTypes.h	/^  STACK_4LETTER = 21,$/;"	e	enum:ocr::stackFlag
STACK_4LETTER	./OCRTypes/OCRTypes_www.h	/^                STACK_4LETTER = 21,$/;"	e	enum:ocr::stackFlag
STACK_4LETTER_DOWN_VOWEL	./OCRTypes/OCRTypes.h	/^  STACK_4LETTER_DOWN_VOWEL = 25,$/;"	e	enum:ocr::stackFlag
STACK_4LETTER_DOWN_VOWEL	./OCRTypes/OCRTypes_www.h	/^                STACK_4LETTER_DOWN_VOWEL = 25,$/;"	e	enum:ocr::stackFlag
STACK_4LETTER_UP_DOWN_VOWEL	./OCRTypes/OCRTypes.h	/^  STACK_4LETTER_UP_DOWN_VOWEL = 27,$/;"	e	enum:ocr::stackFlag
STACK_4LETTER_UP_DOWN_VOWEL	./OCRTypes/OCRTypes_www.h	/^				STACK_4LETTER_UP_DOWN_VOWEL = 27,$/;"	e	enum:ocr::stackFlag
STACK_4LETTER_VOWEL	./OCRTypes/OCRTypes.h	/^  STACK_4LETTER_VOWEL = 23,$/;"	e	enum:ocr::stackFlag
STACK_4LETTER_VOWEL	./OCRTypes/OCRTypes_www.h	/^                STACK_4LETTER_VOWEL = 23,$/;"	e	enum:ocr::stackFlag
START_MATCH	./GMemory/GMap/GMap.h	/^		START_MATCH=1,$/;"	e	enum:ocr::searchParam
STRING_FIND	./OCRTypes/OCRTypes.h	/^  STRING_FIND = 6,$/;"	e	enum:ocr::dataConst
STRING_FIND	./OCRTypes/OCRTypes_www.h	/^		STRING_FIND=6,$/;"	e	enum:ocr::dataConst
STRING_SEARCH	./OCRTypes/OCRTypes.h	/^  STRING_SEARCH = 8,$/;"	e	enum:ocr::searchModeConst
S_POINT	./OCRTypes/OCRTypes.h	/^  S_POINT = 8,      \/\/\/< точка фокальной линии лимитированной длины$/;"	e	enum:ocr::graphConst
S_fp	./OCRAlgorithm/f2c.h	/^typedef \/* Subroutine *\/ int (*S_fp)();$/;"	t
S_fp	./OCRAlgorithm/f2c.h	/^typedef \/* Subroutine *\/ int (*S_fp)(...);$/;"	t
SanskritRusDictRE	./GLogicProcessor/dictReport.cpp	/^void GLogicProcessor::SanskritRusDictRE(vector<string>&text,int print){$/;"	f	class:GLogicProcessor
ScheduleProbability	./GBitset/GBitset.cpp	/^void GBitset::ScheduleProbability( vector<int> &LFase, vector<int> &LGilb,$/;"	f	class:ocr::GBitset
SetFPUState	./OCRString/cpuTest.cpp	/^static inline void SetFPUState(uint32 _State)$/;"	f	file:
SetFastFPU	./OCRString/cpuTest.cpp	/^void SetFastFPU()$/;"	f	namespace:x86
SetFlags	./OCRString/cpuTest.cpp	/^inline void SetFlags(uint16 _StateFlag)$/;"	f
SetPreciseFPU	./OCRString/cpuTest.cpp	/^void SetPreciseFPU()$/;"	f	namespace:x86
ShortBurstNP	./GBitset/GBitsetWordTib.cpp	/^void GBitset::ShortBurstNP(bit_vector  &AMask) {$/;"	f	class:GBitset
ShortBurstNpBl	./GBitset/GBitsetWord.cpp	/^void GBitset::ShortBurstNpBl(bit_vector  &AMask) {$/;"	f	class:GBitset
ShortStringDetector	./GBitset/GBitsetNet.cpp	/^void GBitset::ShortStringDetector() {$/;"	f	class:GBitset
SinghalaASCIToYagpo	./GLogicProcessor/codePagesConverter.cpp	/^string GLogicProcessor::SinghalaASCIToYagpo(string &uniStack){$/;"	f	class:GLogicProcessor
SinhalaASCI	./GLogicProcessor/GLogicProcessor.h	/^	map<string,string> SinhalaASCI;  \/\/map for Sinhala font convertion function  $/;"	m	class:ocr::GLogicProcessor
SinhalaUniToYagpo	./GLogicProcessor/UniToYagpo.cpp	/^string GLogicProcessor::SinhalaUniToYagpo(string &uniStack,int mode){$/;"	f	class:GLogicProcessor
Sort	./OCRAlgorithm/OCRAlgorithm.cpp	/^void Sort(vector<int> &GBuf,int Nff){$/;"	f	namespace:ocr
SplitColumBtn	./GBitset/GBitset.h	/^ int SplitColumBtn;  \/\/\/< обработка скана с РАЗДЕЛЕНИЕМ на файлы - КОЛОНКИ.$/;"	m	class:ocr::GBitset
SplitPagesBtn	./GBitset/GBitset.h	/^ int SplitPagesBtn;  \/\/\/< обработка скана (разворотов книги) с РАЗДЕЛЕНИЕМ  на файлы - СТРАНИЦИ.$/;"	m	class:ocr::GBitset
SquarePointDetector	./GBitset/GBitsetCorrectSqH.cpp	/^void GBitset::SquarePointDetector(){$/;"	f	class:GBitset
StablePoint	./GGraph/GGraphStableFocalPoint.cpp	/^  int  GGraph::StablePoint() {$/;"	f	class:ocr::GGraph
StablePoint	./GGraphBezier/GGraphStableFocalPointBezier.cpp	/^    int  GGraphBezier::StablePoint(vector<OCRPointFloat>&focalPoint) {$/;"	f	class:ocr::GGraphBezier
StablePointT	./GGraph/GGraphStableFocalPoint.cpp	/^  int  GGraph::StablePointT() {$/;"	f	class:ocr::GGraph
StablePointT	./GGraphBezier/GGraphStableFocalPointBezier.cpp	/^    int  GGraphBezier::StablePointT(vector<OCRPointFloat>&focalPoint) {$/;"	f	class:ocr::GGraphBezier
StartCpuInfo	./OCRString/cpuTest.cpp	/^void StartCpuInfo()$/;"	f
StatCorrectLetter	./GBitset/GBitsetCorrectSqL.cpp	/^void GBitset::StatCorrectLetter(vector<int> &WordS, int sizeWdS){$/;"	f	class:GBitset
StatPointLocal	./GBitset/GBitsetPoint.cpp	/^void GBitset::StatPointLocal( int* WPnt, int* HPnt, int* MPoint, int* ms, int* ns ){$/;"	f	class:GBitset
State	./PNG/lodepng.cpp	/^State::State()$/;"	f	class:lodepng::State
State	./PNG/lodepng.cpp	/^State::State(const State& other)$/;"	f	class:lodepng::State
State	./PNG/lodepng.h	/^class State : public LodePNGState$/;"	c	namespace:lodepng
StructureWorld	./GBitset/GBitsetStructure.cpp	/^void GBitset::StructureWorld(){$/;"	f	class:GBitset
SumBit32	./OCRAlgorithm/OCRAlgorithm.cpp	/^    int SumBit32(int Sb){$/;"	f	namespace:ocr
SumBitOn	./GGraph/GGraph.h	/^	int SumBitOn;$/;"	m	struct:ocr::OCRLineStruct
SumNAmp	./GBitset/GBitset.h	/^		int SumNAmp; \/\/\/< суммарное число хороших отсчетов по всем слайсам$/;"	m	class:ocr::GBitset
SumTxtP	./GMemory/GMap/GMap.h	/^        mSIZE *SumTxtP;       \/\/ массив статистической устойчивости распознаваемого текста (массив частоты встречаемости пар букв)$/;"	m	class:ocr::GMap
SumTxtP_vector	./GMemory/GMap/GMap.h	/^        GStr<mSIZE>*SumTxtP_vector;$/;"	m	class:ocr::GMap
SystemMasksNP	./GBitset/GBitsetWordTib.cpp	/^void GBitset::SystemMasksNP(bit_vector  &AMask) {$/;"	f	class:GBitset
SystemMasksNpBl	./GBitset/GBitsetWord.cpp	/^void GBitset::SystemMasksNpBl(bit_vector  &AMask) {$/;"	f	class:GBitset
TEST_LETTER	./OCRTypes/OCRTypes.h	/^  TEST_LETTER = 2,$/;"	e	enum:ocr::drawConst
TEST_LETTER	./OCRTypes/OCRTypes_www.h	/^				TEST_LETTER=2,$/;"	e	enum:ocr::drawConst
TEXT_DICT_SEARCH	./OCRTypes/OCRTypes.h	/^  TEXT_DICT_SEARCH = 12$/;"	e	enum:ocr::searchModeConst
TEXT_SEARCH	./OCRTypes/OCRTypes.h	/^  TEXT_SEARCH = 0,$/;"	e	enum:ocr::searchModeConst
TIB_FROM_HASH	./OCRTypes/OCRTypes.h	/^  TIB_FROM_HASH = 3,$/;"	e	enum:ocr::dataConst
TIB_FROM_HASH	./OCRTypes/OCRTypes_www.h	/^		TIB_FROM_HASH=3,$/;"	e	enum:ocr::dataConst
TIB_TO_ENG_UTF	./OCRTypes/OCRTypes.h	/^  TIB_TO_ENG_UTF = 2,$/;"	e	enum:ocr::dataConst
TIB_TO_ENG_UTF	./OCRTypes/OCRTypes_www.h	/^		TIB_TO_ENG_UTF=2,$/;"	e	enum:ocr::dataConst
TIFF_FILE	./config.h	256;"	d
TIME_ADD	./config.h	215;"	d
TIME_ADD_ASM	./config.h	241;"	d
TIME_PRINT	./config.h	201;"	d
TIME_PRINT_	./config.h	208;"	d
TIME_PRINT_ADD	./config.h	220;"	d
TIME_PRINT_ASM	./config.h	229;"	d
TIME_START	./config.h	197;"	d
TIME_START_ADD	./config.h	214;"	d
TIME_START_ADD_ASM	./config.h	238;"	d
TIME_START_ASM	./config.h	224;"	d
TLline	./GFontEditor/GLetter.h	/^  vector<TsertoOCR> TLline;$/;"	m	class:ocr::wordOCR
TRANSLATE	./OCRTypes/OCRTypes.h	/^  TRANSLATE = 1,$/;"	e	enum:ocr::dataConst
TRANSLATE_ENG	./OCRTypes/OCRTypes.h	/^  TRANSLATE_ENG = 14,$/;"	e	enum:ocr::OCRConst
TRANSLATE_RUS	./OCRTypes/OCRTypes.h	/^  TRANSLATE_RUS = 15$/;"	e	enum:ocr::OCRConst
TRUE_	./OCRAlgorithm/f2c.h	30;"	d
TString	./GMemory/GVector.cpp	/^TString::TString(void) {$/;"	f	class:TString
TString	./GMemory/GVector.h	/^class TString$/;"	c	namespace:ocr
T_POINT	./OCRTypes/OCRTypes.h	/^  T_POINT = 3,      \/\/\/< точки Т-образных пересечений линий$/;"	e	enum:ocr::graphConst
T_POINT	./OCRTypes/OCRTypes_www.h	/^                T_POINT=1,$/;"	e	enum:ocr::drawConst
Test	./GGraphBezier/GGraphTestBezier.cpp	/^    void GGraphBezier::Test(OCRFocalLineBezier &line1, OCRFocalLineBezier &line2){$/;"	f	class:ocr::GGraphBezier
TibRootLetter	./TibetanNameSpace/TibRootLetter.h	/^void TibRootLetter(vector<rootLetterOCR>&rootLetter,$/;"	f
TibRusDictRE	./GLogicProcessor/dictReport.cpp	/^void GLogicProcessor::TibRusDictRE(vector<string>&text,int print,int mode){$/;"	f	class:GLogicProcessor
TibRusDictReport	./GLogicProcessor/dictReport.cpp	/^void GLogicProcessor::TibRusDictReport(GVector*vectorDict, GStr<uint>*keyDict,GVector*strVector){$/;"	f	class:GLogicProcessor
TibRusDictReport	./GLogicProcessor/dictReport.cpp	/^void GLogicProcessor::TibRusDictReport(GVector*vectorDict, GStr<uint>*keyDict,string &textStr){$/;"	f	class:GLogicProcessor
TibetanAlphabet	./GLogicProcessor/GLogicProcessor.h	/^	vector<string>TibetanAlphabet;$/;"	m	class:ocr::GLogicProcessor
TibetanCorrector	./GLogicProcessor/UniToYagpo.cpp	/^void GLogicProcessor::TibetanCorrector(){$/;"	f	class:GLogicProcessor
Transcription	./GLogicProcessor/UniToYagpo.cpp	/^void GLogicProcessor::Transcription(){$/;"	f	class:GLogicProcessor
TsertoOCR	./GFontEditor/GLetter.cpp	/^TsertoOCR::TsertoOCR(){};$/;"	f	class:TsertoOCR
TsertoOCR	./GFontEditor/GLetter.h	/^class TsertoOCR {$/;"	c	namespace:ocr
TurnBookDetector	./GBitset/GBitsetPageSegmentation.cpp	/^void GBitset::TurnBookDetector() {$/;"	f	class:GBitset
TurnX	./GBitset/GBitset.h	/^ int TurnX;     \/\/\/< координата серидины разворота книги (по X).$/;"	m	class:ocr::GBitset
Type	./OCRTypes/OCRTypes.h	/^  CpuType Type;  \/\/ !< Processor type$/;"	m	struct:ocr::SCpuInfo
Type	./OCRTypes/OCRTypes_www.h	/^        CpuType         Type;				\/\/ !< Processor type$/;"	m	struct:ocr::SCpuInfo
UNIX	./config.h	18;"	d
UTF_to_Unicode	./OCRString/php2stl.cpp	/^wstring UTF_to_Unicode(cstr name) {$/;"	f
UTF_to_Unicode	./OCRString/php2stl.cpp	/^wstring UTF_to_Unicode(string &input) {$/;"	f
UTF_to_UnicodeVector	./OCRString/php2stl.cpp	/^void UTF_to_UnicodeVector(string &input, vector<uint> &vt) {$/;"	f
UTF_to_UnicodeVector	./OCRString/php2stl.cpp	/^void UTF_to_UnicodeVector(string &input, vector<ushort> &vt) {$/;"	f
U_fp	./OCRAlgorithm/f2c.h	/^typedef int \/* Unknown procedure type *\/ (*U_fp)();$/;"	t
U_fp	./OCRAlgorithm/f2c.h	/^typedef int \/* Unknown procedure type *\/ (*U_fp)(...);$/;"	t
Uni	./GLogicProcessor/GLogicProcessor.h	/^    vector <string> Uni;$/;"	m	class:ocr::GLogicProcessor
UniBigLetters	./GLogicProcessor/GLogicProcessor.h	/^	uint UniBigLetters[65000];      \/\/\/table for joined to capitals letter conversion$/;"	m	class:ocr::GLogicProcessor
UniToTibetan	./GLogicProcessor/UniToYagpo.cpp	/^string GLogicProcessor::UniToTibetan(string &uniStack, int YagpoWylieFontFlag){$/;"	f	class:GLogicProcessor
UniToWylieConverter	./GLogicProcessor/codePagesConverter.cpp	/^string GLogicProcessor::UniToWylieConverter(string &srcStr,int mode){$/;"	f	class:GLogicProcessor
UniToWylieMap	./GLogicProcessor/GLogicProcessor.h	/^	map<string, uniRecord>UniToWylieMap; \/\/\/<map of Uni To Wylie conversion$/;"	m	class:ocr::GLogicProcessor
UnicodeToYagpo	./GLogicProcessor/codePagesConverter.cpp	/^string GLogicProcessor::UnicodeToYagpo(string &srcStr){$/;"	f	class:GLogicProcessor
Unicode_to_UTF	./OCRString/php2stl.cpp	/^string Unicode_to_UTF(string &input) {$/;"	f
Unicode_to_UTF	./OCRString/php2stl.cpp	/^string Unicode_to_UTF(wchar_t input) {$/;"	f
Unicode_to_UTF	./OCRString/php2stl.cpp	/^string Unicode_to_UTF(wstring &input) {$/;"	f
VECTOR_OCR	./OCRTypes/OCRTypes.h	/^  VECTOR_OCR = 5,$/;"	e	enum:ocr::drawConst
VOID	./OCRAlgorithm/f2c.h	126;"	d
VOWEL	./OCRTypes/OCRTypes.h	/^  VOWEL = 0,$/;"	e	enum:ocr::stackFlag
VOWEL	./OCRTypes/OCRTypes_www.h	/^                VOWEL = 0,$/;"	e	enum:ocr::stackFlag
Vardesc	./OCRAlgorithm/f2c.h	/^struct Vardesc {	\/* for Namelist *\/$/;"	s
Vardesc	./OCRAlgorithm/f2c.h	/^typedef struct Vardesc Vardesc;$/;"	t	typeref:struct:Vardesc
VarianceSA	./GBitset/GBitset.h	/^  int VarianceSA;  \/\/\/< вычисленная дисперсия периода букв умноженныя на 10private:$/;"	m	class:ocr::GBitset
VerticalMirror	./GBitmap/GBitmapTextOrientation.cpp	/^  void  GBitmap::VerticalMirror() {$/;"	f	class:ocr::GBitmap
WDraw	./GBitset/GBitset_algorithm.cpp	/^void GBitset::WDraw(vector<int> &HBuf, int sm, int color){ \/\/  LStr$/;"	f	class:GBitset
WDrawVar	./GBitset/GBitset_algorithm.cpp	/^void GBitset::WDrawVar(vector<int> &HBuf, int WDrawSize, int sm, int scope, int color){$/;"	f	class:GBitset
WIN32	./config.h	49;"	d
WIN32_DRAW	./config.h	48;"	d
WLETTER	./OCRTypes/OCRTypes.h	/^  WLETTER = 1,$/;"	e	enum:ocr::drawConst
WLETTER	./OCRTypes/OCRTypes_www.h	/^                WLETTER=1,$/;"	e	enum:ocr::drawConst
WordSMax	./GBitset/GBitset.h	/^  int WordSMax;    \/\/\/< вычисленное значение максимального колличества букв$/;"	m	class:ocr::GBitset
WriteSpreadData	./GImageEditor/GImageEditor_functions.cpp	/^void WriteSpreadData(GBitmap *data,  $/;"	f
Wylie	./GFontEditor/GLetter.h	/^  string Wylie;$/;"	m	class:ocr::wordOCR
Wylie	./GLogicProcessor/GLogicProcessor.h	/^    vector <string> Wylie;$/;"	m	class:ocr::GLogicProcessor
Wylie	./OCRTypes/OCRTypes.h	/^  string Wylie;$/;"	m	struct:ocr::uniLetterRecord
Wylie	./OCRTypes/OCRTypes_www.h	/^		string Wylie;$/;"	m	struct:ocr::uniLetterRecord
WylieToUnicode	./GLogicProcessor/UniToYagpo.cpp	/^string GLogicProcessor::WylieToUnicode(string &line,int mode){$/;"	f	class:GLogicProcessor
WylieToYagpoConverter	./GLogicProcessor/codePagesConverter.cpp	/^string GLogicProcessor::WylieToYagpoConverter(string &inStr){$/;"	f	class:GLogicProcessor
X86Registers	./OCRString/cpuTest.cpp	/^enum X86Registers$/;"	g	file:
XMCenter	./GBitsetContour/GBitsetContour.h	/^	short xMax,xMin,yMin,yMax, XMCenter, YMCenter, startDir;$/;"	m	class:ocr::GBitsetContour
XMLEncode	./OCRString/php2stl.cpp	/^string XMLEncode(cstr input) {$/;"	f
XMLEncode	./OCRString/php2stl.cpp	/^string XMLEncode(string &input) {$/;"	f
XOR_MODE	./OCRTypes/OCRTypes.h	/^  XOR_MODE = 2,$/;"	e	enum:ocr::drawConst
XOR_MODE	./OCRTypes/OCRTypes_www.h	/^                XOR_MODE=2,$/;"	e	enum:ocr::drawConst
XYPointLocal	./GBitset/GBitsetPoint.cpp	/^void GBitset::XYPointLocal( int xp0, int xp1, int yp0, int yp1 ){$/;"	f	class:GBitset
X_POINT	./OCRTypes/OCRTypes.h	/^  X_POINT = 4,      \/\/\/< точки Х-образных пересечений линий$/;"	e	enum:ocr::graphConst
X_POINT	./OCRTypes/OCRTypes_www.h	/^                X_POINT=2,$/;"	e	enum:ocr::drawConst
Xc0	./GFontEditor/GLetter.h	/^  int Xc0, Yc0, Xc1, Yc1;$/;"	m	class:ocr::columnOCR
Xc1	./GFontEditor/GLetter.h	/^  int Xc0, Yc0, Xc1, Yc1;$/;"	m	class:ocr::columnOCR
Xf0	./GFontEditor/GLetter.h	/^  int Xf0, Yf0, Xf1, Yf1;$/;"	m	class:ocr::frameOCR
Xf1	./GFontEditor/GLetter.h	/^  int Xf0, Yf0, Xf1, Yf1;$/;"	m	class:ocr::frameOCR
Xfg0	./GFontEditor/GLetter.h	/^  int Xfg0, Yfg0, Xfg1, Yfg1;$/;"	m	class:ocr::frameOCR
Xfg1	./GFontEditor/GLetter.h	/^  int Xfg0, Yfg0, Xfg1, Yfg1;$/;"	m	class:ocr::frameOCR
YMCenter	./GBitsetContour/GBitsetContour.h	/^	short xMax,xMin,yMin,yMax, XMCenter, YMCenter, startDir;$/;"	m	class:ocr::GBitsetContour
YagpoToUni	./GLogicProcessor/UniToYagpo.cpp	/^string GLogicProcessor::YagpoToUni(string &srcStr){$/;"	f	class:GLogicProcessor
YagpoToWylieMap	./GLogicProcessor/GLogicProcessor.h	/^	map<string, uniRecord>YagpoToWylieMap; \/\/\/<map of Yagpo UTF To Wylie conversion$/;"	m	class:ocr::GLogicProcessor
Yc0	./GFontEditor/GLetter.h	/^  int Xc0, Yc0, Xc1, Yc1;$/;"	m	class:ocr::columnOCR
Yc1	./GFontEditor/GLetter.h	/^  int Xc0, Yc0, Xc1, Yc1;$/;"	m	class:ocr::columnOCR
Yf0	./GFontEditor/GLetter.h	/^  int Xf0, Yf0, Xf1, Yf1;$/;"	m	class:ocr::frameOCR
Yf1	./GFontEditor/GLetter.h	/^  int Xf0, Yf0, Xf1, Yf1;$/;"	m	class:ocr::frameOCR
Yfg0	./GFontEditor/GLetter.h	/^  int Xfg0, Yfg0, Xfg1, Yfg1;$/;"	m	class:ocr::frameOCR
Yfg1	./GFontEditor/GLetter.h	/^  int Xfg0, Yfg0, Xfg1, Yfg1;$/;"	m	class:ocr::frameOCR
ZFunction	./OCRAlgorithm/OCRAlgorithmFFT.cpp	/^vector<int> ZFunction (wstring s) {$/;"	f	namespace:ocr
Z_POINT	./OCRTypes/OCRTypes.h	/^  Z_POINT = 7,      \/\/\/< точка фокальной линии нулевой длины$/;"	e	enum:ocr::graphConst
Z_f	./OCRAlgorithm/f2c.h	/^typedef VOID Z_f;	\/* double complex function *\/$/;"	t
Z_fp	./OCRAlgorithm/f2c.h	/^typedef \/* Double Complex *\/ VOID (*Z_fp)();$/;"	t
Z_fp	./OCRAlgorithm/f2c.h	/^typedef \/* Double Complex *\/ VOID (*Z_fp)(...);$/;"	t
_GBITMAP_H_	./GBitmap/GBitmap.h	19;"	d
_GBITSET_H_	./GBitset/GBitset.h	14;"	d
_GBitsetContour_H_	./GBitsetContour/GBitsetContour.h	3;"	d
_GBitsetMatrix_H_	./GBitsetMatrix/GBitsetMatrix.h	14;"	d
_GImageEditorOCR_H_	./GImageEditorOCR/GImageEditorOCR.h	20;"	d
_GImageEditor_H_	./GImageEditor/GImageEditor.h	20;"	d
_GLogicProcessor_H_	./GLogicProcessor/GLogicProcessor.h	15;"	d
_GMainEditor_H_	./GMainEditor/GMainEditor.h	20;"	d
_GMap_H_	./GMemory/GMap/GMap.h	19;"	d
_GMemory_H_	./GMemory/GMemory.h	19;"	d
__OCRLib__GGraphOCR__	./GGraphOCR/GGraphOCR.h	16;"	d
__OCRLib__GGraph__	./GGraph/GGraph.h	16;"	d
__OCRLib__GraphOCR__	./GGraphBezier/GGraphBezier.h	18;"	d
_algorithmOCR_128_H	./GBitMask/algorithmOCR_128.cpp	15;"	d	file:
_algorithmOCR_32_H	./GBitMask/algorithmOCR_32.cpp	15;"	d	file:
_matrix_H	./GBitMask/matrixT.cpp	15;"	d	file:
a	./GBitsetContour/GBitsetContour.h	/^	int w,h,a, resX, resY;$/;"	m	class:ocr::GBitsetContour
a	./codeStorage.h	/^int a=0;$/;"	v
a	./codeStorage.h	/^int a=1;$/;"	v
aRefImgs	./GPDF/CGImageFromPDF.h	/^NSMutableArray *aRefImgs;$/;"	v
aaaa	./test_clang.h	/^int aaaa=12;$/;"	v
abs	./OCRAlgorithm/f2c.h	158;"	d
activeGFont	./GFontEditor/GFontEditor.h	/^        vector<GFont*> activeGFont;$/;"	m	class:ocr::GFontEditor
ad	./test_clang.h	/^            vector <   int>ad;$/;"	v
adaptiveFiltration	./GImageEditor/GImageEditorAdaptiveFiltration.cpp	/^void adaptiveFiltration(GBitmap *img_pecha,float scale,int mode){$/;"	f
adaptiveFiltration1	./GImageEditor/GImageEditorAdaptiveFiltration.cpp	/^void adaptiveFiltration1(GBitmap *img_pecha,float *p,int mode){$/;"	f
addBitToStream	./PNG/lodepng.cpp	417;"	d	file:
addBitsToStream	./PNG/lodepng.cpp	/^static void addBitsToStream(size_t* bitpointer, ucvector* bitstream, unsigned value, size_t nbits)$/;"	f	file:
addBitsToStreamReversed	./PNG/lodepng.cpp	/^static void addBitsToStreamReversed(size_t* bitpointer, ucvector* bitstream, unsigned value, size_t nbits)$/;"	f	file:
addChunk	./PNG/lodepng.cpp	/^static unsigned addChunk(ucvector* out, const char* chunkName, const unsigned char* data, size_t length)$/;"	f	file:
addChunk_IDAT	./PNG/lodepng.cpp	/^static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,$/;"	f	file:
addChunk_IEND	./PNG/lodepng.cpp	/^static unsigned addChunk_IEND(ucvector* out)$/;"	f	file:
addChunk_IHDR	./PNG/lodepng.cpp	/^static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,$/;"	f	file:
addChunk_PLTE	./PNG/lodepng.cpp	/^static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info)$/;"	f	file:
addChunk_bKGD	./PNG/lodepng.cpp	/^static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info)$/;"	f	file:
addChunk_cHRM	./PNG/lodepng.cpp	/^static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info)$/;"	f	file:
addChunk_gAMA	./PNG/lodepng.cpp	/^static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info)$/;"	f	file:
addChunk_iCCP	./PNG/lodepng.cpp	/^static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings)$/;"	f	file:
addChunk_iTXt	./PNG/lodepng.cpp	/^static unsigned addChunk_iTXt(ucvector* out, unsigned compressed, const char* keyword, const char* langtag,$/;"	f	file:
addChunk_pHYs	./PNG/lodepng.cpp	/^static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info)$/;"	f	file:
addChunk_sRGB	./PNG/lodepng.cpp	/^static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info)$/;"	f	file:
addChunk_tEXt	./PNG/lodepng.cpp	/^static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring)$/;"	f	file:
addChunk_tIME	./PNG/lodepng.cpp	/^static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time)$/;"	f	file:
addChunk_tRNS	./PNG/lodepng.cpp	/^static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info)$/;"	f	file:
addChunk_zTXt	./PNG/lodepng.cpp	/^static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,$/;"	f	file:
addColorBits	./PNG/lodepng.cpp	/^static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in)$/;"	f	file:
addHuffmanSymbol	./PNG/lodepng.cpp	/^static void addHuffmanSymbol(size_t* bp, ucvector* compressed, unsigned code, unsigned bitlen)$/;"	f	file:
addLengthDistance	./PNG/lodepng.cpp	/^static void addLengthDistance(uivector* values, size_t length, size_t distance)$/;"	f	file:
addLetter	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::addLetter(OCRLetter &letter) {$/;"	f	class:ocr::GGraphOCR
addLettersToOCRFont	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::addLettersToOCRFont(cstr path) {$/;"	f	class:ocr::GGraphOCR
addMask32Vector	./GFontEditor/GLetter.cpp	/^void OCRMatch::addMask32Vector(OCRMatch &a){$/;"	f	class:OCRMatch
addPaddingBits	./PNG/lodepng.cpp	/^static void addPaddingBits(unsigned char* out, const unsigned char* in,$/;"	f	file:
addRecord	./GMemory/GMap/tableDict.cpp	/^void GMap::addRecord(TString &st){$/;"	f	class:GMap
addRecords	./GMemory/GMap/GMap.h	/^        void addRecords(cstr path_,size_t mode){string path=path_; return addRecords(path, mode);}$/;"	f	class:ocr::GMap
addRecords	./GMemory/GMap/tableDict.cpp	/^void GMap::addRecords(GVector *dataVector,int keyField, size_t mode){$/;"	f	class:GMap
addRecords	./GMemory/GMap/tableDict.cpp	/^void GMap::addRecords(string &path,size_t mode){$/;"	f	class:GMap
addRecords	./GMemory/GVector.cpp	/^void GVector::addRecords(GVector *ref) {$/;"	f	class:GVector
addUnknownChunks	./PNG/lodepng.cpp	/^static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize)$/;"	f	file:
add_id	./PNG/lodepng.h	/^  unsigned add_id;$/;"	m	struct:LodePNGEncoderSettings
addr	./OCRAlgorithm/f2c.h	/^	char *addr;$/;"	m	struct:Vardesc
address	./OCRAlgorithm/f2c.h	/^typedef char *address;$/;"	t
adler32	./PNG/lodepng.cpp	/^static unsigned adler32(const unsigned char* data, unsigned len)$/;"	f	file:
adress	./OCRTypes/OCRTypes.h	/^  unsigned int adress;$/;"	m	struct:ocr::hashRecord_
adress	./OCRTypes/OCRTypes_www.h	/^		unsigned int adress;$/;"	m	struct:ocr::hashRecord_
aerr	./OCRAlgorithm/f2c.h	/^{	flag aerr;$/;"	m	struct:__anon9
aliKali	./GBitsetMatrix/GBitsetMatrix.h	/^  GLetter *aliKali;               \/\/\/<ссылка на базу букв$/;"	m	class:ocr::GBitsetMatrix
aliKali	./GBitsetOCR/GBitsetOCR.h	/^	GFont *aliKali;$/;"	m	class:ocr::GBitsetOCR
aliKali	./GFontEditor/GFontEditor.h	/^        GFont* aliKali;$/;"	m	class:ocr::GFontEditor
aliKali	./GLogicProcessor/GLogicProcessor.h	/^    GFont *aliKali;                 \/\/OCRFont of text recognition$/;"	m	class:ocr::GLogicProcessor
aliKali	./GMainEditor/GMainEditor.h	/^        GFont* aliKali;                             \/\/\/<main letter OCR base$/;"	m	class:ocr::GMainEditor
alist	./OCRAlgorithm/f2c.h	/^} alist;$/;"	t	typeref:struct:__anon9
allLetterCount	./GFontEditor/GLetter.h	/^  int allLetterCount;$/;"	m	class:ocr::GLetter
allLetterCount	./OCRTypes/OCRTypes.h	/^  int allLetterCount;$/;"	m	class:ocr::vectorOCR
allMatchCount	./GFontEditor/GLetter.h	/^  int allMatchCount;$/;"	m	class:ocr::OCRMatch
allMatchCount	./GFontEditor/GLetter.h	/^  int allMatchCount;$/;"	m	class:ocr::OCRMatchConst
allVectorCount	./OCRTypes/OCRTypes.h	/^  unsigned int allVectorCount;$/;"	m	class:ocr::vectorOCR
alloc_string	./PNG/lodepng.cpp	/^static char* alloc_string(const char* in)$/;"	f	file:
allocsize	./PNG/lodepng.cpp	/^  size_t allocsize; \/*allocated size in bytes*\/$/;"	m	struct:uivector	file:
allocsize	./PNG/lodepng.cpp	/^  size_t allocsize; \/*allocated size*\/$/;"	m	struct:ucvector	file:
alpInt	./GGraphBezier/GGraphBezier.h	/^        int   alpInt;       \/\/ целочисленное значение угола наклона линии в градусах (0 до 360° grade).$/;"	m	class:ocr::OCRFocalLineBezier
alpha	./GGraphBezier/GGraphBezier.h	/^        float alpha;        \/\/ угол наклона линии в градусах (0 до 360° grade).$/;"	m	class:ocr::OCRFocalLineBezier
alpha	./GGraphBezier/GGraphBezier.h	/^        int alpha;$/;"	m	class:ocr::OCRLineRef
alpha	./PNG/lodepng.h	/^  unsigned alpha; \/*image is not opaque and alpha channel or alpha palette required*\/$/;"	m	struct:LodePNGColorProfile
alphaP1	./GGraphBezier/GGraphBezier.h	/^        float alphaP1;      \/\/ угол наклона первого контрольного вектора (0 до 360° grade).$/;"	m	class:ocr::OCRFocalLineBezier
alphaP1P2	./GGraphBezier/GGraphBezier.h	/^        float alphaP1P2;    \/\/ угол наклона вектора от первой управляющей точки до второй управляющей точки.$/;"	m	class:ocr::OCRFocalLineBezier
alphaP2	./GGraphBezier/GGraphBezier.h	/^        float alphaP2;      \/\/ угол наклона второго контрольного вектора (0 до 360° grade).$/;"	m	class:ocr::OCRFocalLineBezier
alpha_fl	./GGraph/GGraph.h	/^	float *alpha_fl; \/\/\/<массив углов (второй производной) вдоль фокальной линии, float.$/;"	m	class:ocr::GGraph
ang	./GBitsetContour/GBitsetContour.h	/^    char ang[20000],angCalibrate[20000];$/;"	m	class:ocr::GBitsetContour
angCalibrate	./GBitsetContour/GBitsetContour.h	/^    char ang[20000],angCalibrate[20000];$/;"	m	class:ocr::GBitsetContour
angCount	./GBitsetContour/GBitsetContour.h	/^    short angCount,lenCount,angLength;$/;"	m	class:ocr::GBitsetContour
angData	./GBitsetContour/GBitsetContour.h	/^    int angData[20000],angX[20000],angY[20000];$/;"	m	class:ocr::GBitsetContour
angDiff	./GBitsetContour/GBitsetContour.h	/^    char angDiff[20000],angInt[20000],angDiffSum[20000],angDiffVector[20000],angFilterBase[20000];$/;"	m	class:ocr::GBitsetContour
angDiffSum	./GBitsetContour/GBitsetContour.h	/^    char angDiff[20000],angInt[20000],angDiffSum[20000],angDiffVector[20000],angFilterBase[20000];$/;"	m	class:ocr::GBitsetContour
angDiffVector	./GBitsetContour/GBitsetContour.h	/^    char angDiff[20000],angInt[20000],angDiffSum[20000],angDiffVector[20000],angFilterBase[20000];$/;"	m	class:ocr::GBitsetContour
angFilterBase	./GBitsetContour/GBitsetContour.h	/^    char angDiff[20000],angInt[20000],angDiffSum[20000],angDiffVector[20000],angFilterBase[20000];$/;"	m	class:ocr::GBitsetContour
angInt	./GBitsetContour/GBitsetContour.h	/^    char angDiff[20000],angInt[20000],angDiffSum[20000],angDiffVector[20000],angFilterBase[20000];$/;"	m	class:ocr::GBitsetContour
angIntSum	./GBitsetContour/GBitsetContour.h	/^    char angIntSum[20000], angIntVector[20000];$/;"	m	class:ocr::GBitsetContour
angIntVector	./GBitsetContour/GBitsetContour.h	/^    char angIntSum[20000], angIntVector[20000];$/;"	m	class:ocr::GBitsetContour
angLength	./GBitsetContour/GBitsetContour.h	/^    short angCount,lenCount,angLength;$/;"	m	class:ocr::GBitsetContour
angX	./GBitsetContour/GBitsetContour.h	/^    int angData[20000],angX[20000],angY[20000];$/;"	m	class:ocr::GBitsetContour
angY	./GBitsetContour/GBitsetContour.h	/^    int angData[20000],angX[20000],angY[20000];$/;"	m	class:ocr::GBitsetContour
angl_t	./GGraphBezier/GGraphBezier.h	/^        int angl_t;         \/\/ - среднее значение тангенциального угла.$/;"	m	class:ocr::OCRFocalLineBezier
angle	./GGraph/GGraph.h	/^	short angle[12]; \/\/\/<массив углов фокальных и опорных линии относительно центра OCRStar$/;"	m	struct:ocr::OCRStarStruct
angleDiff	./GBitsetContour/angleDiff.cpp	/^void GBitsetContour::angleDiff(){$/;"	f	class:GBitsetContour
applyRE	./GLogicProcessor/grammarCorrector.cpp	/^void GLogicProcessor::applyRE( vector<wordOCR> &wordArray,vector<wordOCR>&lineText){$/;"	f	class:GLogicProcessor
area	./GFontEditor/GLetter.h	/^  int area; \/\/площадь габарита буквы$/;"	m	class:ocr::OCRMatch
area	./GGraph/GGraph.h	/^	uchar area;		   \/\/\/< количество пикселов линии$/;"	m	struct:ocr::OCRLineStruct
area	./OCRTypes/OCRTypes.h	/^  ushort area;$/;"	m	struct:ocr::OCRBoxStruct
area	./OCRTypes/OCRTypes_www.h	/^        uint area;$/;"	m	class:ocr::OCRBox
argc	./config.h	/^	int imgW, imgH, argc;$/;"	m	struct:commandData
associativeSignalProcessing	./GMemory/GMap/associativeSignalProcessing.cpp	/^void GMap::associativeSignalProcessing(string&text){ $/;"	f	class:GMap
attributeLinePixels	./GGraph/GGraphAttributeLinePixels.cpp	/^void GGraph::attributeLinePixels(){$/;"	f	class:ocr::GGraph
attributeLinePixelsF	./GGraph/GGraphAttributeLinePixels.cpp	/^void GGraph::attributeLinePixelsF(GBitmap *img){$/;"	f	class:ocr::GGraph
attributeLinePixelsG	./GGraph/GGraphAttributeLinePixels.cpp	/^void GGraph::attributeLinePixelsG(GBitmap *img){$/;"	f	class:ocr::GGraph
aunit	./OCRAlgorithm/f2c.h	/^	ftnint aunit;$/;"	m	struct:__anon9
autoLevel	./GBitmap/GBitmapAutoLevel.cpp	/^  void GBitmap::autoLevel(){$/;"	f	class:ocr::GBitmap
auto_choose_color_from_profile	./PNG/lodepng.cpp	/^static unsigned auto_choose_color_from_profile(LodePNGColorMode* mode_out,$/;"	f	file:
auto_convert	./PNG/lodepng.h	/^  unsigned auto_convert; \/*automatically choose output PNG color type. Default: true*\/$/;"	m	struct:LodePNGEncoderSettings
avarageLetterH	./GBitsetMatrix/GBitsetMatrix.h	/^  float avarageLetterH;           \/\/\/<средняя высота буквы определяемая в режиме вычисления масштаба букв$/;"	m	class:ocr::GBitsetMatrix
avarageScale	./GMainEditor/GMainEditor.h	/^        float avarageScale;$/;"	m	class:ocr::GMainEditor
b	./test_clang.h	/^int b=23;$/;"	v
b1	./OCRTypes/OCRTypes.h	/^  bool b1;$/;"	m	class:ocr::byteMask
b1	./OCRTypes/OCRTypes_www.h	/^        bool b1;$/;"	m	class:ocr::byteMask
b2	./OCRTypes/OCRTypes.h	/^  bool b2;$/;"	m	class:ocr::byteMask
b2	./OCRTypes/OCRTypes_www.h	/^        bool b2;$/;"	m	class:ocr::byteMask
b3	./OCRTypes/OCRTypes.h	/^  bool b3;$/;"	m	class:ocr::byteMask
b3	./OCRTypes/OCRTypes_www.h	/^        bool b3;$/;"	m	class:ocr::byteMask
b4	./OCRTypes/OCRTypes.h	/^  bool b4;$/;"	m	class:ocr::byteMask
b4	./OCRTypes/OCRTypes_www.h	/^        bool b4;$/;"	m	class:ocr::byteMask
b5	./OCRTypes/OCRTypes.h	/^  bool b5;$/;"	m	class:ocr::byteMask
b5	./OCRTypes/OCRTypes_www.h	/^        bool b5;$/;"	m	class:ocr::byteMask
b6	./OCRTypes/OCRTypes.h	/^  bool b6;$/;"	m	class:ocr::byteMask
b6	./OCRTypes/OCRTypes_www.h	/^        bool b6;$/;"	m	class:ocr::byteMask
b7	./OCRTypes/OCRTypes.h	/^  bool b7;$/;"	m	class:ocr::byteMask
b7	./OCRTypes/OCRTypes_www.h	/^        bool b7;$/;"	m	class:ocr::byteMask
b8	./OCRTypes/OCRTypes.h	/^  bool b8;$/;"	m	class:ocr::byteMask
b8	./OCRTypes/OCRTypes_www.h	/^        bool b8;$/;"	m	class:ocr::byteMask
bLeft	./GBitsetOCR/textOCR_.h	/^    int bRightOld=0,lw1,bLeft,space1,space0;$/;"	v
bRightOld	./GBitsetOCR/textOCR_.h	/^    int bRightOld=0,lw1,bLeft,space1,space0;$/;"	v
background_b	./PNG/lodepng.h	/^  unsigned background_b;       \/*blue component of suggested background color*\/$/;"	m	struct:LodePNGInfo
background_defined	./PNG/lodepng.h	/^  unsigned background_defined; \/*is a suggested background color given?*\/$/;"	m	struct:LodePNGInfo
background_g	./PNG/lodepng.h	/^  unsigned background_g;       \/*green component of suggested background color*\/$/;"	m	struct:LodePNGInfo
background_r	./PNG/lodepng.h	/^  unsigned background_r;       \/*red\/grey\/palette component of suggested background color*\/$/;"	m	struct:LodePNGInfo
baseCount	./GGraph/GGraph.h	/^	uchar baseCount;  \/\/\/< количество опорных линий$/;"	m	struct:ocr::OCRStarStruct
baseDirection	./GBitset/GBitset.h	/^  short baseDirection;$/;"	m	class:ocr::GBitset
baseDirection	./GBitsetContour/GBitsetContour.h	/^  char baseDirection;            \/\/\/<направление контура (по и против часовой стрелки)$/;"	m	class:ocr::GBitsetContour
baseDirection	./GBitsetMatrix/GBitsetMatrix.h	/^  short baseDirection;            \/\/\/<направление письма в языке$/;"	m	class:ocr::GBitsetMatrix
baseDirection	./GBitsetOCR/GBitsetOCR.h	/^  short baseDirection;$/;"	m	class:ocr::GBitsetOCR
baseFilter	./GBitsetContour/baseFilter.cpp	/^void GBitsetContour::baseFilter() {$/;"	f	class:GBitsetContour
baseImg	./GMainEditor/GMainEditor.h	/^        GBitmap *pechaImg, *baseImg;              \/\/\/<global bitmap data$/;"	m	class:ocr::GMainEditor
baseLetter	./GFontEditor/GLetter.h	/^  int baseLetter;$/;"	m	class:ocr::GLetter
baseLetter	./OCRTypes/OCRTypes.h	/^  int baseLetter;$/;"	m	struct:ocr::uniLetterRecord
baseLetter	./OCRTypes/OCRTypes_www.h	/^		int baseLetter;$/;"	m	struct:ocr::uniLetterRecord
baseOCR	./GBitsetContour/contourOCR.cpp	/^void GBitsetContour::baseOCR(){$/;"	f	class:GBitsetContour
bearingLineRecognition	./GGraph/GGraphOCRStar.cpp	/^void GGraph::bearingLineRecognition(OCRStar &star, int mode) {$/;"	f	class:ocr::GGraph
bestMatchString	./GLogicProcessor/spellChecker.cpp	/^void GLogicProcessor::bestMatchString(vector<stringEntry>&matchArray,const char *strKey_,int sL, string &textString,  string &destStr){$/;"	f	class:GLogicProcessor
bicubicGrayScale	./GBitmap/GBitmapScale.cpp	/^  void GBitmap::bicubicGrayScale(const GBitmap*ref, float scale){     \/\/ начало декабря 2018$/;"	f	class:ocr::GBitmap
bicubicGrayScale	./GBitmap/GBitmapScale.cpp	/^  void GBitmap::bicubicGrayScale(float scale){$/;"	f	class:ocr::GBitmap
bicubicScale	./GBitmap/GBitmapScale.cpp	/^  void GBitmap::bicubicScale(const GBitmap*ref, float scale){     \/\/ начало декабря 2018$/;"	f	class:ocr::GBitmap
bicubicScale	./GBitmap/GBitmapScale.cpp	/^  void GBitmap::bicubicScale(float scale){$/;"	f	class:ocr::GBitmap
bilinearScale	./GBitmap/GBitmapScale.cpp	/^  void GBitmap::bilinearScale(GBitmap *ref, float scale) {$/;"	f	class:ocr::GBitmap
bilinearScale	./GBitmap/GBitmapScale.cpp	/^  void GBitmap::bilinearScale(float scale){$/;"	f	class:ocr::GBitmap
binarisation	./GBitmap/GBitmapBinarisation.cpp	/^  void  GBitmap::binarisation(int Tr, int BASE) {$/;"	f	class:ocr::GBitmap
binarisation64	./GBitmap/GBitmapBinarisation.cpp	/^  void  GBitmap::binarisation64() {$/;"	f	class:ocr::GBitmap
binarisationF	./GBitmap/GBitmapBinarisation.cpp	/^  void  GBitmap::binarisationF(int Tr, int BASE) {$/;"	f	class:ocr::GBitmap
binarisationG	./GBitmap/GBitmapBinarisation.cpp	/^  void  GBitmap::binarisationG(int Tr, int BASE) {$/;"	f	class:ocr::GBitmap
binarisationL	./GBitmap/GBitmapBinarisation.cpp	/^  void  GBitmap::binarisationL(int Tr, int BASE) {$/;"	f	class:ocr::GBitmap
binarisationM	./GBitmap/GBitmapBinarisation.cpp	/^  float  GBitmap::binarisationM(int Tr1, int Tr2, int BASE) {$/;"	f	class:ocr::GBitmap
binaryPrint	./OCRString/php2stl.cpp	/^void binaryPrint(unsigned int input, int radix) {$/;"	f
binaryPrint64	./OCRString/php2stl.cpp	/^void binaryPrint64(unsigned long long input, int radix) {$/;"	f
binaryPrintStr	./OCRString/php2stl.cpp	/^string binaryPrintStr(unsigned int input, int radix) {$/;"	f
bit_clear	./OCRAlgorithm/f2c.h	165;"	d
bit_set	./OCRAlgorithm/f2c.h	166;"	d
bit_test	./OCRAlgorithm/f2c.h	164;"	d
bit_vector	./GBitset/GBitset.h	/^typedef std::vector<bool, std::allocator<bool> > bit_vector;$/;"	t
bitdepth	./PNG/lodepng.h	/^  unsigned bitdepth;  \/*bits per sample, see PNG standard or documentation further in this header file*\/$/;"	m	struct:LodePNGColorMode
bites_data	./GBitmap/GBitmap.h	/^	unsigned char *bites_data; \/\/\/<буфер битовых данных битмэпа (маленький запакованный массив)$/;"	m	class:ocr::GBitmap
bites_data_32	./GGraph/GGraph.h	/^	uint *bites_data_32; \/\/\/< транспонированный массив для поиска фокальных точек$/;"	m	class:ocr::GGraph
bites_data_32_2	./GGraph/GGraph.h	/^	uint *bites_data_32_2; \/\/\/< уменьшеный транспонированный массив для поиска фокальных точек$/;"	m	class:ocr::GGraph
bits	./GBitsetOCR/GBitsetOCR.h	/^  bool  *bits;$/;"	m	class:ocr::GBitsetOCR
bits	./PNG/lodepng.h	/^  unsigned bits; \/*bits per channel (not for palette). 1,2 or 4 for greyscale only. 16 if 16-bit per channel required.*\/$/;"	m	struct:LodePNGColorProfile
bits_data	./GBitset/GBitset.h	/^  bool  *bits_data;          \/\/\/<main memory buffer of image data. All data store in bits so byte store 8 pixels$/;"	m	class:ocr::GBitset
bits_data	./GBitsetMatrix/GBitsetMatrix.h	/^  bool  *bits_data;               \/\/\/<буфер данных битмепа в байтах$/;"	m	class:ocr::GBitsetMatrix
bits_data	./GBitsetOCR/GBitsetOCR.h	/^  bool  *bits_data;$/;"	m	class:ocr::GBitsetOCR
bits_per_row	./GBitset/GBitset.h	/^  unsigned short bits_per_row;  \/\/\/<same as nrows$/;"	m	class:ocr::GBitset
bits_per_row	./GBitsetMatrix/GBitsetMatrix.h	/^  unsigned short bits_per_row;  \/\/\/<количество битов в строке$/;"	m	class:ocr::GBitsetMatrix
bits_per_row	./GBitsetOCR/GBitsetOCR.h	/^  unsigned short bits_per_row;$/;"	m	class:ocr::GBitsetOCR
bitsetBorder	./GBitsetOCR/GBitsetOCR.h	/^  int bitsetBorder;$/;"	m	class:ocr::GBitsetOCR
blockArray	./GFontEditor/GLetter.h	/^  vector<blockOCR> blockArray; \/\/ language segmentetion$/;"	m	class:ocr::stringOCR
blockDraw	./GBitset/GBitset_algorithm.cpp	/^void GBitset::blockDraw(int color){$/;"	f	class:GBitset
blockFlag	./GFontEditor/GLetter.h	/^  int blockFlag;$/;"	m	class:ocr::blockOCR
blockIndex	./GFontEditor/GLetter.h	/^  int blockIndex;$/;"	m	class:ocr::wordOCR
blockOCR	./GFontEditor/GLetter.cpp	/^blockOCR::blockOCR(void){}$/;"	f	class:blockOCR
blockOCR	./GFontEditor/GLetter.h	/^class blockOCR {$/;"	c	namespace:ocr
blue	./GBitmap/ppm.h	/^	unsigned char red, green, blue;$/;"	m	struct:__anon1
border	./GBitmap/GBitmap.h	/^	int border;$/;"	m	class:ocr::GBitmap
border	./GBitset/GBitset.h	/^  unsigned short border;     \/\/\/<border size$/;"	m	class:ocr::GBitset
border	./GBitsetContour/GBitsetContour.h	/^  int border;  $/;"	m	class:ocr::GBitsetContour
border	./GBitsetMatrix/GBitsetMatrix.h	/^  unsigned short border;        \/\/\/<размер бордюра$/;"	m	class:ocr::GBitsetMatrix
border	./GBitsetOCR/GBitsetOCR.h	/^  unsigned short border;$/;"	m	class:ocr::GBitsetOCR
border	./GFontEditor/GContour.h	/^    int border;$/;"	m	class:ocr::GContour
border	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int border = 17;$/;"	m	namespace:ocr	file:
borderSize	./GBitmap/GBitmap.cpp	/^inline unsigned int GBitmap::borderSize() const {$/;"	f	class:ocr::GBitmap
borderSize	./GBitsetMatrix/GBitsetMatrix.h	/^	int borderSize(){return border;}$/;"	f	class:ocr::GBitsetMatrix
borderSize	./GBitsetMatrix/GBitsetMatrix.h	/^GBitsetMatrix::borderSize() const$/;"	f	class:ocr::GBitsetMatrix
border_size	./GBitset/GBitset.h	/^GBitset::border_size() const$/;"	f	class:ocr::GBitset
boundaryPM	./PNG/lodepng.cpp	/^static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num)$/;"	f	file:
bpmnode_create	./PNG/lodepng.cpp	/^static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail)$/;"	f	file:
bpmnode_sort	./PNG/lodepng.cpp	/^static void bpmnode_sort(BPMNode* leaves, size_t num)$/;"	f	file:
brightnessCor	./GBitmap/GBitmapBinarisation.cpp	/^  void  GBitmap::brightnessCor(int Wr, int BASE) {$/;"	f	class:ocr::GBitmap
bsearch	./OCRString/php2stl.cpp	/^int bsearch(hashRecord *hashVector, unsigned size, int value) {$/;"	f
btype	./PNG/lodepng.h	/^  unsigned btype; \/*the block type for LZ (0, 1, 2 or 3, see zlib standard). Should be 2 for proper compression.*\/$/;"	m	struct:LodePNGCompressSettings
buildCircle	./GGraph/GGraphOCRStar.cpp	/^void GGraph::buildCircle(OCRStar &star) {$/;"	f	class:ocr::GGraph
buildClusterMask	./GGraph/GGraphOCRStar.cpp	/^void GGraph::buildClusterMask(OCRStar &star){$/;"	f	class:ocr::GGraph
buildDictionary	./GLogicProcessor/dictReport.cpp	/^void  GLogicProcessor::buildDictionary(vector<string> &strVector ){$/;"	f	class:GLogicProcessor
buildDictionaryHashIndex	./GLogicProcessor/loadDictionary.cpp	/^void GLogicProcessor::buildDictionaryHashIndex(){$/;"	f	class:GLogicProcessor
buildDictionaryHashIndexUni	./GLogicProcessor/loadDictionary.cpp	/^void GLogicProcessor::buildDictionaryHashIndexUni( vector<string>&strVector){$/;"	f	class:GLogicProcessor
buildFileDatabase	./GMemory/GMemory.h	/^	void buildFileDatabase(const char *path_)$/;"	f	class:ocr::GMemory
buildFocalLineMask	./GGraph/GGraphOCRStar.cpp	/^void GGraph::buildFocalLineMask() {$/;"	f	class:ocr::GGraph
buildGFont	./GBitsetContour/contourOCR.cpp	/^void GBitsetContour::buildGFont(GFont *contourBase,vector<stringOCR>&strArray_){$/;"	f	class:GBitsetContour
buildGFontFromFont	./GFontEditor/buildLetter.cpp	/^void GFontEditor::buildGFontFromFont(){$/;"	f	class:GFontEditor
buildGFontFromRTF	./GFontEditor/buildLetter.cpp	/^void GFontEditor::buildGFontFromRTF(){$/;"	f	class:GFontEditor
buildHashRegister	./GGraph/GGraphOCRStar.cpp	/^void GGraph::buildHashRegister(OCRStar &star, int mode) {$/;"	f	class:ocr::GGraph
buildHashTable	./GGraph/GGraphAlgorithm.cpp	/^void GGraph::buildHashTable() {$/;"	f	class:ocr::GGraph
buildHashTable	./GGraphOCR/GGraphOCR.cpp	/^void GGraphOCR::buildHashTable() {$/;"	f	class:ocr::GGraphOCR
buildLetter	./GGraph/GGraphLetter.cpp	/^void GGraph::buildLetter(OCRLetter &letter) {$/;"	f	class:ocr::GGraph
buildLetter	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::buildLetter(OCRLetter &letter, const char *path) {$/;"	f	class:ocr::GGraphOCR
buildLetterCorrelationTable	./GGraphOCR/GGraphOCRBuildOCRTable.cpp	/^void GGraphOCR::buildLetterCorrelationTable(uint letterIndex, cstr path) {$/;"	f	class:ocr::GGraphOCR
buildOCRAlphaTable	./GGraphBezier/GGraphFocalLineRecognitionBezier.cpp	/^    void GGraphBezier::buildOCRAlphaTable(){$/;"	f	class:ocr::GGraphBezier
buildOCRFont	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::buildOCRFont(const char *path) {$/;"	f	class:ocr::GGraphOCR
buildOCRFont	./GMainEditor/startOCR.cpp	/^void GMainEditor::buildOCRFont(){$/;"	f	class:GMainEditor
buildOCRFontClusterTable	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::buildOCRFontClusterTable() {$/;"	f	class:ocr::GGraphOCR
buildOCRLineTable	./GGraph/GGraphBuildFocalLineTable.cpp	/^void GGraph::buildOCRLineTable(){$/;"	f	class:GGraph
buildOCRLineTable	./GGraphBezier/GGraphFocalLineRecognitionBezier.cpp	/^void GGraphBezier::buildOCRLineTable(){$/;"	f	class:ocr::GGraphBezier
buildOCRStars	./GGraph/GGraphOCRStar.cpp	/^void GGraph::buildOCRStars() {$/;"	f	class:ocr::GGraph
buildOCRTable	./GGraphOCR/GGraphOCRBuildOCRTable.cpp	/^void GGraphOCR::buildOCRTable(cstr path) {$/;"	f	class:ocr::GGraphOCR
buildOCRTable1	./GGraphOCR/GGraphOCRBuildOCRTable.cpp	/^void GGraphOCR::buildOCRTable1(cstr path) {$/;"	f	class:ocr::GGraphOCR
buildOpenType	./GLogicProcessor/buildOpenType.cpp	/^void GLogicProcessor::buildOpenType(vector<OCRMatch>&line,vector<OCRMatch>&letterLine){$/;"	f	class:GLogicProcessor
buildSearchString	./GLogicProcessor/buidSearchString.cpp	/^void GLogicProcessor::buildSearchString(vector<OCRMatch>&line,$/;"	f	class:GLogicProcessor
buildSearchStringNew	./GLogicProcessor/buidSearchStringNew.cpp	/^void GLogicProcessor::buildSearchStringNew(vector<OCRMatch>&line,$/;"	f	class:GLogicProcessor
buildSyllableStat	./GLogicProcessor/loadDictionary.cpp	/^void  GLogicProcessor::buildSyllableStat(){$/;"	f	class:GLogicProcessor
buildTesseractData	./GFontEditor/GFontEditor.cpp	/^void GFontEditor::buildTesseractData(){$/;"	f	class:GFontEditor
buildTextLine	./GGraphOCR/GGraphOCRLetterNeighbors.cpp	/^void GGraphOCR::buildTextLine(vector<OCRLetter> &matchLetter, GGraph &graph) {$/;"	f	class:GGraphOCR
buildTranslationDictionary	./GLogicProcessor/dictReport.cpp	/^void  GLogicProcessor::buildTranslationDictionary(vector<string> &strVector ){$/;"	f	class:GLogicProcessor
buildWordDictionary	./GLogicProcessor/dictReport.cpp	/^void  GLogicProcessor::buildWordDictionary(vector<string> &strVector ){$/;"	f	class:GLogicProcessor
buildXPoint	./GGraph/GGraphOCRStar.cpp	/^void GGraph::buildXPoint() {$/;"	f	class:ocr::GGraph
byteMask	./OCRTypes/OCRTypes.cpp	/^byteMask::byteMask() { b1 = b2 = b3 = b4 = b5 = b6 = b7 = b8 = 0; }$/;"	f	class:ocr::byteMask
byteMask	./OCRTypes/OCRTypes.h	/^class byteMask {$/;"	c	namespace:ocr
byteMask	./OCRTypes/OCRTypes_www.h	/^    class byteMask{$/;"	c	namespace:ocr
bytes_data	./GBitmap/GBitmap.h	/^	unsigned char *bytes_data; \/\/\/<буфер байтовых данных битмэпа (большой распакованный массив)$/;"	m	class:ocr::GBitmap
bytes_data	./GBitsetContour/GBitsetContour.h	/^  unsigned char  *bytes_data;      \/\/\/<основной байтовый буфер данных битмэпа$/;"	m	class:ocr::GBitsetContour
bytes_data_buf	./GBitmap/GBitmap.h	/^	unsigned char *bytes_data_buf; \/\/\/<промежуточный буфер обработки битмэпа$/;"	m	class:ocr::GBitmap
bytes_per_row	./GBitmap/GBitmap.h	/^	int bytes_per_row;$/;"	m	class:ocr::GBitmap
bytes_per_row	./GBitsetContour/GBitsetContour.h	/^  int bytes_per_row;     \/\/\/<количество байтов в строке $/;"	m	class:ocr::GBitsetContour
c	./OCRAlgorithm/f2c.h	/^	complex c;$/;"	m	union:Multitype
cLimit	./OCRTypes/OCRTypes.h	/^const short cLimit = 10;$/;"	m	namespace:ocr
cLimit	./OCRTypes/OCRTypes_www.h	/^	const short cLimit=10;$/;"	m	namespace:ocr
cMatch	./GGraph/GGraph.h	/^	uchar cMatch[4];	 \/\/\/<массив корреляции OCRStar кластера$/;"	m	struct:ocr::OCRStarStruct
cMatrix	./GFontEditor/GFont.h	/^        GStr<uchar> *cMatrix;                       \/\/\/матрица взаимной корреляции всех букв базы$/;"	m	class:ocr::GFont
cP	./GBitsetMatrix/GBitsetMatrix_level.cpp	214;"	d	file:
cP	./GGraph/GGraph.h	/^	OCRPoint cP[5]; \/\/\/<координаты пяти проверочных точек линии$/;"	m	struct:ocr::OCRLineStruct
cPoint	./GGraph/GGraph.h	/^	OCRPoint cPoint;    \/\/\/< центр OCRCluster$/;"	m	struct:ocr::OCRClusterStruct
cPoint	./GGraph/GGraph.h	/^	OCRPoint cPoint; \/\/\/<центр звездочки$/;"	m	struct:ocr::OCRStarStruct
cRGB	./OCRTypes/OCRTypes.h	/^  cRGB = 4,$/;"	e	enum:ocr::drawConst
cRGB	./OCRTypes/OCRTypes_www.h	/^                cRGB=4,$/;"	e	enum:ocr::drawConst
c_out	./GBitset/GBitset.h	/^  ofstream c_out;            \/\/\/<debug file stream$/;"	m	class:ocr::GBitset
c_out	./GBitsetContour/GBitsetContour.h	/^  ofstream c_out;                  \/\/\/<отладочный вывод в файл$/;"	m	class:ocr::GBitsetContour
c_out	./GBitsetOCR/GBitsetOCR.h	/^  ofstream c_out;$/;"	m	class:ocr::GBitsetOCR
c_out	./GLogicProcessor/GLogicProcessor.h	/^		ofstream c_out;$/;"	m	class:ocr::GLogicProcessor
c_out	./config.h	/^	std::ofstream c_out;$/;"	m	struct:commandData
c_out1_	./GBitsetMatrix/letterCorrelation.cpp	27;"	d	file:
c_out_	./GBitsetMatrix/letterCorrelation.cpp	26;"	d	file:
c_out_	./GBitsetMatrix/letterCorrelation.cpp	621;"	d	file:
c_str	./OCRTypes/OCRTypes.h	/^  const char *c_str() { return data; }$/;"	f	class:ocr::GString
cacheCor	./GBitsetMatrix/GBitsetMatrix.h	/^  unsigned char cacheCor[4352];   \/\/\/< массив кэша коэффициента корреляции по области поиска максимума 128*34$/;"	m	class:ocr::GBitsetMatrix
calculatemoments	./GBitset/GBitset.cpp	/^void GBitset::calculatemoments(vector<int> &LGilb,$/;"	f	class:ocr::GBitset
calibrateAngle	./GBitsetContour/calibrateAngle.cpp	/^void GBitsetContour::calibrateAngle(){  \/\/main point for recognise Letter up corner and set center mass$/;"	f	class:GBitsetContour
canvasImgH	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int canvasImgH;$/;"	m	namespace:ocr	file:
canvasImgW	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int canvasImgW;$/;"	m	namespace:ocr	file:
capacity	./GMemory/MmapFile.h	/^	size_t capacity() const { return capacity_; }$/;"	f	class:MemoryFile
capacity_	./GMemory/MmapFile.h	/^	size_t capacity_;$/;"	m	class:MemoryFile
ccc	./test_clang.h	/^int ccc=23;$/;"	v
cchar	./OCRTypes/OCRTypes.h	/^typedef const char cchar;$/;"	t	namespace:ocr
center	./GFontEditor/GLetter.h	/^  OCRPointFloat center;$/;"	m	class:ocr::wordOCR
center	./GGraphBezier/GGraphBezier.h	/^        OCRPointFloat center;    \/\/ координаты середины прямой соединяющей концы линии.$/;"	m	class:ocr::OCRFocalLineBezier
centerDist	./GFontEditor/GLetter.h	/^  int centerDist; \/\/ distance between centers of match vector$/;"	m	class:ocr::OCRMatch
centerDist	./GFontEditor/GLetter.h	/^  int centerDist; \/\/ distance between centers of match vector$/;"	m	class:ocr::OCRMatchConst
centerDist	./OCRTypes/OCRTypes.h	/^  short centerDist;$/;"	m	class:ocr::vectorOCR
centerM	./GGraphBezier/GGraphBezier.h	/^        OCRPointFloat centerM;   \/\/ координаты центра масс.(совпадает с центром окружности).$/;"	m	class:ocr::OCRFocalLineBezier
cerr	./OCRAlgorithm/f2c.h	/^{	flag cerr;$/;"	m	struct:__anon8
chain	./PNG/lodepng.cpp	/^  unsigned short* chain;$/;"	m	struct:Hash	file:
chains0	./PNG/lodepng.cpp	/^  BPMNode** chains0;$/;"	m	struct:BPMLists	file:
chains1	./PNG/lodepng.cpp	/^  BPMNode** chains1;$/;"	m	struct:BPMLists	file:
chainz	./PNG/lodepng.cpp	/^  unsigned short* chainz; \/*those with same amount of zeros*\/$/;"	m	struct:Hash	file:
changeColorPPM	./GBitmap/ppm.h	/^void changeColorPPM(PPMImage *img)$/;"	f
charToHex	./OCRString/php2stl.cpp	/^string charToHex(unsigned char input) {$/;"	f
checkColorValidity	./PNG/lodepng.cpp	/^static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) \/*bd = bitdepth*\/$/;"	f	file:
checkFlag	./GFontEditor/GLetter.h	/^  int checkFlag; \/\/ flag of cheking by correction table$/;"	m	class:ocr::wordOCR
checkInCorrectionTable	./GLogicProcessor/grammarCorrector.cpp	/^void GLogicProcessor::checkInCorrectionTable(vector<stringOCR> &correctionTable,stringOCR &testStr,string &srcStr){$/;"	f	class:GLogicProcessor
check_border	./GBitset/GBitset_base.cpp	/^GBitset::check_border() const$/;"	f	class:GBitset
children	./PNG/lodepng.cpp	/^  ColorTree* children[16]; \/*up to 16 pointers to ColorTree of next level*\/$/;"	m	struct:ColorTree	file:
chrm_blue_x	./PNG/lodepng.h	/^  unsigned chrm_blue_x;  \/* Blue x times 100000 *\/$/;"	m	struct:LodePNGInfo
chrm_blue_y	./PNG/lodepng.h	/^  unsigned chrm_blue_y;  \/* Blue y times 100000 *\/$/;"	m	struct:LodePNGInfo
chrm_defined	./PNG/lodepng.h	/^  unsigned chrm_defined; \/* Whether a cHRM chunk is present (0 = not present, 1 = present). *\/$/;"	m	struct:LodePNGInfo
chrm_green_x	./PNG/lodepng.h	/^  unsigned chrm_green_x; \/* Green x times 100000 *\/$/;"	m	struct:LodePNGInfo
chrm_green_y	./PNG/lodepng.h	/^  unsigned chrm_green_y; \/* Green y times 100000 *\/$/;"	m	struct:LodePNGInfo
chrm_red_x	./PNG/lodepng.h	/^  unsigned chrm_red_x;   \/* Red x times 100000 *\/$/;"	m	struct:LodePNGInfo
chrm_red_y	./PNG/lodepng.h	/^  unsigned chrm_red_y;   \/* Red y times 100000 *\/$/;"	m	struct:LodePNGInfo
chrm_white_x	./PNG/lodepng.h	/^  unsigned chrm_white_x; \/* White Point x times 100000 *\/$/;"	m	struct:LodePNGInfo
chrm_white_y	./PNG/lodepng.h	/^  unsigned chrm_white_y; \/* White Point y times 100000 *\/$/;"	m	struct:LodePNGInfo
ciend	./OCRAlgorithm/f2c.h	/^	flag ciend;$/;"	m	struct:__anon5
cierr	./OCRAlgorithm/f2c.h	/^{	flag cierr;$/;"	m	struct:__anon5
cifmt	./OCRAlgorithm/f2c.h	/^	char *cifmt;$/;"	m	struct:__anon5
cilist	./OCRAlgorithm/f2c.h	/^} cilist;$/;"	t	typeref:struct:__anon5
cirec	./OCRAlgorithm/f2c.h	/^	ftnint cirec;$/;"	m	struct:__anon5
ciunit	./OCRAlgorithm/f2c.h	/^	ftnint ciunit;$/;"	m	struct:__anon5
clampFloat	./GBitmap/GBitmapScale.cpp	/^  static inline char clampFloat(float val){$/;"	f	namespace:ocr
classification	./GLogicProcessor/classification.cpp	/^void GLogicProcessor::classification(vector<stringOCR>&strArray,$/;"	f	class:GLogicProcessor
clear	./GMemory/GMap/GMap.cpp	/^void GMap::clear(){$/;"	f	class:GMap
clear	./GMemory/GVector.cpp	/^void GVector::clear() {$/;"	f	class:GVector
clearLetter	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::clearLetter(OCRLetter &letter) {$/;"	f	class:ocr::GGraphOCR
clearOCR	./GFontEditor/GLetter.cpp	/^void stringOCR::clearOCR(){$/;"	f	class:stringOCR
clearRegion	./GBitmap/GBitmap.cpp	/^void GBitmap::clearRegion(int x0, int y0, int w, int h) {$/;"	f	class:ocr::GBitmap
clearText	./OCRString/php2stl.cpp	/^void clearText(string &str) {$/;"	f
clearTextSkt	./OCRString/php2stl.cpp	/^void clearTextSkt(string &key) {$/;"	f
cllist	./OCRAlgorithm/f2c.h	/^} cllist;$/;"	t	typeref:struct:__anon8
close	./GMemory/GMap/GMap.cpp	/^void GMap::close(){$/;"	f	class:GMap
close	./GMemory/GVector.cpp	/^void GVector::close(void) {$/;"	f	class:GVector
close	./GMemory/GVector.h	/^void GStr<T>::close() {$/;"	f	class:ocr::GStr
closeSVG	./OCRString/php2stl.cpp	/^string closeSVG() {$/;"	f
cluster	./GGraph/GGraph.h	/^	uchar *cluster;	 \/\/\/< индексы OCRStar кластеров буквы$/;"	m	struct:ocr::OCRLetterStruct
cluster	./GGraph/GGraph.h	/^	uchar cluster;	  \/\/\/< флаг OCRStar как ядра кластера$/;"	m	struct:ocr::OCRStarStruct
clusterArray	./GGraph/GGraph.h	/^	GStr<uchar> clusterArray;$/;"	m	class:ocr::GGraph
clusterCount	./GGraph/GGraph.h	/^	ushort clusterCount; \/\/\/<количество кластеров OCRStar буквы$/;"	m	struct:ocr::OCRLetterStruct
clusterCount	./GGraphOCR/GGraphOCR.h	/^	uint clusterCount; \/\/\/<количество кластеров буквы$/;"	m	struct:ClusterMatchStruct
clusterID	./GGraphOCR/GGraphOCR.h	/^	uint clusterID;	   \/\/\/<номер базового кластера в таблице кластеров$/;"	m	struct:ClusterMatchStruct
clusterMaskCorrelation	./GGraphOCR/GGraphOCRCorrelationLookup2.cpp	/^int GGraphOCR::clusterMaskCorrelation(OCRMask &maskT,OCRMask &mask){$/;"	f	class:ocr::GGraphOCR
clusters_copy	./GMemory/GMap/GMap.h	/^        int  *clusters_copy;      \/\/ копия массива clusters_data, предназначена для восстановления счетчиков цепочек с помощью memcpy$/;"	m	class:ocr::GMap
clusters_copy_vector	./GMemory/GMap/GMap.h	/^        GStr<int>*clusters_copy_vector;$/;"	m	class:ocr::GMap
clusters_data	./GMemory/GMap/GMap.h	/^        int  *clusters_data;      \/\/ Плотный массив цепочек адресов (позиций) ОДИНАКОВЫХ пар букв в распознаваемом тексте.$/;"	m	class:ocr::GMap
clusters_data_vector	./GMemory/GMap/GMap.h	/^        GStr<int>*clusters_data_vector;$/;"	m	class:ocr::GMap
clusters_size	./GMemory/GMap/GMap.h	/^        ulong clusters_size;    \/\/ размер массива цепочек адресов clusters_data$/;"	m	class:ocr::GMap
cn	./GFontEditor/GLetter.h	/^  int cn;     \/\/ counter of this letter recognition$/;"	m	class:ocr::GLetter
cnRes	./GFontEditor/GLetter.h	/^  uint cnRes; \/\/ rezult counter of this letter recognition (cCount\/10 000)$/;"	m	class:ocr::GLetter
cnt	./codeStorage.h	/^int cnt = 0;$/;"	v
codeEnter	./GLogicProcessor/GLogicProcessor.h	/^    unsigned short codeEnter;      \/\/ исходныя кодировка перевода каретки во всех словарях, обычно 10$/;"	m	class:ocr::GLogicProcessor
codeEnter	./GMemory/GMap/GMap.h	/^        mSIZE codeEnter;         \/\/ исходная кодировка перевода каретки во всех словарях, обычно 10$/;"	m	class:ocr::GMap
codePoint	./GMemory/GMap/GMap.h	/^        mSIZE codePoint;         \/\/ исходная кодировка точки во всех словарях, обычно 3851$/;"	m	class:ocr::GMap
codeSpace	./GFontEditor/GLetter.h	/^  int codeSpace; \/\/\/< test value of test value of code space between this letter$/;"	m	class:ocr::GLetter
codeSpace	./GMemory/GMap/GMap.h	/^        mSIZE codeSpace;         \/\/ исходная кодировка пробела во всех словарях, обычно 32$/;"	m	class:ocr::GMap
collectMatchWithDirection	./GLogicProcessor/testWordLine.cpp	/^uint collectMatchWithDirection(vector<OCRMatch>&originalMatch,GBitmap *lineImg32, OCRMatch &a, OCRMatch &b, OCRBox &s){$/;"	f
collectStackLetter	./GLogicProcessor/collectStackLetter.cpp	/^void GLogicProcessor::collectStackLetter(vector<stringOCR>&strArray,$/;"	f	class:GLogicProcessor
collectTextLine	./GLogicProcessor/collectTextLine.cpp	/^void GLogicProcessor::collectTextLine(vector<OCRMatch>&dLine){$/;"	f	class:GLogicProcessor
color	./GBitmap/GBitmap.h	/^	int color() { return colorMode; }$/;"	f	class:ocr::GBitmap
color	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^vector<string> color;$/;"	m	namespace:ocr	file:
color	./OCRTypes/OCRTypes.h	/^  vector<int> color;$/;"	m	class:ocr::drawDataRecord
color	./PNG/lodepng.h	/^  LodePNGColorMode color;     \/*color type and bits, palette and transparency of the PNG file*\/$/;"	m	struct:LodePNGInfo
colorCode	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^map<string, string> colorCode;$/;"	m	namespace:ocr	file:
colorMode	./GBitmap/GBitmap.h	/^	int colorMode;$/;"	m	class:ocr::GBitmap
colorModeOut	./GBitmap/GBitmap.h	/^	int colorModeOut = 0; \/\/\/ флаг выходного формата изображения. По умолчанию равен colorMode$/;"	m	class:ocr::GBitmap
color_convert	./PNG/lodepng.h	/^  unsigned color_convert; \/*whether to convert the PNG to the color type you want. Default: yes*\/$/;"	m	struct:LodePNGDecoderSettings
color_tree_add	./PNG/lodepng.cpp	/^static void color_tree_add(ColorTree* tree,$/;"	f	file:
color_tree_cleanup	./PNG/lodepng.cpp	/^static void color_tree_cleanup(ColorTree* tree)$/;"	f	file:
color_tree_get	./PNG/lodepng.cpp	/^static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)$/;"	f	file:
color_tree_has	./PNG/lodepng.cpp	/^static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)$/;"	f	file:
color_tree_init	./PNG/lodepng.cpp	/^static void color_tree_init(ColorTree* tree)$/;"	f	file:
colored	./PNG/lodepng.h	/^  unsigned colored; \/*not greyscale*\/$/;"	m	struct:LodePNGColorProfile
colortype	./PNG/lodepng.h	/^  LodePNGColorType colortype; \/*color type, see PNG standard or documentation further in this header file*\/$/;"	m	struct:LodePNGColorMode
cols	./codeStorage.h	/^TCMAP *cols;$/;"	v
columnArray	./GFontEditor/GLetter.h	/^  vector<columnOCR> columnArray;$/;"	m	class:ocr::frameOCR
columnFlag	./GFontEditor/GLetter.h	/^  int columnFlag;$/;"	m	class:ocr::columnOCR
columnOCR	./GFontEditor/GLetter.cpp	/^columnOCR::columnOCR(void){}$/;"	f	class:columnOCR
columnOCR	./GFontEditor/GLetter.h	/^class columnOCR {$/;"	c	namespace:ocr
columns	./GBitmap/GBitmap.cpp	/^inline unsigned int GBitmap::columns() const {$/;"	f	class:ocr::GBitmap
columns	./GBitset/GBitset.h	/^GBitset::columns() const$/;"	f	class:ocr::GBitset
columns	./GBitsetContour/GBitsetContour.h	/^GBitsetContour::columns() const$/;"	f	class:ocr::GBitsetContour
columns	./GBitsetMatrix/GBitsetMatrix.h	/^GBitsetMatrix::columns() const$/;"	f	class:ocr::GBitsetMatrix
columns	./GBitsetOCR/GBitsetOCR.h	/^GBitsetOCR::columns() const$/;"	f	class:ocr::GBitsetOCR
combineMatchLetters	./GLogicProcessor/testWordLine.cpp	/^uint combineMatchLetters(vector<OCRMatch>&originalMatch,GBitmap *lineImg32, OCRMatch &a, OCRMatch &b, OCRBox &s){$/;"	f
commandData	./config.h	/^struct commandData {$/;"	s
commentaryIndex	./GFontEditor/GLetter.h	/^  string commentaryIndex;$/;"	m	class:ocr::wordOCR
commentaryIndex	./GLogicProcessor/GLogicProcessor.h	/^	vector<string>commentaryIndex; \/\/\/<commentary index in text$/;"	m	class:ocr::GLogicProcessor
compactResultOCR	./GLogicProcessor/letterAssociation.cpp	/^void GLogicProcessor::compactResultOCR(vector<OCRMatch>&letterLine,string&OCRresult){$/;"	f	class:GLogicProcessor
complex	./OCRAlgorithm/f2c.h	/^typedef struct { real r, i; } complex;$/;"	t	typeref:struct:__anon3
compress	./PNG/lodepng.cpp	/^unsigned compress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,$/;"	f	namespace:lodepng
compress	./PNG/lodepng.cpp	/^unsigned compress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,$/;"	f	namespace:lodepng
compressMatch	./GLogicProcessor/compressMatch.cpp	/^void GLogicProcessor::compressMatch(vector<OCRMatch>&letterLine){$/;"	f	class:GLogicProcessor
compressMatchPrint	./GLogicProcessor/compressMatch.cpp	/^void GLogicProcessor::compressMatchPrint(vector<OCRMatch>&letterLine){$/;"	f	class:GLogicProcessor
compression_method	./PNG/lodepng.h	/^  unsigned compression_method;\/*compression method of the original file. Always 0.*\/$/;"	m	struct:LodePNGInfo
constantPhrase	./GMemory/GMap/GMap.h	/^        uint constantPhrase;    \/\/ минимальная длина части фразы словаря, которую имеет смысл проверять как непрерывную.(длина ключа)$/;"	m	class:ocr::GMap
context	./OCRTypes/OCRTypes.h	/^  string context;$/;"	m	struct:ocr::dictKeyStruct
context	./OCRTypes/OCRTypes_www.h	/^		string context;$/;"	m	struct:ocr::dictKey
contour	./GFontEditor/GLetter.h	/^  GContour *contour[10];$/;"	m	class:ocr::GLetter
contourCount	./GBitsetContour/GBitsetContour.h	/^	short max_down, startLetter, startLine, contourCount, contourIndex, indexFilter;$/;"	m	class:ocr::GBitsetContour
contourCount	./GFontEditor/GLetter.h	/^  uint contourCount;$/;"	m	class:ocr::GLetter
contourIndex	./GBitsetContour/GBitsetContour.h	/^	short max_down, startLetter, startLine, contourCount, contourIndex, indexFilter;$/;"	m	class:ocr::GBitsetContour
contourIndex	./OCRTypes/OCRTypes.h	/^  int contourIndex;$/;"	m	class:ocr::vectorOCR
contourRecognition	./GBitset/GBitset.cpp	/^void GBitset::contourRecognition(){$/;"	f	class:ocr::GBitset
convertCXS_to_UTF	./GLogicProcessor/converterPali.cpp	/^string GLogicProcessor::convertCXS_to_UTF(string &inStr){$/;"	f	class:GLogicProcessor
convertCXS_to_UTF_nocopy	./GLogicProcessor/converterPali.cpp	/^void GLogicProcessor::convertCXS_to_UTF_nocopy(string &inStr){$/;"	f	class:GLogicProcessor
convertDirectoryToUTF	./OCRString/php2stl.cpp	/^void convertDirectoryToUTF() {$/;"	f
convertFileToUTF8	./OCRString/php2stl.cpp	/^void convertFileToUTF8(cstr path) {$/;"	f
coord_fx	./GGraph/GGraph.h	/^	float *coord_fx; \/\/\/<массив координат точек всех фокальныэх линий по "y", float.$/;"	m	class:ocr::GGraph
coord_fy	./GGraph/GGraph.h	/^	float *coord_fy; \/\/\/<массив координат точек всех фокальныэх линий по "x", float.$/;"	m	class:ocr::GGraph
copy	./GBitMask/GBitmask.cpp	/^void GBitMask32::copy(GBitMask32* dest){$/;"	f	class:ocr::GBitMask32
copy	./GFontEditor/GLetter.cpp	/^void GLetter::copy(GLetter* letter){$/;"	f	class:GLetter
copyData	./GFontEditor/GLetter.cpp	/^void OCRMatch::copyData(GLetter *letter){$/;"	f	class:OCRMatch
copyMatch	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::copyMatch(OCRLetter &letter, OCRLetter &matchL) {$/;"	f	class:ocr::GGraphOCR
corA	./GGraphBezier/GGraphBezier.h	/^        int corA;           \/\/ - коэффициент корреляции линии с дугой (0-100%).$/;"	m	class:ocr::OCRFocalLineBezier
corC	./GGraphBezier/GGraphBezier.h	/^        int corC;           \/\/ - коэффициент корреляции линии с кругом (0-100%).$/;"	m	class:ocr::OCRFocalLineBezier
corL	./GGraphBezier/GGraphBezier.h	/^        int corL;           \/\/ - коэффициент корреляции линии с прямой (0-100%).$/;"	m	class:ocr::OCRFocalLineBezier
corS	./GGraphBezier/GGraphBezier.h	/^        int corS;           \/\/ - коэффициент корреляции линии со спиралью (0-100%).$/;"	m	class:ocr::OCRFocalLineBezier
corr	./GGraph/GGraph.h	/^	ushort corr;	\/\/\/<величина корреляции с наиболее соответсвующей линией$/;"	m	struct:ocr::OCRLineStruct
corr	./GGraph/GGraph.h	/^	ushort corr;  \/\/\/< корреляция OCRStar$/;"	m	struct:ocr::OCRStarStruct
corrC	./GGraph/GGraph.h	/^	ushort corrC; \/\/\/< корреляция OCRStar в кластере$/;"	m	struct:ocr::OCRStarStruct
correctionTable	./GMainEditor/GMainEditor.h	/^        vector<stringOCR>correctionTable; \/\/\/vector of all unsertan and hand-checked letters for draw in correction table$/;"	m	class:ocr::GMainEditor
correlation	./GBitMask/GBitMask.h	/^		int correlation;           \/\/\/< величина корреляции маски$/;"	m	class:ocr::GBitMask32
correlation	./GFontEditor/GLetter.h	/^  float correlation;$/;"	m	class:ocr::OCRMatch
correlation	./GFontEditor/GLetter.h	/^  float correlation;$/;"	m	class:ocr::OCRMatchConst
correlation	./GFontEditor/GLetter.h	/^  int correlation;     \/\/\/< value of correlation$/;"	m	class:ocr::GLetter
correlation	./GFontEditor/GLetter.h	/^  int correlation;$/;"	m	class:ocr::stringOCR
correlation	./GFontEditor/GLetter.h	/^  int correlation;$/;"	m	class:ocr::wordOCR
correlation	./GFontEditor/GLetter.h	/^  uchar correlation;$/;"	m	struct:ocr::keyOCR
correlation	./GFontEditor/GLetter.h	/^  uint correlation;$/;"	m	struct:ocr::maskData_
correlation	./GGraph/GGraph.h	/^	ushort correlation;$/;"	m	struct:ocr::OCRClusterStruct
correlation	./GGraph/GGraph.h	/^	ushort correlation;$/;"	m	struct:ocr::OCRLetterStruct
correlation	./GGraphOCR/GGraphOCR.h	/^	uint correlation;$/;"	m	struct:ClusterMatchStruct
correlationGraph	./GGraphOCR/GGraphOCRCorrelation.cpp	/^void GGraphOCR::correlationGraph(GGraph &graph, OCRLetter &letter) {$/;"	f	class:ocr::GGraphOCR
correlationGraphArea	./GGraphOCR/GGraphOCRCorrelation.cpp	/^int GGraphOCR::correlationGraphArea(GGraph &graph, OCRLetter &letter, vector<int> &searchStar) {$/;"	f	class:ocr::GGraphOCR
correlationLetterCluster	./GGraphOCR/GGraphOCRFont.cpp	/^int GGraphOCR::correlationLetterCluster(OCRLetter &letterTest, OCRLetter &letter, OCRStar &starT, OCRStar &star) {$/;"	f	class:ocr::GGraphOCR
correlationMap	./GFontEditor/GFont.h	/^        GMap *correlationMap;$/;"	m	class:ocr::GFont
correlationNew	./GFontEditor/GLetter.h	/^  float correlationNew;$/;"	m	class:ocr::OCRMatch
correlationNew	./GFontEditor/GLetter.h	/^  float correlationNew;$/;"	m	class:ocr::OCRMatchConst
correlationNew	./GGraph/GGraph.h	/^	ushort correlationNew;$/;"	m	struct:ocr::OCRLetterStruct
correlationOCR	./GGraphOCR/GGraphOCRCorrelation.cpp	/^void GGraphOCR::correlationOCR(GGraph &graph, OCRLetter &letter) {$/;"	f	class:ocr::GGraphOCR
correlationVector	./GFontEditor/GFont.h	/^        GVector *correlationVector;$/;"	m	class:ocr::GFont
count	./GBitsetOCR/textOCR_.h	/^correlation=0; int count=0;$/;"	v
count	./GFontEditor/GLetter.h	/^  short count;$/;"	m	class:ocr::stringOCR
count	./OCRTypes/OCRTypes.h	/^  int count;$/;"	m	struct:ocr::stringMatch_
count	./OCRTypes/OCRTypes.h	/^  short count;$/;"	m	class:ocr::drawDataRecord
count	./OCRTypes/OCRTypes_www.h	/^		int count;$/;"	m	struct:ocr::stringMatch_
countLetter	./GBitsetOCR/textOCR_.h	/^count=0; int countLetter=0;$/;"	v
countZeros	./PNG/lodepng.cpp	/^static unsigned countZeros(const unsigned char* data, size_t size, size_t pos)$/;"	f	file:
cout_	./config.h	184;"	d
crRes	./GFontEditor/GLetter.h	/^  uint crRes; \/\/ middle result of correlation$/;"	m	class:ocr::GLetter
crSum	./GFontEditor/GLetter.h	/^  uint crSum; \/\/ buffer for store result of correlation this letter in text$/;"	m	class:ocr::GLetter
cray	./OCRAlgorithm/f2c.h	205;"	d
create	./GBitmap/GBitmap.h	/^	static GBitmap *create(const GBitmap *ref) { return new GBitmap(ref); }$/;"	f	class:ocr::GBitmap
create	./GBitmap/GBitmap.h	/^	static GBitmap *create(const char *path) { return new GBitmap(path); }$/;"	f	class:ocr::GBitmap
create	./GBitmap/GBitmap.h	/^	static GBitmap *create(const int ncolumns, const int nrows) { return new GBitmap(ncolumns, nrows); }$/;"	f	class:ocr::GBitmap
create	./GBitmap/GBitmap.h	/^	static GBitmap *create(const int ncolumns, const int nrows, const int mode) {$/;"	f	class:ocr::GBitmap
create	./GBitset/GBitset.h	/^  static GBitset* create(const GBitset *ref)$/;"	f	class:ocr::GBitset
create	./GBitset/GBitset.h	/^  static GBitset* create(const GBitset *ref, const int border)$/;"	f	class:ocr::GBitset
create	./GBitset/GBitset.h	/^  static GBitset* create(const int nrows, const int ncolumns, const int border=0)$/;"	f	class:ocr::GBitset
create	./GBitset/GBitset.h	/^  static GBitset* create(void) {return new GBitset;}$/;"	f	class:ocr::GBitset
create	./GBitsetContour/GBitsetContour.h	/^  static GBitsetContour* create(const GBitsetContour *ref)$/;"	f	class:ocr::GBitsetContour
create	./GBitsetContour/GBitsetContour.h	/^  static GBitsetContour* create(const int nrows, const int ncolumns)$/;"	f	class:ocr::GBitsetContour
create	./GBitsetContour/GBitsetContour.h	/^  static GBitsetContour* create(void) {return new GBitsetContour;}$/;"	f	class:ocr::GBitsetContour
create	./GBitsetMatrix/GBitsetMatrix.h	/^  static GBitsetMatrix* create(const GBitsetMatrix *ref)$/;"	f	class:ocr::GBitsetMatrix
create	./GBitsetMatrix/GBitsetMatrix.h	/^  static GBitsetMatrix* create(const GBitsetMatrix *ref, const int border)$/;"	f	class:ocr::GBitsetMatrix
create	./GBitsetMatrix/GBitsetMatrix.h	/^  static GBitsetMatrix* create(const int nrows, const int ncolumns, const int border=0)$/;"	f	class:ocr::GBitsetMatrix
create	./GBitsetMatrix/GBitsetMatrix.h	/^  static GBitsetMatrix* create(void) {return new GBitsetMatrix;}$/;"	f	class:ocr::GBitsetMatrix
create	./GBitsetOCR/GBitsetOCR.h	/^  static GBitsetOCR* create(const GBitsetOCR *ref)$/;"	f	class:ocr::GBitsetOCR
create	./GBitsetOCR/GBitsetOCR.h	/^  static GBitsetOCR* create(const GBitsetOCR *ref, const int border)$/;"	f	class:ocr::GBitsetOCR
create	./GBitsetOCR/GBitsetOCR.h	/^  static GBitsetOCR* create(const int nrows, const int ncolumns, const int border=0)$/;"	f	class:ocr::GBitsetOCR
create	./GFontEditor/GContour.h	/^    static GContour* create(int *angX,int *angY,int *andData, int length_,int dir){return new GContour(angX, angY, andData, length_, dir);}$/;"	f	class:ocr::GContour
create	./GFontEditor/GContour.h	/^    static GContour* create(int length_,int dir){return new GContour(length_,dir);}$/;"	f	class:ocr::GContour
create	./GFontEditor/GContour.h	/^    static GContour* create(void){return new GContour;}$/;"	f	class:ocr::GContour
create	./GFontEditor/GFont.h	/^        static GFont* create(const char* path){return new GFont(path);}$/;"	f	class:ocr::GFont
create	./GFontEditor/GFont.h	/^        static GFont* create(void){return new GFont;}$/;"	f	class:ocr::GFont
create	./GFontEditor/GFontEditor.h	/^        static GFontEditor* create(void){return new GFontEditor;}$/;"	f	class:ocr::GFontEditor
create	./GFontEditor/GLetter.h	/^  static GLetter *create(void) { return new GLetter; }$/;"	f	class:ocr::GLetter
create	./GFontEditor/GLetter.h	/^  static frameOCR *create(void) { return new frameOCR; }$/;"	f	class:ocr::frameOCR
create	./GFontEditor/GLetter.h	/^  static wordOCR *create(void) { return new wordOCR; }$/;"	f	class:ocr::wordOCR
create	./GLogicProcessor/GLogicProcessor.h	/^	static GLogicProcessor* create(void) {return new GLogicProcessor;}$/;"	f	class:ocr::GLogicProcessor
create	./GMainEditor/GMainEditor.h	/^        static GMainEditor* create(void) {return new GMainEditor;}$/;"	f	class:ocr::GMainEditor
create	./GMemory/GMap/GMap.h	/^        static GMap* create(cstr path_) {string path=path_; return new GMap(path);}$/;"	f	class:ocr::GMap
create	./GMemory/GMap/GMap.h	/^        static GMap* create(string &path) {return new GMap(path);}$/;"	f	class:ocr::GMap
create	./GMemory/GMap/GMap.h	/^        static GMap* create(string &path,GVector *data) {return new GMap(path,data);}$/;"	f	class:ocr::GMap
create	./GMemory/GMap/GMap.h	/^        static GMap* create(string &path,GVector *dataText,GStr<mSIZE> *dataDict) {return new GMap(path,dataText,dataDict);}$/;"	f	class:ocr::GMap
create	./GMemory/GMemory.h	/^	static GMemory *create(void) { return new GMemory; }$/;"	f	class:ocr::GMemory
create	./GMemory/GVector.h	/^    static  GStr *create() {$/;"	f	class:ocr::GStr
create	./GMemory/GVector.h	/^    static GStr *create(GVector *parentVector, cstr name) {$/;"	f	class:ocr::GStr
create	./GMemory/GVector.h	/^    static GStr *create(cstr path) {$/;"	f	class:ocr::GStr
create	./GMemory/GVector.h	/^    static GStr *create(int sizePool) {$/;"	f	class:ocr::GStr
create	./GMemory/GVector.h	/^    static GStr2D *create() {$/;"	f	class:ocr::GStr2D
create	./GMemory/GVector.h	/^    static GVector *create() {$/;"	f	class:ocr::GVector
create	./GMemory/GVector.h	/^    static GVector *create(GVector *parentVector, cstr name) {$/;"	f	class:ocr::GVector
create	./GMemory/GVector.h	/^    static GVector *create(GVector *ref) {$/;"	f	class:ocr::GVector
create	./GMemory/GVector.h	/^    static GVector *create(char *data_, int mode) {$/;"	f	class:ocr::GVector
create	./GMemory/GVector.h	/^    static GVector *create(cstr path) {$/;"	f	class:ocr::GVector
create	./GMemory/GVector.h	/^    static GVector *create(string &path) {$/;"	f	class:ocr::GVector
create	./GMemory/MmapFile.h	/^	static MemoryFile *create(const char *pathname, e_open_mode open_mode) { return new MemoryFile(pathname, open_mode); }$/;"	f	class:MemoryFile
create	./GPDF/GPDF.h	/^    static GPDF* create(const char *path)$/;"	f	class:ocr::GPDF
create	./GPDF/GPDF.h	/^    static GPDF* create(void) {return new GPDF;}$/;"	f	class:ocr::GPDF
create	./OCRAlgorithm/OCRAlgorithm.h	/^ static OCRFilter* create(const int size){return new OCRFilter(size); }$/;"	f	class:ocr::OCRFilter
create	./OCRTypes/OCRTypes.h	/^  static vectorOCR *create(void) { return new vectorOCR; }$/;"	f	class:ocr::vectorOCR
createFromPNG	./GBitmap/GBitmap.h	/^	static GBitmap *createFromPNG(const char *inputData) { return new GBitmap(inputData); }$/;"	f	class:ocr::GBitmap
createFromPNG	./GBitmap/GBitmap.h	/^	static GBitmap *createFromPNG(string &inputData) { return new GBitmap(inputData.c_str()); }$/;"	f	class:ocr::GBitmap
createFromPNGData	./GBitmap/GBitmap.h	/^	static GBitmap *createFromPNGData(unsigned char *dataPNG, uint size) { return new GBitmap(dataPNG, size); }$/;"	f	class:ocr::GBitmap
createIndex	./GMemory/loadDB.cpp	/^indexRecord *GMemory::createIndex(tableRecord &rec, int searchField, int searchMode) {$/;"	f	class:GMemory
createLevel	./GBitset/GBitset.h	/^  static GBitset* createLevel(const GBitmap *ref)  \/\/@@@?$/;"	f	class:ocr::GBitset
createRegion	./GBitmap/GBitmap.h	/^	static GBitmap *createRegion(const GBitmap *ref, int x0, int y0, int w, int h) {$/;"	f	class:ocr::GBitmap
createRegion	./GBitsetMatrix/GBitsetMatrix.h	/^  static GBitsetMatrix* createRegion(const GBitmap *ref, short x, short y, short w, short h, short stepW, short stepH, short flipV)$/;"	f	class:ocr::GBitsetMatrix
createResize	./GBitset/GBitset.h	/^  static GBitset* createResize(const GBitmap *ref, short stepW, short stepH, short flipV)$/;"	f	class:ocr::GBitset
createResize	./GBitsetContour/GBitsetContour.h	/^  static GBitsetContour* createResize(const GBitmap *ref, short stepW, short stepH, short flipV)$/;"	f	class:ocr::GBitsetContour
createResize	./GBitsetMatrix/GBitsetMatrix.h	/^  static GBitsetMatrix* createResize(const GBitmap *ref, short stepW, short stepH, short flipV)$/;"	f	class:ocr::GBitsetMatrix
createResize	./GBitsetOCR/GBitsetOCR.h	/^  static GBitsetOCR* createResize(const GBitmap *ref, short stepW, short stepH)$/;"	f	class:ocr::GBitsetOCR
createRotate	./GBitmap/GBitmap.h	/^	static GBitmap *createRotate(const GBitmap *ref, const float rotation) { return new GBitmap(ref, 0, rotation, 0); }$/;"	f	class:ocr::GBitmap
createScale	./GBitmap/GBitmap.h	/^	static GBitmap *createScale(const GBitmap *ref, const float scale) { return new GBitmap(ref, scale, 0, 0); }$/;"	f	class:ocr::GBitmap
createScale	./GBitmap/GBitmap.h	/^	static GBitmap *createScale(const GBitmap *ref, const float scale, int mode) {$/;"	f	class:ocr::GBitmap
createScaleRotate	./GBitmap/GBitmap.h	/^	static GBitmap *createScaleRotate(const GBitmap *ref, const float scale, const float rotation) {$/;"	f	class:ocr::GBitmap
crop32	./GBitmap/GBitmap.cpp	/^void GBitmap::crop32() {$/;"	f	class:ocr::GBitmap
cropLetter	./GFontEditor/GLetter.cpp	/^void GLetter::cropLetter(){$/;"	f	class:GLetter
csta	./OCRAlgorithm/f2c.h	/^	char *csta;$/;"	m	struct:__anon8
cstr	./OCRTypes/OCRTypes.h	/^typedef const char *cstr;$/;"	t	namespace:ocr
cstr	./OCRTypes/OCRTypes_www.h	/^    typedef const char*			cstr;$/;"	t	namespace:ocr
cunit	./OCRAlgorithm/f2c.h	/^	ftnint cunit;$/;"	m	struct:__anon8
curveQuadraticAproximation	./OCRAlgorithm/OCRAlgorithm.cpp	/^void curveQuadraticAproximation(OCRPoint &p0, OCRPoint &p1, OCRPoint &p3) {$/;"	f	namespace:ocr
curveQubicAproximation	./OCRAlgorithm/OCRAlgorithm.cpp	/^void curveQubicAproximation(OCRPoint &p0, OCRPoint &p1, OCRPoint &p2, OCRPoint &p3) {$/;"	f	namespace:ocr
custom_context	./PNG/lodepng.h	/^  const void* custom_context; \/*optional custom settings for custom functions*\/$/;"	m	struct:LodePNGCompressSettings
custom_context	./PNG/lodepng.h	/^  const void* custom_context; \/*optional custom settings for custom functions*\/$/;"	m	struct:LodePNGDecompressSettings
custom_deflate	./PNG/lodepng.h	/^  unsigned (*custom_deflate)(unsigned char**, size_t*,$/;"	m	struct:LodePNGCompressSettings
custom_inflate	./PNG/lodepng.h	/^  unsigned (*custom_inflate)(unsigned char**, size_t*,$/;"	m	struct:LodePNGDecompressSettings
custom_zlib	./PNG/lodepng.h	/^  unsigned (*custom_zlib)(unsigned char**, size_t*,$/;"	m	struct:LodePNGCompressSettings
custom_zlib	./PNG/lodepng.h	/^  unsigned (*custom_zlib)(unsigned char**, size_t*,$/;"	m	struct:LodePNGDecompressSettings
d	./GBitsetContour/GBitsetContour.h	/^	short dlt_y, t, d, xl, yl, n,m;$/;"	m	class:ocr::GBitsetContour
d	./OCRAlgorithm/f2c.h	/^	doublereal d;$/;"	m	union:Multitype
d0	./OCRTypes/OCRTypes.h	/^    short d0;$/;"	m	struct:ocr::OCRDataStruct
d1	./OCRTypes/OCRTypes.h	/^    uchar d1;$/;"	m	struct:ocr::OCRDataStruct
d2	./OCRTypes/OCRTypes.h	/^    uchar d2;$/;"	m	struct:ocr::OCRDataStruct
dH	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int dH;$/;"	m	namespace:ocr	file:
dIndex	./GFontEditor/GLetter.h	/^  vector<int> dIndex; \/\/ вектор индикатора наличия разделителя слогов после$/;"	m	class:ocr::OCRMatch
dM	./GGraphBezier/GGraphBezier.h	/^        float dM;           \/\/ - расстояние от центра масс до середины прямой соединяющей концы линии.$/;"	m	class:ocr::OCRFocalLineBezier
dSinhalaASCIToYagpo	./GLogicProcessor/codePagesConverter.cpp	/^string GLogicProcessor::dSinhalaASCIToYagpo(string &inStr){$/;"	f	class:GLogicProcessor
dWylieToYagpoConverter	./GLogicProcessor/codePagesConverter.cpp	/^string GLogicProcessor::dWylieToYagpoConverter(string &inStr){$/;"	f	class:GLogicProcessor
dX	./GFontEditor/GContour.h	/^    int dX,dY;  \/\/координаты левого верхнего угла контура на странице$/;"	m	class:ocr::GContour
dX	./GFontEditor/GLetter.h	/^  int dX, dY; \/\/\/<смещение координат центра буквы относительно изображения буквы$/;"	m	class:ocr::GLetter
dX	./GFontEditor/GLetter.h	/^  int dX, dY;$/;"	m	class:ocr::OCRMatch
dX	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^float dX;$/;"	m	namespace:ocr	file:
dY	./GFontEditor/GContour.h	/^    int dX,dY;  \/\/координаты левого верхнего угла контура на странице$/;"	m	class:ocr::GContour
dY	./GFontEditor/GLetter.h	/^  int dX, dY; \/\/\/<смещение координат центра буквы относительно изображения буквы$/;"	m	class:ocr::GLetter
dY	./GFontEditor/GLetter.h	/^  int dX, dY;$/;"	m	class:ocr::OCRMatch
dY	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^float dY;$/;"	m	namespace:ocr	file:
dabs	./OCRAlgorithm/f2c.h	159;"	d
dampMap	./OCRString/php2stl.cpp	/^string dampMap(map<string, string> &map) {$/;"	f
data	./GBitmap/ppm.h	/^	PPMPixel *data;$/;"	m	struct:__anon2
data	./GGraphBezier/GGraphBezier.h	/^        vector<OCRPointFloat>data;    \/\/ вектор для массивов координат точек фокальной линии по "x" и "y".$/;"	m	class:ocr::OCRFocalLineBezier
data	./GMemory/GMemory.h	/^	GVector *data;$/;"	m	class:ocr::tableRecord
data	./GMemory/GVector.h	/^    char    *data;$/;"	m	class:ocr::GStr
data	./GMemory/GVector.h	/^    char *       data;      \/\/указатель на данные$/;"	m	class:ocr::TString
data	./GMemory/GVector.h	/^    char * data;$/;"	m	class:ocr::GVector
data	./GMemory/MmapFile.h	/^	char *data() { return data_; }$/;"	f	class:MemoryFile
data	./GMemory/MmapFile.h	/^	const char *data() const { return data_; }$/;"	f	class:InputMemoryFile
data	./OCRTypes/OCRTypes.h	/^  char data;$/;"	m	class:ocr::GTextBufer
data	./OCRTypes/OCRTypes.h	/^  char data[127];$/;"	m	class:ocr::GString
data	./OCRTypes/OCRTypes.h	/^  short data;$/;"	m	struct:ocr::OCRPointStruct
data	./OCRTypes/OCRTypes.h	/^  vector<vector<OCRPointFloat> > data;$/;"	m	class:ocr::drawDataRecord
data	./OCRTypes/OCRTypes_www.h	/^		char data;$/;"	m	class:ocr::GTextBufer
data	./PNG/lodepng.cpp	/^  unsigned char* data;$/;"	m	struct:ucvector	file:
data	./PNG/lodepng.cpp	/^  unsigned* data;$/;"	m	struct:uivector	file:
data	./config.h	/^	std::map<std::string, std::string> data;$/;"	m	struct:commandData
dataConst	./OCRTypes/OCRTypes.h	/^enum dataConst {$/;"	g	namespace:ocr
dataConst	./OCRTypes/OCRTypes_www.h	/^	enum dataConst{$/;"	g	namespace:ocr
dataLocation	./GMemory/GVector.h	/^    int    dataLocation;$/;"	m	class:ocr::GVector
dataLocation	./GMemory/GVector.h	/^    ulong dataLocation;$/;"	m	class:ocr::GStr
dataMFile	./GMemory/GVector.h	/^    MemoryFile *dataMFile;$/;"	m	class:ocr::GStr
dataMFile	./GMemory/GVector.h	/^    MemoryFile *dataMFile;$/;"	m	class:ocr::GVector
dataPath	./GMemory/GMap/GMap.h	/^        string dataPath;$/;"	m	class:ocr::GMap
dataPath	./GMemory/GVector.h	/^    string      dataPath;$/;"	m	class:ocr::GVector
dataPtr	./GMemory/GVector.h	/^    T *dataPtr() {$/;"	f	class:ocr::GStr
dataSize	./GMemory/GVector.h	/^    ulong *dataSize;  \/\/размер занимаемый актуальными данными$/;"	m	class:ocr::GStr
dataSize	./GMemory/GVector.h	/^    ulong *dataSize;  \/\/размер занимаемый актуальными данными$/;"	m	class:ocr::GVector
dataStr	./GMemory/GVector.h	/^    vector<char> dataStr;$/;"	m	class:ocr::TString
dataT	./GMemory/GVector.h	/^    T *   dataT;$/;"	m	class:ocr::GStr2D
data_	./GMemory/MmapFile.h	/^	char *data_;$/;"	m	class:MemoryFile
data_	./GMemory/MmapFile.h	/^	const char *data_;$/;"	m	class:InputMemoryFile
data_normalisation	./GBitset/GBitset_Starting.cpp	/^void GBitset::data_normalisation() {$/;"	f	class:GBitset
data_null_border	./GBitset/GBitset_Starting.cpp	/^void GBitset::data_null_border() {$/;"	f	class:GBitset
data_size	./GBitmap/GBitmap.h	/^	int data_size;$/;"	m	class:ocr::GBitmap
data_size	./GBitset/GBitset.h	/^  int data_size;             \/\/\/<size of main memory buffer of image data$/;"	m	class:ocr::GBitset
data_size	./GBitsetContour/GBitsetContour.h	/^  int data_size;                   \/\/\/<размер основного байтового буфера данных битмэпа$/;"	m	class:ocr::GBitsetContour
data_size	./GBitsetMatrix/GBitsetMatrix.h	/^  int data_size;                  \/\/\/<количество пикселов в битмэпе$/;"	m	class:ocr::GBitsetMatrix
data_size	./GBitsetOCR/GBitsetOCR.h	/^  int data_size;$/;"	m	class:ocr::GBitsetOCR
data_size	./GMemory/GVector.h	/^    ulong data_size(void) {$/;"	f	class:ocr::GVector
data_size_p	./GBitmap/GBitmap.h	/^	unsigned int data_size_p; \/\/\/ размер упакованного массива байтов. 1 байт - 8 пикселов изображения$/;"	m	class:ocr::GBitmap
data_size_p32	./GBitmap/GBitmap.h	/^	unsigned int data_size_p32; \/\/\/ размер упакованного массива integer. 1 integer - 32 пиксела изображения$/;"	m	class:ocr::GBitmap
data_traverser	./OCRString/php2stl.cpp	/^struct data_traverser: public xml_tree_walker {$/;"	s	file:
day	./PNG/lodepng.h	/^  unsigned day;     \/*1-31*\/$/;"	m	struct:LodePNGTime
dblword	./config.h	/^	struct dblword {$/;"	s	union:ticks
dd	./test_clang.h	/^char     *dd;  \/\/char dd$/;"	v
dd	./test_clang.h	/^int tt=1; float dd=3;$/;"	v
decode	./PNG/lodepng.cpp	/^unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const std::string& filename,$/;"	f	namespace:lodepng
decode	./PNG/lodepng.cpp	/^unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const unsigned char* in,$/;"	f	namespace:lodepng
decode	./PNG/lodepng.cpp	/^unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,$/;"	f	namespace:lodepng
decodeGeneric	./PNG/lodepng.cpp	/^static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,$/;"	f	file:
decodeURL	./OCRString/php2stl.cpp	/^void decodeURL(string &URLstr) {$/;"	f
decodeURL_C	./OCRString/php2stl.cpp	/^cstr decodeURL_C(cstr URLstr) {$/;"	f
decodeValuesFromImageDictionary	./GPDF/CGImageFromPDF.h	/^CGFloat *decodeValuesFromImageDictionary(CGPDFDictionaryRef dict, CGColorSpaceRef cgColorSpace, NSInteger bitsPerComponent) {$/;"	f
decoder	./PNG/lodepng.h	/^  LodePNGDecoderSettings decoder; \/*the decoding settings*\/$/;"	m	struct:LodePNGState
decompress	./PNG/lodepng.cpp	/^unsigned decompress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,$/;"	f	namespace:lodepng
decompress	./PNG/lodepng.cpp	/^unsigned decompress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,$/;"	f	namespace:lodepng
deflate	./PNG/lodepng.cpp	/^static unsigned deflate(unsigned char** out, size_t* outsize,$/;"	f	file:
deflateDynamic	./PNG/lodepng.cpp	/^static unsigned deflateDynamic(ucvector* out, size_t* bp, Hash* hash,$/;"	f	file:
deflateFixed	./PNG/lodepng.cpp	/^static unsigned deflateFixed(ucvector* out, size_t* bp, Hash* hash,$/;"	f	file:
deflateNoCompression	./PNG/lodepng.cpp	/^static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize)$/;"	f	file:
delimeter	./GFontEditor/GLetter.h	/^  string delimeter;$/;"	m	class:ocr::OCRMatch
delimeter	./GFontEditor/GLetter.h	/^  string delimeter;$/;"	m	class:ocr::stringOCR
delimeter	./GFontEditor/GLetter.h	/^  string delimeter;$/;"	m	class:ocr::wordOCR
delimeterPali	./GLogicProcessor/GLogicProcessor.h	/^	vector<string>delimeterPali; \/\/\/<vector for all tibetan punctuation marks$/;"	m	class:ocr::GLogicProcessor
delimeterTib	./GLogicProcessor/GLogicProcessor.h	/^	vector<string>delimeterTib; \/\/\/<vector for all tibetan punctuation marks$/;"	m	class:ocr::GLogicProcessor
delta	./GMemory/GMap/GMap.h	/^        ulong delta;               \/\/ максимальное количество не четких букв в легитимной фразе словаря (dlt=0; четкий поиск)$/;"	m	class:ocr::GMap
deltaLimit	./OCRTypes/OCRTypes.h	/^const short deltaLimit = 13;$/;"	m	namespace:ocr
deltaLimit	./OCRTypes/OCRTypes_www.h	/^	const short deltaLimit=13;$/;"	m	namespace:ocr
deltaSlice	./GBitset/GBitset.cpp	/^void GBitset::deltaSlice(vector<vector<int> > &INFase,vector<vector<int> > &INGilb){$/;"	f	class:ocr::GBitset
deltaX	./GBitset/GBitset.h	/^  short deltaX;$/;"	m	class:ocr::GBitset
deltaX	./GBitsetContour/GBitsetContour.h	/^  int deltaX;$/;"	m	class:ocr::GBitsetContour
deltaX	./GBitsetMatrix/GBitsetMatrix.h	/^  short deltaX;$/;"	m	class:ocr::GBitsetMatrix
deltaX	./OCRTypes/OCRTypes.h	/^  short deltaX;$/;"	m	class:ocr::OCRTextData
deltaX	./OCRTypes/OCRTypes_www.h	/^		short deltaX;$/;"	m	class:ocr::OCRTextData
destData	./GBitset/GBitset.h	/^  GBitmap *destData;         \/\/\/<debug graphic Bitmap$/;"	m	class:ocr::GBitset
destData	./GBitsetContour/GBitsetContour.h	/^  GBitmap* destData;               \/\/\/<отладочный графический массив$/;"	m	class:ocr::GBitsetContour
destKey	./OCRTypes/OCRTypes.h	/^  string destKey;$/;"	m	struct:ocr::dictKeyStruct
destKey	./OCRTypes/OCRTypes_www.h	/^		string destKey;$/;"	m	struct:ocr::dictKey
destroy	./GBitmap/GBitmap.cpp	/^void GBitmap::destroy(void) {$/;"	f	class:ocr::GBitmap
destroy	./GBitset/GBitset_base.cpp	/^GBitset::destroy(void){$/;"	f	class:GBitset
destroy	./GBitsetContour/GBitsetContour.cpp	/^GBitsetContour::destroy(void)$/;"	f	class:GBitsetContour
destroy	./GBitsetMatrix/GBitsetMatrix_base.cpp	/^GBitsetMatrix::destroy(void)$/;"	f	class:GBitsetMatrix
destroy	./GBitsetOCR/GBitset_baseOCR.cpp	/^GBitsetOCR::destroy(void)$/;"	f	class:GBitsetOCR
destroy	./GFontEditor/GContour.cpp	/^void GContour::destroy(void){$/;"	f	class:ocr::GContour
destroy	./GFontEditor/GFont.cpp	/^	void GFont::destroy(void){$/;"	f	class:ocr::GFont
destroy	./GFontEditor/GLetter.cpp	/^void GLetter::destroy(){$/;"	f	class:GLetter
destroy	./GFontEditor/GLetter.cpp	/^void blockOCR::destroy(void){}$/;"	f	class:blockOCR
destroy	./GFontEditor/GLetter.cpp	/^void columnOCR::destroy(void){}$/;"	f	class:columnOCR
destroy	./GFontEditor/GLetter.cpp	/^void frameOCR::destroy(void){}$/;"	f	class:frameOCR
destroy	./GFontEditor/GLetter.cpp	/^void lineOCR::destroy(void){}$/;"	f	class:lineOCR
destroy	./GFontEditor/GLetter.cpp	/^void recordOCR::destroy(void){}$/;"	f	class:recordOCR
destroy	./GFontEditor/GLetter.cpp	/^void stringOCR::destroy(void){$/;"	f	class:stringOCR
destroy	./GFontEditor/GLetter.cpp	/^void wordOCR::destroy(void){$/;"	f	class:wordOCR
destroy	./GLogicProcessor/GLogicProcessor.cpp	/^    void GLogicProcessor::destroy(void)$/;"	f	class:ocr::GLogicProcessor
destroy	./GMainEditor/GMainEditor.cpp	/^	void GMainEditor::destroy(void){$/;"	f	class:ocr::GMainEditor
destroy	./GMemory/GMap/GMap.cpp	/^void GMap::destroy(void){$/;"	f	class:GMap
destroy	./GMemory/GMemory.cpp	/^void GMemory::destroy(void)$/;"	f	class:ocr::GMemory
destroy	./GMemory/GVector.cpp	/^void GVector::destroy(void) {$/;"	f	class:GVector
destroy	./GMemory/GVector.h	/^void GStr2D<T>::destroy(void) {$/;"	f	class:ocr::GStr2D
destroy	./GMemory/GVector.h	/^void GStr<T>::destroy(void) {$/;"	f	class:ocr::GStr
destroy	./OCRTypes/OCRTypes.cpp	/^void vectorOCR::destroy(void) {}$/;"	f	class:ocr::vectorOCR
detectCircle	./GGraph/GGraphOCRStar.cpp	/^void GGraph::detectCircle() {$/;"	f	class:ocr::GGraph
detectContourT	./GBitmap/GBitmapPenWidth.cpp	/^  void GBitmap::detectContourT() {$/;"	f	class:ocr::GBitmap
detectFocalPoint	./GGraph/GGraphDetectFocalPoint.cpp	/^ushort GGraph::detectFocalPoint(short search_x,$/;"	f	class:ocr::GGraph
detectP_POINT	./GGraph/GGraphOCRStar.cpp	/^void GGraph::detectP_POINT() {$/;"	f	class:ocr::GGraph
detectPageAngle	./GBitmap/GBitmapDetectorRadon.cpp	/^  float GBitmap::detectPageAngle(int g) {$/;"	f	class:ocr::GBitmap
detectPageAngleB	./GBitmap/GBitmapDetectorRadon.cpp	/^  float GBitmap::detectPageAngleB(int maxAngle, int Tr, int BASE) {$/;"	f	class:ocr::GBitmap
detectRegion	./GBitmap/GBitmap.cpp	/^GBitmap *GBitmap::detectRegion(int frame, int *x0, int *x1, int *y0, int *y1, int mode) {$/;"	f	class:ocr::GBitmap
detectRotation	./GBitset/GBitset.cpp	/^float GBitset::detectRotation(){$/;"	f	class:ocr::GBitset
detectScale	./GGraphOCR/GGraphOCRStarCorrelation.cpp	/^void GGraphOCR::detectScale(OCRStar *starsT, OCRLetter &letter) {$/;"	f	class:ocr::GGraphOCR
dict	./OCRTypes/OCRTypes.h	/^  string dict;$/;"	m	class:ocr::OCRDictRecord
dict	./OCRTypes/OCRTypes.h	/^  string dict;$/;"	m	struct:ocr::dictKeyStruct
dict	./OCRTypes/OCRTypes_www.h	/^		string dict;$/;"	m	class:ocr::OCRDictRecord
dict	./OCRTypes/OCRTypes_www.h	/^		string dict;$/;"	m	struct:ocr::dictKey
dictData	./GMemory/GMap/GMap.h	/^        mSIZE* dictData(){return dictionary_data;}$/;"	f	class:ocr::GMap
dictIndexChesh	./GLogicProcessor/GLogicProcessor.h	/^	map<string,vector <int> >dictIndexChesh; \/\/\/< index map for all Chesh dictionary$/;"	m	class:ocr::GLogicProcessor
dictIndexPali	./GLogicProcessor/GLogicProcessor.h	/^	map<string,vector <int> >dictIndexPali; \/\/\/< index map for all pali dictionary$/;"	m	class:ocr::GLogicProcessor
dictIndexTib	./GLogicProcessor/GLogicProcessor.h	/^	map<string,vector <int> >dictIndexTib; \/\/\/< index map for all tibetan dictionary$/;"	m	class:ocr::GLogicProcessor
dictKey	./OCRTypes/OCRTypes.h	/^} dictKey;$/;"	t	namespace:ocr	typeref:struct:ocr::dictKeyStruct
dictKey	./OCRTypes/OCRTypes_www.h	/^	struct dictKey {$/;"	s	namespace:ocr
dictKeyStruct	./OCRTypes/OCRTypes.h	/^typedef struct dictKeyStruct {$/;"	s	namespace:ocr
dictKey_sort	./OCRString/php2stl.cpp	/^bool dictKey_sort(const dictKey d1, const dictKey d2) {$/;"	f
dictRecord	./GLogicProcessor/GLogicProcessor.h	/^	map<int, OCRDictRecord> dictRecord; \/\/\/< main map for all dictionary$/;"	m	class:ocr::GLogicProcessor
dictReport	./GLogicProcessor/GLogicProcessor.h	/^	vector<OCRDictRecord> dictReport; \/\/\/< vector for translation output$/;"	m	class:ocr::GLogicProcessor
dictReportPage	./GLogicProcessor/GLogicProcessor.h	/^	vector<vector<OCRDictRecord> >dictReportPage;  \/\/\/<vector for multi-line translation output$/;"	m	class:ocr::GLogicProcessor
dict_size	./GLogicProcessor/GLogicProcessor.h	/^    unsigned int dict_size;           \/\/ размер массива словаря $/;"	m	class:ocr::GLogicProcessor
dict_size	./GMemory/GMap/GMap.h	/^        ulong dict_size;           \/\/ размер массива словаря$/;"	m	class:ocr::GMap
dict_size1	./GLogicProcessor/GLogicProcessor.h	/^    unsigned int dict_size1;       \/\/ размер словаря без переводов каретки Enter      $/;"	m	class:ocr::GLogicProcessor
dict_size1	./GMemory/GMap/GMap.h	/^        ulong dict_size1;       \/\/ размер словаря без переводов каретки Enter$/;"	m	class:ocr::GMap
dictionaryGMap	./GMemory/GMemory.h	/^	GMap *dictionaryGMap; \/\/\/map of main dictionary$/;"	m	class:ocr::GMemory
dictionaryReady	./GLogicProcessor/GLogicProcessor.h	/^	int dictionaryReady;  \/\/flag of dictionary loading$/;"	m	class:ocr::GLogicProcessor
dictionary_data	./GLogicProcessor/GLogicProcessor.h	/^    unsigned short  *dictionary_data; \/\/ массив словаря$/;"	m	class:ocr::GLogicProcessor
dictionary_data	./GMemory/GMap/GMap.h	/^        mSIZE  *dictionary_data; \/\/ массив словаря$/;"	m	class:ocr::GMap
dictionary_data_vector	./GMemory/GMap/GMap.h	/^        GStr<mSIZE>*dictionary_data_vector;$/;"	m	class:ocr::GMap
dims	./OCRAlgorithm/f2c.h	/^	ftnlen *dims;$/;"	m	struct:Vardesc
dir	./GGraph/GGraph.h	/^	char dir[4]; \/\/\/<массив индикаторов направления фокальных линий OCRStar$/;"	m	struct:ocr::OCRStarStruct
directParsePDF	./GPDF/CGImageFromPDF.h	/^void directParsePDF(const char*path){$/;"	f
direction	./GFontEditor/GContour.h	/^    int direction;$/;"	m	class:ocr::GContour
direction	./OCRTypes/OCRTypes.h	/^  short direction;$/;"	m	class:ocr::OCRTextData
direction	./OCRTypes/OCRTypes_www.h	/^		short direction;$/;"	m	class:ocr::OCRTextData
disp	./GGraph/GGraph.h	/^	ushort disp;	  \/\/\/<дисперсия длин линий$/;"	m	struct:ocr::OCRStarStruct
dlt0	./GBitMask/GBitMask.h	/^		int dlt0,dlt1,dlt2; \/\/характеристики маски$/;"	m	class:ocr::GBitMask128
dlt0	./GBitMask/GBitMask.h	/^		int dlt0;                  \/\/\/величина растискивания(дерривации) изображения маски OFF$/;"	m	class:ocr::GBitMask32
dlt1	./GBitMask/GBitMask.h	/^		int dlt0,dlt1,dlt2; \/\/характеристики маски$/;"	m	class:ocr::GBitMask128
dlt1	./GBitMask/GBitMask.h	/^        int dlt1;                  \/\/\/величина эрозии изображения в маске ON$/;"	m	class:ocr::GBitMask32
dlt2	./GBitMask/GBitMask.h	/^		int dlt0,dlt1,dlt2; \/\/характеристики маски$/;"	m	class:ocr::GBitMask128
dlt2	./GBitMask/GBitMask.h	/^        int dlt2;                  \/\/\/величина эрозии изображения в маске OFF$/;"	m	class:ocr::GBitMask32
dlt_y	./GBitsetContour/GBitsetContour.h	/^	short dlt_y, t, d, xl, yl, n,m;$/;"	m	class:ocr::GBitsetContour
dmax	./OCRAlgorithm/f2c.h	163;"	d
dmin	./OCRAlgorithm/f2c.h	162;"	d
document	./GPDF/GPDF.h	/^    CGPDFDocumentRef document;$/;"	m	class:ocr::GPDF
dotGain	./GBitmap/GBitmap.cpp	/^  void GBitmap::dotGain(int gRateLefts, int gRateRight,$/;"	f	class:ocr::GBitmap
doublecomplex	./OCRAlgorithm/f2c.h	/^typedef struct { doublereal r, i; } doublecomplex;$/;"	t	typeref:struct:__anon4
doublereal	./OCRAlgorithm/f2c.h	/^typedef double doublereal;$/;"	t
drawConst	./OCRTypes/OCRTypes.h	/^enum drawConst {$/;"	g	namespace:ocr
drawConst	./OCRTypes/OCRTypes_www.h	/^		enum drawConst{$/;"	g	namespace:ocr
drawContour	./GBitsetContour/contourOCR.cpp	/^void GBitsetContour::drawContour(){$/;"	f	class:GBitsetContour
drawContour	./GFontEditor/GLetter.cpp	/^void GLetter::drawContour(){$/;"	f	class:GLetter
drawCorrelation	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void GGraphOCR::drawCorrelation(GGraph &graph, OCRLetter &letter) {$/;"	f	class:ocr::GGraphOCR
drawCorrelationImg	./GGraphOCR/GGraphOCRLetterNeighbors.cpp	/^void GGraphOCR::drawCorrelationImg(vector<OCRLetter> &matchLetter, GGraph &graphPage, GBitmap *imgPage) {$/;"	f	class:GGraphOCR
drawData	./GBitset/GBitset.h	/^  GBitmap* drawData;$/;"	m	class:ocr::GBitset
drawData	./GBitsetContour/GBitsetContour.h	/^  GBitmap* drawData;              \/\/\/<отладочный графический массив$/;"	m	class:ocr::GBitsetContour
drawData	./GBitsetOCR/GBitsetOCR.h	/^  GBitmap* drawData;           \/\/bitmap for drawing$/;"	m	class:ocr::GBitsetOCR
drawData32	./GBitsetMatrix/GBitsetMatrix_level.cpp	/^GBitmap* GBitsetMatrix::drawData32(){$/;"	f	class:GBitsetMatrix
drawDataRGB	./GBitset/GBitset.h	/^  GBitmap* drawDataRGB;$/;"	m	class:ocr::GBitset
drawDataRGB	./GBitsetMatrix/GBitsetMatrix.h	/^  GBitmap* drawDataRGB;           \/\/\/<отладочный графический массив$/;"	m	class:ocr::GBitsetMatrix
drawDataRecord	./GFontEditor/GLetter.cpp	/^drawDataRecord::drawDataRecord(){}$/;"	f	class:drawDataRecord
drawDataRecord	./OCRTypes/OCRTypes.h	/^class drawDataRecord {$/;"	c	namespace:ocr
drawEditLetter	./GFontEditor/drawBase.cpp	/^string GFontEditor::drawEditLetter(unsigned int letterIndex) {$/;"	f	class:GFontEditor
drawFont	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::drawFont() {$/;"	f	class:ocr::GGraphOCR
drawGrapeLine	./GLogicProcessor/drawGrapeLine.cpp	/^void GLogicProcessor::drawGrapeLine(vector<OCRMatch>&line){$/;"	f	class:GLogicProcessor
drawGraph	./GBitset/GBitset.h	/^  drawDataRecord drawGraph;  \/\/\/<debug graphic data$/;"	m	class:ocr::GBitset
drawGraph	./GBitsetContour/GBitsetContour.h	/^  drawDataRecord drawGraph;        \/\/\/<отладочный графический массив$/;"	m	class:ocr::GBitsetContour
drawGraph	./GBitsetMatrix/GBitsetMatrix.h	/^	drawDataRecord drawGraph;     \/\/\/<отладочный графический массив$/;"	m	class:ocr::GBitsetMatrix
drawGraphSVG	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void GGraphOCR::drawGraphSVG(GGraph &graph, string &dataStr) {$/;"	f	class:ocr::GGraphOCR
drawHTML	./GFontEditor/drawBase.cpp	/^void GFont::drawHTML(uint startRec, int rowsNum, string &result, int mode) {$/;"	f	class:GFont
drawHTML	./GFontEditor/drawBase.cpp	/^void GFont::drawHTML(vector<ulong> &searchResult, string &result, int mode) {$/;"	f	class:GFont
drawHist	./GBitmap/GBitmapAutoLevel.cpp	/^void drawHist(float h[]){$/;"	f
drawHist	./GBitmap/GBitmapAutoLevel.cpp	/^void drawHist(int h[]){$/;"	f
drawImg	./GBitmap/GBitmap.cpp	/^void GBitmap::drawImg(GBitmap *img, int x0, int y0) {$/;"	f	class:ocr::GBitmap
drawImg	./GBitmap/GBitmap.cpp	/^void GBitmap::drawImg(GBitmap *img, int x0, int y0, int mode) {$/;"	f	class:ocr::GBitmap
drawLetter	./GFontEditor/GFont.cpp	/^    GBitmap* GFont::drawLetter(unsigned int in){$/;"	f	class:ocr::GFont
drawLetter	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::drawLetter(OCRLetter &letter, const char *path) {} \/\/_________________________________________________________$/;"	f	class:ocr::GGraphOCR
drawLetterClustersSVG	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void GGraphOCR::drawLetterClustersSVG(OCRLetter &letter, cstr path) {$/;"	f	class:ocr::GGraphOCR
drawLetterCorrelationSVG	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void GGraphOCR::drawLetterCorrelationSVG(OCRLetter &letterTest, OCRLetter &letter, cstr path) {$/;"	f	class:ocr::GGraphOCR
drawLetterPict	./GFontEditor/GFont.cpp	/^    GBitmap* GFont::drawLetterPict(int in){$/;"	f	class:ocr::GFont
drawLetterPict	./GFontEditor/GLetter.cpp	/^GBitmap* GLetter::drawLetterPict(int mode){$/;"	f	class:GLetter
drawLetterSVG	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void GGraphOCR::drawLetterSVG(OCRLetter &letter, string &dataStr) {$/;"	f	class:ocr::GGraphOCR
drawLine	./GBitsetMatrix/GBitsetMatrix.h	/^  GGraphBezier drawLine;                \/\/\/<графический масив фокальных линий$/;"	m	class:ocr::GBitsetMatrix
drawMask32V	./GBitmap/GBitmap32.cpp	/^void GBitmap::drawMask32V(void *mask32,int x0, int y0,OCRBox *s, int mode){$/;"	f	class:GBitmap
drawMatchLine	./GLogicProcessor/drawMatchLine.cpp	/^void GLogicProcessor::drawMatchLine(vector<OCRMatch>&line){$/;"	f	class:GLogicProcessor
drawMode	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int drawMode=0; \/\/1-night mode; 0 - normal mode$/;"	m	namespace:ocr	file:
drawNFase	./GBitset/GBitset.cpp	/^void GBitset::drawNFase(vector<vector<int> > &INFase, int color){$/;"	f	class:ocr::GBitset
drawNewLetters	./GFontEditor/drawBase.cpp	/^string GFontEditor::drawNewLetters() {$/;"	f	class:GFontEditor
drawOCRBaseImage	./GFontEditor/drawBase.cpp	/^GBitmap *GFont::drawOCRBaseImage(uint startRec, uint rowsNum) {$/;"	f	class:GFont
drawOCRBasePict	./GFontEditor/drawBase.cpp	/^GBitmap *GFont::drawOCRBasePict(vector<ulong> &searchResult, int mode) {$/;"	f	class:GFont
drawOCRBasePict	./GFontEditor/drawBase.cpp	/^void GFont::drawOCRBasePict(uint startRec, uint rowsNum, int mode) {$/;"	f	class:GFont
drawOCRLineAffineCorrelationSVG	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void GGraphOCR::drawOCRLineAffineCorrelationSVG(OCRLine &lineT, OCRLine &line,OCRPoint *pointDataT, OCRPoint *pointData, int dir, string &dataStr){$/;"	f	class:ocr::GGraphOCR
drawOCRLineCorrelationSVG	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void GGraphOCR::drawOCRLineCorrelationSVG(OCRLine &lineT, OCRLine &line,OCRPoint *pointData,string &dataStr){$/;"	f	class:ocr::GGraphOCR
drawOCRPage	./GMainEditor/drawPage.cpp	/^void GMainEditor::drawOCRPage(vector<stringOCR>&strArray){$/;"	f	class:GMainEditor
drawOCRStarCorrelation	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int GGraphOCR::drawOCRStarCorrelation(OCRStar &starT, $/;"	f	class:ocr::GGraphOCR
drawPict	./GFontEditor/GFont.cpp	/^    GBitmap* GFont::drawPict(int in){$/;"	f	class:ocr::GFont
drawPict	./GFontEditor/GLetter.cpp	/^GBitmap* GLetter::drawPict(){$/;"	f	class:GLetter
drawPict32	./GFontEditor/GLetter.cpp	/^GBitmap* GLetter::drawPict32(){$/;"	f	class:GLetter
drawPict32	./GFontEditor/GLetter.cpp	/^void OCRMatch::drawPict32(GBitmap* outBitmap32,int dx,int dy, int mode){$/;"	f	class:OCRMatch
drawPoint	./GBitsetMatrix/GBitsetMatrix.h	/^  GGraphBezier drawPoint;               \/\/\/<графический масив фокальных точек$/;"	m	class:ocr::GBitsetMatrix
drawStrArray	./GMainEditor/drawPage.cpp	/^void GMainEditor::drawStrArray(vector<stringOCR>&strArray, int border){$/;"	f	class:GMainEditor
drawStrArrayDebug	./GMainEditor/drawPage.cpp	/^void GMainEditor::drawStrArrayDebug(vector<stringOCR>&strArray, int border){$/;"	f	class:GMainEditor
drawToSVG	./GFontEditor/GLetter.cpp	/^string GLetter::drawToSVG(){$/;"	f	class:GLetter
drawVector	./GMainEditor/startOCR.cpp	/^void GMainEditor::drawVector( vector<OCRPointFloat>&strPoint, vector<OCRFocalLineBezier>&lineVec){$/;"	f	class:GMainEditor
dw	./config.h	/^	} dw; \/\/ little endian$/;"	m	union:ticks	typeref:struct:ticks::dblword
dy_line	./GBitsetContour/GBitsetContour.h	/^	short res, xBegin, xEnd, xL,yL,hL, wL, dy_line, y_line, yLine, *ln,*lt;$/;"	m	class:ocr::GBitsetContour
e_open_mode	./GMemory/MmapFile.h	/^	enum e_open_mode$/;"	g	class:MemoryFile
ecode	./codeStorage.h	/^int ecode, pksiz, i, rsiz;$/;"	v
eentry	./OCRTypes/OCRTypes.h	/^  string eentry;$/;"	m	class:ocr::OCRDictRecord
eentry	./OCRTypes/OCRTypes_www.h	/^		string eentry;$/;"	m	class:ocr::OCRDictRecord
emptyFolder	./OCRString/php2stl.cpp	/^bool emptyFolder(string &dirPath) {$/;"	f
encode	./PNG/lodepng.cpp	/^unsigned encode(const std::string& filename,$/;"	f	namespace:lodepng
encode	./PNG/lodepng.cpp	/^unsigned encode(std::vector<unsigned char>& out, const unsigned char* in, unsigned w, unsigned h,$/;"	f	namespace:lodepng
encode	./PNG/lodepng.cpp	/^unsigned encode(std::vector<unsigned char>& out,$/;"	f	namespace:lodepng
encodeByID	./GLogicProcessor/UniToYagpo.cpp	/^void GLogicProcessor::encodeByID(string &vData){$/;"	f	class:GLogicProcessor
encodeID	./GMemory/GMap/GMap.cpp	/^void GMap::encodeID(string &vData){$/;"	f	class:GMap
encodeLZ77	./PNG/lodepng.cpp	/^static unsigned encodeLZ77(uivector* out, Hash* hash,$/;"	f	file:
encodeURL	./OCRString/php2stl.cpp	/^void encodeURL(string &URLstr) {$/;"	f
encoder	./PNG/lodepng.h	/^  LodePNGEncoderSettings encoder; \/*the encoding settings*\/$/;"	m	struct:LodePNGState
end	./GFontEditor/GLetter.h	/^  OCRPointFloat end;$/;"	m	class:ocr::OCRMatch
end	./GFontEditor/GLetter.h	/^  OCRPointFloat end;$/;"	m	class:ocr::OCRMatchConst
end	./GGraph/GGraph.h	/^	OCRPoint end; \/\/\/< координаты окончания линии в конечной точке или экстремуме$/;"	m	struct:ocr::OCRLineStruct
end	./GGraphBezier/GGraphBezier.h	/^        OCRPointFloat end;       \/\/ координаты окончания линии.$/;"	m	class:ocr::OCRFocalLineBezier
end32	./GGraph/GGraph.h	/^	OCRPoint end32; \/\/\/< координаты окончания линии в маске 32х32$/;"	m	struct:ocr::OCRLineStruct
endContour	./GBitsetContour/GBitsetContour.h	/^	short *lineCoordinate, endContour;$/;"	m	class:ocr::GBitsetContour
endID	./GGraph/GGraph.h	/^	uint endID;		 \/\/\/< id номер конечной OCRStar$/;"	m	struct:ocr::OCRLineStruct
endIndex	./GGraph/GGraph.h	/^	uchar endIndex;  \/\/\/< индекс линии в конечной OCRStar  $/;"	m	struct:ocr::OCRLineStruct
endIndex	./OCRTypes/OCRTypes.h	/^  int endIndex;$/;"	m	struct:ocr::stringMatch_
endIndex	./OCRTypes/OCRTypes_www.h	/^		int endIndex;$/;"	m	struct:ocr::stringMatch_
endIndexSrc	./OCRTypes/OCRTypes.h	/^  int endIndexSrc;$/;"	m	struct:ocr::stringMatch_
endIndexSrc	./OCRTypes/OCRTypes_www.h	/^		int endIndexSrc;$/;"	m	struct:ocr::stringMatch_
endl	./codeStorage.h	/^cout<<"complete"<<endl;$/;"	v
endl	./codeStorage.h	/^cout<<"data readed"<<endl;$/;"	v
endl	./codeStorage.h	/^cout<<endl<<endl<<"\/\/_____Tokio cabinet"<<endl; $/;"	v
endl	./test_clang.h	/^cout<<endl<<"1_______________________________________________________________________________________"<<endl;$/;"	v
endl	./test_clang.h	/^cout<<endl<<"2___________________________________________________________________"<<endl;$/;"	v
endl	./workCode_retreat.h	/^cout <<"www"<<endl;$/;"	v
erase	./GMemory/GVector.h	/^void GStr<T>::erase(ulong id) {$/;"	f	class:ocr::GStr
eraseAllMask	./GFontEditor/GLetter.h	/^  void eraseAllMask() {$/;"	f	class:ocr::GLetter
eraseBorder	./GBitmap/GBitmap.cpp	/^void GBitmap::eraseBorder(uint dX, uint dY) {$/;"	f	class:ocr::GBitmap
eraseDublicateMask	./GFontEditor/GLetter.cpp	/^void GLetter::eraseDublicateMask(){$/;"	f	class:GLetter
eraseEmptyMask	./GFontEditor/GLetter.cpp	/^void GLetter::eraseEmptyMask(){$/;"	f	class:GLetter
eraseMask	./GFontEditor/GLetter.cpp	/^void GLetter::eraseMask(int id){$/;"	f	class:GLetter
eraseMaskContent	./GFontEditor/GLetter.cpp	/^void GLetter::eraseMaskContent(int m){$/;"	f	class:GLetter
eraseNoCorrelationMask	./GFontEditor/letterOCR.cpp	/^void GFontEditor::eraseNoCorrelationMask(GLetter* letter){$/;"	f	class:GFontEditor
error	./OCRString/php2stl.cpp	/^void error(char *msg) {$/;"	f
error	./PNG/lodepng.h	/^  unsigned error;$/;"	m	struct:LodePNGState
example	./OCRTypes/OCRTypes.h	/^  string example;$/;"	m	class:ocr::OCRDictRecord
example	./OCRTypes/OCRTypes_www.h	/^		string example;$/;"	m	class:ocr::OCRDictRecord
exp	./OCRTypes/OCRTypes.h	/^  string exp;$/;"	m	class:ocr::OCRDictRecord
exp	./OCRTypes/OCRTypes_www.h	/^		string exp;$/;"	m	class:ocr::OCRDictRecord
explode	./OCRString/php2stl.cpp	/^int explode(const string &delimiter, const string &input, vector<string> &result) {$/;"	f
explodeOCR	./GLogicProcessor/grammarCorrector.cpp	/^vector<stringOCR> GLogicProcessor::explodeOCR(const vector<string> &delimiter, stringOCR &input) {$/;"	f	class:GLogicProcessor
explodeOCR	./GLogicProcessor/grammarCorrector.cpp	/^vector<wordOCR> GLogicProcessor::explodeOCR(const vector<string> &delimiter, const string &input) {$/;"	f	class:GLogicProcessor
explodeW	./OCRString/php2stl.cpp	/^int explodeW(const wstring &delimiter, const wstring &input,vector<wstring> &result) {$/;"	f
exportAllRecords	./GMemory/loadDB.cpp	/^void GMemory::exportAllRecords(string &tableName, string path) {$/;"	f	class:GMemory
exportGFontsDB	./GFontEditor/GFontEditor.cpp	/^string  GFontEditor::exportGFontsDB(string &path){$/;"	f	class:GFontEditor
exportHex	./GMemory/GVector.cpp	/^void TString::exportHex(string &str) {$/;"	f	class:TString
exportOCR	./GMainEditor/drawPage.cpp	/^void GMainEditor::exportOCR(){$/;"	f	class:GMainEditor
exportTStr	./GMemory/GVector.cpp	/^void GVector::exportTStr(cstr path) {$/;"	f	class:GVector
exportTStr	./GMemory/GVector.cpp	/^void GVector::exportTStr(string &path) {$/;"	f	class:GVector
exportTable	./GMemory/loadDB.cpp	/^void GMemory::exportTable(string &name, string &ext) {$/;"	f	class:GMemory
exportXML	./GMemory/GVector.cpp	/^void GVector::exportXML(string &path) {$/;"	f	class:GVector
extrem	./GGraph/GGraph.h	/^	uchar extrem[MAX_EXTREM];$/;"	m	struct:ocr::OCRLineStruct
extremCount	./GGraph/GGraph.h	/^	uchar extremCount; \/\/\/< количество экстремумов линии$/;"	m	struct:ocr::OCRLineStruct
fLine	./GFontEditor/GLetter.h	/^  OCRFocalLineBezier *fLine; \/\/\/указатель на массив фокальных линий буквы$/;"	m	class:ocr::GLetter
fMap	./OCRTypes/OCRTypes.h	/^  vector<uniRecord> fMap;$/;"	m	struct:ocr::fontOCRMap
fMap	./OCRTypes/OCRTypes_www.h	/^		vector<uniRecord> fMap;$/;"	m	struct:ocr::fontOCRMap
fPoint	./GBitsetMatrix/GBitsetMatrix.h	/^  OCRPointFloat *fPoint;               \/\/\/<указатель на первый элемент вектора фокальных точек$/;"	m	class:ocr::GBitsetMatrix
fPoint	./GFontEditor/GLetter.h	/^      *fPoint; \/\/\/указатель на массив топологических ключевых точек буквы$/;"	m	class:ocr::GLetter
fPointCount	./GFontEditor/GLetter.h	/^  ulong fPointCount() { return focalPoint->size(); }; \/\/\/<количество признаков$/;"	f	class:ocr::GLetter
fd	./codeStorage.h	/^close(fd);$/;"	v
fdb	./codeStorage.h	/^TCTDB *fdb;$/;"	v
fdb	./codeStorage.h	/^tctdbdel(fdb);$/;"	v
field	./GMemory/GMap/GMap.h	/^    uint field;$/;"	m	struct:pageRecordLink
field	./GMemory/GMap/GMap.h	/^    ushort field;$/;"	m	struct:pageLink
fieldNum	./GMemory/GMemory.h	/^	int fieldNum;	  \/\/number of field in the table adressed by index$/;"	m	class:ocr::indexRecord
file	./GFontEditor/GLetter.h	/^  string file;$/;"	m	class:ocr::stringOCR
file	./GFontEditor/GLetter.h	/^  string file;$/;"	m	class:ocr::wordOCR
fileExt	./OCRString/php2stl.cpp	/^string fileExt(string &path) {$/;"	f
fileList	./config.h	/^	std::vector<std::string> fileList;$/;"	m	struct:commandData
fileName	./GBitsetOCR/GBitsetOCR.h	/^  string fileName;$/;"	m	class:ocr::GBitsetOCR
fileName	./GFontEditor/GFont.h	/^        string fileName;$/;"	m	class:ocr::GFont
fileName	./OCRString/php2stl.cpp	/^string fileName(string &path) {$/;"	f
fileOpen	./OCRString/php2stl.cpp	/^bool fileOpen(string &path) {$/;"	f
fileSet	./config.h	/^	std::vector<std::string> fileSet;$/;"	m	struct:commandData
file_handle_	./GMemory/MmapFile.h	/^	HANDLE file_handle_;$/;"	m	class:InputMemoryFile
file_handle_	./GMemory/MmapFile.h	/^	HANDLE file_handle_;$/;"	m	class:MemoryFile
file_handle_	./GMemory/MmapFile.h	/^	int file_handle_;$/;"	m	class:InputMemoryFile
file_handle_	./GMemory/MmapFile.h	/^	int file_handle_;$/;"	m	class:MemoryFile
file_lock	./OCRString/php2stl.cpp	/^struct flock *file_lock(short type, short whence) {$/;"	f
file_mapping_handle_	./GMemory/MmapFile.h	/^	HANDLE file_mapping_handle_;$/;"	m	class:InputMemoryFile
file_mapping_handle_	./GMemory/MmapFile.h	/^	HANDLE file_mapping_handle_;$/;"	m	class:MemoryFile
fill	./GBitmap/GBitmap.cpp	/^void GBitmap::fill(unsigned char value) {$/;"	f	class:ocr::GBitmap
fill	./GBitset/GBitset_base.cpp	/^GBitset::fill(bool value)$/;"	f	class:GBitset
fill	./GBitsetContour/GBitsetContour.cpp	/^void GBitsetContour::fill(bool value)$/;"	f	class:GBitsetContour
fill	./GBitsetOCR/GBitset_baseOCR.cpp	/^GBitsetOCR::fill(bool value)$/;"	f	class:GBitsetOCR
fill	./GMemory/GVector.h	/^void GStr<T>::fill(char value){$/;"	f	class:ocr::GStr
fill32V	./GBitmap/GBitmap32.cpp	/^void GBitmap::fill32V(bool color, OCRBox *s){$/;"	f	class:GBitmap
fillColumns32V	./GBitmap/GBitmap32.cpp	/^void GBitmap::fillColumns32V(bool color, OCRBox *s){$/;"	f	class:GBitmap
fillContour	./GBitsetContour/readContour.cpp	/^void GBitsetContour::fillContour(GContour *contour){$/;"	f	class:GBitsetContour
filter	./PNG/lodepng.cpp	/^static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,$/;"	f	file:
filterCount	./GBitsetContour/GBitsetContour.h	/^    int filterCount[300];$/;"	m	class:ocr::GBitsetContour
filterGilbert	./GBitset/GBitset_algorithm.cpp	/^ void GBitset::filterGilbert(vector<int> &HBuf,$/;"	f	class:GBitset
filterHigh	./OCRAlgorithm/OCRAlgorithm.cpp	/^ void OCRFilter::filterHigh(vector<int> &In, int KHig){$/;"	f	class:ocr::OCRFilter
filterHigh	./OCRAlgorithm/OCRAlgorithm.cpp	/^void OCRFilter::filterHigh(int* In,uint size, int KHig){$/;"	f	class:ocr::OCRFilter
filterHighTest	./GBitset/GBitsetTest.cpp	/^ void GBitset::filterHighTest(vector<int> &In, int KHig){$/;"	f	class:GBitset
filterIndex	./GBitsetContour/GBitsetContour.h	/^    short filterIndex;$/;"	m	class:ocr::GBitsetContour
filterIntegrator	./GBitset/GBitsetTest.cpp	/^ void GBitset::filterIntegrator(vector<int> &In, int KHig){$/;"	f	class:GBitset
filterLaplasian	./OCRAlgorithm/OCRAlgorithm.cpp	/^ void OCRFilter::filterLaplasian( int *Buf1, int *BufTL, int size, int KHig, int KLow ){$/;"	f	class:ocr::OCRFilter
filterLaplasian	./OCRAlgorithm/OCRAlgorithm.cpp	/^ void OCRFilter::filterLaplasian( vector<int> &In, int KHig, int KLow){  \/\/ filterLaplasianM1$/;"	f	class:ocr::OCRFilter
filterLaplasian	./OCRAlgorithm/OCRAlgorithm.cpp	/^ void OCRFilter::filterLaplasian(vector<int> &HBuf,$/;"	f	class:ocr::OCRFilter
filterLaplasianTest	./GBitset/GBitsetTest.cpp	/^ void GBitset::filterLaplasianTest( vector<int> &In, int KHig, int KLow){ \/\/ filterLaplasianTest$/;"	f	class:GBitset
filterScanline	./PNG/lodepng.cpp	/^static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,$/;"	f	file:
filter_method	./PNG/lodepng.h	/^  unsigned filter_method;     \/*filter method of the original file*\/$/;"	m	struct:LodePNGInfo
filter_palette_zero	./PNG/lodepng.h	/^  unsigned filter_palette_zero;$/;"	m	struct:LodePNGEncoderSettings
filter_strategy	./PNG/lodepng.h	/^  LodePNGFilterStrategy filter_strategy;$/;"	m	struct:LodePNGEncoderSettings
find	./GFontEditor/GLetter.cpp	/^int stringOCR::find(const string& match,int position){$/;"	f	class:stringOCR
find	./OCRTypes/OCRTypes.cpp	/^int GString::find(const char *ref) {$/;"	f	class:ocr::GString
find	./OCRTypes/OCRTypes.cpp	/^int GString::find(string &ref) {$/;"	f	class:ocr::GString
findExtremAlpha	./GGraph/GGraphFindExtremPoints.cpp	/^void GGraph::findExtremAlpha(){$/;"	f	class:ocr::GGraph
findExtremAlphaFl	./GGraph/GGraphFindExtremPoints.cpp	/^void GGraph::findExtremAlphaFl(){$/;"	f	class:ocr::GGraph
findExtremPoints	./GGraph/GGraphFindExtremPoints.cpp	/^void GGraph::findExtremPoints() {$/;"	f	class:ocr::GGraph
findStringMatch	./GLogicProcessor/spellChecker.cpp	/^string GLogicProcessor::findStringMatch(const char *strKey, int sL, int offset){$/;"	f	class:GLogicProcessor
flag	./OCRAlgorithm/f2c.h	/^typedef long int flag;$/;"	t
flag	./OCRAlgorithm/f2c.h	/^typedef short flag;$/;"	t
flag	./OCRTypes/OCRTypes.h	/^  int flag;$/;"	m	struct:ocr::dictKeyStruct
flag	./OCRTypes/OCRTypes_www.h	/^		int flag;$/;"	m	struct:ocr::dictKey
flagPSymbols	./GMemory/GMap/GMap.h	/^        size_t flagPSymbols;        \/\/ "1" символы пробела, точки в словаре и тексте удаляются, "0" все остается как есть$/;"	m	class:ocr::GMap
flog2	./PNG/lodepng.cpp	/^static float flog2(float f)$/;"	f	file:
flush	./GMemory/MmapFile.cpp	/^bool MemoryFile::flush()$/;"	f	class:MemoryFile
focalLine	./GBitmap/GBitmapFocalLine.cpp	/^  int  GBitmap::focalLine(int n_RemovLayers) {$/;"	f	class:ocr::GBitmap
focalLine	./GBitsetMatrix/GBitsetMatrix.h	/^  vector<OCRFocalLineBezier>focalLine;  \/\/\/< вестор фокальных линий$/;"	m	class:ocr::GBitsetMatrix
focalLine	./GFontEditor/GLetter.h	/^      focalLine; \/\/\/массив линий соединяющих топологические ключевые точки буквы$/;"	m	class:ocr::GLetter
focalLine	./GGraph/GGraph.h	/^	GStr<OCRLine> focalLine;$/;"	m	class:ocr::GGraph
focalLineAngleM	./GGraphBezier/GGraphFocalLineRecLevelingBezier.cpp	/^    void GGraphBezier::focalLineAngleM(OCRFocalLineBezier &line){$/;"	f	class:ocr::GGraphBezier
focalLineBezierF	./GGraphBezier/GGraphFocalLineBezier.cpp	/^    void GGraphBezier::focalLineBezierF(OCRFocalLineBezier &line){$/;"	f	class:ocr::GGraphBezier
focalLineBezierP	./GGraphBezier/GGraphFocalLineBezier.cpp	/^    void GGraphBezier::focalLineBezierP(OCRFocalLineBezier &line, int strL, int endL){$/;"	f	class:ocr::GGraphBezier
focalLineEnds	./GGraphBezier/GGraphFocalLineRecLevelingBezier.cpp	/^    void GGraphBezier::focalLineEnds(OCRFocalLineBezier &line, int strL, int endL){$/;"	f	class:ocr::GGraphBezier
focalLineExtremLimit	./GGraph/GGraphAlgorithm.cpp	/^bool GGraph::focalLineExtremLimit(OCRLine &line, int index0, int index1){$/;"	f	class:ocr::GGraph
focalLineLengthM	./GGraphBezier/GGraphFocalLineRecLevelingBezier.cpp	/^    void GGraphBezier::focalLineLengthM(OCRFocalLineBezier &line){$/;"	f	class:ocr::GGraphBezier
focalLineLengthMid	./GGraph/GGraphFindExtremPoints.cpp	/^void GGraph::focalLineLengthMid(){$/;"	f	class:ocr::GGraph
focalLineMid	./GGraph/GGraphFindExtremPoints.cpp	/^void GGraph::focalLineMid(){$/;"	f	class:ocr::GGraph
focalLineMiddleA	./GGraphBezier/GGraphFocalLineRecLevelingBezier.cpp	/^    void GGraphBezier::focalLineMiddleA(OCRFocalLineBezier &line, uint K_Mid2){$/;"	f	class:ocr::GGraphBezier
focalLineMiddleB	./GGraphBezier/GGraphFocalLineRecLevelingBezier.cpp	/^    void GGraphBezier::focalLineMiddleB(OCRFocalLineBezier &line, uint K_Mid2){$/;"	f	class:ocr::GGraphBezier
focalLineNorm	./GGraphBezier/GGraphFocalLineRecLevelingBezier.cpp	/^    void GGraphBezier::focalLineNorm( OCRFocalLineBezier &line){$/;"	f	class:ocr::GGraphBezier
focalLineRecAngle	./GGraphBezier/GGraphFocalLineRecognitionBezier.cpp	/^    void GGraphBezier::focalLineRecAngle(vector<OCRPointFloat>&dataVector, GStr<int>*newPoints, uint deltaAngle){$/;"	f	class:ocr::GGraphBezier
focalLineRecCircle2	./GGraphBezier/GGraphFocalLineBezier.cpp	/^    void GGraphBezier::focalLineRecCircle2 (OCRFocalLineBezier &line) {$/;"	f	class:ocr::GGraphBezier
focalLineRecMass	./GGraphBezier/GGraphFocalLineBezier.cpp	/^    void GGraphBezier::focalLineRecMass(OCRFocalLineBezier &line){$/;"	f	class:ocr::GGraphBezier
focalLineRecognition	./GGraph/GGraphFocalLineRecognition.cpp	/^int GGraph::focalLineRecognition() {$/;"	f	class:ocr::GGraph
focalLineRecognition	./GGraphBezier/GGraphFocalLineRecognitionBezier.cpp	/^    int  GGraphBezier::focalLineRecognition(vector<OCRPointFloat>&focalPoint, vector<OCRFocalLineBezier> &focalLine) {$/;"	f	class:ocr::GGraphBezier
focalLineSplit	./GGraphBezier/GGraphFocalLineRecognitionBezier.cpp	/^    void GGraphBezier::focalLineSplit(GStr<int>*newPoints, vector<OCRFocalLineBezier> &focalLine,vector<OCRPointFloat>&focalPoint,OCRFocalLineBezier &lineP){$/;"	f	class:ocr::GGraphBezier
focalLineT	./GBitmap/GBitmapFocalLine.cpp	/^  int  GBitmap::focalLineT(int n_RemovLayers) {$/;"	f	class:ocr::GBitmap
focalLineT1	./GBitmap/GBitmapFocalLine.cpp	/^  int  GBitmap::focalLineT1(int n_RemovLayers) {$/;"	f	class:ocr::GBitmap
focalLineTabM	./GGraphBezier/GGraphFocalLineRecLevelingBezier.cpp	/^    void GGraphBezier::focalLineTabM(OCRFocalLineBezier &line){$/;"	f	class:ocr::GGraphBezier
focalPoint	./GBitsetMatrix/GBitsetMatrix.h	/^  vector<OCRPointFloat>focalPoint;     \/\/\/< вестор фокальных точек$/;"	m	class:ocr::GBitsetMatrix
focalPoint	./GFontEditor/GLetter.h	/^  GStr<OCRPointFloat> *focalPoint; \/\/\/массив топологических ключевых точек буквы$/;"	m	class:ocr::GLetter
focalPoint	./GGraph/GGraph.h	/^	GStr<OCRPoint> focalPoint;$/;"	m	class:ocr::GGraph
focalPointT1	./GGraphBezier/GGraphFocalPointBezier.cpp	/^    int  GGraphBezier::focalPointT1() {$/;"	f	class:ocr::GGraphBezier
focalPointXTL	./GGraph/GGraphFocalPoint.cpp	/^  int  GGraph::focalPointXTL() {$/;"	f	class:ocr::GGraph
focalPointXTL	./GGraphBezier/GGraphFocalPointBezier.cpp	/^    int  GGraphBezier::focalPointXTL(vector<OCRPointFloat>&focalPoint) {$/;"	f	class:ocr::GGraphBezier
folderList	./config.h	/^	std::vector<std::string> folderList;$/;"	m	struct:commandData
folderPath	./OCRString/php2stl.cpp	/^string folderPath(string &path) {$/;"	f
font	./GFontEditor/GFontEditor.h	/^        GFont* font;$/;"	m	class:ocr::GFontEditor
font	./GGraphOCR/GGraphOCR.h	/^	GVector *font;$/;"	m	class:ocr::GGraphOCR
fontBase	./GFontEditor/GFontEditor.h	/^        vector<GFont*> fontBase;$/;"	m	class:ocr::GFontEditor
fontClusterTable	./GGraphOCR/GGraphOCR.h	/^	GVector *fontClusterTable; \/\/\/< таблица базовых кластеров$/;"	m	class:ocr::GGraphOCR
fontEditor	./GMainEditor/GMainEditor.h	/^        GFontEditor *fontEditor;$/;"	m	class:ocr::GMainEditor
fontEditor	./config.h	/^	void *fontEditor;$/;"	m	struct:commandData
fontGMap	./GLogicProcessor/GLogicProcessor.h	/^    GMap *fontGMap;                 \/\/\/main font data map. Builded from fontTable. Keys it is unicode of letters.$/;"	m	class:ocr::GLogicProcessor
fontGMap	./GMemory/GMemory.h	/^	GMap *fontGMap;			 \/\/\/main font data map. Builded from fontTable. Keys it is unicode of letters.$/;"	m	class:ocr::GMemory
fontMap	./GLogicProcessor/GLogicProcessor.h	/^	map<string,map<string,uniRecord> >fontMap;$/;"	m	class:ocr::GLogicProcessor
fontMap	./OCRTypes/OCRTypes.h	/^} fontMap;$/;"	t	namespace:ocr	typeref:struct:ocr::fontOCRMap
fontMap	./OCRTypes/OCRTypes_www.h	/^	}fontMap;$/;"	t	namespace:ocr	typeref:struct:ocr::fontOCRMap
fontMaskGStr	./GGraphOCR/GGraphOCR.h	/^	GStr<OCRMask> fontMaskGStr; \/\/\/< массив масок базовых кластеров,$/;"	m	class:ocr::GGraphOCR
fontMaskTable	./GGraphOCR/GGraphOCR.h	/^	GVector *fontMaskTable; \/\/\/< таблица масок базовых кластеров,$/;"	m	class:ocr::GGraphOCR
fontName	./GFontEditor/GFont.h	/^        string fontName;$/;"	m	class:ocr::GFont
fontName	./OCRTypes/OCRTypes.h	/^  string fontName;$/;"	m	struct:ocr::fontOCRMap
fontName	./OCRTypes/OCRTypes_www.h	/^		string fontName;$/;"	m	struct:ocr::fontOCRMap
fontNameMap	./GLogicProcessor/GLogicProcessor.h	/^	map<string,int>fontNameMap;  \/\/\/<map of tibetan font names $/;"	m	class:ocr::GLogicProcessor
fontNormalisation	./GFontEditor/GFont.cpp	/^    void GFont::fontNormalisation(){$/;"	f	class:ocr::GFont
fontOCRMap	./OCRTypes/OCRTypes.h	/^typedef struct fontOCRMap {$/;"	s	namespace:ocr
fontOCRMap	./OCRTypes/OCRTypes_www.h	/^	typedef struct fontOCRMap{$/;"	s	namespace:ocr
fontPath	./GGraphOCR/GGraphOCR.h	/^	string fontPath;$/;"	m	class:ocr::GGraphOCR
fontRegisterGStr	./GGraphOCR/GGraphOCR.h	/^	GStr<OCRRegister> fontRegisterGStr; \/\/\/< массив кольцевых регистров базовых кластеров$/;"	m	class:ocr::GGraphOCR
fontRegisterTable	./GGraphOCR/GGraphOCR.h	/^	GVector *fontRegisterTable; \/\/\/< таблица кольцевых регистров углов $/;"	m	class:ocr::GGraphOCR
fontSize	./GFontEditor/GLetter.h	/^  int fontSize;$/;"	m	class:ocr::wordOCR
fontStackGMap	./GLogicProcessor/GLogicProcessor.h	/^    GMap *fontStackGMap;            \/\/\/main font data map. Builded from fontTable. Keys it is unicode of letters.$/;"	m	class:ocr::GLogicProcessor
fontStackGMap	./GMemory/GMemory.h	/^	GMap *fontStackGMap;	 \/\/\/main font data map. Builded from fontTable. Keys it is unicode of letters.$/;"	m	class:ocr::GMemory
fontStat	./GFontEditor/GFont.h	/^        map<string,int>fontStat;$/;"	m	class:ocr::GFont
fontStatID	./GFontEditor/GFont.h	/^        map<int,int>fontStatID;$/;"	m	class:ocr::GFont
fontTable	./GLogicProcessor/GLogicProcessor.h	/^    GVector *fontTable;             \/\/\/main font data table. Read from XML LETTERS_GRAMMAR.xml$/;"	m	class:ocr::GLogicProcessor
fontTable	./GMemory/GMemory.h	/^	GVector *fontTable;		 \/\/\/main font data table. Read from XML LETTERS_GRAMMAR.xml$/;"	m	class:ocr::GMemory
for_each	./OCRString/php2stl.cpp	/^    virtual bool for_each(xml_node &n) {$/;"	f	struct:data_traverser
force_palette	./PNG/lodepng.h	/^  unsigned force_palette;$/;"	m	struct:LodePNGEncoderSettings
forkProccesOCR	./GMainEditor/startOCR.cpp	/^void GMainEditor::forkProccesOCR(int pidID,GBitmap *pechaImgID_){$/;"	f	class:GMainEditor
forkProccesOCR_	./GMainEditor/startOCR.cpp	/^bool GMainEditor::forkProccesOCR_(pidID *pidIDArray,int ID, int maxFork){$/;"	f	class:GMainEditor
frameArray	./GBitset/GBitset.h	/^  vector<frameOCR>frameArray;$/;"	m	class:ocr::GBitset
frameArray	./GBitsetMatrix/GBitsetMatrix.h	/^  vector<frameOCR>frameArray;     \/\/\/<массив координат блоков букв в строке$/;"	m	class:ocr::GBitsetMatrix
frameDraw	./GBitset/GBitset_algorithm.cpp	/^void GBitset::frameDraw(int color){$/;"	f	class:GBitset
frameFlag	./GFontEditor/GLetter.h	/^  int frameFlag;$/;"	m	class:ocr::frameOCR
frameOCR	./GFontEditor/GLetter.cpp	/^frameOCR::frameOCR(){}$/;"	f	class:frameOCR
frameOCR	./GFontEditor/GLetter.h	/^class frameOCR {$/;"	c	namespace:ocr
freeLetter	./GGraph/GGraphAlgorithm.cpp	/^void GGraph::freeLetter(OCRLetter &letter) {$/;"	f	class:ocr::GGraph
freeLetter	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::freeLetter(OCRLetter &letter) {$/;"	f	class:ocr::GGraphOCR
freeMemory	./GFontEditor/GFont.cpp	/^    void  GFont::freeMemory(){$/;"	f	class:ocr::GFont
freeTextVectors	./GMemory/GMap/GMap.cpp	/^void GMap::freeTextVectors(){$/;"	f	class:GMap
freelist	./PNG/lodepng.cpp	/^  BPMNode** freelist;$/;"	m	struct:BPMLists	file:
ftnint	./OCRAlgorithm/f2c.h	/^typedef long int ftnint;$/;"	t
ftnint	./OCRAlgorithm/f2c.h	/^typedef short ftnint;$/;"	t
ftnlen	./OCRAlgorithm/f2c.h	/^typedef long int ftnlen;$/;"	t
ftnlen	./OCRAlgorithm/f2c.h	/^typedef short ftnlen;$/;"	t
g	./OCRAlgorithm/f2c.h	/^	integer1 g;$/;"	m	union:Multitype
g_Cpu	./OCRString/cpuTest.cpp	/^static SCpuInfo g_Cpu;$/;"	v	file:
gama_defined	./PNG/lodepng.h	/^  unsigned gama_defined; \/* Whether a gAMA chunk is present (0 = not present, 1 = present). *\/$/;"	m	struct:LodePNGInfo
gama_gamma	./PNG/lodepng.h	/^  unsigned gama_gamma;   \/* Gamma exponent times 100000 *\/$/;"	m	struct:LodePNGInfo
gaussian	./GBitmap/GBitmapFilter.cpp	/^  void  GBitmap::gaussian(int amplitude) {$/;"	f	class:ocr::GBitmap
gaussianF	./GBitmap/GBitmapFilter.cpp	/^  void  GBitmap::gaussianF(int amplitude) {$/;"	f	class:ocr::GBitmap
gaussianT	./GBitmap/GBitmapFilter.cpp	/^  void  GBitmap::gaussianT(int amplitude) {$/;"	f	class:ocr::GBitmap
gcos	./OCRAlgorithm/f2c.h	206;"	d
generateFixedDistanceTree	./PNG/lodepng.cpp	/^static unsigned generateFixedDistanceTree(HuffmanTree* tree)$/;"	f	file:
generateFixedLitLenTree	./PNG/lodepng.cpp	/^static unsigned generateFixedLitLenTree(HuffmanTree* tree)$/;"	f	file:
get	./GBitmap/GBitmap.cpp	/^int GBitmap::get(int x, int y) {$/;"	f	class:ocr::GBitmap
get	./GMemory/GVector.cpp	/^void TString::get(TString *st, uint i) {$/;"	f	class:TString
get	./GMemory/GVector.h	/^T GStr<T>::get(ulong id) {$/;"	f	class:ocr::GStr
getCharVector	./GMemory/GVector.cpp	/^void TString::getCharVector(vector<char> &charVector, uint i) {$/;"	f	class:TString
getHKey	./GMemory/GMap/GMap.cpp	/^ulong GMap::getHKey(string & key,int keyField){$/;"	f	class:GMap
getHKey	./GMemory/GMap/GMap.cpp	/^ulong GMap::getHKey(vector<ulong>&searchResult,string & key,int keyField){$/;"	f	class:GMap
getHKey_	./GMemory/GMap/GMap.cpp	/^ulong GMap::getHKey_(string & key,int keyField){$/;"	f	class:GMap
getHash	./PNG/lodepng.cpp	/^static unsigned getHash(const unsigned char* data, size_t size, size_t pos)$/;"	f	file:
getID	./OCRString/php2stl.cpp	/^unsigned int getID(string data) {  \/\/ extract ID from xml data$/;"	f
getImageFromPDF	./GPDF/drawPDF.h	/^void getImageFromPDF(CGPDFObjectRef obj,const char * key){$/;"	f
getImageRef	./GPDF/CGImageFromPDF.h	/^NSImage *getImageRef(CGPDFStreamRef myStream) {$/;"	f
getInt	./GMemory/GVector.cpp	/^int GVector::getInt(ulong indexRecord) {$/;"	f	class:GVector
getInt	./GMemory/GVector.cpp	/^int TString::getInt(uint i) {$/;"	f	class:TString
getIntVector	./GMemory/GVector.cpp	/^void TString::getIntVector(vector<int> &intVector, uint i) {$/;"	f	class:TString
getKey	./GMemory/GMap/GMap.cpp	/^ulong GMap::getKey(string & key_, int mode){$/;"	f	class:GMap
getKey	./GMemory/GMap/GMap.cpp	/^void GMap::getKey(string &key_, vector<ulong>&searchResult,int mode){$/;"	f	class:GMap
getKeyID	./GMemory/GMap/GMap.cpp	/^void GMap::getKeyID(string &key,vector<pLink>&searchResult){$/;"	f	class:GMap
getKeyStr	./GMemory/GMap/GMap.cpp	/^void GMap::getKeyStr(ulong index,vector<uint>&key){$/;"	f	class:GMap
getLetter	./GFontEditor/GFont.cpp	/^    GLetter*  GFont::getLetter(ulong index){$/;"	f	class:ocr::GFont
getLong	./GMemory/GVector.cpp	/^int TString::getLong(uint i) {$/;"	f	class:TString
getName	./GMemory/GVector.cpp	/^void GVector::getName(string &str) {$/;"	f	class:GVector
getNumColorChannels	./PNG/lodepng.cpp	/^static unsigned getNumColorChannels(LodePNGColorType colortype)$/;"	f	file:
getOCRKey	./GMemory/GMap/GMap.cpp	/^void GMap::getOCRKey(string &key,vector<ulong>&searchResult, int mode){$/;"	f	class:GMap
getOCRLetter	./GFontEditor/GFont.cpp	/^    GLetter*  GFont::getOCRLetter(ulong index){$/;"	f	class:ocr::GFont
getOCRStackKey	./GMemory/GMap/GMap.cpp	/^void GMap::getOCRStackKey(string &key,vector<uint>&letterX_,map<vector<int>,ulong>&searchResult, int mode){$/;"	f	class:GMap
getPaletteTranslucency	./PNG/lodepng.cpp	/^static unsigned getPaletteTranslucency(const unsigned char* palette, size_t palettesize)$/;"	f	file:
getPixelColorRGBA16	./PNG/lodepng.cpp	/^static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,$/;"	f	file:
getPixelColorRGBA8	./PNG/lodepng.cpp	/^static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,$/;"	f	file:
getPixelColorsRGBA8	./PNG/lodepng.cpp	/^static void getPixelColorsRGBA8(unsigned char* buffer, size_t numpixels,$/;"	f	file:
getPtr	./GMemory/GVector.cpp	/^void *GVector::getPtr(ulong indexRecord, ulong &size) {$/;"	f	class:GVector
getPtr	./GMemory/GVector.cpp	/^void TString::getPtr(char **p, uint i, int *size) {$/;"	f	class:TString
getPtr	./GMemory/GVector.h	/^T *GStr<T>::getPtr(ulong indexRecord, ulong size) {$/;"	f	class:ocr::GStr
getStr	./GMemory/GVector.cpp	/^void GVector::getStr(string &str, cstr name) {$/;"	f	class:GVector
getStr	./GMemory/GVector.cpp	/^void GVector::getStr(ulong indexRecord, string &str) {$/;"	f	class:GVector
getStr	./GMemory/GVector.cpp	/^void GVector::getStr(ulong indexRecord, uint **p, uint &size) {$/;"	f	class:GVector
getStr	./GMemory/GVector.cpp	/^void GVector::getStr(ulong indexRecord, vector<uint> &str) {$/;"	f	class:GVector
getStr	./GMemory/GVector.cpp	/^void TString::getStr(char **p, uint i) {$/;"	f	class:TString
getStr	./GMemory/GVector.cpp	/^void TString::getStr(string &str, uint i) {$/;"	f	class:TString
getTStr	./GMemory/GVector.cpp	/^void GVector::getTStr(ulong indexRecord, TString &str) {$/;"	f	class:GVector
getTStrData	./GMemory/GVector.cpp	/^void GVector::getTStrData(ulong indexRecord, TString &str) {$/;"	f	class:GVector
getTextKey	./GMemory/GMap/GMap.cpp	/^void GMap::getTextKey(string &key,vector<dictKey>&searchResult, int mode){$/;"	f	class:GMap
getTreeInflateDynamic	./PNG/lodepng.cpp	/^static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,$/;"	f	file:
getTreeInflateFixed	./PNG/lodepng.cpp	/^static void getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d)$/;"	f	file:
getValueRequiredBits	./PNG/lodepng.cpp	/^static unsigned getValueRequiredBits(unsigned char value)$/;"	f	file:
getVector	./GMemory/GVector.cpp	/^void *GVector::getVector(ulong indexRecord) {$/;"	f	class:GVector
getVectorByName	./GMemory/GVector.cpp	/^void *GVector::getVectorByName(cstr name) {$/;"	f	class:GVector
glyph	./GBitsetOCR/GBitsetOCR.h	/^  GLetter *glyph;$/;"	m	class:ocr::GBitsetOCR
grammarCorrector	./GLogicProcessor/grammarCorrector.cpp	/^void GLogicProcessor::grammarCorrector(string &lineString,$/;"	f	class:GLogicProcessor
grammarCorrector	./GLogicProcessor/grammarCorrector.cpp	/^void GLogicProcessor::grammarCorrector(vector<stringOCR>&strArray,$/;"	f	class:GLogicProcessor
grammarOCR	./GLogicProcessor/grammarOCR.cpp	/^void GLogicProcessor::grammarOCR(vector<OCRMatch>&pageText, string &mainString){$/;"	f	class:GLogicProcessor
grammarPali	./GLogicProcessor/GLogicProcessor.h	/^	vector<string>grammarPali; \/\/\/<common Plai grammar paricles$/;"	m	class:ocr::GLogicProcessor
grammarTib	./GLogicProcessor/GLogicProcessor.h	/^	vector<string>grammarTib; \/\/\/<common tibetan words. It is not used in search$/;"	m	class:ocr::GLogicProcessor
graphConst	./OCRTypes/OCRTypes.h	/^enum graphConst {$/;"	g	namespace:ocr
graphFocalLine	./GGraph/GGraphFocalLine.cpp	/^void  GGraph::graphFocalLine(int n_RemovLayers) {$/;"	f	class:GGraph
graphFocalPoint	./GGraphBezier/GGraphFocalPointBezier.cpp	/^    int  GGraphBezier::graphFocalPoint(vector<OCRPointFloat>&focalPoint) {$/;"	f	class:ocr::GGraphBezier
graphH	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int graphH;$/;"	m	namespace:ocr	file:
graphImg	./GGraph/GGraph.h	/^	uchar *graphImg; \/\/\/<изображение фокальных линий$/;"	m	struct:ocr::OCRLetterStruct
graphW	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int graphW;$/;"	m	namespace:ocr	file:
green	./GBitmap/ppm.h	/^	unsigned char red, green, blue;$/;"	m	struct:__anon1
grm	./OCRTypes/OCRTypes.h	/^  string grm;$/;"	m	struct:ocr::dictKeyStruct
grm	./OCRTypes/OCRTypes_www.h	/^		string grm;$/;"	m	struct:ocr::dictKey
h	./GBitsetContour/GBitsetContour.h	/^	int w,h,a, resX, resY;$/;"	m	class:ocr::GBitsetContour
h	./GFontEditor/GContour.h	/^    int h;$/;"	m	class:ocr::GContour
h	./GFontEditor/GLetter.h	/^  int h;$/;"	m	class:ocr::TsertoOCR
h	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, w, h;$/;"	m	class:ocr::stringOCR
h	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
h	./GGraphOCR/GGraphOCR.h	/^	uchar h;$/;"	m	struct:ClusterMatchStruct
h	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^float h = 0.4;$/;"	m	namespace:ocr	file:
h	./OCRAlgorithm/f2c.h	/^	shortint h;$/;"	m	union:Multitype
h	./OCRTypes/OCRTypes.h	/^  short h;$/;"	m	class:ocr::OCRTextData
h	./OCRTypes/OCRTypes_www.h	/^		short h;$/;"	m	class:ocr::OCRTextData
hFile1	./GLogicProcessor/GLogicProcessor.h	/^	FILE *hFile1,*hFile2,*hFile3,*hFile4;  \/\/\/files of hash table for grammar coreector dictionary. Each chink is 4Gb and base on SSD drive$/;"	m	class:ocr::GLogicProcessor
hFile2	./GLogicProcessor/GLogicProcessor.h	/^	FILE *hFile1,*hFile2,*hFile3,*hFile4;  \/\/\/files of hash table for grammar coreector dictionary. Each chink is 4Gb and base on SSD drive$/;"	m	class:ocr::GLogicProcessor
hFile3	./GLogicProcessor/GLogicProcessor.h	/^	FILE *hFile1,*hFile2,*hFile3,*hFile4;  \/\/\/files of hash table for grammar coreector dictionary. Each chink is 4Gb and base on SSD drive$/;"	m	class:ocr::GLogicProcessor
hFile4	./GLogicProcessor/GLogicProcessor.h	/^	FILE *hFile1,*hFile2,*hFile3,*hFile4;  \/\/\/files of hash table for grammar coreector dictionary. Each chink is 4Gb and base on SSD drive$/;"	m	class:ocr::GLogicProcessor
hL	./GBitsetContour/GBitsetContour.h	/^	short res, xBegin, xEnd, xL,yL,hL, wL, dy_line, y_line, yLine, *ln,*lt;$/;"	m	class:ocr::GBitsetContour
hStrMax	./GBitset/GBitset.h	/^  int hStrMax;     \/\/\/< вычисленное значение максимальной высоты строки на странице$/;"	m	class:ocr::GBitset
hasTail	./GLogicProcessor/grammarCorrector.cpp	/^    bool GLogicProcessor::hasTail(OCRMatch&match){$/;"	f	class:GLogicProcessor
hash	./GGraph/GGraph.h	/^	ushort hash;$/;"	m	struct:ocr::OCRStarStruct
hash	./OCRTypes/OCRTypes.h	/^  unsigned int hash;$/;"	m	struct:ocr::hashRecord_
hash	./OCRTypes/OCRTypes_www.h	/^        unsigned int hash;$/;"	m	struct:ocr::hashRecord_
hashCount	./GMemory/GMap/GMap.h	/^        ulong hashCount;$/;"	m	class:ocr::GMap
hashData	./GMemory/GMap/GMap.h	/^        GVector *hashData;        \/\/двухмерный массив соответствия значения хеш-функции и индексов записей в векторе данных$/;"	m	class:ocr::GMap
hashData0	./GLogicProcessor/GLogicProcessor.h	/^	char *hashData0,*hashData1;  \/\/\/hashed index for all words and phrases (about 600mb) this data it is all adress space of integer. Every integer it is uniq hash of string$/;"	m	class:ocr::GLogicProcessor
hashData1	./GLogicProcessor/GLogicProcessor.h	/^	char *hashData0,*hashData1;  \/\/\/hashed index for all words and phrases (about 600mb) this data it is all adress space of integer. Every integer it is uniq hash of string$/;"	m	class:ocr::GLogicProcessor
hashError	./GMemory/GMap/GMap.h	/^        uint hashError;$/;"	m	class:ocr::GMap
hashLimit	./GMemory/GMap/GMap.h	/^        uint hashLimit;           \/\/величина на которую делится полное значение хеша. Болшее значение делает хеш меньше но с большим колмчеством повторов$/;"	m	class:ocr::GMap
hashMatch	./GLogicProcessor/spellChecker.cpp	/^int GLogicProcessor::hashMatch(string &str){$/;"	f	class:GLogicProcessor
hashRecord	./OCRTypes/OCRTypes.h	/^} hashRecord;$/;"	t	namespace:ocr	typeref:struct:ocr::hashRecord_
hashRecord	./OCRTypes/OCRTypes_www.h	/^	}hashRecord;	$/;"	t	namespace:ocr	typeref:struct:ocr::hashRecord_
hashRecord_	./OCRTypes/OCRTypes.h	/^typedef struct hashRecord_ {$/;"	s	namespace:ocr
hashRecord_	./OCRTypes/OCRTypes_www.h	/^	typedef struct hashRecord_{$/;"	s	namespace:ocr
hashSize	./GLogicProcessor/GLogicProcessor.h	/^	unsigned long hashSize; \/\/size of second level hash index. $/;"	m	class:ocr::GLogicProcessor
hashTable	./GGraph/GGraph.h	/^	ushort *hashTable;		  \/\/\/<таблица упаковки хеша$/;"	m	class:ocr::GGraph
hashTable	./GGraphOCR/GGraphOCR.h	/^	ushort *hashTable;		   \/\/\/< таблица упаковки хеша$/;"	m	class:ocr::GGraphOCR
hashTableOCRStar	./GGraph/GGraph.h	/^	ushort *hashTableOCRStar; \/\/\/<таблица упаковки упорядоченного хеша OCRStar$/;"	m	class:ocr::GGraph
hashTableOCRStar	./GGraphOCR/GGraphOCR.h	/^	ushort *hashTableOCRStar;  \/\/\/< таблица упаковки упорядоченного хеша OCRStar$/;"	m	class:ocr::GGraphOCR
hashTableReady	./GGraph/GGraph.h	/^	char hashTableReady;	  \/\/\/<флаг готовности таблиц хеша$/;"	m	class:ocr::GGraph
hashTableReady	./GGraphOCR/GGraphOCR.h	/^	char hashTableReady;	   \/\/\/< флаг готовности таблиц хеша$/;"	m	class:ocr::GGraphOCR
hashTableStar	./GGraph/GGraph.h	/^	uchar *hashTableStar;	  \/\/\/<таблица упаковки неупорядоченного хеша OCRStar$/;"	m	class:ocr::GGraph
hashTableStar	./GGraphOCR/GGraphOCR.h	/^	uchar *hashTableStar;	   \/\/\/< таблица упаковки неупорядоченного хеша OCRStar$/;"	m	class:ocr::GGraphOCR
hashValue	./GBitMask/algorithmOCR_128.cpp	/^int GBitMask128::hashValue(){$/;"	f	class:GBitMask128
hashVector	./GLogicProcessor/GLogicProcessor.h	/^    hashRecord *hashVector; \/\/\/second level hash index. Every adress in hashRecord it is offset in text buffer.$/;"	m	class:ocr::GLogicProcessor
hash_cleanup	./PNG/lodepng.cpp	/^static void hash_cleanup(Hash* hash)$/;"	f	file:
hash_init	./PNG/lodepng.cpp	/^static unsigned hash_init(Hash* hash, unsigned windowsize)$/;"	f	file:
hash_register128	./GGraph/GGraphSSE.cpp	/^    void GGraph::hash_register128(){$/;"	f	class:ocr::GGraph
hash_register64	./GGraph/GGraphSSE.cpp	/^    void GGraph::hash_register64(){$/;"	f	class:ocr::GGraph
haveTopic	./OCRTypes/OCRTypes.h	/^  int haveTopic;$/;"	m	struct:ocr::sData
haveTopic	./OCRTypes/OCRTypes_www.h	/^        int haveTopic;$/;"	m	struct:ocr::sData
head	./PNG/lodepng.cpp	/^  int* head; \/*hash value to head circular pos - can be outdated if went around window*\/$/;"	m	struct:Hash	file:
headz	./PNG/lodepng.cpp	/^  int* headz; \/*similar to head, but for chainz*\/$/;"	m	struct:Hash	file:
height	./GFontEditor/GContour.h	/^    int height(){return h;}$/;"	f	class:ocr::GContour
hex2char	./OCRString/php2stl.cpp	/^char hex2char(char hex) {$/;"	f
hexCode	./GMainEditor/GMainEditor.h	/^                unsigned char hexCode[18991]; \/\/byte to char string hex code$/;"	m	class:ocr::GMainEditor
hour	./PNG/lodepng.h	/^  unsigned hour;    \/*0-23*\/$/;"	m	struct:LodePNGTime
html	./GFontEditor/GLetter.h	/^  string html;$/;"	m	class:ocr::wordOCR
huffmanDecodeSymbol	./PNG/lodepng.cpp	/^static unsigned huffmanDecodeSymbol(const unsigned char* in, size_t* bp,$/;"	f	file:
i	./GBitsetContour/GBitsetContour.h	/^	int i;$/;"	m	class:ocr::GBitsetContour
i	./GMemory/GMemory.h	/^	int i;			   \/\/index of pointer to index in vIndex or mIndex vector according of indexDataType$/;"	m	class:ocr::indexRecord
i	./OCRAlgorithm/f2c.h	/^	integer i;$/;"	m	union:Multitype
i	./OCRAlgorithm/f2c.h	/^typedef struct { doublereal r, i; } doublecomplex;$/;"	m	struct:__anon4
i	./OCRAlgorithm/f2c.h	/^typedef struct { real r, i; } complex;$/;"	m	struct:__anon3
i	./codeStorage.h	/^int ecode, pksiz, i, rsiz;$/;"	v
iLeft	./GBitsetContour/GBitsetContour.h	/^	int iLeft,iTop;$/;"	m	class:ocr::GBitsetContour
iLeft	./GBitsetOCR/GBitsetOCR.h	/^  int iLeft, iTop, letterWsum, letterHsum,proportion;$/;"	m	class:ocr::GBitsetOCR
iLeft	./GMainEditor/GMainEditor.h	/^        int stringIndex, wordIndex, iLeft,iTop;$/;"	m	class:ocr::GMainEditor
iTop	./GBitsetContour/GBitsetContour.h	/^	int iLeft,iTop;$/;"	m	class:ocr::GBitsetContour
iTop	./GBitsetOCR/GBitsetOCR.h	/^  int iLeft, iTop, letterWsum, letterHsum,proportion;$/;"	m	class:ocr::GBitsetOCR
iTop	./GMainEditor/GMainEditor.h	/^        int stringIndex, wordIndex, iLeft,iTop;$/;"	m	class:ocr::GMainEditor
iccp_defined	./PNG/lodepng.h	/^  unsigned iccp_defined;      \/* Whether an iCCP chunk is present (0 = not present, 1 = present). *\/$/;"	m	struct:LodePNGInfo
iccp_name	./PNG/lodepng.h	/^  char* iccp_name;            \/* Null terminated string with profile name, 1-79 bytes *\/$/;"	m	struct:LodePNGInfo
iccp_profile	./PNG/lodepng.h	/^  unsigned char* iccp_profile;$/;"	m	struct:LodePNGInfo
iccp_profile_size	./PNG/lodepng.h	/^  unsigned iccp_profile_size; \/* The size of iccp_profile in bytes *\/$/;"	m	struct:LodePNGInfo
iciend	./OCRAlgorithm/f2c.h	/^	flag iciend;$/;"	m	struct:__anon6
icierr	./OCRAlgorithm/f2c.h	/^{	flag icierr;$/;"	m	struct:__anon6
icifmt	./OCRAlgorithm/f2c.h	/^	char *icifmt;$/;"	m	struct:__anon6
icilist	./OCRAlgorithm/f2c.h	/^} icilist;$/;"	t	typeref:struct:__anon6
icirlen	./OCRAlgorithm/f2c.h	/^	ftnint icirlen;$/;"	m	struct:__anon6
icirnum	./OCRAlgorithm/f2c.h	/^	ftnint icirnum;$/;"	m	struct:__anon6
iciunit	./OCRAlgorithm/f2c.h	/^	char *iciunit;$/;"	m	struct:__anon6
id	./GBitMask/GBitMask.h	/^		int id;                    \/\/\/< номер маски в букве$/;"	m	class:ocr::GBitMask32
id	./GFontEditor/GLetter.h	/^  int id;$/;"	m	class:ocr::OCRMatch
id	./GFontEditor/GLetter.h	/^  int id;$/;"	m	class:ocr::OCRMatchConst
id	./GFontEditor/GLetter.h	/^  int id;$/;"	m	class:ocr::wordOCR
id	./GFontEditor/GLetter.h	/^  uint id;$/;"	m	struct:ocr::maskData_
id	./GLogicProcessor/dictReportLocal.cpp	/^    vector<uint>id;$/;"	m	struct:textK	file:
id	./OCRTypes/OCRTypes.h	/^  uint id;$/;"	m	struct:ocr::dictKeyStruct
id	./OCRTypes/OCRTypes_www.h	/^		uint id;$/;"	m	struct:ocr::dictKey
idNumber	./GFontEditor/GLetter.h	/^  unsigned int idNumber; \/\/ uniq id number of string$/;"	m	class:ocr::stringOCR
idNumber	./GFontEditor/GLetter.h	/^  unsigned short idNumber; \/\/\/< id number in base$/;"	m	class:ocr::GLetter
idNumber	./config.h	/^	unsigned int idNumber;$/;"	m	struct:commandData
id_data	./GGraph/GGraph.h	/^	ushort *id_data; \/\/\/< массив для поиска id номеров фокальных точек по заданным координатам$/;"	m	class:ocr::GGraph
id_data2	./GGraph/GGraph.h	/^	ushort *id_data2; \/\/\/< уменьшеный массив для поиска id номеров фокальных точек по заданным координатам$/;"	m	class:ocr::GGraph
if_exists_fail_if_not_exists_create	./GMemory/MmapFile.h	/^		if_exists_fail_if_not_exists_create,$/;"	e	enum:MemoryFile::e_open_mode
if_exists_keep_if_dont_exists_create	./GMemory/MmapFile.h	/^		if_exists_keep_if_dont_exists_create,$/;"	e	enum:MemoryFile::e_open_mode
if_exists_keep_if_dont_exists_fail	./GMemory/MmapFile.h	/^		if_exists_keep_if_dont_exists_fail,$/;"	e	enum:MemoryFile::e_open_mode
if_exists_truncate_if_not_exists_create	./GMemory/MmapFile.h	/^		if_exists_truncate_if_not_exists_create,$/;"	e	enum:MemoryFile::e_open_mode
if_exists_truncate_if_not_exists_fail	./GMemory/MmapFile.h	/^		if_exists_truncate_if_not_exists_fail,$/;"	e	enum:MemoryFile::e_open_mode
ignore_adler32	./PNG/lodepng.h	/^  unsigned ignore_adler32; \/*if 1, continue and don't give an error message if the Adler32 checksum is corrupted*\/$/;"	m	struct:LodePNGDecompressSettings
ignore_crc	./PNG/lodepng.h	/^  unsigned ignore_crc; \/*ignore CRC checksums*\/$/;"	m	struct:LodePNGDecoderSettings
ignore_critical	./PNG/lodepng.h	/^  unsigned ignore_critical; \/*ignore unknown critical chunks*\/$/;"	m	struct:LodePNGDecoderSettings
ignore_end	./PNG/lodepng.h	/^  unsigned ignore_end; \/*ignore issues at end of file if possible (missing IEND chunk, too large chunk, ...)*\/$/;"	m	struct:LodePNGDecoderSettings
imageData	./GFontEditor/GFontEditor.h	/^        GVector *imageData;$/;"	m	class:ocr::GFontEditor
imageEditor	./GFontEditor/GFontEditor.h	/^        GImageEditor *imageEditor;$/;"	m	class:ocr::GFontEditor
imageEditor	./GMainEditor/GMainEditor.h	/^        GImageEditor *imageEditor;$/;"	m	class:ocr::GMainEditor
imageEditor	./config.h	/^	void *imageEditor;$/;"	m	struct:commandData
imageFromPage	./GPDF/GPDF.h	/^    GBitmap* imageFromPage(uint pageNum){GBitmap*img=GBitmap::create(); return img;}$/;"	f	class:ocr::GPDF
imagePath	./GPDF/GPDF.h	/^    string imagePath;              \/\/path to folder with PDF content images$/;"	m	class:ocr::GPDF
img	./GFontEditor/GContour.h	/^    GBitmap* img;$/;"	m	class:ocr::GContour
img	./GFontEditor/GLetter.h	/^  GBitmap *img; \/\/\/ bitmap image from origimal text$/;"	m	class:ocr::wordOCR
img	./GFontEditor/GLetter.h	/^  GBitmap *img; \/\/\/ bitmap image of string from origimal text$/;"	m	class:ocr::stringOCR
img	./GGraph/GGraph.h	/^	uchar *img;		 \/\/\/<нормализованное изображение буквы$/;"	m	struct:ocr::OCRLetterStruct
img	./workCode_retreat.h	/^GBitmap *img=GBitmap::create("\/sdcard\/web\/root\/1.png");$/;"	v
img32Union	./GBitmap/GBitmap32.cpp	/^uint GBitmap::img32Union(GBitmap *bImg,OCRBox *s){$/;"	f	class:GBitmap
img32UnionLine	./GBitmap/GBitmap32.cpp	/^uint GBitmap::img32UnionLine(GBitmap *bImg,OCRBox *s){$/;"	f	class:GBitmap
imgFlag	./GFontEditor/GLetter.h	/^  int imgFlag;$/;"	m	class:ocr::stringOCR
imgFlag	./GFontEditor/GLetter.h	/^  int imgFlag;$/;"	m	class:ocr::wordOCR
imgH	./GGraph/GGraph.h	/^	ushort imgH;$/;"	m	struct:ocr::OCRLetterStruct
imgH	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int imgH;$/;"	m	namespace:ocr	file:
imgH	./config.h	/^	int imgW, imgH, argc;$/;"	m	struct:commandData
imgIntegralSum	./GBitmap/GBitmap32.cpp	/^void GBitmap::imgIntegralSum(GBitmap *bImg,vector<uint>&sum,OCRBox *s){$/;"	f	class:GBitmap
imgOn	./GBitMask/GBitMask.h	/^		unsigned int imgOn[128];   \/\/\/< исходная область для получения масок$/;"	m	class:ocr::GBitMask32
imgW	./GBitMask/GBitMask.h	/^		int imgW;                  \/\/\/<габариты выделенного признака по ширине (высота равнна mH)$/;"	m	class:ocr::GBitMask32
imgW	./GGraph/GGraph.h	/^	ushort imgW;$/;"	m	struct:ocr::OCRLetterStruct
imgW	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int imgW;$/;"	m	namespace:ocr	file:
imgW	./config.h	/^	int imgW, imgH, argc;$/;"	m	struct:commandData
imgX0	./GBitmap/GBitmap.h	/^	unsigned int imgX0, imgX1, imgY0, imgY1; \/\/габариты изображения$/;"	m	class:ocr::GBitmap
imgX1	./GBitmap/GBitmap.h	/^	unsigned int imgX0, imgX1, imgY0, imgY1; \/\/габариты изображения$/;"	m	class:ocr::GBitmap
imgY0	./GBitmap/GBitmap.h	/^	unsigned int imgX0, imgX1, imgY0, imgY1; \/\/габариты изображения$/;"	m	class:ocr::GBitmap
imgY1	./GBitmap/GBitmap.h	/^	unsigned int imgX0, imgX1, imgY0, imgY1; \/\/габариты изображения$/;"	m	class:ocr::GBitmap
impFilter	./GBitsetContour/impulseFilterFunction.cpp	/^int impFilter(std::string *srcStr, char *aFt, short angLen){$/;"	f
impFilter2	./GBitsetContour/impulseFilter7.cpp	/^int GBitsetContour::impFilter2(char *filterStr, char *aFt, short angLen){$/;"	f	class:GBitsetContour
impFilter3	./GBitsetContour/impulseFilter7.cpp	/^int GBitsetContour::impFilter3(char *filterStr, char *aFt, short angLen){$/;"	f	class:GBitsetContour
impFilter4	./GBitsetContour/impulseFilter7.cpp	/^int GBitsetContour::impFilter4(char *filterStr, char *aFt, short angLen){$/;"	f	class:GBitsetContour
impFilter5	./GBitsetContour/impulseFilter7.cpp	/^int GBitsetContour::impFilter5(char *filterStr, char *aFt, short angLen){$/;"	f	class:GBitsetContour
impFilter6	./GBitsetContour/impulseFilter7.cpp	/^int GBitsetContour::impFilter6(char *filterStr, char *aFt, short angLen){$/;"	f	class:GBitsetContour
impFilter7	./GBitsetContour/impulseFilter7.cpp	/^int GBitsetContour::impFilter7(char *filterStr, char *aFt, short angLen){$/;"	f	class:GBitsetContour
implode	./OCRString/php2stl.cpp	/^string implode(const string &delimiter, const vector<string> &input) {$/;"	f
implode	./OCRString/php2stl.cpp	/^string implode(const string &delimiter, list<string> &input) {$/;"	f
implode	./OCRString/php2stl.cpp	/^string implode(cstr delimiter, const vector<string> &input) {$/;"	f
implode	./OCRString/php2stl.cpp	/^string implode(cstr delimiter, list<string> &input) {$/;"	f
implodeOCR	./GLogicProcessor/grammarCorrector.cpp	/^string GLogicProcessor::implodeOCR(const string &delimiter, const vector<wordOCR> &input) {$/;"	f	class:GLogicProcessor
implodeW	./OCRString/php2stl.cpp	/^wstring implodeW(const wstring &delimiter, const vector<wstring> &input) {$/;"	f
import	./GMemory/GVector.cpp	/^void GVector::import(string &path, int mode) {$/;"	f	class:GVector
importDict	./GMemory/GVector.cpp	/^void GVector::importDict(map<string, ulong> keyMap, string &path, string &path1) {$/;"	f	class:GVector
importDictTab	./GMemory/loadDB.cpp	/^void GMemory::importDictTab(string &name, string &path, string &category, int year) {$/;"	f	class:GMemory
importGFontsDB	./GFontEditor/GFontEditor.cpp	/^string GFontEditor::importGFontsDB(string &path){$/;"	f	class:GFontEditor
importLetter	./GFontEditor/GFontEditor.cpp	/^void GFontEditor::importLetter(GLetter *letter){$/;"	f	class:GFontEditor
importOCR	./GMemory/loadDB.cpp	/^void GMemory::importOCR(string &name, string &path, string &delimeter) {$/;"	f	class:GMemory
importOCRLetters	./GFontEditor/GFontEditor.cpp	/^void GFontEditor::importOCRLetters(){$/;"	f	class:GFontEditor
importTAB	./GMemory/GVector.cpp	/^void GVector::importTAB(string &path) {$/;"	f	class:GVector
importTXT	./GMemory/GVector.cpp	/^void GVector::importTXT(string &path) {$/;"	f	class:GVector
importTable	./GMemory/loadDB.cpp	/^void GMemory::importTable(string &name, string &path) {$/;"	f	class:GMemory
importText	./GMemory/loadDB.cpp	/^void GMemory::importText(string &name, string &path, int index) {$/;"	f	class:GMemory
importTextFolder	./GMemory/loadDB.cpp	/^void GMemory::importTextFolder(string &name, string &path, string &category) {$/;"	f	class:GMemory
importXML	./GMemory/GVector.cpp	/^void GVector::importXML(string &path) {$/;"	f	class:GVector
impulseFilter	./GBitsetContour/impulseFilter.cpp	/^void GBitsetContour::impulseFilter(char* angFilter){$/;"	f	class:GBitsetContour
inBit	./GBitsetContour/GBitsetContour.h	/^	bool inBit[10];$/;"	m	class:ocr::GBitsetContour
inTopic	./OCRTypes/OCRTypes.h	/^  int inTopic;$/;"	m	struct:ocr::sData
inTopic	./OCRTypes/OCRTypes_www.h	/^        int inTopic;$/;"	m	struct:ocr::sData
in_use	./PNG/lodepng.cpp	/^  int in_use;$/;"	m	struct:BPMNode	file:
inacc	./OCRAlgorithm/f2c.h	/^	char	*inacc;$/;"	m	struct:__anon10
inacclen	./OCRAlgorithm/f2c.h	/^	ftnlen	inacclen;$/;"	m	struct:__anon10
inblank	./OCRAlgorithm/f2c.h	/^	char	*inblank;$/;"	m	struct:__anon10
inblanklen	./OCRAlgorithm/f2c.h	/^	ftnlen	inblanklen;$/;"	m	struct:__anon10
index	./GGraph/GGraph.h	/^	uint   index;       \/\/\/< ID номер OCRCluster$/;"	m	struct:ocr::OCRClusterStruct
index	./GGraph/GGraph.h	/^	uint index;		 \/\/\/< id number в векторе focalLine$/;"	m	struct:ocr::OCRLineStruct
index	./GGraph/GGraph.h	/^	uint index; \/\/\/< ID номер звездочки$/;"	m	struct:ocr::OCRStarStruct
index	./GGraphBezier/GGraphBezier.h	/^        int index;          \/\/ id number$/;"	m	class:ocr::OCRFocalLineBezier
index	./GGraphBezier/GGraphBezier.h	/^        int index;$/;"	m	class:ocr::OCRLineRef
index	./GMemory/GMap/GMap.h	/^    uint index;$/;"	m	struct:pageLink
index	./GMemory/GMap/GMap.h	/^    uint index;$/;"	m	struct:pageRecordLink
index	./GMemory/GMemory.h	/^	vector<indexRecord> index;$/;"	m	class:ocr::tableRecord
index	./GMemory/GVector.h	/^    uint *index;  \/\/указатель на индекс начальных позиций строк$/;"	m	class:ocr::TString
index	./GMemory/GVector.h	/^    uint *index;$/;"	m	class:ocr::GStr2D
index	./GMemory/GVector.h	/^    ulong *index;$/;"	m	class:ocr::GVector
index	./PNG/lodepng.cpp	/^  int index; \/*the payload. Only has a meaningful value if this is in the last level*\/$/;"	m	struct:ColorTree	file:
index	./PNG/lodepng.cpp	/^  unsigned index; \/*index of this leaf node (called "count" in the paper)*\/$/;"	m	struct:BPMNode	file:
indexById	./GLogicProcessor/grammarCorrector.cpp	/^int GLogicProcessor::indexById(vector<stringOCR> &correctionTable, unsigned int in) {$/;"	f	class:GLogicProcessor
indexDataType	./GMemory/GMemory.h	/^	int indexDataType; \/\/type of the index data (GMap or GVector)$/;"	m	class:ocr::indexRecord
indexFilter	./GBitsetContour/GBitsetContour.h	/^	short max_down, startLetter, startLine, contourCount, contourIndex, indexFilter;$/;"	m	class:ocr::GBitsetContour
indexLetter	./GBitsetOCR/textOCR_.h	/^int indexLetter=-1;$/;"	v
indexMaxW	./GBitsetOCR/textOCR_.h	/^int ln=matchLine.size(); int maxW=0, indexMaxW;$/;"	v
indexOffset	./GMemory/GVector.h	/^           indexOffset;  \/\/адрес размещения массива индекса записей. отсчитывается от начала файла$/;"	m	class:ocr::GVector
indexRecord	./GMemory/GMemory.cpp	/^indexRecord::indexRecord()$/;"	f	class:ocr::indexRecord
indexRecord	./GMemory/GMemory.h	/^class indexRecord$/;"	c	namespace:ocr
indexStr	./GMemory/GVector.h	/^    vector<uint> indexStr;$/;"	m	class:ocr::TString
indexType	./GMemory/GMemory.h	/^	int indexType;	 \/\/search type in index (b-tree in sorted vector, hash, associative full-text search, OCR and all another)$/;"	m	class:ocr::indexRecord
indir	./OCRAlgorithm/f2c.h	/^	char 	*indir;$/;"	m	struct:__anon10
indirlen	./OCRAlgorithm/f2c.h	/^	ftnlen	indirlen;$/;"	m	struct:__anon10
inerr	./OCRAlgorithm/f2c.h	/^{	flag inerr;$/;"	m	struct:__anon10
inex	./OCRAlgorithm/f2c.h	/^	ftnint	*inex;	\/*parameters in standard's order*\/$/;"	m	struct:__anon10
infile	./OCRAlgorithm/f2c.h	/^	char *infile;$/;"	m	struct:__anon10
infilen	./OCRAlgorithm/f2c.h	/^	ftnlen infilen;$/;"	m	struct:__anon10
inflate	./PNG/lodepng.cpp	/^static unsigned inflate(unsigned char** out, size_t* outsize,$/;"	f	file:
inflateHuffmanBlock	./PNG/lodepng.cpp	/^static unsigned inflateHuffmanBlock(ucvector* out, const unsigned char* in, size_t* bp,$/;"	f	file:
inflateNoCompression	./PNG/lodepng.cpp	/^static unsigned inflateNoCompression(ucvector* out, const unsigned char* in, size_t* bp, size_t* pos, size_t inlength)$/;"	f	file:
infmt	./OCRAlgorithm/f2c.h	/^	char	*infmt;$/;"	m	struct:__anon10
infmtlen	./OCRAlgorithm/f2c.h	/^	ftnlen	infmtlen;$/;"	m	struct:__anon10
info_png	./PNG/lodepng.h	/^  LodePNGInfo info_png; \/*info of the PNG image obtained after decoding*\/$/;"	m	struct:LodePNGState
info_raw	./PNG/lodepng.h	/^  LodePNGColorMode info_raw; \/*specifies the format in which you would like to get the raw pixel buffer*\/$/;"	m	struct:LodePNGState
inform	./OCRAlgorithm/f2c.h	/^	char	*inform;$/;"	m	struct:__anon10
informlen	./OCRAlgorithm/f2c.h	/^	ftnint	informlen;$/;"	m	struct:__anon10
init	./GBitmap/GBitmap.cpp	/^void GBitmap::init(const GBitmap *ref) {$/;"	f	class:ocr::GBitmap
init	./GBitmap/GBitmap.cpp	/^void GBitmap::init(const GBitmap *ref, float scale, float rotation, int mode) {$/;"	f	class:ocr::GBitmap
init	./GBitmap/GBitmap.cpp	/^void GBitmap::init(int acolumns, int arows, int mode) {$/;"	f	class:ocr::GBitmap
init	./GBitset/GBitset_base.cpp	/^GBitset::init(const GBitset *ref, int aborder)$/;"	f	class:GBitset
init	./GBitset/GBitset_base.cpp	/^GBitset::init(int arows, int acolumns, int aborder)$/;"	f	class:GBitset
init	./GBitset/GBitset_level.cpp	/^void GBitset::init(const GBitmap *ref, short stepW, short stepH, short flipV){$/;"	f	class:GBitset
init	./GBitsetContour/GBitsetContour.cpp	/^GBitsetContour::init(int acolumns, int arows)$/;"	f	class:GBitsetContour
init	./GBitsetContour/GBitsetContour.cpp	/^void GBitsetContour::init(const GBitsetContour *ref)$/;"	f	class:GBitsetContour
init	./GBitsetContour/GBitsetContourLevel.cpp	/^GBitsetContour::init(const GBitmap *ref, short stepW, short stepH, short flipV)$/;"	f	class:GBitsetContour
init	./GBitsetMatrix/GBitsetMatrix_base.cpp	/^GBitsetMatrix::init(const GBitsetMatrix *ref, int aborder)$/;"	f	class:GBitsetMatrix
init	./GBitsetMatrix/GBitsetMatrix_base.cpp	/^GBitsetMatrix::init(int arows, int acolumns, int aborder)$/;"	f	class:GBitsetMatrix
init	./GBitsetMatrix/GBitsetMatrix_level.cpp	/^GBitsetMatrix::init(const GBitmap *ref, short stepW, short stepH, short flipV)$/;"	f	class:GBitsetMatrix
init	./GBitsetMatrix/GBitsetMatrix_level.cpp	/^void GBitsetMatrix::init(const GBitmap *ref,$/;"	f	class:GBitsetMatrix
init	./GBitsetOCR/GBitset_baseOCR.cpp	/^GBitsetOCR::init(const GBitmap *ref, short stepW, short stepH){$/;"	f	class:GBitsetOCR
init	./GBitsetOCR/GBitset_baseOCR.cpp	/^GBitsetOCR::init(const GBitsetOCR *ref, int aborder)$/;"	f	class:GBitsetOCR
init	./GBitsetOCR/GBitset_baseOCR.cpp	/^GBitsetOCR::init(int arows, int acolumns, int aborder)$/;"	f	class:GBitsetOCR
init	./GFontEditor/GContour.cpp	/^void GContour::init(int *angX,int *angY,int *andData,int length_,int dir){$/;"	f	class:ocr::GContour
init	./GFontEditor/GContour.cpp	/^void GContour::init(int length_,int dir){$/;"	f	class:ocr::GContour
init	./GGraph/GGraph.cpp	/^void GGraph::init(int acolumns, int arows, int mode) {$/;"	f	class:ocr::GGraph
init	./GLogicProcessor/GLogicProcessor.cpp	/^    void GLogicProcessor::init(){$/;"	f	class:ocr::GLogicProcessor
init	./GMainEditor/GMainEditor.cpp	/^	GMainEditor::init(){$/;"	f	class:ocr::GMainEditor
init	./GMemory/GMap/GMap.cpp	/^void GMap::init(string &path){$/;"	f	class:GMap
init	./GMemory/GMap/GMap.cpp	/^void GMap::init(string &path, GVector *data){$/;"	f	class:GMap
init	./GMemory/GMap/GMap.cpp	/^void GMap::init(string &path, GVector *dataText,GStr<mSIZE> *dataDict){$/;"	f	class:GMap
init	./GMemory/GMemory.cpp	/^void GMemory::init()$/;"	f	class:ocr::GMemory
init	./GMemory/GVector.cpp	/^void GVector::GVector::init() {$/;"	f	class:GVector::GVector
init	./GMemory/GVector.cpp	/^void GVector::GVector::init(GVector *ref) {$/;"	f	class:GVector::GVector
init	./GMemory/GVector.cpp	/^void GVector::GVector::init(char *data_, int mode) {$/;"	f	class:GVector::GVector
init	./GMemory/GVector.cpp	/^void GVector::init(GVector *parentVector, cstr name) {$/;"	f	class:GVector
init	./GMemory/GVector.cpp	/^void GVector::init(string &path) {$/;"	f	class:GVector
init	./GMemory/GVector.h	/^void GStr2D<T>::GStr2D::init() {$/;"	f	class:ocr::GStr2D::GStr2D
init	./GMemory/GVector.h	/^void GStr<T>::GStr::init() {$/;"	f	class:ocr::GStr::GStr
init	./GMemory/GVector.h	/^void GStr<T>::GStr::init(int sizePool) {$/;"	f	class:ocr::GStr::GStr
init	./GMemory/GVector.h	/^void GStr<T>::init(GVector *parentVector, cstr name) {$/;"	f	class:ocr::GStr
init	./GMemory/GVector.h	/^void GStr<T>::init(cstr path) {$/;"	f	class:ocr::GStr
init	./config.h	/^	int init;$/;"	m	struct:commandData
initData	./GGraph/GGraph.cpp	/^void GGraph::initData(){$/;"	f	class:ocr::GGraph
initHashTable	./GGraphOCR/GGraphOCR.cpp	/^void GGraphOCR::initHashTable(GGraph &graph) {$/;"	f	class:ocr::GGraphOCR
initID	./GGraph/GGraphFocalLineRecognition.cpp	/^void GGraph::initID() {$/;"	f	class:ocr::GGraph
initID2_flag	./GGraph/GGraph.h	/^	int initID2_flag; \/\/\/< флаг инициализации массива id_data2$/;"	m	class:ocr::GGraph
initID_flag	./GGraph/GGraph.h	/^	int initID_flag; \/\/\/< флаг инициализации массива id_data$/;"	m	class:ocr::GGraph
initImage	./GBitmap/GBitmap.cpp	/^void GBitmap::initImage(const char *path) {$/;"	f	class:ocr::GBitmap
initLevel	./GBitset/GBitset_level.cpp	/^GBitset::initLevel(const GBitmap *ref) {$/;"	f	class:GBitset
initLine_flag	./GGraph/GGraph.h	/^	int initLine_flag;	\/\/\/< флаг инициализации массива line_data$/;"	m	class:ocr::GGraph
initLine_flag	./GGraph/GGraph.h	/^	uchar initLine_flag; \/\/\/< флаг инициализации line_data$/;"	m	struct:ocr::OCRLetterStruct
initPNG	./GBitmap/GBitmap.cpp	/^void GBitmap::initPNG(const char *inputData) {$/;"	f	class:ocr::GBitmap
initPNGData	./GBitmap/GBitmap.cpp	/^void GBitmap::initPNGData(unsigned char *dataPNG, uint size) {$/;"	f	class:ocr::GBitmap
initRegion	./GBitmap/GBitmap.cpp	/^void GBitmap::initRegion(const GBitmap *ref, int x0, int y0, int w, int h) {$/;"	f	class:ocr::GBitmap
initStarArray	./GGraph/GGraphFocalLineRecognition.cpp	/^void GGraph::initStarArray() {$/;"	f	class:ocr::GGraph
initVariables	./GMemory/GMap/GMap.cpp	/^void GMap::initVariables(){$/;"	f	class:GMap
inlist	./OCRAlgorithm/f2c.h	/^} inlist;$/;"	t	typeref:struct:__anon10
inname	./OCRAlgorithm/f2c.h	/^	char	*inname;$/;"	m	struct:__anon10
innamed	./OCRAlgorithm/f2c.h	/^	ftnint	*innamed;$/;"	m	struct:__anon10
innamlen	./OCRAlgorithm/f2c.h	/^	ftnlen	innamlen;$/;"	m	struct:__anon10
innerData	./GMemory/GMap/GMap.h	/^        GVector *innerData;       \/\/контейнер сохраняемых значений внутренних переменных и всех внутренних данных$/;"	m	class:ocr::GMap
innerData	./GMemory/GVector.h	/^    ulong   *innerData;  \/\/массив размещенный в начале файла, в который записываются внутренние$/;"	m	class:ocr::GStr
innerData	./GMemory/GVector.h	/^    ulong *innerData;  \/\/массив размещенный в начале файла, в который записываются внутренние$/;"	m	class:ocr::GVector
innrec	./OCRAlgorithm/f2c.h	/^	ftnint	*innrec;$/;"	m	struct:__anon10
innum	./OCRAlgorithm/f2c.h	/^	ftnint	*innum;$/;"	m	struct:__anon10
inopen	./OCRAlgorithm/f2c.h	/^	ftnint	*inopen;$/;"	m	struct:__anon10
inputBitmap	./GBitsetOCR/GBitsetOCR.h	/^  const GBitmap  *inputBitmap, *GFontImg;               \/\/actual bitmap pointer for input data$/;"	m	class:ocr::GBitsetOCR
inputVect	./GLogicProcessor/GLogicProcessor.h	/^	vector<string>inputVect;$/;"	m	class:ocr::GLogicProcessor
inrecl	./OCRAlgorithm/f2c.h	/^	ftnint	*inrecl;$/;"	m	struct:__anon10
inseq	./OCRAlgorithm/f2c.h	/^	char	*inseq;$/;"	m	struct:__anon10
inseqlen	./OCRAlgorithm/f2c.h	/^	ftnlen	inseqlen;$/;"	m	struct:__anon10
insert	./GFontEditor/GLetter.cpp	/^void stringOCR::insert(int index, wordOCR &word){$/;"	f	class:stringOCR
int16	./OCRTypes/OCRTypes.h	/^typedef short int16;$/;"	t	namespace:ocr
int16	./OCRTypes/OCRTypes_www.h	/^    typedef short               int16;$/;"	t	namespace:ocr
int32	./OCRTypes/OCRTypes.h	/^typedef int int32;$/;"	t	namespace:ocr
int32	./OCRTypes/OCRTypes_www.h	/^    typedef int                 int32;$/;"	t	namespace:ocr
int64	./OCRTypes/OCRTypes.h	/^typedef long long int64;$/;"	t	namespace:ocr
int64	./OCRTypes/OCRTypes_www.h	/^    typedef long long           int64;$/;"	t	namespace:ocr
int8	./OCRTypes/OCRTypes.h	/^typedef char int8;$/;"	t	namespace:ocr
int8	./OCRTypes/OCRTypes_www.h	/^    typedef char                int8;$/;"	t	namespace:ocr
intArea	./OCRAlgorithm/OCRAlgorithm.cpp	/^    void  intArea(OCRBox &a, OCRBox &b,OCRBox &dataBox){$/;"	f	namespace:ocr
intToHex	./OCRString/php2stl.cpp	/^string intToHex(int input) {$/;"	f
integer	./OCRAlgorithm/f2c.h	/^typedef long int integer;$/;"	t
integer1	./OCRAlgorithm/f2c.h	/^typedef char integer1;$/;"	t
interlace_method	./PNG/lodepng.h	/^  unsigned interlace_method;  \/*interlace method of the original file: 0=none, 1=Adam7*\/$/;"	m	struct:LodePNGInfo
intersectionArea	./GLogicProcessor/intersectionArea.cpp	/^int  GLogicProcessor::intersectionArea(OCRBox *s, GBitmap *lineImg32,GBitmap *letterAImg,GBitmap *letterBImg){$/;"	f	class:GLogicProcessor
inunf	./OCRAlgorithm/f2c.h	/^	char	*inunf;$/;"	m	struct:__anon10
inunflen	./OCRAlgorithm/f2c.h	/^	ftnlen	inunflen;$/;"	m	struct:__anon10
inunit	./OCRAlgorithm/f2c.h	/^	ftnint inunit;$/;"	m	struct:__anon10
invert	./GBitmap/GBitmap.cpp	/^void GBitmap::invert() {$/;"	f	class:ocr::GBitmap
isDelimeter	./GLogicProcessor/UniToYagpo.cpp	/^bool GLogicProcessor::isDelimeter(string &str){$/;"	f	class:GLogicProcessor
isGreyICCProfile	./PNG/lodepng.cpp	/^static unsigned isGreyICCProfile(const unsigned char* profile, unsigned size)$/;"	f	file:
isNearP	./OCRAlgorithm/OCRAlgorithm.cpp	/^bool isNearP(OCRPointFloat p1, OCRPointFloat p2, int d){$/;"	f	namespace:ocr
isPali	./OCRString/php2stl.cpp	/^bool isPali(string &key_) {  \/\/определает является ли строка строкой языка Пали (результат основан на употреблении букв ITRANS)$/;"	f
isRGBICCProfile	./PNG/lodepng.cpp	/^static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size)$/;"	f	file:
isRegExp	./OCRString/php2stl.cpp	/^bool isRegExp(string &src) {$/;"	f
isTibDigit	./GLogicProcessor/grammarCorrector.cpp	/^    bool GLogicProcessor::isTibDigit(string &name) {$/;"	f	class:GLogicProcessor
is_dir	./OCRString/php2stl.cpp	/^bool is_dir(cstr path) {$/;"	f
is_dir	./OCRString/php2stl.cpp	/^bool is_dir(string &path) {$/;"	f
is_file	./OCRString/php2stl.cpp	/^bool is_file(cstr path) {$/;"	f
is_file	./OCRString/php2stl.cpp	/^bool is_file(string &path) {$/;"	f
itext_keys	./PNG/lodepng.h	/^  char** itext_keys; \/*the English keyword of the text chunk (e.g. "Comment")*\/$/;"	m	struct:LodePNGInfo
itext_langtags	./PNG/lodepng.h	/^  char** itext_langtags; \/*language tag for this text's language, ISO\/IEC 646 string, e.g. ISO 639 language tag*\/$/;"	m	struct:LodePNGInfo
itext_num	./PNG/lodepng.h	/^  size_t itext_num; \/*the amount of international texts in this PNG*\/$/;"	m	struct:LodePNGInfo
itext_strings	./PNG/lodepng.h	/^  char** itext_strings; \/*the actual international text - UTF-8 string*\/$/;"	m	struct:LodePNGInfo
itext_transkeys	./PNG/lodepng.h	/^  char** itext_transkeys; \/*keyword translated to the international language - UTF-8 string*\/$/;"	m	struct:LodePNGInfo
itoa	./OCRString/php2stl.cpp	/^char *itoa(unsigned int value, char *result, int base) {$/;"	f
itoa64	./OCRString/php2stl.cpp	/^char *itoa64(long long value, char *result, int base) {$/;"	f
itoaSTL	./OCRString/php2stl.cpp	/^string itoaSTL(long long value, int base) {$/;"	f
join	./OCRString/php2stl.cpp	/^void join(vector<string>&v,cstr delimeter,string &result){$/;"	f
k	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^float k;$/;"	m	namespace:ocr	file:
k1	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^float k1;$/;"	m	namespace:ocr	file:
kShapeCassidy	./OCRTypes/OCRTypes.h	/^const short kShapeCassidy = 10;$/;"	m	namespace:ocr
kShapeCassidy	./OCRTypes/OCRTypes_www.h	/^	const short kShapeCassidy=10;$/;"	m	namespace:ocr
key	./GFontEditor/GLetter.h	/^  keyOCR *key; \/\/\/указатель на массив ближайших по корреляции букв$/;"	m	class:ocr::GLetter
key	./GLogicProcessor/dictReportLocal.cpp	/^    string key;$/;"	m	struct:textK	file:
key	./OCRTypes/OCRTypes.h	/^  map<string, dictKey> key;$/;"	m	class:ocr::OCRDictRecord
key	./OCRTypes/OCRTypes.h	/^  map<string, string> key;   \/\/ main map for store all string value$/;"	m	struct:ocr::uniLetterRecord
key	./OCRTypes/OCRTypes.h	/^  string key;$/;"	m	struct:ocr::dictKeyStruct
key	./OCRTypes/OCRTypes_www.h	/^		map<string,dictKey>key;$/;"	m	class:ocr::OCRDictRecord
key	./OCRTypes/OCRTypes_www.h	/^		map<string,string> key; \/\/main map for store all string value$/;"	m	struct:ocr::uniLetterRecord
key	./OCRTypes/OCRTypes_www.h	/^		string key;$/;"	m	struct:ocr::dictKey
key	./PNG/lodepng.h	/^  unsigned key; \/*image is not opaque and color key is possible instead of full alpha*\/$/;"	m	struct:LodePNGColorProfile
keyCount_	./GFontEditor/GLetter.h	/^  uint keyCount_;$/;"	m	class:ocr::GLetter
keyOCR	./GFontEditor/GLetter.h	/^struct keyOCR {$/;"	s	namespace:ocr
keyOCRVector	./GFontEditor/GLetter.h	/^  GStr<keyOCR> *keyOCRVector; \/\/\/массив ближайших по корреляции букв$/;"	m	class:ocr::GLetter
keyPtr	./OCRTypes/OCRTypes.h	/^  char *keyPtr;$/;"	m	struct:ocr::stringEntry_
keyPtr	./OCRTypes/OCRTypes_www.h	/^		char *keyPtr;$/;"	m	struct:ocr::stringEntry_
keySize	./OCRTypes/OCRTypes.h	/^  int keySize;$/;"	m	struct:ocr::stringEntry_
keySize	./OCRTypes/OCRTypes_www.h	/^		int  keySize;$/;"	m	struct:ocr::stringEntry_
keyUTF	./OCRTypes/OCRTypes.h	/^  string keyUTF;             \/\/ letter in TibetanUni in UTF$/;"	m	struct:ocr::uniLetterRecord
keyUTF	./OCRTypes/OCRTypes_www.h	/^		string keyUTF;  \/\/letter in TibetanUni in UTF$/;"	m	struct:ocr::uniLetterRecord
key_b	./PNG/lodepng.h	/^  unsigned key_b;       \/*blue component of color key*\/$/;"	m	struct:LodePNGColorMode
key_b	./PNG/lodepng.h	/^  unsigned short key_b;$/;"	m	struct:LodePNGColorProfile
key_defined	./PNG/lodepng.h	/^  unsigned key_defined; \/*is a transparent color key given? 0 = false, 1 = true*\/$/;"	m	struct:LodePNGColorMode
key_g	./PNG/lodepng.h	/^  unsigned key_g;       \/*green component of color key*\/$/;"	m	struct:LodePNGColorMode
key_g	./PNG/lodepng.h	/^  unsigned short key_g;$/;"	m	struct:LodePNGColorProfile
key_r	./PNG/lodepng.h	/^  unsigned key_r;       \/*red\/greyscale component of color key*\/$/;"	m	struct:LodePNGColorMode
key_r	./PNG/lodepng.h	/^  unsigned short key_r; \/*key values, always as 16-bit, in 8-bit case the byte is duplicated, e.g. 65535 means 255*\/$/;"	m	struct:LodePNGColorProfile
lang	./OCRTypes/OCRTypes.h	/^  string lang;$/;"	m	struct:ocr::uniLetterRecord
lang	./OCRTypes/OCRTypes_www.h	/^		string lang;$/;"	m	struct:ocr::uniLetterRecord
langFlag	./GFontEditor/GLetter.h	/^  int langFlag;$/;"	m	class:ocr::blockOCR
lastOf	./OCRString/php2stl.cpp	/^string lastOf(string &name) {$/;"	f
lazymatching	./PNG/lodepng.h	/^  unsigned lazymatching; \/*use lazy matching: better compression but a bit slower. Default: true*\/$/;"	m	struct:LodePNGCompressSettings
lbase	./OCRTypes/OCRTypes.h	/^  vector<short> lbase;      \/\/ valid (2)letters$/;"	m	struct:ocr::rootLetterOCRStruct
lbase	./OCRTypes/OCRTypes_www.h	/^		vector<short> lbase;  \/\/valid (2)letters$/;"	m	struct:ocr::rootLetterOCRStruct
lbase1	./OCRTypes/OCRTypes.h	/^  vector<short> lbase1;     \/\/ valid (3)letters$/;"	m	struct:ocr::rootLetterOCRStruct
lbase1	./OCRTypes/OCRTypes_www.h	/^		vector<short> lbase1;  \/\/valid (3)letters$/;"	m	struct:ocr::rootLetterOCRStruct
lbase2	./OCRTypes/OCRTypes.h	/^  vector<short> lbase2;     \/\/ valid (4)letters$/;"	m	struct:ocr::rootLetterOCRStruct
lbase2	./OCRTypes/OCRTypes_www.h	/^		vector<short> lbase2;  \/\/valid (4)letters$/;"	m	struct:ocr::rootLetterOCRStruct
len	./GGraph/GGraph.h	/^	char len[4]; \/\/\/<массив индикаторов длин фокальных линий OCRStar$/;"	m	struct:ocr::OCRStarStruct
len	./GGraphBezier/GGraphBezier.h	/^        float len;          \/\/ длина прямой соединяющей концы линии.$/;"	m	class:ocr::OCRFocalLineBezier
len	./GGraphBezier/GGraphBezier.h	/^        int len;    \/\/относительная длина в процентах к длинне базовой линии.$/;"	m	class:ocr::OCRLineRef
len	./GMemory/GVector.h	/^    uint         len;       \/\/длина индекса$/;"	m	class:ocr::TString
len	./OCRTypes/OCRTypes.h	/^  int len;$/;"	m	struct:ocr::sData
len	./OCRTypes/OCRTypes.h	/^  uchar len;$/;"	m	class:ocr::GString
len	./OCRTypes/OCRTypes_www.h	/^        int len;$/;"	m	struct:ocr::sData
lenA	./GGraph/GGraph.h	/^	ushort lenA;			 \/\/\/< количество пикселов линии.$/;"	m	struct:ocr::OCRLineStruct
lenA	./GGraphBezier/GGraphBezier.h	/^        int lenA;           \/\/ количество пикселов линии.$/;"	m	class:ocr::OCRFocalLineBezier
lenB	./GGraphBezier/GGraphBezier.h	/^        float lenB;         \/\/ длина кривой Безье (вычислено по уравнению растеризации, медленно).$/;"	m	class:ocr::OCRFocalLineBezier
lenBf	./GGraphBezier/GGraphBezier.h	/^        float lenBf;        \/\/ - длина кривой Безье (вычислено рекурсиво и бысто).$/;"	m	class:ocr::OCRFocalLineBezier
lenBff	./GGraphBezier/GGraphBezier.h	/^        float lenBff;       \/\/ - длина кривой Безье, приближенное значение (очень бысто, вычислено всего по 4 векторам).$/;"	m	class:ocr::OCRFocalLineBezier
lenCount	./GBitsetContour/GBitsetContour.h	/^    short angCount,lenCount,angLength;$/;"	m	class:ocr::GBitsetContour
lenE0	./GGraph/GGraph.h	/^	ushort lenE0;  \/\/\/< длина линии от начала до первой точки экстремума$/;"	m	struct:ocr::OCRLineStruct
lenE1	./GGraph/GGraph.h	/^	ushort lenE1;  \/\/\/< длина линии от конца до последней точки экстремума$/;"	m	struct:ocr::OCRLineStruct
lenM	./GGraphBezier/GGraphBezier.h	/^        float lenM;         \/\/ длина сглаженной фокальной линии.$/;"	m	class:ocr::OCRFocalLineBezier
lenP	./GGraphBezier/GGraphBezier.h	/^        float lenP;         \/\/ длина укороченной кривой Безье (как часть длины сглаженной фокальной линии).$/;"	m	class:ocr::OCRFocalLineBezier
lenP1	./GGraphBezier/GGraphBezier.h	/^        float lenP1;        \/\/ длина первого контрольного вектора в pix.$/;"	m	class:ocr::OCRFocalLineBezier
lenP1P2	./GGraphBezier/GGraphBezier.h	/^        float lenP1P2;      \/\/ расстояние вектора от первой управляющей точки до второй управляющей точки в pix.$/;"	m	class:ocr::OCRFocalLineBezier
lenP2	./GGraphBezier/GGraphBezier.h	/^        float lenP2;        \/\/ длина второго контрольного вектора в pix.$/;"	m	class:ocr::OCRFocalLineBezier
lenSum	./OCRTypes/OCRTypes.h	/^  int lenSum;$/;"	m	struct:ocr::stringMatch_
lenSum	./OCRTypes/OCRTypes_www.h	/^		int lenSum;$/;"	m	struct:ocr::stringMatch_
lenght	./OCRTypes/OCRTypes.h	/^  uint lenght;$/;"	m	struct:ocr::dictKeyStruct
lenght	./OCRTypes/OCRTypes_www.h	/^		uint lenght;$/;"	m	struct:ocr::dictKey
length	./GFontEditor/GContour.h	/^    int length;$/;"	m	class:ocr::GContour
length	./GFontEditor/GLetter.cpp	/^int stringOCR::length(){$/;"	f	class:stringOCR
length	./GFontEditor/GLetter.h	/^  uint length; \/\/ длина фразы найденой в словаре$/;"	m	class:ocr::OCRMatch
length	./GGraph/GGraph.h	/^	ushort length; \/\/\/< длина линии до конечной точки без учета экстремумов$/;"	m	struct:ocr::OCRLineStruct
length	./OCRTypes/OCRTypes.h	/^  short length;$/;"	m	class:ocr::vectorOCR
lengthSum	./GFontEditor/GLetter.h	/^  ulong lengthSum;$/;"	m	class:ocr::GLetter
lengths	./PNG/lodepng.cpp	/^  unsigned* lengths; \/*the lengths of the codes of the 1d-tree*\/$/;"	m	struct:HuffmanTree	file:
letter	./GFontEditor/GLetter.h	/^  vector<OCRMatch> letter; \/\/ вектор пар букв входящих в OCRMatch$/;"	m	class:ocr::OCRMatch
letter	./OCRTypes/OCRTypes.h	/^  string letter;$/;"	m	struct:ocr::rootLetterOCRStruct
letter	./OCRTypes/OCRTypes_www.h	/^		string letter;$/;"	m	struct:ocr::rootLetterOCRStruct
letterArea	./GLogicProcessor/intersectionArea.cpp	/^void  GLogicProcessor::letterArea(OCRMatch &a, GBitmap *letterAImg){$/;"	f	class:GLogicProcessor
letterAssociation	./GLogicProcessor/letterAssociation.cpp	/^void GLogicProcessor::letterAssociation(vector<stringOCR>&strArray,$/;"	f	class:GLogicProcessor
letterBaseOCR	./GFontEditor/letterOCR.cpp	/^void GFontEditor::letterBaseOCR(int startIndex){$/;"	f	class:GFontEditor
letterClusterCorrelation	./GGraphOCR/GGraphOCRStarCorrelation.cpp	/^void GGraphOCR::letterClusterCorrelation(OCRLetter &letterTest, OCRLetter &letter) {$/;"	f	class:ocr::GGraphOCR
letterClusterTable	./GGraphOCR/GGraphOCR.h	/^	GVector *letterClusterTable; \/\/\/< таблица базовых кластеров буквы.$/;"	m	class:ocr::GGraphOCR
letterConstruction	./GLogicProcessor/letterConstructions.cpp	/^void GLogicProcessor::letterConstruction(vector<OCRMatch>&letterLine,int OCRMode){$/;"	f	class:GLogicProcessor
letterCopy	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::letterCopy(OCRLetter &letter, OCRLetter &letter1) {$/;"	f	class:ocr::GGraphOCR
letterCorrelation	./GBitsetMatrix/letterCorrelation.cpp	/^void GBitsetMatrix::letterCorrelation(vector<OCRMatch>&matchLine,$/;"	f	class:GBitsetMatrix
letterCorrelation	./GGraph/GGraphLetterCorrelation.cpp	/^void GGraph::letterCorrelation(OCRLetter &letter)$/;"	f	class:ocr::GGraph
letterCount	./GFontEditor/GFont.h	/^        ulong letterCount(){return *recordCount-1;}$/;"	f	class:ocr::GFont
letterCusterCorrelation	./GGraphOCR/GGraphOCRCorrelation.cpp	/^int GGraphOCR::letterCusterCorrelation(GGraph &graph, OCRLetter &letter, OCRStar &starT, OCRStar &star) {$/;"	f	class:ocr::GGraphOCR
letterDataId	./GBitsetContour/GBitsetContour.h	/^    char *letterDataId;$/;"	m	class:ocr::GBitsetContour
letterH	./GFontEditor/GLetter.h	/^  int letterH; \/\/\/габаритная высота буквы$/;"	m	class:ocr::GLetter
letterH	./GFontEditor/GLetter.h	/^  int letterH;$/;"	m	class:ocr::OCRMatch
letterH	./GFontEditor/GLetter.h	/^  int letterH;$/;"	m	class:ocr::OCRMatchConst
letterH	./GGraph/GGraph.h	/^	ushort letterH;$/;"	m	struct:ocr::OCRLetterStruct
letterHsum	./GBitsetOCR/GBitsetOCR.h	/^  int iLeft, iTop, letterWsum, letterHsum,proportion;$/;"	m	class:ocr::GBitsetOCR
letterID	./GFontEditor/GLetter.h	/^  int letterID;$/;"	m	class:ocr::OCRMatchConst
letterID	./GFontEditor/GLetter.h	/^  int letterID;$/;"	m	class:ocr::wordOCR
letterID	./GFontEditor/GLetter.h	/^  uint letterID; \/\/ uniq letter ID number in database (UNIX timestamp)$/;"	m	class:ocr::GLetter
letterID	./GFontEditor/GLetter.h	/^  uint letterID; \/\/уникальный ID номкр буквы в базе$/;"	m	class:ocr::OCRMatch
letterID	./GGraph/GGraph.h	/^	uint letterID;$/;"	m	struct:ocr::OCRLetterStruct
letterID	./OCRTypes/OCRTypes.h	/^  letterID = 3,$/;"	e	enum:ocr::drawConst
letterID	./OCRTypes/OCRTypes_www.h	/^				letterID=3,$/;"	e	enum:ocr::drawConst
letterIndex	./GFontEditor/GLetter.h	/^  int letterIndex;$/;"	m	class:ocr::OCRMatch
letterIndex	./GFontEditor/GLetter.h	/^  int letterIndex;$/;"	m	class:ocr::OCRMatchConst
letterIndex	./GFontEditor/GLetter.h	/^  int letterIndex;$/;"	m	class:ocr::wordOCR
letterIndex	./GFontEditor/GLetter.h	/^  uint letterIndex;$/;"	m	struct:ocr::maskData_
letterIndex	./GFontEditor/GLetter.h	/^  ulong letterIndex;       \/\/\/ letter index in base$/;"	m	class:ocr::GLetter
letterIndex	./GFontEditor/GLetter.h	/^  ushort letterIndex;$/;"	m	struct:ocr::keyOCR
letterIndex	./GGraph/GGraph.h	/^	uint letterIndex;$/;"	m	struct:ocr::OCRLetterStruct
letterIndex	./GGraphOCR/GGraphOCR.h	/^	uint letterIndex;  \/\/\/<номер буквы в которой размещен кластер.$/;"	m	struct:ClusterMatchStruct
letterIndex	./OCRTypes/OCRTypes.h	/^  int letterIndex;$/;"	m	class:ocr::vectorOCR
letterKey	./OCRTypes/OCRTypes.h	/^  letterKey = 0,$/;"	e	enum:ocr::stackFlag
letterKey	./OCRTypes/OCRTypes_www.h	/^				letterKey = 0,$/;"	e	enum:ocr::stackFlag
letterLineArea	./GLogicProcessor/intersectionArea.cpp	/^void  GLogicProcessor::letterLineArea(OCRMatch &a,GBitmap *lineImg32, GBitmap *letterAImg){$/;"	f	class:GLogicProcessor
letterLineReg	./GGraphOCR/GGraphOCR.h	/^	vector<int> letterLineReg; \/\/\/< таблица учета количества проверок корреляции фокальных линий буквы (исползуется в lookup4)$/;"	m	class:ocr::GGraphOCR
letterMaskOptimisation	./GFontEditor/letterOCR.cpp	/^void  GFontEditor::letterMaskOptimisation(GLetter *letter){$/;"	f	class:GFontEditor
letterNeighbors	./GGraphOCR/GGraphOCRLetterNeighbors.cpp	/^void GGraphOCR::letterNeighbors(vector<OCRLetter> &matchLine, GGraph &graph) {$/;"	f	class:GGraphOCR
letterNeighbors	./GLogicProcessor/letterNeighbors.cpp	/^void GLogicProcessor::letterNeighbors(vector<OCRMatch>&matchLine,GBitmap* lineImg32,GBitmap* letterAImg,GBitmap* letterBImg){$/;"	f	class:GLogicProcessor
letterNeighborsNew	./GLogicProcessor/letterNeighborsNew.cpp	/^void GLogicProcessor::letterNeighborsNew(vector<OCRMatch>&matchLine,GBitmap* lineImg32,GBitmap* letterAImg,GBitmap* letterBImg){$/;"	f	class:GLogicProcessor
letterNeighborsSanskrit	./GLogicProcessor/letterNeighborsSanskrit.cpp	/^void GLogicProcessor::letterNeighborsSanskrit(vector<OCRMatch>&matchLine,GBitmap* lineImg32,GBitmap* letterAImg,GBitmap* letterBImg){$/;"	f	class:GLogicProcessor
letterOCR	./GFontEditor/letterOCR.cpp	/^void GFontEditor::letterOCR(GLetter *letter, string &name, int *correlation,int mode){$/;"	f	class:GFontEditor
letterP	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^OCRLetter *letterP;$/;"	m	namespace:ocr	file:
letterProbability	./GLogicProcessor/letterProbability.cpp	/^void GLogicProcessor::letterProbability(vector<OCRMatch>&matchLine){$/;"	f	class:GLogicProcessor
letterReadCount	./GFontEditor/GFont.h	/^        uint letterReadCount;$/;"	m	class:ocr::GFont
letterScale	./GLogicProcessor/GLogicProcessor.h	/^    vector<string>letterScale;                      \/\/\/<Array of scale letters$/;"	m	class:ocr::GLogicProcessor
letterSet	./GFontEditor/GFont.h	/^        vector<ulong>letterSet;                       \/\/\/массив индексов букв распознаваемого языка$/;"	m	class:ocr::GFont
letterSign	./GLogicProcessor/GLogicProcessor.h	/^    vector<string>letterSign;                       \/\/\/<Array of vowel letters$/;"	m	class:ocr::GLogicProcessor
letterTextClusterCorrelation	./GGraphOCR/GGraphOCRCorrelation.cpp	/^int GGraphOCR::letterTextClusterCorrelation(GGraph &graph, OCRLetter &letter, vector<int> &searchStar) {$/;"	f	class:ocr::GGraphOCR
letterToHex	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::letterToHex(OCRLetter &letter, string &str) {$/;"	f	class:ocr::GGraphOCR
letterToLetterCorrelation	./GBitsetMatrix/letterToLetterCorrelation.cpp	/^int GBitsetMatrix::letterToLetterCorrelation(GLetter *glyph,$/;"	f	class:GBitsetMatrix
letterToStr	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::letterToStr(OCRLetter &letter, TString &st) {$/;"	f	class:ocr::GGraphOCR
letterUTF	./OCRTypes/OCRTypes.h	/^  string letterUTF;          \/\/ letter in Yagpo code in UTF$/;"	m	struct:ocr::uniLetterRecord
letterUTF	./OCRTypes/OCRTypes_www.h	/^		string letterUTF;  \/\/letter in Yagpo code in UTF$/;"	m	struct:ocr::uniLetterRecord
letterUTFLowerCase	./OCRTypes/OCRTypes.h	/^  string letterUTFLowerCase; \/\/ letter in UTF in lowerCase form$/;"	m	struct:ocr::uniLetterRecord
letterUTFLowerCase	./OCRTypes/OCRTypes_www.h	/^		string letterUTFLowerCase;  \/\/letter in UTF in lowerCase form$/;"	m	struct:ocr::uniLetterRecord
letterW	./GFontEditor/GLetter.h	/^  int letterW; \/\/\/габаритная ширина буквы в строке без учета огласовок и$/;"	m	class:ocr::GLetter
letterW	./GFontEditor/GLetter.h	/^  int letterW;$/;"	m	class:ocr::OCRMatch
letterW	./GFontEditor/GLetter.h	/^  int letterW;$/;"	m	class:ocr::OCRMatchConst
letterW	./GGraph/GGraph.h	/^	ushort letterW;$/;"	m	struct:ocr::OCRLetterStruct
letterWsum	./GBitsetOCR/GBitsetOCR.h	/^  int iLeft, iTop, letterWsum, letterHsum,proportion;$/;"	m	class:ocr::GBitsetOCR
letterX	./GMemory/GMap/GMap.h	/^        uint *letterX;      \/\/ массив координат пар букв в распознаваемом тексте$/;"	m	class:ocr::GMap
letters_data	./GMemory/GMap/GMap.h	/^        int  *letters_data;       \/\/ Разреженный массив адресов пар букв встечающихся в распознаваемом тексте один раз (без учета одинаковых).$/;"	m	class:ocr::GMap
letters_data_vector	./GMemory/GMap/GMap.h	/^        GStr<int>*letters_data_vector;$/;"	m	class:ocr::GMap
letters_size	./GMemory/GMap/GMap.h	/^        uint letters_size;$/;"	m	class:ocr::GMap
level	./GGraph/GGraph.h	/^	char level;$/;"	m	struct:ocr::OCRStarStruct
level	./GGraph/GGraph.h	/^	uchar  level;       \/\/\/<порядок распознавания OCRCluster в букве$/;"	m	struct:ocr::OCRClusterStruct
level	./OCRTypes/OCRTypes.h	/^  int level; \/\/релевантность записи$/;"	m	class:ocr::OCRDictRecord
level	./OCRTypes/OCRTypes.h	/^  int level; \/\/релевантность ключа$/;"	m	struct:ocr::dictKeyStruct
level	./OCRTypes/OCRTypes_www.h	/^		int level;  \/\/релевантность ключа$/;"	m	struct:ocr::dictKey
level	./OCRTypes/OCRTypes_www.h	/^        int level;  \/\/релевантность записи$/;"	m	class:ocr::OCRDictRecord
libCurl	./OCRString/php2stl.cpp	/^void libCurl(vector<string> &argVector) {$/;"	f
line	./GBitsetContour/GBitsetContour.h	/^  GBitmap* line;                  \/\/\/<GBitmap в который записывается вся промежуточная информация в процессе выделения контуров. (Контур, заливка, концы контуров)$/;"	m	class:ocr::GBitsetContour
line	./GFontEditor/GLetter.h	/^  vector<OCRMatch> line;       \/\/ OCR result$/;"	m	class:ocr::stringOCR
line	./GFontEditor/GLetter.h	/^  vector<int> line; \/\/ вектор индексов пар букв входящих в OCRMatch$/;"	m	class:ocr::OCRMatch
line	./GFontEditor/GLetter.h	/^  vector<pointLine> line;$/;"	m	class:ocr::TsertoOCR
line	./GGraph/GGraph.h	/^	OCRLine *line;	 \/\/\/<указатель на массив OCRLine буквы$/;"	m	struct:ocr::OCRLetterStruct
line	./GGraph/GGraph.h	/^	OCRLine line[16];	\/\/\/< фокальные линии OCRCluster$/;"	m	struct:ocr::OCRClusterStruct
line	./GGraph/GGraph.h	/^	uint line[4];  \/\/\/<массив фокальных линий звездочки$/;"	m	struct:ocr::OCRStarStruct
lineArray	./GFontEditor/GLetter.h	/^  vector<lineOCR> lineArray;   \/\/ maket segmentation$/;"	m	class:ocr::stringOCR
lineCoordinate	./GBitsetContour/GBitsetContour.h	/^	short *lineCoordinate, endContour;$/;"	m	class:ocr::GBitsetContour
lineCorr	./GGraph/GGraph.h	/^	uchar lineCorr[4];  \/\/\/<массив величин корреляций фокальных линий звездочки$/;"	m	struct:ocr::OCRStarStruct
lineCount	./GBitset/GBitset.h	/^  short lineCount;$/;"	m	class:ocr::GBitset
lineCount	./GBitsetContour/GBitsetContour.h	/^  int lineCount;                \/\/\/<количество строк в тексте$/;"	m	class:ocr::GBitsetContour
lineCount	./GBitsetMatrix/GBitsetMatrix.h	/^  short lineCount;                \/\/\/<общее количество строк на странице$/;"	m	class:ocr::GBitsetMatrix
lineCount	./GFontEditor/GLetter.h	/^  int lineCount;$/;"	m	class:ocr::GLetter
lineCount	./GGraph/GGraph.h	/^	uchar  lineCount;   \/\/\/<количество линий в OCRStar круга или количество опорных линий$/;"	m	struct:ocr::OCRClusterStruct
lineCount	./GGraph/GGraph.h	/^	uchar lineCount; \/\/\/<количество линий в OCRStar круга или количество соответствий линий при корреляции$/;"	m	struct:ocr::OCRStarStruct
lineCount	./GGraph/GGraph.h	/^	ushort lineCount;  \/\/\/<количество OCRLine в букве$/;"	m	struct:ocr::OCRLetterStruct
lineCount	./OCRTypes/OCRTypes.h	/^  short lineCount;$/;"	m	class:ocr::OCRTextData
lineCount	./OCRTypes/OCRTypes_www.h	/^		short lineCount;$/;"	m	class:ocr::OCRTextData
lineD	./GFontEditor/GContour.h	/^    int *lineX,*lineY,*lineD;$/;"	m	class:ocr::GContour
lineData	./GBitsetContour/GBitsetContour.h	/^    unsigned char *lineData ;$/;"	m	class:ocr::GBitsetContour
lineDraw	./GBitset/GBitset_algorithm.cpp	/^void GBitset::lineDraw(int color){$/;"	f	class:GBitset
lineFlag	./GFontEditor/GLetter.h	/^  int lineFlag;$/;"	m	class:ocr::lineOCR
lineH	./GFontEditor/GLetter.h	/^  int lineH;$/;"	m	class:ocr::OCRMatch
lineH	./GFontEditor/GLetter.h	/^  int lineH;$/;"	m	class:ocr::OCRMatchConst
lineH	./GGraph/GGraph.h	/^	ushort lineH;$/;"	m	struct:ocr::OCRLetterStruct
lineIndex	./GFontEditor/GLetter.h	/^  int lineIndex;         \/\/\/ индех строки в странице$/;"	m	class:ocr::stringOCR
lineIndex	./GFontEditor/GLetter.h	/^  int lineIndex; \/\/\/ index of line in page$/;"	m	class:ocr::wordOCR
lineIndex	./GFontEditor/GLetter.h	/^  int lineIndex;$/;"	m	class:ocr::OCRMatch
lineIndex	./GFontEditor/GLetter.h	/^  int lineIndex;$/;"	m	class:ocr::OCRMatchConst
lineIndex	./config.h	/^	std::vector<int> lineIndex;$/;"	m	struct:commandData
lineOCR	./GBitsetOCR/lineOCR.cpp	/^int GBitsetOCR::lineOCR(GBitmap *line,vector<OCRMatch>&matchLine, int yLimit0, int yLimit1, float scale,int index,int scaleMode){$/;"	f	class:GBitsetOCR
lineOCR	./GFontEditor/GLetter.cpp	/^lineOCR::lineOCR(void){}$/;"	f	class:lineOCR
lineOCR	./GFontEditor/GLetter.h	/^class lineOCR {$/;"	c	namespace:ocr
lineOCRScaleDetector	./GBitsetOCR/lineOCR.cpp	/^float GBitsetOCR::lineOCRScaleDetector(GBitmap *line,$/;"	f	class:GBitsetOCR
lineSize	./config.h	/^	std::vector<int> lineSize;$/;"	m	struct:commandData
lineTextTranslation	./GLogicProcessor/dictReportLocal.cpp	/^void GLogicProcessor::lineTextTranslation(string &destString,int mode_){$/;"	f	class:GLogicProcessor
lineTextTranslationChn	./GLogicProcessor/dictReportLocal.cpp	/^void GLogicProcessor::lineTextTranslationChn(string &destString){$/;"	f	class:GLogicProcessor
lineTextTranslationSkt	./GLogicProcessor/dictReportLocal.cpp	/^void GLogicProcessor::lineTextTranslationSkt(string &destString){$/;"	f	class:GLogicProcessor
lineTibetanCorrector	./GLogicProcessor/UniToYagpo.cpp	/^string GLogicProcessor::lineTibetanCorrector(string &srcLine){$/;"	f	class:GLogicProcessor
lineTranscription	./GLogicProcessor/UniToYagpo.cpp	/^string GLogicProcessor::lineTranscription(string &srcLine){$/;"	f	class:GLogicProcessor
lineW	./GGraph/GGraph.h	/^	float lineW;	  \/\/\/< средняя ширина штриха линии$/;"	m	struct:ocr::OCRLineStruct
lineW	./GGraph/GGraph.h	/^	float lineW;  \/\/\/< средняя толщина фокальной линии$/;"	m	struct:ocr::OCRStarStruct
lineWidth	./GBitmap/GBitmapPenWidth.cpp	/^  int  GBitmap::lineWidth() {$/;"	f	class:ocr::GBitmap
lineX	./GFontEditor/GContour.h	/^    int *lineX,*lineY,*lineD;$/;"	m	class:ocr::GContour
lineY	./GFontEditor/GContour.h	/^    int *lineX,*lineY,*lineD;$/;"	m	class:ocr::GContour
line_data	./GGraph/GGraph.h	/^	OCRData *line_data; \/\/\/< массив данных атрибутированных пикселов. 	$/;"	m	class:ocr::GGraph
line_data	./GGraph/GGraph.h	/^	OCRData *line_data; \/\/\/<диаграмма Воронова и данные атрибутов пикселов$/;"	m	struct:ocr::OCRLetterStruct
line_weight	./GGraph/GGraph.h	/^	char line_weight[4]; \/\/\/< массив относительных весов корреляции фокальной линии в общей корреляции OCRStar$/;"	m	struct:ocr::OCRStarStruct
linkDict	./GLogicProcessor/dictReportLocal.cpp	/^inline string linkDict(const char* line,int *id){$/;"	f
linkDict	./GLogicProcessor/dictReportLocal.cpp	/^inline string linkDict(string &line,int *id){$/;"	f
linkEdit	./GLogicProcessor/dictReportLocal.cpp	/^inline string linkEdit(const char* line,int *id){$/;"	f
linkEdit	./GLogicProcessor/dictReportLocal.cpp	/^inline string linkEdit(string &line,int *id){$/;"	f
linkOriginal	./GLogicProcessor/dictReportLocal.cpp	/^inline string linkOriginal(string &line,int *id){$/;"	f
linkText	./GLogicProcessor/dictReportLocal.cpp	/^inline string linkText(string &line,int *id){$/;"	f
listsize	./PNG/lodepng.cpp	/^  unsigned listsize;$/;"	m	struct:BPMLists	file:
lj	./OCRTypes/OCRTypes.h	/^  vector<short> lj;         \/\/ joined leter$/;"	m	struct:ocr::rootLetterOCRStruct
lj	./OCRTypes/OCRTypes_www.h	/^		vector<short> lj;  \/\/joined leter$/;"	m	struct:ocr::rootLetterOCRStruct
lm	./OCRTypes/OCRTypes.h	/^  vector<short> lm;         \/\/ modificator$/;"	m	struct:ocr::rootLetterOCRStruct
lm	./OCRTypes/OCRTypes_www.h	/^		vector<short> lm;  \/\/modificator$/;"	m	struct:ocr::rootLetterOCRStruct
ln	./GBitsetContour/GBitsetContour.h	/^	short res, xBegin, xEnd, xL,yL,hL, wL, dy_line, y_line, yLine, *ln,*lt;$/;"	m	class:ocr::GBitsetContour
ln	./GBitsetOCR/textOCR_.h	/^int ln=matchLine.size(); int maxW=0, indexMaxW;$/;"	v
ln	./OCRTypes/OCRTypes.h	/^  string ln;$/;"	m	struct:ocr::dictKeyStruct
ln	./OCRTypes/OCRTypes_www.h	/^		string ln;$/;"	m	struct:ocr::dictKey
loadDB	./GMemory/loadDB.cpp	/^void GMemory::loadDB() {$/;"	f	class:GMemory
loadDictLevelFile	./GLogicProcessor/loadDictionary.cpp	/^void GLogicProcessor::loadDictLevelFile(){$/;"	f	class:GLogicProcessor
loadMapFilePali	./GLogicProcessor/loadMap.cpp	/^void GLogicProcessor::loadMapFilePali(const char *mapName){$/;"	f	class:GLogicProcessor
loadTable	./GMemory/loadDB.cpp	/^void GMemory::loadTable(string &name) {$/;"	f	class:GMemory
loadTransliterationFile	./GLogicProcessor/loadMap.cpp	/^void GLogicProcessor::loadTransliterationFile(const char *mapName){$/;"	f	class:GLogicProcessor
load_file	./PNG/lodepng.cpp	/^unsigned load_file(std::vector<unsigned char>& buffer, const std::string& filename)$/;"	f	namespace:lodepng
localSum	./GBitset/GBitset.cpp	/^ void GBitset::localSum(vector<vector<int> > &INFase,$/;"	f	class:ocr::GBitset
localSumStatic	./GBitset/GBitset.cpp	/^ void GBitset::localSumStatic(vector<vector<int> > &INFase,$/;"	f	class:ocr::GBitset
lockFlag	./GMemory/GVector.h	/^    ulong *lockFlag;  \/\/флаг блокировки чтения-записи$/;"	m	class:ocr::GVector
lodepng	./PNG/lodepng.cpp	/^namespace lodepng$/;"	n	file:
lodepng	./PNG/lodepng.h	/^namespace lodepng$/;"	n
lodepng_add32bitInt	./PNG/lodepng.cpp	/^static void lodepng_add32bitInt(ucvector* buffer, unsigned value)$/;"	f	file:
lodepng_add_itext	./PNG/lodepng.cpp	/^unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,$/;"	f
lodepng_add_text	./PNG/lodepng.cpp	/^unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str)$/;"	f
lodepng_addofl	./PNG/lodepng.cpp	/^static int lodepng_addofl(size_t a, size_t b, size_t* result)$/;"	f	file:
lodepng_assign_icc	./PNG/lodepng.cpp	/^static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size)$/;"	f	file:
lodepng_auto_choose_color	./PNG/lodepng.cpp	/^unsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,$/;"	f
lodepng_buffer_file	./PNG/lodepng.cpp	/^static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename)$/;"	f	file:
lodepng_can_have_alpha	./PNG/lodepng.cpp	/^unsigned lodepng_can_have_alpha(const LodePNGColorMode* info)$/;"	f
lodepng_chunk_ancillary	./PNG/lodepng.cpp	/^unsigned char lodepng_chunk_ancillary(const unsigned char* chunk)$/;"	f
lodepng_chunk_append	./PNG/lodepng.cpp	/^unsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk)$/;"	f
lodepng_chunk_check_crc	./PNG/lodepng.cpp	/^unsigned lodepng_chunk_check_crc(const unsigned char* chunk)$/;"	f
lodepng_chunk_create	./PNG/lodepng.cpp	/^unsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,$/;"	f
lodepng_chunk_data	./PNG/lodepng.cpp	/^unsigned char* lodepng_chunk_data(unsigned char* chunk)$/;"	f
lodepng_chunk_data_const	./PNG/lodepng.cpp	/^const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk)$/;"	f
lodepng_chunk_find	./PNG/lodepng.cpp	/^unsigned char* lodepng_chunk_find(unsigned char* chunk, const unsigned char* end, const char type[5])$/;"	f
lodepng_chunk_find_const	./PNG/lodepng.cpp	/^const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5])$/;"	f
lodepng_chunk_generate_crc	./PNG/lodepng.cpp	/^void lodepng_chunk_generate_crc(unsigned char* chunk)$/;"	f
lodepng_chunk_length	./PNG/lodepng.cpp	/^unsigned lodepng_chunk_length(const unsigned char* chunk)$/;"	f
lodepng_chunk_next	./PNG/lodepng.cpp	/^unsigned char* lodepng_chunk_next(unsigned char* chunk)$/;"	f
lodepng_chunk_next_const	./PNG/lodepng.cpp	/^const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk)$/;"	f
lodepng_chunk_private	./PNG/lodepng.cpp	/^unsigned char lodepng_chunk_private(const unsigned char* chunk)$/;"	f
lodepng_chunk_safetocopy	./PNG/lodepng.cpp	/^unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk)$/;"	f
lodepng_chunk_type	./PNG/lodepng.cpp	/^void lodepng_chunk_type(char type[5], const unsigned char* chunk)$/;"	f
lodepng_chunk_type_equals	./PNG/lodepng.cpp	/^unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type)$/;"	f
lodepng_clear_icc	./PNG/lodepng.cpp	/^void lodepng_clear_icc(LodePNGInfo* info)$/;"	f
lodepng_clear_itext	./PNG/lodepng.cpp	/^void lodepng_clear_itext(LodePNGInfo* info)$/;"	f
lodepng_clear_text	./PNG/lodepng.cpp	/^void lodepng_clear_text(LodePNGInfo* info)$/;"	f
lodepng_color_mode_cleanup	./PNG/lodepng.cpp	/^void lodepng_color_mode_cleanup(LodePNGColorMode* info)$/;"	f
lodepng_color_mode_copy	./PNG/lodepng.cpp	/^unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source)$/;"	f
lodepng_color_mode_equal	./PNG/lodepng.cpp	/^static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b)$/;"	f	file:
lodepng_color_mode_init	./PNG/lodepng.cpp	/^void lodepng_color_mode_init(LodePNGColorMode* info)$/;"	f
lodepng_color_mode_make	./PNG/lodepng.cpp	/^LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth)$/;"	f
lodepng_color_profile_add	./PNG/lodepng.cpp	/^static unsigned lodepng_color_profile_add(LodePNGColorProfile* profile,$/;"	f	file:
lodepng_color_profile_init	./PNG/lodepng.cpp	/^void lodepng_color_profile_init(LodePNGColorProfile* profile)$/;"	f
lodepng_compress_settings_init	./PNG/lodepng.cpp	/^void lodepng_compress_settings_init(LodePNGCompressSettings* settings)$/;"	f
lodepng_convert	./PNG/lodepng.cpp	/^unsigned lodepng_convert(unsigned char* out, const unsigned char* in,$/;"	f
lodepng_convert_rgb	./PNG/lodepng.cpp	/^unsigned lodepng_convert_rgb($/;"	f
lodepng_crc32	./PNG/lodepng.cpp	/^unsigned lodepng_crc32(const unsigned char* data, size_t length)$/;"	f
lodepng_crc32_table	./PNG/lodepng.cpp	/^static unsigned lodepng_crc32_table[256] = {$/;"	v	file:
lodepng_decode	./PNG/lodepng.cpp	/^unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,$/;"	f
lodepng_decode24	./PNG/lodepng.cpp	/^unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)$/;"	f
lodepng_decode24_file	./PNG/lodepng.cpp	/^unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename)$/;"	f
lodepng_decode32	./PNG/lodepng.cpp	/^unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)$/;"	f
lodepng_decode32_file	./PNG/lodepng.cpp	/^unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename)$/;"	f
lodepng_decode_file	./PNG/lodepng.cpp	/^unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,$/;"	f
lodepng_decode_memory	./PNG/lodepng.cpp	/^unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,$/;"	f
lodepng_decoder_settings_init	./PNG/lodepng.cpp	/^void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings)$/;"	f
lodepng_decompress_settings_init	./PNG/lodepng.cpp	/^void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings)$/;"	f
lodepng_default_compress_settings	./PNG/lodepng.cpp	/^const LodePNGCompressSettings lodepng_default_compress_settings = {2, 1, DEFAULT_WINDOWSIZE, 3, 128, 1, 0, 0, 0};$/;"	v
lodepng_default_decompress_settings	./PNG/lodepng.cpp	/^const LodePNGDecompressSettings lodepng_default_decompress_settings = {0, 0, 0, 0};$/;"	v
lodepng_deflate	./PNG/lodepng.cpp	/^unsigned lodepng_deflate(unsigned char** out, size_t* outsize,$/;"	f
lodepng_deflatev	./PNG/lodepng.cpp	/^static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,$/;"	f	file:
lodepng_encode	./PNG/lodepng.cpp	/^unsigned lodepng_encode(unsigned char** out, size_t* outsize,$/;"	f
lodepng_encode24	./PNG/lodepng.cpp	/^unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h)$/;"	f
lodepng_encode24_file	./PNG/lodepng.cpp	/^unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h)$/;"	f
lodepng_encode32	./PNG/lodepng.cpp	/^unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h)$/;"	f
lodepng_encode32_file	./PNG/lodepng.cpp	/^unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h)$/;"	f
lodepng_encode_file	./PNG/lodepng.cpp	/^unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,$/;"	f
lodepng_encode_memory	./PNG/lodepng.cpp	/^unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,$/;"	f
lodepng_encoder_settings_init	./PNG/lodepng.cpp	/^void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings)$/;"	f
lodepng_error_text	./PNG/lodepng.cpp	/^const char* lodepng_error_text(unsigned code)$/;"	f
lodepng_filesize	./PNG/lodepng.cpp	/^static long lodepng_filesize(const char* filename)$/;"	f	file:
lodepng_free	./PNG/lodepng.cpp	/^static void lodepng_free(void* ptr)$/;"	f	file:
lodepng_get_bpp	./PNG/lodepng.cpp	/^unsigned lodepng_get_bpp(const LodePNGColorMode* info)$/;"	f
lodepng_get_bpp_lct	./PNG/lodepng.cpp	/^static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth)$/;"	f	file:
lodepng_get_channels	./PNG/lodepng.cpp	/^unsigned lodepng_get_channels(const LodePNGColorMode* info)$/;"	f
lodepng_get_color_profile	./PNG/lodepng.cpp	/^unsigned lodepng_get_color_profile(LodePNGColorProfile* profile,$/;"	f
lodepng_get_raw_size	./PNG/lodepng.cpp	/^size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color)$/;"	f
lodepng_get_raw_size_idat	./PNG/lodepng.cpp	/^static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)$/;"	f	file:
lodepng_get_raw_size_lct	./PNG/lodepng.cpp	/^size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth)$/;"	f
lodepng_has_palette_alpha	./PNG/lodepng.cpp	/^unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info)$/;"	f
lodepng_huffman_code_lengths	./PNG/lodepng.cpp	/^unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,$/;"	f
lodepng_inflate	./PNG/lodepng.cpp	/^unsigned lodepng_inflate(unsigned char** out, size_t* outsize,$/;"	f
lodepng_inflatev	./PNG/lodepng.cpp	/^static unsigned lodepng_inflatev(ucvector* out,$/;"	f	file:
lodepng_info_cleanup	./PNG/lodepng.cpp	/^void lodepng_info_cleanup(LodePNGInfo* info)$/;"	f
lodepng_info_copy	./PNG/lodepng.cpp	/^unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source)$/;"	f
lodepng_info_init	./PNG/lodepng.cpp	/^void lodepng_info_init(LodePNGInfo* info)$/;"	f
lodepng_inspect	./PNG/lodepng.cpp	/^unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,$/;"	f
lodepng_inspect_chunk	./PNG/lodepng.cpp	/^unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,$/;"	f
lodepng_is_alpha_type	./PNG/lodepng.cpp	/^unsigned lodepng_is_alpha_type(const LodePNGColorMode* info)$/;"	f
lodepng_is_greyscale_type	./PNG/lodepng.cpp	/^unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info)$/;"	f
lodepng_is_palette_type	./PNG/lodepng.cpp	/^unsigned lodepng_is_palette_type(const LodePNGColorMode* info)$/;"	f
lodepng_load_file	./PNG/lodepng.cpp	/^unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename)$/;"	f
lodepng_malloc	./PNG/lodepng.cpp	/^static void* lodepng_malloc(size_t size)$/;"	f	file:
lodepng_mulofl	./PNG/lodepng.cpp	/^static int lodepng_mulofl(size_t a, size_t b, size_t* result)$/;"	f	file:
lodepng_palette_add	./PNG/lodepng.cpp	/^unsigned lodepng_palette_add(LodePNGColorMode* info,$/;"	f
lodepng_palette_clear	./PNG/lodepng.cpp	/^void lodepng_palette_clear(LodePNGColorMode* info)$/;"	f
lodepng_pixel_overflow	./PNG/lodepng.cpp	/^static int lodepng_pixel_overflow(unsigned w, unsigned h,$/;"	f	file:
lodepng_read32bitInt	./PNG/lodepng.cpp	/^unsigned lodepng_read32bitInt(const unsigned char* buffer)$/;"	f
lodepng_realloc	./PNG/lodepng.cpp	/^static void* lodepng_realloc(void* ptr, size_t new_size)$/;"	f	file:
lodepng_save_file	./PNG/lodepng.cpp	/^unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename)$/;"	f
lodepng_set32bitInt	./PNG/lodepng.cpp	/^static void lodepng_set32bitInt(unsigned char* buffer, unsigned value)$/;"	f	file:
lodepng_set_icc	./PNG/lodepng.cpp	/^unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size)$/;"	f
lodepng_state_cleanup	./PNG/lodepng.cpp	/^void lodepng_state_cleanup(LodePNGState* state)$/;"	f
lodepng_state_copy	./PNG/lodepng.cpp	/^void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source)$/;"	f
lodepng_state_init	./PNG/lodepng.cpp	/^void lodepng_state_init(LodePNGState* state)$/;"	f
lodepng_zlib_compress	./PNG/lodepng.cpp	/^unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,$/;"	f
lodepng_zlib_decompress	./PNG/lodepng.cpp	/^unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,$/;"	f
log	./config.h	/^	std::ofstream log;$/;"	m	struct:commandData
logicProcessor	./GFontEditor/GFontEditor.h	/^        GLogicProcessor *logicProcessor;$/;"	m	class:ocr::GFontEditor
logicProcessor	./GMainEditor/GMainEditor.h	/^        GLogicProcessor *logicProcessor;$/;"	m	class:ocr::GMainEditor
logicProcessor	./config.h	/^	void *logicProcessor;$/;"	m	struct:commandData
logical	./OCRAlgorithm/f2c.h	/^typedef long int logical;$/;"	t
logical1	./OCRAlgorithm/f2c.h	/^typedef char logical1;$/;"	t
longMemory	./config.h	/^	void *longMemory;$/;"	m	struct:commandData
longint	./OCRAlgorithm/f2c.h	/^typedef long long longint;		\/* system-dependent *\/$/;"	t
lookupProcess3	./GMemory/GMap/lookupProcess3.cpp	/^uint GMap::lookupProcess3(ulong w, ulong oldw){$/;"	f	class:GMap
lookupProcess3_T	./GMemory/GMap/lookupProcess3.cpp	/^uint GMap::lookupProcess3_T(ulong w, ulong oldw){$/;"	f	class:GMap
lookupProcess4	./GMemory/GMap/lookupProcess4.cpp	/^bool GMap::lookupProcess4(ulong n,ulong oldw,ulong w){   \/\/ int *xMaxStart, int *xMaxEnd$/;"	f	class:GMap
lookupProcessFontMatch3	./GMemory/GMap/lookupProcessFontMatch3.cpp	/^uint GMap::lookupProcessFontMatch3(map<vector<int>,ulong>&searchResult,$/;"	f	class:GMap
lowerCase	./OCRString/php2stl.cpp	/^void lowerCase(string &srcStr) {$/;"	f
lowerCase_nocopy	./GLogicProcessor/converterPali.cpp	/^void GLogicProcessor::lowerCase_nocopy(string &inStr){$/;"	f	class:GLogicProcessor
lsj	./OCRTypes/OCRTypes.h	/^  vector<short> lsj;        \/\/ subjoined leter$/;"	m	struct:ocr::rootLetterOCRStruct
lsj	./OCRTypes/OCRTypes_www.h	/^		vector<short> lsj;  \/\/subjoined leter$/;"	m	struct:ocr::rootLetterOCRStruct
lssj	./OCRTypes/OCRTypes.h	/^  vector<short> lssj;       \/\/ sub subjoined leter$/;"	m	struct:ocr::rootLetterOCRStruct
lssj	./OCRTypes/OCRTypes_www.h	/^		vector<short> lssj;  \/\/sub subjoined leter$/;"	m	struct:ocr::rootLetterOCRStruct
lt	./GBitsetContour/GBitsetContour.h	/^	short res, xBegin, xEnd, xL,yL,hL, wL, dy_line, y_line, yLine, *ln,*lt;$/;"	m	class:ocr::GBitsetContour
lw1	./GBitsetOCR/textOCR_.h	/^    int bRightOld=0,lw1,bLeft,space1,space0;$/;"	v
m	./GBitset/GBitset.h	/^ int m;         \/\/\/< ширина двухмерного массива (если массивы так используем)$/;"	m	class:ocr::GBitset
m	./GBitsetContour/GBitsetContour.h	/^	short dlt_y, t, d, xl, yl, n,m;$/;"	m	class:ocr::GBitsetContour
mData	./GGraphBezier/GGraphBezier.h	/^        vector<OCRPointFloat>mData;   \/\/ - вектор для массива усредненных координат точек фокальной линии по "x" и "y"(NO Б.Д.).$/;"	m	class:ocr::OCRFocalLineBezier
mDict	./GLogicProcessor/GLogicProcessor.h	/^    GVector *mDict;$/;"	m	class:ocr::GLogicProcessor
mH	./GBitMask/GBitMask.h	/^		int mW,mH;                 \/\/\/<габариты массивов маски (mHImg=mH)  \/\/ mW ширмна (фиксированная) прямоугольника маски$/;"	m	class:ocr::GBitMask32
mH	./GBitMask/GBitMask.h	/^		int mW,mH;       \/\/ габариты маски: по ширине (фиксированный) 64, по высоте  1-128$/;"	m	class:ocr::GBitMask128
mHOn	./GBitMask/GBitMask.h	/^		int mWOn,mHOn;             \/\/\/<реальные габариты зоны ON$/;"	m	class:ocr::GBitMask32
mIndex	./GMemory/GMemory.h	/^	GMap *mIndex;	  \/\/pointer on index data$/;"	m	class:ocr::indexRecord
mLen	./GGraph/GGraph.h	/^	float mLen;	  \/\/\/< средняя длина луча$/;"	m	struct:ocr::OCRStarStruct
mSIZE	./GMemory/GMap/GMap.h	40;"	d
mTab	./GGraphBezier/GGraphBezier.h	/^        vector<OCRPointFloat>mTab;    \/\/ вектор для таблицы интегральных сумм сглаженных координат фокальной линии.$/;"	m	class:ocr::OCRFocalLineBezier
mW	./GBitMask/GBitMask.h	/^		int mW,mH;                 \/\/\/<габариты массивов маски (mHImg=mH)  \/\/ mW ширмна (фиксированная) прямоугольника маски$/;"	m	class:ocr::GBitMask32
mW	./GBitMask/GBitMask.h	/^		int mW,mH;       \/\/ габариты маски: по ширине (фиксированный) 64, по высоте  1-128$/;"	m	class:ocr::GBitMask128
mWOn	./GBitMask/GBitMask.h	/^		int mWOn,mHOn;             \/\/\/<реальные габариты зоны ON$/;"	m	class:ocr::GBitMask32
mainDict	./GLogicProcessor/GLogicProcessor.h	/^    map<string, OCRDictRecord>mainDict; \/\/\/main map of dictionary records.$/;"	m	class:ocr::GLogicProcessor
mainDictIndex	./GLogicProcessor/GLogicProcessor.h	/^    GMap *mainDictIndex;$/;"	m	class:ocr::GLogicProcessor
mainDictReport	./GLogicProcessor/dictReport.cpp	/^void  GLogicProcessor::mainDictReport(){$/;"	f	class:GLogicProcessor
mainEditor	./config.h	/^	void *mainEditor;$/;"	m	struct:commandData
mainLetterTableKey	./GLogicProcessor/GLogicProcessor.h	/^	map<string,map<string,string> > mainLetterTableKey; \/\/\/base letter table for all letter conversion function in typing key$/;"	m	class:ocr::GLogicProcessor
mainLetterTableOCRKey	./GLogicProcessor/GLogicProcessor.h	/^	map<string,map<string,string> > mainLetterTableOCRKey; \/\/\/base letter table for all letter conversion function in OCR$/;"	m	class:ocr::GLogicProcessor
mainLetterTableUni	./GLogicProcessor/GLogicProcessor.h	/^	map<string,map<string,string> > mainLetterTableUni; \/\/\/base letter table for all letter conversion function in Uni key$/;"	m	class:ocr::GLogicProcessor
mainLetterTableYagpo	./GLogicProcessor/GLogicProcessor.h	/^	map<string,map<string,string> > mainLetterTableYagpo; \/\/\/base letter table for all letter conversion function in Yagpo key$/;"	m	class:ocr::GLogicProcessor
mainString	./GBitsetOCR/GBitsetOCR.h	/^  string mainString;$/;"	m	class:ocr::GBitsetOCR
mainString	./GMainEditor/GMainEditor.h	/^		string mainString;$/;"	m	class:ocr::GMainEditor
mainTextTranslation	./GLogicProcessor/dictReportLocal.cpp	/^void  GLogicProcessor::mainTextTranslation(string &textPage){$/;"	f	class:GLogicProcessor
main_pdf	./GPDF/tiffio_osx.h	/^int main_pdf (int argc, char * const argv[])$/;"	f
mask	./GGraph/GGraph.h	/^	int mask[32];$/;"	m	struct:ocr::OCRMaskStruct
mask	./GGraph/GGraph.h	/^	uchar mask; \/\/\/<\/маркер наличия маски$/;"	m	struct:ocr::OCRLineStruct
mask128	./GFontEditor/GLetter.h	/^  GBitMask128 mask128; \/\/\/габаритная маска(изображение) буквы$/;"	m	class:ocr::GLetter
mask256	./GBitmap/GBitmap.h	/^	unsigned int mask256[256];$/;"	m	class:ocr::GBitmap
mask32	./GBitsetMatrix/GBitsetMatrix.h	/^  GBitMask32 *mask32[32];         \/\/\/массив масок 32х32$/;"	m	class:ocr::GBitsetMatrix
mask32	./GFontEditor/GLetter.h	/^  GBitMask32 *mask32; \/\/\/<<указатель на маски признаков$/;"	m	class:ocr::GLetter
mask32Count	./GBitsetMatrix/GBitsetMatrix.h	/^  int mask32Count;                \/\/\/<размерность массива масок 32х32$/;"	m	class:ocr::GBitsetMatrix
mask32Count	./GFontEditor/GLetter.h	/^  ulong mask32Count() { return mask32Vector->size(); }; \/\/\/<количество признаков$/;"	f	class:ocr::GLetter
mask32Vector	./GFontEditor/GLetter.h	/^  GStr<GBitMask32> *mask32Vector; \/\/\/контейнер для масок буквы$/;"	m	class:ocr::GLetter
mask32Vector	./GFontEditor/GLetter.h	/^  vector<GBitMask32> mask32Vector;$/;"	m	class:ocr::OCRMatch
maskBorder	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int maskBorder = 14;$/;"	m	namespace:ocr	file:
maskC	./GGraph/GGraph.h	/^	OCRMask maskC; \/\/\/< маска кластера$/;"	m	struct:ocr::OCRClusterStruct
maskC	./GGraph/GGraph.h	/^	OCRMask maskC; \/\/\/< маска кластера$/;"	m	struct:ocr::OCRStarStruct
maskCor	./GBitsetMatrix/GBitsetMatrix.h	/^  unsigned int maskCor[384*32*4]; \/\/\/< кэш масок ON  и  OFF  (setMatrix_Lion)$/;"	m	class:ocr::GBitsetMatrix
maskCorrelation	./GFontEditor/GFontEditor.cpp	/^int GFontEditor::maskCorrelation(GBitMask32 &mask1,GBitMask32&mask2){$/;"	f	class:GFontEditor
maskCount	./GBitMask/algorithmOCR_32.cpp	/^    int  GBitMask32::maskCount(){$/;"	f	class:ocr::GBitMask32
maskData_	./GFontEditor/GLetter.h	/^struct maskData_ {$/;"	s	namespace:ocr
maskFromVector	./GFontEditor/GLetter.cpp	/^void GLetter::maskFromVector(){$/;"	f	class:GLetter
maskH	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int maskH = 128;$/;"	m	namespace:ocr	file:
maskLine	./GGraph/GGraph.h	/^	int maskLine[32]; \/\/\/<маска формы фокальной линий$/;"	m	struct:ocr::OCRLineStruct
maskNormalisation	./GFontEditor/GLetter.cpp	/^void GLetter::maskNormalisation(){$/;"	f	class:GLetter
maskOriginal	./GFontEditor/GLetter.h	/^  GBitMask128 maskOriginal; \/\/\/габаритная маска оригинального исходного$/;"	m	class:ocr::GLetter
maskType	./GBitMask/GBitMask.h	/^		int maskType;              \/\/\/<тип маски 1 -маска On-Off. Для других типов не выполняется эррозия!(маски малых объектов)$/;"	m	class:ocr::GBitMask32
maskType	./GBitMask/GBitMask.h	/^		int maskType;    \/\/тип маски$/;"	m	class:ocr::GBitMask128
matExpDispers	./GBitset/GBitset.cpp	/^  void GBitset::matExpDispers(vector<vector<int> > &INFase,$/;"	f	class:ocr::GBitset
match	./GFontEditor/GLetter.h	/^  vector<OCRMatch> match, match1;$/;"	m	class:ocr::wordOCR
match	./GGraph/GGraph.h	/^	int match;		\/\/\/<id номер наиболее соответствующей линии в тексте$/;"	m	struct:ocr::OCRLineStruct
match	./GGraph/GGraph.h	/^	short match[4];	 \/\/\/<массив id номеров гипотез OCRStar текста$/;"	m	struct:ocr::OCRStarStruct
match	./GGraph/GGraph.h	/^	uint *match;	 \/\/\/< все matches в гипотезе буквы$/;"	m	struct:ocr::OCRLetterStruct
match1	./GFontEditor/GLetter.h	/^  vector<OCRMatch> match, match1;$/;"	m	class:ocr::wordOCR
matchCount	./GFontEditor/GLetter.h	/^  int matchCount; \/\/ count for mutch points in structure$/;"	m	class:ocr::OCRMatch
matchCount	./GFontEditor/GLetter.h	/^  int matchCount; \/\/ count for mutch points in structure$/;"	m	class:ocr::OCRMatchConst
matchCount	./GGraph/GGraph.h	/^	uchar matchCount; \/\/\/< количество гипотез OCRStar в тексте$/;"	m	struct:ocr::OCRStarStruct
matchCount	./GGraph/GGraph.h	/^	ushort matchCount;$/;"	m	struct:ocr::OCRLetterStruct
matchID	./GGraph/GGraph.h	/^	uint   matchID;     \/\/\/< ID номер наилучшей гипотезы корреляции$/;"	m	struct:ocr::OCRClusterStruct
matchID	./GGraph/GGraph.h	/^	uint matchID; \/\/\/< IDномер гипотезы буквы наиболее соответствующий этой OCRStar$/;"	m	struct:ocr::OCRStarStruct
matchIndex	./GGraphOCR/GGraphOCR.h	/^	uint matchIndex;   \/\/\/<номер букве в которой найден кластер,$/;"	m	struct:ClusterMatchStruct
matchIndex	./OCRTypes/OCRTypes.h	/^  int matchIndex;$/;"	m	struct:ocr::stringMatch_
matchIndex	./OCRTypes/OCRTypes_www.h	/^		int matchIndex;$/;"	m	struct:ocr::stringMatch_
matchStar	./GGraph/GGraph.h	/^	uint matchStar;$/;"	m	struct:ocr::OCRStarStruct
matchSum	./OCRTypes/OCRTypes.h	/^  short matchSum;$/;"	m	class:ocr::vectorOCR
matchSumTest	./GFontEditor/GLetter.h	/^  int matchSumTest; \/\/ calculated match$/;"	m	class:ocr::OCRMatch
matchSumTest	./GFontEditor/GLetter.h	/^  int matchSumTest; \/\/ calculated match$/;"	m	class:ocr::OCRMatchConst
matrix	./config.h	/^	void *matrix;$/;"	m	struct:commandData
max	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^OCRPoint max, min;$/;"	m	namespace:ocr	file:
max	./OCRAlgorithm/f2c.h	161;"	d
max	./OCRString/php2stl.cpp	/^int max(int &a, int &b) {$/;"	f
maxBitAdress	./GBitset/GBitset.h	/^		int maxBitAdress;$/;"	m	class:ocr::GBitset
maxC	./GGraphBezier/GGraphBezier.h	/^        int maxC;           \/\/ - значение максимальной корреляции.$/;"	m	class:ocr::OCRFocalLineBezier
maxCor	./GGraphBezier/GGraphBezier.h	/^        int maxCor;         \/\/ прямая-1, дуга-2, спираль-3, круг-4.$/;"	m	class:ocr::OCRFocalLineBezier
maxHashError	./GMemory/GMap/GMap.h	/^        uint maxHashError;$/;"	m	class:ocr::GMap
maxID	./GFontEditor/GFont.h	/^        uint maxID;$/;"	m	class:ocr::GFont
maxUniRecord	./GLogicProcessor/GLogicProcessor.h	/^	int maxUniRecord;  \/\/\/<max length of tibetan staÏck letter in Unicode codepage$/;"	m	class:ocr::GLogicProcessor
maxW	./GBitsetOCR/textOCR_.h	/^int ln=matchLine.size(); int maxW=0, indexMaxW;$/;"	v
maxY	./GFontEditor/GLetter.h	/^  int maxY;$/;"	m	class:ocr::OCRMatch
maxY	./GFontEditor/GLetter.h	/^  int maxY;$/;"	m	class:ocr::OCRMatchConst
max_down	./GBitsetContour/GBitsetContour.h	/^	short max_down, startLetter, startLine, contourCount, contourIndex, indexFilter;$/;"	m	class:ocr::GBitsetContour
maxbitlen	./PNG/lodepng.cpp	/^  unsigned maxbitlen; \/*maximum number of bits a single code can get*\/$/;"	m	struct:HuffmanTree	file:
mc68010	./OCRAlgorithm/f2c.h	207;"	d
mc68020	./OCRAlgorithm/f2c.h	208;"	d
memBase	./OCRTypes/OCRTypes.h	/^  int memBase;$/;"	m	struct:ocr::sData
memint	./OCRTypes/OCRTypes.h	/^typedef uint32 memint;$/;"	t	namespace:ocr
memint	./OCRTypes/OCRTypes.h	/^typedef uint64 memint;$/;"	t	namespace:ocr
memint	./OCRTypes/OCRTypes_www.h	/^    typedef uint32			memint;$/;"	t	namespace:ocr
memint	./OCRTypes/OCRTypes_www.h	/^    typedef uint64			memint;$/;"	t	namespace:ocr
memory	./PNG/lodepng.cpp	/^  BPMNode* memory;$/;"	m	struct:BPMLists	file:
memoryRequest	./GMemory/memoryRequest.cpp	/^void GMemory::memoryRequest(string &destString)$/;"	f	class:GMemory
memprint	./OCRString/php2stl.cpp	/^void memprint(cstr ptr, int size) {$/;"	f
memsize	./PNG/lodepng.cpp	/^  unsigned memsize;$/;"	m	struct:BPMLists	file:
mettaPali	./GLogicProcessor/GLogicProcessor.h	/^    vector<uniLetterRecord>mettaPali;$/;"	m	class:ocr::GLogicProcessor
middleH	./OCRTypes/OCRTypes.h	/^  short middleH;$/;"	m	class:ocr::OCRTextData
middleH	./OCRTypes/OCRTypes_www.h	/^		short middleH;$/;"	m	class:ocr::OCRTextData
min	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^OCRPoint max, min;$/;"	m	namespace:ocr	file:
min	./OCRAlgorithm/f2c.h	160;"	d
minLen	./GGraph/GGraph.h	/^	uchar minLen;	 \/\/\/<длина самой короткой линии$/;"	m	struct:ocr::OCRStarStruct
minmatch	./PNG/lodepng.h	/^  unsigned minmatch; \/*mininum lz77 length. 3 is normally best, 6 can be better for some PNGs. Default: 0*\/$/;"	m	struct:LodePNGCompressSettings
minute	./PNG/lodepng.h	/^  unsigned minute;  \/*0-59*\/$/;"	m	struct:LodePNGTime
mips	./OCRAlgorithm/f2c.h	209;"	d
month	./PNG/lodepng.h	/^  unsigned month;   \/*1-12*\/$/;"	m	struct:LodePNGTime
n	./GBitsetContour/GBitsetContour.h	/^	short dlt_y, t, d, xl, yl, n,m;$/;"	m	class:ocr::GBitsetContour
nEnter	./GLogicProcessor/GLogicProcessor.h	/^    unsigned int nEnter;           \/\/ количество переводов каретки Enter в словаре$/;"	m	class:ocr::GLogicProcessor
nEnter	./GMemory/GMap/GMap.h	/^        ulong nEnter;           \/\/ количество переводов каретки Enter в словаре$/;"	m	class:ocr::GMap
nLetter	./GLogicProcessor/GLogicProcessor.h	/^    unsigned short nLetter;        \/\/ количество разных букв в словаре$/;"	m	class:ocr::GLogicProcessor
nLetter	./GMemory/GMap/GMap.h	/^        ulong nLetter;          \/\/ количество разных букв в словаре$/;"	m	class:ocr::GMap
nLetterP	./GMemory/GMap/GMap.h	/^        ulong nLetterP;         \/\/ количество разных пар букв в словаре$/;"	m	class:ocr::GMap
nLetterPT	./GMemory/GMap/GMap.h	/^        ulong nLetterPT;$/;"	m	class:ocr::GMap
nRank	./GLogicProcessor/GLogicProcessor.h	/^    unsigned int nRank,rank;       \/\/ округленное значение nLetter до ближайшей степени двойки nRank. Сама степень двойки равна rank $/;"	m	class:ocr::GLogicProcessor
nRank	./GMemory/GMap/GMap.h	/^        ulong nRank,rank;       \/\/ округленное значение nLetter до ближайшей степени двойки nRank. Сама степень двойки равна rank$/;"	m	class:ocr::GMap
nReg0	./GGraph/GGraph.h	/^	uchar nReg0;  \/\/\/<количество единиц в регистре reg0_0$/;"	m	struct:ocr::OCRRegisterStruct
nReg1	./GGraph/GGraph.h	/^	uchar nReg1;  \/\/\/<количество единиц в регистре reg1_0$/;"	m	struct:ocr::OCRRegisterStruct
nReg2	./GGraph/GGraph.h	/^	uchar nReg2;  \/\/\/<количество единиц в регистре reg2_0$/;"	m	struct:ocr::OCRRegisterStruct
nRemovLayers	./GGraph/GGraph.h	/^	uint nRemovLayers; \/\/\/<количество слоев эррозии изображения$/;"	m	class:ocr::GGraph
name	./GFontEditor/GLetter.h	/^  GString name;$/;"	m	class:ocr::OCRMatchConst
name	./GFontEditor/GLetter.h	/^  string name;$/;"	m	class:ocr::GLetter
name	./GFontEditor/GLetter.h	/^  string name;$/;"	m	class:ocr::OCRMatch
name	./GFontEditor/GLetter.h	/^  string name;$/;"	m	class:ocr::stringOCR
name	./GFontEditor/GLetter.h	/^  string name;$/;"	m	class:ocr::wordOCR
name	./GGraph/GGraph.h	/^	GString name;$/;"	m	struct:ocr::OCRLetterStruct
name	./GMemory/GMemory.h	/^	string name;$/;"	m	class:ocr::tableRecord
name	./OCRAlgorithm/f2c.h	/^	char *name;$/;"	m	struct:Namelist
name	./OCRAlgorithm/f2c.h	/^	char *name;$/;"	m	struct:Vardesc
name	./OCRTypes/OCRTypes.h	/^  string name;$/;"	m	class:ocr::vectorOCR
name	./codeStorage.h	/^const char *rbuf, *name;$/;"	v
nameUni	./GFontEditor/GLetter.h	/^  GString nameUni;$/;"	m	class:ocr::OCRMatchConst
nameUni	./GFontEditor/GLetter.h	/^  string nameUni;$/;"	m	class:ocr::OCRMatch
ncnr	./GBitset/GBitset.h	/^  int ncnr;        \/\/\/< наибольшее из ncolumns и nrows те из ширины и высоты печа$/;"	m	class:ocr::GBitset
ncnr	./OCRAlgorithm/OCRAlgorithm.h	/^		 int ncnr;      \/\/\/<размерность буферных массивов фильтров$/;"	m	class:ocr::OCRFilter
ncolumns	./GBitmap/GBitmap.h	/^	int ncolumns;$/;"	m	class:ocr::GBitmap
ncolumns	./GBitset/GBitset.h	/^  unsigned short ncolumns;   \/\/\/<image height$/;"	m	class:ocr::GBitset
ncolumns	./GBitsetContour/GBitsetContour.h	/^  int ncolumns;          \/\/\/<ширина битмэпа$/;"	m	class:ocr::GBitsetContour
ncolumns	./GBitsetMatrix/GBitsetMatrix.h	/^  unsigned short ncolumns;      \/\/\/<ширина битмэпа$/;"	m	class:ocr::GBitsetMatrix
ncolumns	./GBitsetOCR/GBitsetOCR.h	/^  unsigned short ncolumns;$/;"	m	class:ocr::GBitsetOCR
newLetter	./GFontEditor/GLetter.h	/^  int newLetter;$/;"	m	class:ocr::GLetter
newLine	./GFontEditor/GLetter.h	/^  string newLine;$/;"	m	class:ocr::wordOCR
nextfree	./PNG/lodepng.cpp	/^  unsigned nextfree;$/;"	m	struct:BPMLists	file:
nfas	./GBitset/GBitset.h	/^		int nfas;    \/\/\/< количество фазовых сечений   1< nfas < 128;  16 или 32 вычисляемое значение$/;"	m	class:ocr::GBitset
nfasSt	./GBitset/GBitset.h	/^		int nfasSt;  \/\/\/< количество фазовых сечений   1< nfas < 128;  32  базовое значение$/;"	m	class:ocr::GBitset
nicematch	./PNG/lodepng.h	/^  unsigned nicematch; \/*stop searching if >= this length found. Set to 258 for best compression. Default: 128*\/$/;"	m	struct:LodePNGCompressSettings
node	./GGraph/GGraph.h	/^	ushort node[MAX_EXTREM]; \/\/\/< id номера производных линий (необходимо для lookup4)$/;"	m	struct:ocr::OCRLineStruct
nodeCount	./GGraph/GGraph.h	/^	uchar nodeCount; \/\/\/< количество производных линий после выделения экстремумов$/;"	m	struct:ocr::OCRLineStruct
nrows	./GBitmap/GBitmap.h	/^	int nrows;$/;"	m	class:ocr::GBitmap
nrows	./GBitset/GBitset.h	/^  unsigned short nrows;      \/\/\/<image width$/;"	m	class:ocr::GBitset
nrows	./GBitsetContour/GBitsetContour.h	/^  int nrows;             \/\/\/<высота битмэпа$/;"	m	class:ocr::GBitsetContour
nrows	./GBitsetMatrix/GBitsetMatrix.h	/^  unsigned short nrows;         \/\/\/<высота битмэпа$/;"	m	class:ocr::GBitsetMatrix
nrows	./GBitsetOCR/GBitsetOCR.h	/^  unsigned short nrows;$/;"	m	class:ocr::GBitsetOCR
num_cores	./config.h	/^	int num_cores; \/\/количество процессоров в системе$/;"	m	struct:commandData
numcodes	./PNG/lodepng.cpp	/^  unsigned numcodes; \/*number of symbols in the alphabet = number of codes*\/$/;"	m	struct:HuffmanTree	file:
numcolors	./PNG/lodepng.h	/^  unsigned numcolors; \/*amount of colors, up to 257. Not valid if bits == 16.*\/$/;"	m	struct:LodePNGColorProfile
numfree	./PNG/lodepng.cpp	/^  unsigned numfree;$/;"	m	struct:BPMLists	file:
numpixels	./PNG/lodepng.h	/^  size_t numpixels;$/;"	m	struct:LodePNGColorProfile
nvars	./OCRAlgorithm/f2c.h	/^	int nvars;$/;"	m	struct:Namelist
oacc	./OCRAlgorithm/f2c.h	/^	char *oacc;$/;"	m	struct:__anon7
objIndex	./OCRTypes/OCRTypes.h	/^  int objIndex;$/;"	m	class:ocr::vectorOCR
oblnk	./OCRAlgorithm/f2c.h	/^	char *oblnk;$/;"	m	struct:__anon7
ocr	./GBitMask/GBitMask.h	/^namespace ocr {$/;"	n
ocr	./GBitMask/GBitmask.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GBitMask/algorithmOCR_32.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GBitMask/matrixT.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GBitmap/GBitmap.cpp	/^namespace ocr$/;"	n	file:
ocr	./GBitmap/GBitmap.h	/^namespace ocr {$/;"	n
ocr	./GBitmap/GBitmapAutoLevel.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GBitmap/GBitmapBinarisation.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GBitmap/GBitmapDetectorRadon.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GBitmap/GBitmapFilter.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GBitmap/GBitmapFocalLine.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GBitmap/GBitmapPenWidth.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GBitmap/GBitmapRotate.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GBitmap/GBitmapScale.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GBitmap/GBitmapTextOrientation.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GBitset/GBitset.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GBitset/GBitset.h	/^namespace ocr {$/;"	n
ocr	./GBitsetContour/GBitsetContour.h	/^namespace ocr {$/;"	n
ocr	./GBitsetMatrix/GBitsetMatrix.h	/^namespace ocr {$/;"	n
ocr	./GBitsetOCR/GBitsetOCR.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GBitsetOCR/GBitsetOCR.h	/^namespace ocr{$/;"	n
ocr	./GFontEditor/GContour.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GFontEditor/GContour.h	/^namespace ocr {$/;"	n
ocr	./GFontEditor/GFont.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GFontEditor/GFont.h	/^namespace ocr {$/;"	n
ocr	./GFontEditor/GFontEditor.h	/^namespace ocr {$/;"	n
ocr	./GFontEditor/GLetter.h	/^namespace ocr {$/;"	n
ocr	./GGraph/GGraph.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GGraph/GGraph.h	/^namespace ocr {$/;"	n
ocr	./GGraph/GGraphAlgorithm.cpp	/^namespace ocr$/;"	n	file:
ocr	./GGraph/GGraphAttributeLinePixels.cpp	/^namespace ocr$/;"	n	file:
ocr	./GGraph/GGraphDetectFocalPoint.cpp	/^namespace ocr$/;"	n	file:
ocr	./GGraph/GGraphFindExtremPoints.cpp	/^namespace ocr$/;"	n	file:
ocr	./GGraph/GGraphFocalLineRecognition.cpp	/^namespace ocr$/;"	n	file:
ocr	./GGraph/GGraphFocalPoint.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GGraph/GGraphLetter.cpp	/^namespace ocr$/;"	n	file:
ocr	./GGraph/GGraphLetterCorrelation.cpp	/^namespace ocr$/;"	n	file:
ocr	./GGraph/GGraphOCRStar.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GGraph/GGraphSSE.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GGraph/GGraphStableFocalPoint.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GGraphBezier/GGraphBezier.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GGraphBezier/GGraphBezier.h	/^namespace ocr{$/;"	n
ocr	./GGraphBezier/GGraphBuildLetterSaBezier.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GGraphBezier/GGraphCorrelationBezierFullBezier.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GGraphBezier/GGraphCorrelationBezierPartBezier.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GGraphBezier/GGraphFocalLineBezier.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GGraphBezier/GGraphFocalLineRecLevelingBezier.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GGraphBezier/GGraphFocalLineRecognitionBezier.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GGraphBezier/GGraphFocalPointBezier.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GGraphBezier/GGraphLineMatrixBezier.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GGraphBezier/GGraphStableFocalPointBezier.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GGraphBezier/GGraphTestBezier.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GGraphOCR/GGraphOCR.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GGraphOCR/GGraphOCR.h	/^namespace ocr {$/;"	n
ocr	./GGraphOCR/GGraphOCRBuildOCRTable.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GGraphOCR/GGraphOCRCorrelation.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GGraphOCR/GGraphOCRCorrelationLookup2.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GGraphOCR/GGraphOCRCorrelationLookup3.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GGraphOCR/GGraphOCRCorrelationLookup4.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GGraphOCR/GGraphOCRFont.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GGraphOCR/GGraphOCRStarCorrelation.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GGraphOCR/GGraphOCRTextCorrelation.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GGraphOCR/GGraphOCRTextCorrelationHash.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GGraphOCR/GGraphOCRTextOCR.cpp	/^namespace ocr {$/;"	n	file:
ocr	./GImageEditor/GImageEditor.h	/^namespace ocr{$/;"	n
ocr	./GImageEditorOCR/GImageEditorOCR.h	/^namespace ocr{$/;"	n
ocr	./GLogicProcessor/GLogicProcessor.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GLogicProcessor/GLogicProcessor.h	/^namespace ocr{$/;"	n
ocr	./GMainEditor/GMainEditor.cpp	/^namespace ocr{$/;"	n	file:
ocr	./GMainEditor/GMainEditor.h	/^namespace ocr{$/;"	n
ocr	./GMemory/GMap/GMap.h	/^namespace ocr{$/;"	n
ocr	./GMemory/GMemory.cpp	/^namespace ocr$/;"	n	file:
ocr	./GMemory/GMemory.h	/^namespace ocr$/;"	n
ocr	./GMemory/GVector.h	/^namespace ocr$/;"	n
ocr	./GPDF/GPDF.h	/^namespace ocr{$/;"	n
ocr	./OCRAlgorithm/OCRAlgorithm.cpp	/^namespace ocr{$/;"	n	file:
ocr	./OCRAlgorithm/OCRAlgorithm.h	/^namespace ocr {$/;"	n
ocr	./OCRAlgorithm/OCRAlgorithmFFT.cpp	/^namespace ocr{$/;"	n	file:
ocr	./OCRTypes/OCRTypes.cpp	/^namespace ocr {$/;"	n	file:
ocr	./OCRTypes/OCRTypes.h	/^namespace ocr {$/;"	n
ocr	./OCRTypes/OCRTypes_www.h	/^namespace ocr {$/;"	n
oerr	./OCRAlgorithm/f2c.h	/^{	flag oerr;$/;"	m	struct:__anon7
offset	./GMemory/GMap/GMap.h	/^    ushort offset;$/;"	m	struct:pageRecordLink
ofm	./OCRAlgorithm/f2c.h	/^	char *ofm;$/;"	m	struct:__anon7
ofnm	./OCRAlgorithm/f2c.h	/^	char *ofnm;$/;"	m	struct:__anon7
ofnmlen	./OCRAlgorithm/f2c.h	/^	ftnlen ofnmlen;$/;"	m	struct:__anon7
oldName	./GFontEditor/GLetter.h	/^  string oldName;$/;"	m	class:ocr::stringOCR
oldName	./GFontEditor/GLetter.h	/^  string oldName;$/;"	m	class:ocr::wordOCR
olist	./OCRAlgorithm/f2c.h	/^} olist;$/;"	t	typeref:struct:__anon7
onOffRate	./GFontEditor/GLetter.h	/^  int onOffRate; \/\/\/соотношение площади буквы покрытой и не покрытой признаками$/;"	m	class:ocr::GLetter
openFontOCR	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::openFontOCR(const char *path) {$/;"	f	class:ocr::GGraphOCR
openType	./GFontEditor/GLetter.h	/^      *openType; \/\/\/массив габаритов всех составляющих букву элементов OpenType$/;"	m	class:ocr::GLetter
operator !=	./OCRTypes/OCRTypes.cpp	/^bool GString::operator!=(const GString ref) {$/;"	f	class:ocr::GString
operator !=	./OCRTypes/OCRTypes.cpp	/^bool GString::operator!=(const char *ref) {$/;"	f	class:ocr::GString
operator !=	./OCRTypes/OCRTypes.cpp	/^bool GString::operator!=(string &ref) {$/;"	f	class:ocr::GString
operator ()	./GFontEditor/GLetter.h	/^  bool operator()(wordOCR const &a, wordOCR const &b) const {$/;"	f	struct:ocr::wordOCR_sort
operator *	./OCRTypes/OCRTypes.cpp	/^OCRPointFloat OCRPointFloat::operator*(int n) {$/;"	f	class:ocr::OCRPointFloat
operator +	./OCRTypes/OCRTypes.cpp	/^void GString::operator+(const char *ref) {$/;"	f	class:ocr::GString
operator +=	./GFontEditor/GFont.cpp	/^    void  GFont::operator+=(GLetter *letter){$/;"	f	class:ocr::GFont
operator +=	./GFontEditor/GLetter.cpp	/^void  stringOCR::operator+=(stringOCR& ref){$/;"	f	class:stringOCR
operator +=	./GFontEditor/GLetter.cpp	/^void  stringOCR::operator+=(wordOCR ref){$/;"	f	class:stringOCR
operator +=	./GFontEditor/GLetter.cpp	/^void OCRMatch::operator+=(const OCRMatch &right){$/;"	f	class:OCRMatch
operator +=	./GMemory/GVector.cpp	/^void TString::operator+=(cstr str) {$/;"	f	class:TString
operator +=	./GMemory/GVector.cpp	/^void TString::operator+=(string &str) {$/;"	f	class:TString
operator +=	./GMemory/GVector.cpp	/^void TString::operator+=(uint i) {$/;"	f	class:TString
operator +=	./OCRTypes/OCRTypes.cpp	/^void GString::operator+=(const char *ref) {$/;"	f	class:ocr::GString
operator +=	./OCRTypes/OCRTypes.cpp	/^void GString::operator+=(int ref) {$/;"	f	class:ocr::GString
operator +=	./OCRTypes/OCRTypes.cpp	/^void GString::operator+=(string &ref) {$/;"	f	class:ocr::GString
operator +=	./OCRTypes/OCRTypes.cpp	/^void GString::operator+=(uint ref) {$/;"	f	class:ocr::GString
operator <	./GFontEditor/GLetter.cpp	/^int operator<(const GLetter &left, const GLetter &right){$/;"	f
operator <	./GFontEditor/GLetter.cpp	/^int operator<(const OCRMatch &left, const OCRMatch &right){$/;"	f
operator <	./GFontEditor/GLetter.h	/^  bool operator<(wordOCR &right) { return correlation < right.correlation; };$/;"	f	class:ocr::wordOCR
operator <	./OCRTypes/OCRTypes.cpp	/^int operator<(const OCRDictRecord &left, const OCRDictRecord &right) {$/;"	f	namespace:ocr
operator <	./OCRTypes/OCRTypes.cpp	/^int operator<(const dictKey &left, const dictKey &right) {$/;"	f	namespace:ocr
operator <	./OCRTypes/OCRTypes.h	/^  bool operator<(const hashRecord_ c) const { return (this->hash < c.hash); }$/;"	f	struct:ocr::hashRecord_
operator <	./OCRTypes/OCRTypes_www.h	/^		bool operator < (const hashRecord_ c) const{      $/;"	f	struct:ocr::hashRecord_
operator =	./GBitmap/GBitmap.cpp	/^inline GBitmap *GBitmap::operator=(const GBitmap *ref) {$/;"	f	class:ocr::GBitmap
operator =	./GBitset/GBitset.h	/^GBitset::operator=(const GBitset*ref)$/;"	f	class:ocr::GBitset
operator =	./GBitsetMatrix/GBitsetMatrix.h	/^GBitsetMatrix::operator=(const GBitsetMatrix*ref)$/;"	f	class:ocr::GBitsetMatrix
operator =	./GFontEditor/GLetter.cpp	/^void  wordOCR::operator=(wordOCR *ref){$/;"	f	class:wordOCR
operator =	./GFontEditor/GLetter.cpp	/^void OCRMatch::operator = (OCRMatchConst &right){$/;"	f	class:OCRMatch
operator =	./GFontEditor/GLetter.cpp	/^void OCRMatchConst::operator = (const OCRMatch &right){$/;"	f	class:OCRMatchConst
operator =	./OCRTypes/OCRTypes.cpp	/^void GString::operator=(const GString ref) {$/;"	f	class:ocr::GString
operator =	./OCRTypes/OCRTypes.cpp	/^void GString::operator=(const char *ref) {$/;"	f	class:ocr::GString
operator =	./OCRTypes/OCRTypes.cpp	/^void GString::operator=(string &ref) {$/;"	f	class:ocr::GString
operator =	./PNG/lodepng.cpp	/^State& State::operator=(const State& other)$/;"	f	class:lodepng::State
operator ==	./GFontEditor/GLetter.cpp	/^bool  wordOCR::operator==(vector<string> &ref){$/;"	f	class:wordOCR
operator ==	./GFontEditor/GLetter.cpp	/^int operator==(const GLetter &left, const GLetter &right){$/;"	f
operator ==	./GFontEditor/GLetter.cpp	/^int operator==(const OCRMatch &left, const OCRMatch &right){$/;"	f
operator ==	./GFontEditor/GLetter.h	/^  int operator==(stringOCR &wt) {$/;"	f	class:ocr::stringOCR
operator ==	./OCRTypes/OCRTypes.cpp	/^bool GString::operator==(const GString ref) {$/;"	f	class:ocr::GString
operator ==	./OCRTypes/OCRTypes.cpp	/^bool GString::operator==(const char *ref) {$/;"	f	class:ocr::GString
operator ==	./OCRTypes/OCRTypes.cpp	/^bool GString::operator==(string &ref) {$/;"	f	class:ocr::GString
operator ==	./OCRTypes/OCRTypes.cpp	/^int operator==(const OCRDictRecord &left, const OCRDictRecord &right) {$/;"	f	namespace:ocr
operator ==	./OCRTypes/OCRTypes.cpp	/^int operator==(const dictKey &left, const dictKey &right) {$/;"	f	namespace:ocr
operator ==	./OCRTypes/OCRTypes.h	/^  bool operator==(const hashRecord_ c) const { return (this->hash == c.hash); }$/;"	f	struct:ocr::hashRecord_
operator ==	./OCRTypes/OCRTypes_www.h	/^		bool operator == (const hashRecord_ c) const$/;"	f	struct:ocr::hashRecord_
operator []	./GBitmap/GBitmap.cpp	/^inline const unsigned char *GBitmap::operator[](int row) const {$/;"	f	class:ocr::GBitmap
operator []	./GBitmap/GBitmap.cpp	/^inline unsigned char *GBitmap::operator[](int row) {$/;"	f	class:ocr::GBitmap
operator []	./GBitset/GBitset.h	/^GBitset::operator[](int row) const$/;"	f	class:ocr::GBitset
operator []	./GBitset/GBitset.h	/^GBitset::operator[](int row)$/;"	f	class:ocr::GBitset
operator []	./GBitsetContour/GBitsetContour.h	/^GBitsetContour::operator[](int row) const$/;"	f	class:ocr::GBitsetContour
operator []	./GBitsetContour/GBitsetContour.h	/^GBitsetContour::operator[](int row)$/;"	f	class:ocr::GBitsetContour
operator []	./GBitsetMatrix/GBitsetMatrix.h	/^GBitsetMatrix::operator[](int row) const$/;"	f	class:ocr::GBitsetMatrix
operator []	./GBitsetMatrix/GBitsetMatrix.h	/^GBitsetMatrix::operator[](int row)$/;"	f	class:ocr::GBitsetMatrix
operator []	./GBitsetOCR/GBitsetOCR.h	/^GBitsetOCR::operator[](int row)$/;"	f	class:ocr::GBitsetOCR
operator []	./GFontEditor/GFontEditor.cpp	/^GFont*  GFontEditor::operator[](int index){$/;"	f	class:GFontEditor
operator []	./GFontEditor/GLetter.cpp	/^wordOCR*  stringOCR::operator[](int index){$/;"	f	class:stringOCR
operator []	./GMemory/GVector.cpp	/^string TString::operator[](uint i) {$/;"	f	class:TString
operator []	./GMemory/GVector.cpp	/^void *GVector::operator[](const char *name) {$/;"	f	class:GVector
operator []	./GMemory/GVector.h	/^T &GStr<T>::operator[](ulong id) {$/;"	f	class:ocr::GStr
operator []	./GMemory/GVector.h	/^T *GStr2D<T>::operator[](uint index_) {$/;"	f	class:ocr::GStr2D
operator []	./OCRTypes/OCRTypes.cpp	/^inline char *GString::operator[](int id) {$/;"	f	class:ocr::GString
optimizationSkew	./GBitmap/GBitmapDetectorRadon.cpp	/^  void GBitmap::optimizationSkew( unsigned int g ) {$/;"	f	class:ocr::GBitmap
optimizationW	./GBitmap/GBitmapDetectorRadon.cpp	/^  void GBitmap::optimizationW( int g ) {$/;"	f	class:ocr::GBitmap
orl	./OCRAlgorithm/f2c.h	/^	ftnint orl;$/;"	m	struct:__anon7
osta	./OCRAlgorithm/f2c.h	/^	char *osta;$/;"	m	struct:__anon7
ounit	./OCRAlgorithm/f2c.h	/^	ftnint ounit;$/;"	m	struct:__anon7
out	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^ostringstream out;$/;"	m	namespace:ocr	file:
p	./test_clang.h	/^char *p; \/\/\/char p$/;"	v
p0	./GGraphBezier/GGraphBezier.h	/^        OCRPointFloat p0;        \/\/ координаты начальной точки кривой Безье апроксимирующей фокальную линию (могут не совпадать с точкой start).$/;"	m	class:ocr::OCRFocalLineBezier
p0_c	./GGraphBezier/GGraphBezier.h	/^        OCRPointFloat p0_c;      \/\/ координаты начальной точки кривой Безье приведенные к её середине.$/;"	m	class:ocr::OCRFocalLineBezier
p0_r	./GGraph/GGraph.h	/^	int p0_r;		 \/\/\/< регистры проверки точек линии по маске 32х32$/;"	m	struct:ocr::OCRLineStruct
p0_y	./GGraph/GGraph.h	/^	uchar p0_y;$/;"	m	struct:ocr::OCRLineStruct
p1	./GBitsetContour/GBitsetContour.h	/^	unsigned char *p1, *p2;$/;"	m	class:ocr::GBitsetContour
p1	./GGraphBezier/GGraphBezier.h	/^        OCRPointFloat p1;        \/\/ координаты первой контрольной точки кривой Безье апроксимирующей фокальную линию.$/;"	m	class:ocr::OCRFocalLineBezier
p1_r	./GGraph/GGraph.h	/^	int p1_r;$/;"	m	struct:ocr::OCRLineStruct
p1_y	./GGraph/GGraph.h	/^	uchar p1_y;$/;"	m	struct:ocr::OCRLineStruct
p1letter	./GMemory/GMap/GMap.cpp	/^string GMap::p1letter(mSIZE code){$/;"	f	class:GMap
p2	./GBitsetContour/GBitsetContour.h	/^	unsigned char *p1, *p2;$/;"	m	class:ocr::GBitsetContour
p2	./GGraphBezier/GGraphBezier.h	/^        OCRPointFloat p2;        \/\/ координаты второй контрольной точки кривой Безье апроксимирующей фокальную линию.$/;"	m	class:ocr::OCRFocalLineBezier
p2_r	./GGraph/GGraph.h	/^	int p2_r;$/;"	m	struct:ocr::OCRLineStruct
p2_y	./GGraph/GGraph.h	/^	uchar p2_y;$/;"	m	struct:ocr::OCRLineStruct
p2letter	./GMemory/GMap/GMap.cpp	/^string GMap::p2letter(mSIZE code){$/;"	f	class:GMap
p3	./GBitsetContour/GBitsetContour.h	/^	short *p3;$/;"	m	class:ocr::GBitsetContour
p3	./GGraphBezier/GGraphBezier.h	/^        OCRPointFloat p3;        \/\/ координаты конечной точки кривой Безье апроксимирующей фокальную линию (могут не совпадать с точкой end).$/;"	m	class:ocr::OCRFocalLineBezier
p3_c	./GGraphBezier/GGraphBezier.h	/^        OCRPointFloat p3_c;      \/\/ координаты конечной точки кривой Безье приведенные к ее середине.$/;"	m	class:ocr::OCRFocalLineBezier
p3_r	./GGraph/GGraph.h	/^	int p3_r;$/;"	m	struct:ocr::OCRLineStruct
p3_y	./GGraph/GGraph.h	/^	uchar p3_y;$/;"	m	struct:ocr::OCRLineStruct
p4_r	./GGraph/GGraph.h	/^	int p4_r;$/;"	m	struct:ocr::OCRLineStruct
p4_y	./GGraph/GGraph.h	/^	uchar p4_y;$/;"	m	struct:ocr::OCRLineStruct
pCount	./GFontEditor/GLetter.h	/^  int pCount; \/\/количество пикселов буквы$/;"	m	class:ocr::OCRMatch
pCount	./GGraph/GGraph.h	/^	uint pCount; \/\/\/<количество инициализированных точек в pointsArray$/;"	m	class:ocr::GGraph
pLink	./GMemory/GMap/GMap.h	/^}pLink;$/;"	t	typeref:struct:pageLink
pSum	./GFontEditor/GLetter.h	/^  vector<uint> pSum; \/\/ массив интегральных сумм (описание в testWordLine.cpp)$/;"	m	class:ocr::OCRMatch
pTicks	./config.h	/^} pTicks; \/\/структура данных запроса числа тактов процессора (один такт 0.3 наносекунды, 3.3GHz)$/;"	t	typeref:union:ticks
pW	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int pW = 5;$/;"	m	namespace:ocr	file:
packBitMask	./GBitMask/algorithmOCR_32.cpp	/^    void GBitMask32::packBitMask(){$/;"	f	class:ocr::GBitMask32
packBitMask	./GBitMask/algorithmOCR_32.cpp	/^    void GBitMask32::packBitMask(GBitmap *img){$/;"	f	class:ocr::GBitMask32
packBitMask	./GBitMask/algorithmOCR_32.cpp	/^    void GBitMask32::packBitMask(unsigned int *MaskInt,$/;"	f	class:ocr::GBitMask32
packBitMask128	./GBitMask/algorithmOCR_128.cpp	/^ void GBitMask128::packBitMask128(GBitmap *img){$/;"	f	class:GBitMask128
packImg	./GBitmap/GBitmap.cpp	/^void GBitmap::packImg(int invert) {$/;"	f	class:ocr::GBitmap
packImg32	./GBitmap/GBitmap.cpp	/^void GBitmap::packImg32(int invert) {$/;"	f	class:ocr::GBitmap
packImg32V	./GBitmap/GBitmap32.cpp	/^void GBitmap::packImg32V(int invert){$/;"	f	class:GBitmap
packImg32V_	./GGraph/GGraph.cpp	/^uchar*  GGraph::packImg32V_(int w, int h, uchar *bytes_data_){$/;"	f	class:ocr::GGraph
pack_flag	./GBitmap/GBitmap.h	/^	unsigned int pack_flag; \/\/ 1 массив bites_data запакован функцией packImg$/;"	m	class:ocr::GBitmap
paethPredictor	./PNG/lodepng.cpp	/^static unsigned char paethPredictor(short a, short b, short c)$/;"	f	file:
pageLink	./GMemory/GMap/GMap.h	/^typedef struct pageLink{$/;"	s
pageNum	./GPDF/GPDF.h	/^    uint pageNum;$/;"	m	class:ocr::GPDF
pageOCR	./GBitsetOCR/pageOCR.cpp	/^void GBitsetOCR::pageOCR(GLogicProcessor *logicProcessor, int mode){$/;"	f	class:GBitsetOCR
pagePointDetector	./GBitset/GBitsetPoint.cpp	/^void GBitset::pagePointDetector(){$/;"	f	class:GBitset
pageRecordLink	./GMemory/GMap/GMap.h	/^typedef struct pageRecordLink{$/;"	s
pageScale	./GBitsetOCR/GBitsetOCR.h	/^  float pageScale;$/;"	m	class:ocr::GBitsetOCR
pageSegmentation	./GLogicProcessor/pageSegmentation.cpp	/^void GLogicProcessor::pageSegmentation(vector<OCRMatch>&matchLine,vector<OCRLine>&focalLine,int pageW,int dY){$/;"	f	class:GLogicProcessor
pageSegmentationBitset	./GBitset/GBitsetPageSegmentation.cpp	/^void GBitset::pageSegmentationBitset() {$/;"	f	class:GBitset
pageStart	./GBitset/GBitset.cpp	/^void GBitset::pageStart(vector<vector<int> > &INFase,$/;"	f	class:ocr::GBitset
pageStringDetector	./GBitset/GBitset_Starting.cpp	/^void GBitset::pageStringDetector(vector<stringOCR>&strArray_,int mode){$/;"	f	class:GBitset
palette	./PNG/lodepng.h	/^  unsigned char palette[1024]; \/*Remembers up to the first 256 RGBA colors, in no particular order*\/$/;"	m	struct:LodePNGColorProfile
palette	./PNG/lodepng.h	/^  unsigned char* palette; \/*palette in RGBARGBA... order. When allocated, must be either 0, or have size 1024*\/$/;"	m	struct:LodePNGColorMode
palettesize	./PNG/lodepng.h	/^  size_t palettesize; \/*palette size in number of colors (amount of bytes is 4 * palettesize)*\/$/;"	m	struct:LodePNGColorMode
parent	./GMemory/GVector.h	/^    GVector *   parent;$/;"	m	class:ocr::GVector
parent	./GMemory/GVector.h	/^    GVector *parent;$/;"	m	class:ocr::GStr
parentID	./GGraph/GGraph.h	/^	uint parentID;	 \/\/\/< id номер родительской линии$/;"	m	struct:ocr::OCRLineStruct
parseQuery	./OCRString/php2stl.cpp	/^void parseQuery() {$/;"	f
path	./GFontEditor/GLetter.h	/^  string path;  \/\/ original text filename$/;"	m	class:ocr::stringOCR
path	./GMemory/GVector.h	/^    string path() {$/;"	f	class:ocr::GVector
path	./OCRTypes/OCRTypes.h	/^  string path;$/;"	m	struct:ocr::sData
pdp11	./OCRAlgorithm/f2c.h	210;"	d
pechaDataLoaded	./GMainEditor/GMainEditor.h	/^		int pechaDataLoaded;$/;"	m	class:ocr::GMainEditor
pechaImg	./GMainEditor/GMainEditor.h	/^        GBitmap *pechaImg, *baseImg;              \/\/\/<global bitmap data$/;"	m	class:ocr::GMainEditor
phys_defined	./PNG/lodepng.h	/^  unsigned phys_defined; \/*if 0, there is no pHYs chunk and the values below are undefined, if 1 else there is one*\/$/;"	m	struct:LodePNGInfo
phys_unit	./PNG/lodepng.h	/^  unsigned phys_unit; \/*may be 0 (unknown unit) or 1 (metre)*\/$/;"	m	struct:LodePNGInfo
phys_x	./PNG/lodepng.h	/^  unsigned phys_x; \/*pixels per unit in x direction*\/$/;"	m	struct:LodePNGInfo
phys_y	./PNG/lodepng.h	/^  unsigned phys_y; \/*pixels per unit in y direction*\/$/;"	m	struct:LodePNGInfo
pict	./GFontEditor/GLetter.h	/^  GBitmap *pict;                   \/\/\/изображение буквы$/;"	m	class:ocr::GLetter
pictFlag	./GFontEditor/GLetter.h	/^  int pictFlag; \/\/\/флаг наличия изображения в букве$/;"	m	class:ocr::GLetter
pid	./OCRTypes/OCRTypes.h	/^  int pid;$/;"	m	struct:ocr::pidIDStruct
pid	./OCRTypes/OCRTypes_www.h	/^        int pid;$/;"	m	struct:ocr::pidIDStruct
pidID	./OCRTypes/OCRTypes.h	/^} pidID;$/;"	t	namespace:ocr	typeref:struct:ocr::pidIDStruct
pidID	./OCRTypes/OCRTypes_www.h	/^	}pidID;$/;"	t	namespace:ocr	typeref:struct:ocr::pidIDStruct
pidIDStruct	./OCRTypes/OCRTypes.h	/^typedef struct pidIDStruct {$/;"	s	namespace:ocr
pidIDStruct	./OCRTypes/OCRTypes_www.h	/^    typedef struct pidIDStruct{$/;"	s	namespace:ocr
pixelCount	./GBitmap/GBitmap32.cpp	/^int GBitmap::pixelCount(OCRBox *s){$/;"	f	class:GBitmap
pkbuf	./codeStorage.h	/^char pkbuf[256];$/;"	v
pksiz	./codeStorage.h	/^int ecode, pksiz, i, rsiz;$/;"	v
point	./GGraph/GGraph.h	/^	OCRPoint *point; \/\/\/<массив точек отцифровки линий буквы$/;"	m	struct:ocr::OCRLetterStruct
point	./GGraph/GGraph.h	/^	OCRPoint point[12]; \/\/\/<массив фокальных точек концов лучей и опорных линий.$/;"	m	struct:ocr::OCRStarStruct
pointArray	./GGraph/GGraph.h	/^	GStr<OCRPoint> pointArray;$/;"	m	class:ocr::GGraph
pointCassidy	./OCRTypes/OCRTypes.h	/^  int pointCassidy;$/;"	m	class:ocr::vectorOCR
pointCount	./GGraph/GGraph.h	/^	uchar pointCount;$/;"	m	struct:ocr::OCRStarStruct
pointCount	./GGraph/GGraph.h	/^	ushort pointCount; \/\/\/<количество точек отцифровки линий буквы;$/;"	m	struct:ocr::OCRLetterStruct
pointDraw	./GBitset/GBitset_algorithm.cpp	/^void GBitset::pointDraw(int color){$/;"	f	class:GBitset
pointIndex	./GGraph/GGraph.h	/^	uint pointIndex; \/\/\/< индекс первой точки линии в массиве pointArray$/;"	m	struct:ocr::OCRLineStruct
pointLine	./OCRTypes/OCRTypes.h	/^struct pointLine {$/;"	s	namespace:ocr
pointLine	./OCRTypes/OCRTypes_www.h	/^    struct pointLine{$/;"	s	namespace:ocr
pointReg	./GGraphOCR/GGraphOCR.h	/^	GStr<int> pointReg;		   \/\/\/< массив занятости фокальных точек текста$/;"	m	class:ocr::GGraphOCR
pointRegCluster	./GGraphOCR/GGraphOCR.h	/^	GStr<int> pointRegCluster; \/\/\/< массив занятости фокальных точек текста первого кластера эталона$/;"	m	class:ocr::GGraphOCR
pointsAngle	./OCRAlgorithm/OCRAlgorithm.cpp	/^float pointsAngle(OCRPoint &p0, OCRPoint &p1, OCRPoint &p2){$/;"	f	namespace:ocr
pointsArray	./GGraph/GGraph.h	/^	GStr<OCRPoint> pointsArray;$/;"	m	class:ocr::GGraph
poolSize	./GMemory/GVector.h	/^    ulong *poolSize;  \/\/общий размер файла вектора$/;"	m	class:ocr::GStr
poolSize	./GMemory/GVector.h	/^    ulong *poolSize;  \/\/общий размер файла вектора$/;"	m	class:ocr::GVector
pop_back	./GMemory/GVector.h	/^void GStr<T>::pop_back() {$/;"	f	class:ocr::GStr
pop_backMask	./GFontEditor/GLetter.h	/^  void pop_backMask() { mask32Vector->pop_back(); }; \/\/\/<стирает последнюю маску$/;"	f	class:ocr::GLetter
postProcessScanlines	./PNG/lodepng.cpp	/^static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,$/;"	f	file:
power_Two	./OCRAlgorithm/OCRAlgorithm.cpp	/^void power_Two(unsigned int* PowerTwo){ $/;"	f	namespace:ocr
preProcessScanlines	./PNG/lodepng.cpp	/^static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,$/;"	f	file:
predefined_filters	./PNG/lodepng.h	/^  const unsigned char* predefined_filters;$/;"	m	struct:LodePNGEncoderSettings
pref	./config.h	/^	void *pref;		  \/\/ GStr<int> сохраняемых данных программы$/;"	m	struct:commandData
prefVector	./config.h	/^	void *prefVector; \/\/ GVector сохраняемых данных программы$/;"	m	struct:commandData
print	./GLogicProcessor/GLogicProcessor.h	/^	int print;$/;"	m	class:ocr::GLogicProcessor
print	./GMainEditor/GMainEditor.h	/^		int print;$/;"	m	class:ocr::GMainEditor
printClusterMaskSVG	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void printClusterMaskSVG(OCRStar &star,OCRStar *starArray, OCRLine *focalLine,OCRPoint *pointsArray){$/;"	f	namespace:ocr
printCorrelation	./GGraphOCR/GGraphOCR.h	/^	uint printCorrelation;	   \/\/\/< глобальная переменная вывод отладки корреляции буквы$/;"	m	class:ocr::GGraphOCR
printDIndex	./GLogicProcessor/testWordLine.cpp	/^void GLogicProcessor::printDIndex(OCRMatch &a){$/;"	f	class:GLogicProcessor
printDictEntry	./GMemory/GMap/GMap.cpp	/^void GMap::printDictEntry(ulong n){$/;"	f	class:GMap
printDictTextLine	./GMemory/GMap/GMap.cpp	/^void GMap::printDictTextLine(ulong n){$/;"	f	class:GMap
printHeadStyle	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void printHeadStyle(int mode) {$/;"	f	namespace:ocr
printImg	./GFontEditor/GFontEditor.h	/^        int printImg;$/;"	m	class:ocr::GFontEditor
printInputEntry	./GMemory/GMap/GMap.cpp	/^void GMap::printInputEntry(){$/;"	f	class:GMap
printLetterImg	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void GGraphOCR::printLetterImg(OCRLetter &letter) {$/;"	f	class:ocr::GGraphOCR
printLetterImgSVG	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void printLetterImgSVG(OCRLetter &letter) {$/;"	f	namespace:ocr
printLetterLineDirLable	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void printLetterLineDirLable(OCRStar &star,OCRLine *lines,OCRPoint *points,uchar mode) {$/;"	f	namespace:ocr
printLetterOCRStarBaseLine	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void printLetterOCRStarBaseLine(OCRStar &star) {$/;"	f	namespace:ocr
printLetterOCRStarSVG	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void printLetterOCRStarSVG(OCRLetter &letter, OCRStar &star) {$/;"	f	namespace:ocr
printLetterSVG	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void GGraphOCR::printLetterSVG(OCRLetter &letter, cstr path) {$/;"	f	class:ocr::GGraphOCR
printLine	./GGraph/GGraphAlgorithm.cpp	/^void GGraph::printLine(OCRLine &line) {$/;"	f	class:ocr::GGraph
printLine	./GGraphOCR/GGraphOCR.cpp	/^void GGraphOCR::printLine(OCRLetter &letter, OCRLine &line) {$/;"	f	class:ocr::GGraphOCR
printLineSVG	./GGraph/GGraphAlgorithm.cpp	/^void GGraph::printLineSVG(OCRLine &line, string &str){$/;"	f	class:ocr::GGraph
printLines	./GGraph/GGraphAlgorithm.cpp	/^void GGraph::printLines() {$/;"	f	class:ocr::GGraph
printList	./OCRString/php2stl.cpp	/^void printList(list<string> &list) {$/;"	f
printMap	./OCRString/php2stl.cpp	/^void printMap(map<string, string> &map) {$/;"	f
printMask	./GBitMask/algorithmOCR_128.cpp	/^void GBitMask128::printMask(){$/;"	f	class:GBitMask128
printMask	./GBitMask/algorithmOCR_32.cpp	/^    void GBitMask32::printMask(){$/;"	f	class:ocr::GBitMask32
printMask	./GBitMask/algorithmOCR_32.cpp	/^    void GBitMask32::printMask(ofstream &c_out){$/;"	f	class:ocr::GBitMask32
printMask	./GBitMask/algorithmOCR_32.cpp	/^    void GBitMask32::printMask(unsigned int *MaskInt){$/;"	f	class:ocr::GBitMask32
printMask	./GBitMask/algorithmOCR_32.cpp	/^    void GBitMask32::printMask(unsigned int *MaskInt, ofstream &c_out){$/;"	f	class:ocr::GBitMask32
printMask1	./GBitMask/algorithmOCR_32.cpp	/^    void GBitMask32::printMask1(ofstream &c_out){$/;"	f	class:ocr::GBitMask32
printOCRLineLabel	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void printOCRLineLabel(OCRLine &line, OCRPoint *points) {$/;"	f	namespace:ocr
printOCRLineMaskSVG	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void printOCRLineMaskSVG(OCRLine &line,OCRPoint *pointData, int mode) {$/;"	f	namespace:ocr
printOCRMask	./GGraph/GGraphAlgorithm.cpp	/^void GGraph::printOCRMask(int *p) {$/;"	f	class:ocr::GGraph
printOCRMask	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::printOCRMask(int *p) {$/;"	f	class:ocr::GGraphOCR
printOCRStarCluster	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void printOCRStarCluster(OCRStar &star) {$/;"	f	namespace:ocr
printOCRStarHash	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void printOCRStarHash(OCRStar &star) {$/;"	f	namespace:ocr
printOCRStarPoint	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void printOCRStarPoint(OCRStar &star) {$/;"	f	namespace:ocr
printPoint	./GGraph/GGraph.cpp	/^void GGraph::printPoint(int x, int y) {$/;"	f	class:ocr::GGraph
printPointP	./GGraph/GGraph.cpp	/^void GGraph::printPointP(unsigned char *p0) {$/;"	f	class:ocr::GGraph
printPointS	./GGraph/GGraph.cpp	/^void GGraph::printPointS(int sl) {$/;"	f	class:ocr::GGraph
printReg	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^void printReg(uint64 &reg, cstr text){$/;"	f	namespace:ocr
printSVG	./GGraph/GGraphAlgorithm.cpp	/^void GGraph::printSVG(cstr path){$/;"	f	class:ocr::GGraph
printStar	./GGraph/GGraphAlgorithm.cpp	/^void GGraph::printStar(OCRStar &star) {$/;"	f	class:ocr::GGraph
printStar	./GGraphOCR/GGraphOCR.cpp	/^void GGraphOCR::printStar(OCRLetter &letter, OCRStar &star) {$/;"	f	class:ocr::GGraphOCR
printStarSVG	./GGraph/GGraphAlgorithm.cpp	/^void GGraph::printStarSVG(OCRStar &star, string &str){$/;"	f	class:ocr::GGraph
printStars	./GGraph/GGraphAlgorithm.cpp	/^void GGraph::printStars(const char *path, int mode) {$/;"	f	class:ocr::GGraph
printToScreen	./GBitmap/GBitmap.cpp	/^void GBitmap::printToScreen() {$/;"	f	class:ocr::GBitmap
printToScreen	./GGraphBezier/GGraphBezier.cpp	/^void OCRFocalLineBezier::printToScreen(){$/;"	f	class:ocr::OCRFocalLineBezier
printToScreenBinary	./GBitmap/GBitmap.cpp	/^void GBitmap::printToScreenBinary() {$/;"	f	class:ocr::GBitmap
proccessImage	./GImageEditorOCR/imageProcessOCR.cpp	/^void proccessImage(GBitmap *pechaImg,float *param){$/;"	f
processID	./config.h	/^	int processID;$/;"	m	struct:commandData
processIDStatus	./config.h	/^	int processIDStatus[100];$/;"	m	struct:commandData
processInput	./processInput.cpp	/^void processInput(string &destString) {$/;"	f
processKey	./GMemory/GMap/tableDict.cpp	/^void GMap::processKey(string &key,uint index, uint field){$/;"	f	class:GMap
processKeyWordlist	./GMemory/GMap/tableDict.cpp	/^void GMap::processKeyWordlist(string &key,ulong index, uint field){$/;"	f	class:GMap
proportion	./GBitsetOCR/GBitsetOCR.h	/^  int iLeft, iTop, letterWsum, letterHsum,proportion;$/;"	m	class:ocr::GBitsetOCR
ptrToStr	./OCRString/php2stl.cpp	/^string ptrToStr(cstr st, int ln) {$/;"	f
push_Ptr	./GMemory/GVector.h	/^void GStr<T>::push_Ptr(void *dat, ulong size) {$/;"	f	class:ocr::GStr
push_TabStr	./GMemory/GVector.cpp	/^void TString::push_TabStr(string &str) {$/;"	f	class:TString
push_back	./GFontEditor/GFont.cpp	/^    void GFont::push_back(GLetter *letter){$/;"	f	class:ocr::GFont
push_back	./GFontEditor/GLetter.cpp	/^void GLetter::push_back(GBitMask32 &mask){$/;"	f	class:GLetter
push_back	./GFontEditor/GLetter.cpp	/^void GLetter::push_back(keyOCR &mask){$/;"	f	class:GLetter
push_back	./GFontEditor/GLetter.cpp	/^void stringOCR::push_back(const wordOCR &word){$/;"	f	class:stringOCR
push_back	./GMemory/GVector.cpp	/^void GVector::push_back(TString &st) {$/;"	f	class:GVector
push_back	./GMemory/GVector.cpp	/^void GVector::push_back(char *str, ulong size) {$/;"	f	class:GVector
push_back	./GMemory/GVector.cpp	/^void GVector::push_back(const char *str) {$/;"	f	class:GVector
push_back	./GMemory/GVector.cpp	/^void GVector::push_back(string &str) {$/;"	f	class:GVector
push_back	./GMemory/GVector.cpp	/^void GVector::push_back(string &str, cstr name) {$/;"	f	class:GVector
push_back	./GMemory/GVector.cpp	/^void TString::push_back(TString &st) {$/;"	f	class:TString
push_back	./GMemory/GVector.cpp	/^void TString::push_back(char *ptr, uint size_) {$/;"	f	class:TString
push_back	./GMemory/GVector.cpp	/^void TString::push_back(const char *str) {$/;"	f	class:TString
push_back	./GMemory/GVector.cpp	/^void TString::push_back(string &str) {$/;"	f	class:TString
push_back	./GMemory/GVector.cpp	/^void TString::push_back(uint intData) {$/;"	f	class:TString
push_back	./GMemory/GVector.h	/^void GStr<T>::push_back(T dat) {$/;"	f	class:ocr::GStr
push_backL	./GMemory/GVector.cpp	/^void TString::push_backL(ulong longData) {$/;"	f	class:TString
put	./GBitmap/GBitmap.cpp	/^void GBitmap::put(int x, int y, int color) {$/;"	f	class:ocr::GBitmap
put	./GMemory/GVector.h	/^void GStr<T>::put(ulong indexRecord, T dat) {$/;"	f	class:ocr::GStr
putCStr	./GMemory/GVector.cpp	/^void GVector::putCStr(ulong indexRecord, const char *str) {$/;"	f	class:GVector
putInt	./GMemory/GVector.cpp	/^void GVector::putInt(ulong indexRecord, int data) {$/;"	f	class:GVector
putName	./GMemory/GVector.cpp	/^void GVector::putName(string &str) {$/;"	f	class:GVector
putPtr	./GMemory/GVector.cpp	/^void GVector::putPtr(ulong indexRecord, void *ptr, ulong size) {$/;"	f	class:GVector
putPtr	./GMemory/GVector.h	/^void GStr<T>::putPtr(ulong indexRecord, void *dat, ulong size) {$/;"	f	class:ocr::GStr
putStr	./GMemory/GVector.cpp	/^void GVector::putStr(ulong indexRecord, string &str) {$/;"	f	class:GVector
putStr	./GMemory/GVector.cpp	/^void GVector::putStr(ulong indexRecord, vector<uint> &str) {$/;"	f	class:GVector
putTStr	./GMemory/GVector.cpp	/^void GVector::putTStr(ulong indexRecord, TString &st) {$/;"	f	class:GVector
qbit_clear	./OCRAlgorithm/f2c.h	26;"	d
qbit_set	./OCRAlgorithm/f2c.h	27;"	d
qry	./codeStorage.h	/^TDBQRY *qry;$/;"	v
r	./OCRAlgorithm/f2c.h	/^	real r;$/;"	m	union:Multitype
r	./OCRAlgorithm/f2c.h	/^typedef struct { doublereal r, i; } doublecomplex;$/;"	m	struct:__anon4
r	./OCRAlgorithm/f2c.h	/^typedef struct { real r, i; } complex;$/;"	m	struct:__anon3
r1	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int r1,r2,r3,r4;$/;"	m	namespace:ocr	file:
r2	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int r1,r2,r3,r4;$/;"	m	namespace:ocr	file:
r3	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int r1,r2,r3,r4;$/;"	m	namespace:ocr	file:
r4	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int r1,r2,r3,r4;$/;"	m	namespace:ocr	file:
rLink	./GMemory/GMap/GMap.h	/^}rLink;$/;"	t	typeref:struct:pageRecordLink
radius	./GGraph/GGraph.h	/^	float radius; \/\/\/< радиус$/;"	m	struct:ocr::OCRStarStruct
radius	./GGraphBezier/GGraphBezier.h	/^        int radius;         \/\/ - радиус круга в pix.$/;"	m	class:ocr::OCRFocalLineBezier
rank	./GLogicProcessor/GLogicProcessor.h	/^    unsigned int nRank,rank;       \/\/ округленное значение nLetter до ближайшей степени двойки nRank. Сама степень двойки равна rank $/;"	m	class:ocr::GLogicProcessor
rank	./GMemory/GMap/GMap.h	/^        ulong nRank,rank;       \/\/ округленное значение nLetter до ближайшей степени двойки nRank. Сама степень двойки равна rank$/;"	m	class:ocr::GMap
rbuf	./codeStorage.h	/^const char *rbuf, *name;$/;"	v
read	./GMemory/GVector.h	/^void GStr<T>::read(cstr path) {$/;"	f	class:ocr::GStr
readBitFromReversedStream	./PNG/lodepng.cpp	/^static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream)$/;"	f	file:
readBitFromStream	./PNG/lodepng.cpp	/^static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)$/;"	f	file:
readBitsFromReversedStream	./PNG/lodepng.cpp	/^static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)$/;"	f	file:
readBitsFromStream	./PNG/lodepng.cpp	/^static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)$/;"	f	file:
readChunk_PLTE	./PNG/lodepng.cpp	/^static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength)$/;"	f	file:
readChunk_bKGD	./PNG/lodepng.cpp	/^static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)$/;"	f	file:
readChunk_cHRM	./PNG/lodepng.cpp	/^static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)$/;"	f	file:
readChunk_gAMA	./PNG/lodepng.cpp	/^static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)$/;"	f	file:
readChunk_iCCP	./PNG/lodepng.cpp	/^static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecompressSettings* zlibsettings,$/;"	f	file:
readChunk_iTXt	./PNG/lodepng.cpp	/^static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecompressSettings* zlibsettings,$/;"	f	file:
readChunk_pHYs	./PNG/lodepng.cpp	/^static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)$/;"	f	file:
readChunk_sRGB	./PNG/lodepng.cpp	/^static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)$/;"	f	file:
readChunk_tEXt	./PNG/lodepng.cpp	/^static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)$/;"	f	file:
readChunk_tIME	./PNG/lodepng.cpp	/^static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)$/;"	f	file:
readChunk_tRNS	./PNG/lodepng.cpp	/^static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength)$/;"	f	file:
readChunk_zTXt	./PNG/lodepng.cpp	/^static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecompressSettings* zlibsettings,$/;"	f	file:
readData2JPG	./OCRString/php2stl.cpp	/^void readData2JPG(cstr file) {$/;"	f
readDataTXT	./GMemory/GMap/tableDict.cpp	/^void GMap::readDataTXT(string &path){$/;"	f	class:GMap
readDataVector	./GMemory/GMap/tableDict.cpp	/^void GMap::readDataVector(GVector *dataVector){$/;"	f	class:GMap
readDataVector	./GMemory/GMap/tableDict.cpp	/^void GMap::readDataVector(GVector *dataVector,int keyField){$/;"	f	class:GMap
readDataVectorHash	./GMemory/GMap/tableDict.cpp	/^void GMap::readDataVectorHash(GVector *dataVector,int keyField){$/;"	f	class:GMap
readDataVectorText	./GMemory/GMap/tableDict.cpp	/^void GMap::readDataVectorText(GVector *dataVector,int keyField){$/;"	f	class:GMap
readDataVectorWordlist	./GMemory/GMap/tableDict.cpp	/^void GMap::readDataVectorWordlist(GVector *dataVector,int keyField){$/;"	f	class:GMap
readDictionary	./GLogicProcessor/loadDictionary.cpp	/^void GLogicProcessor::readDictionary(){$/;"	f	class:GLogicProcessor
readDictionaryFileMakerXML	./GLogicProcessor/loadDictionary.cpp	/^void GLogicProcessor::readDictionaryFileMakerXML(string &fileName){$/;"	f	class:GLogicProcessor
readDirectory	./OCRString/php2stl.cpp	/^void readDirectory(vector<string> &fileList, vector<string> &folderList, string &dirPath) {$/;"	f
readDirectoryToArray	./OCRString/php2stl.cpp	/^int readDirectoryToArray(vector<string> &fileList, string &dirPath, cstr ext) {$/;"	f
readDirectoryToArray	./OCRString/php2stl.cpp	/^int readDirectoryToArray(vector<string> &fileList, string &dirPath, string &ext) {$/;"	f
readFontDataXML	./GLogicProcessor/loadDictionary.cpp	/^void GLogicProcessor::readFontDataXML(string &path){$/;"	f	class:GLogicProcessor
readFromCorrectionTable	./GBitsetOCR/textOCR.cpp	/^int GBitsetOCR::readFromCorrectionTable(vector<stringOCR>&correctionTable,vector<wordOCR>&pageText,int index){$/;"	f	class:GBitsetOCR
readFromStr	./GFontEditor/GLetter.cpp	/^void GLetter::readFromStr(TString *st){$/;"	f	class:GLetter
readFromStr	./GGraphBezier/GGraphBezier.cpp	/^void OCRFocalLineBezier::readFromStr(TString &st){$/;"	f	class:ocr::OCRFocalLineBezier
readGFontDB	./GFontEditor/GFont.cpp	/^    void GFont::readGFontDB(){   \/\/deprecated$/;"	f	class:ocr::GFont
readGFontXML	./GFontEditor/GFont.cpp	/^    void GFont::readGFontXML(){$/;"	f	class:ocr::GFont
readGFonts	./GFontEditor/GFontEditor.cpp	/^void GFontEditor::readGFonts(){ $/;"	f	class:GFontEditor
readGrammarDataXML	./GLogicProcessor/loadDictionary.cpp	/^void GLogicProcessor::readGrammarDataXML(string &path){$/;"	f	class:GLogicProcessor
readHexData	./OCRString/php2stl.cpp	/^void readHexData(string &data) {$/;"	f
readInMemory	./OCRString/php2stl.cpp	/^unsigned long readInMemory(char **textBuffer, string &path) {$/;"	f
readInput	./OCRString/php2stl.cpp	/^void readInput() {$/;"	f
readInputAction	./GMainEditor/readInputAction.cpp	/^string GMainEditor::readInputAction(){$/;"	f	class:GMainEditor
readInputData	./OCRString/php2stl.cpp	/^void readInputData(cstr ext) {$/;"	f
readLetter	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::readLetter(OCRLetter &letter, int index) {$/;"	f	class:ocr::GGraphOCR
readLetterByID	./GGraphOCR/GGraphOCRFont.cpp	/^int GGraphOCR::readLetterByID(OCRLetter &letter, int ID) {$/;"	f	class:ocr::GGraphOCR
readMapXML	./OCRString/php2stl.cpp	/^void readMapXML(map<string, string> &inputMap, string &path) {$/;"	f
readMatch	./GLogicProcessor/letterAssociation.cpp	/^void GLogicProcessor::readMatch(vector<OCRMatch>&line,const char *path){$/;"	f	class:GLogicProcessor
readOnlyLetter	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::readOnlyLetter(OCRLetter &letter, int index) {$/;"	f	class:ocr::GGraphOCR
readOuterContour	./GBitsetContour/readContour.cpp	/^void GBitsetContour::readOuterContour(int vL){ \/\/algorithm for reading contour of OCR Letter$/;"	f	class:GBitsetContour
readPPM	./GBitmap/ppm.h	/^static PPMImage *readPPM(const char *filename)$/;"	f
readPreferences	./OCRString/php2stl.cpp	/^void readPreferences() {$/;"	f
readText	./OCRString/php2stl.cpp	/^string readText(string &inFile) {$/;"	f
readText	./OCRString/php2stl.cpp	/^unsigned long readText(char *buff, cstr path) {$/;"	f
readText	./OCRString/php2stl.cpp	/^void readText(map<string, uint> &strMap, string &inFile) {$/;"	f
readText	./OCRString/php2stl.cpp	/^void readText(string &str, cstr path) {$/;"	f
readText	./OCRString/php2stl.cpp	/^void readText(string &str, string &inFile) {$/;"	f
readText	./OCRString/php2stl.cpp	/^void readText(vector<string> &strVector, string &inFile) {$/;"	f
read_text_chunks	./PNG/lodepng.h	/^  unsigned read_text_chunks; \/*if false but remember_unknown_chunks is true, they're stored in the unknown chunks*\/$/;"	m	struct:LodePNGDecoderSettings
real	./OCRAlgorithm/f2c.h	/^typedef float real;$/;"	t
rebuildBaseIndex	./GFontEditor/testLetter.cpp	/^void GFontEditor::rebuildBaseIndex(){$/;"	f	class:GFontEditor
rebuildGFont	./GFontEditor/GFontEditor.cpp	/^void GFontEditor::rebuildGFont(){$/;"	f	class:GFontEditor
rebuildMask	./GFontEditor/letterOCR.cpp	/^void GFontEditor::rebuildMask(){$/;"	f	class:GFontEditor
rebuildMaskInLetter	./GFontEditor/letterOCR.cpp	/^void GFontEditor::rebuildMaskInLetter(GLetter *letter,int* pfds){$/;"	f	class:GFontEditor
rebuildMaskInLetterVector	./GFontEditor/letterOCR.cpp	/^void GFontEditor::rebuildMaskInLetterVector(GLetter *letter,int* pfds){$/;"	f	class:GFontEditor
recID	./OCRTypes/OCRTypes.h	/^  int recID;$/;"	m	class:ocr::OCRDictRecord
recID	./OCRTypes/OCRTypes_www.h	/^		int recID;$/;"	m	class:ocr::OCRDictRecord
recordArray	./GFontEditor/GLetter.h	/^  vector<recordOCR> recordArray;$/;"	m	class:ocr::frameOCR
recordArraySize	./GMemory/GVector.h	/^    ulong *recordArraySize;  \/\/размер файла учета записей$/;"	m	class:ocr::GVector
recordCount	./GMemory/GMap/GMap.h	/^        ulong recordCount;      \/\/ количество записей$/;"	m	class:ocr::GMap
recordCount	./GMemory/GVector.h	/^    ulong *recordCount;      \/\/количество записей в векторе$/;"	m	class:ocr::GVector
recordCount	./GMemory/GVector.h	/^    ulong *recordCount;  \/\/количество записей в векторе$/;"	m	class:ocr::GStr
recordFlag	./GFontEditor/GLetter.h	/^  int recordFlag;$/;"	m	class:ocr::GLetter
recordFlag	./OCRTypes/OCRTypes.h	/^  int recordFlag;$/;"	m	class:ocr::OCRDictRecord
recordFlag	./OCRTypes/OCRTypes_www.h	/^		int recordFlag;$/;"	m	class:ocr::OCRDictRecord
recordName	./GBitsetContour/GBitsetContour.h	/^	string recordName;$/;"	m	class:ocr::GBitsetContour
recordOCR	./GFontEditor/GLetter.cpp	/^recordOCR::recordOCR(void){}$/;"	f	class:recordOCR
recordOCR	./GFontEditor/GLetter.h	/^class recordOCR {$/;"	c	namespace:ocr
recordStatus	./GFontEditor/GLetter.h	/^  int recordStatus; \/\/\/флаг принадлежности к языку распознавания$/;"	m	class:ocr::GLetter
recursiveBezier	./GGraphBezier/GGraphFocalLineBezier.cpp	/^    void GGraphBezier::recursiveBezier( vector<OCRPointFloat>&lineBezierPoints,$/;"	f	class:ocr::GGraphBezier
red	./GBitmap/ppm.h	/^	unsigned char red, green, blue;$/;"	m	struct:__anon1
reg	./GGraph/GGraph.h	/^	OCRRegister reg;  \/\/\/< структура кольцевых регистров для lookup1$/;"	m	struct:ocr::OCRStarStruct
reg	./GGraph/GGraph.h	/^	int reg[32]; \/\/\/<массив поисковых регистров маски кластера OCRStar$/;"	m	struct:ocr::OCRMaskStruct
reg0_0	./GGraph/GGraph.h	/^	uint64 reg0_0; \/\/\/<поисковый регистр углов лимитированных фокальных линий с учётом коротких линий (с неопределённым$/;"	m	struct:ocr::OCRRegisterStruct
reg0_1	./GGraph/GGraph.h	/^	uint64 reg0_1; \/\/\/<регистр маски лимитов углов  лимитированных фокальных линий с учётом коротких линий (с$/;"	m	struct:ocr::OCRRegisterStruct
reg1_0	./GGraph/GGraph.h	/^	uint64 reg1_0; \/\/\/<поисковый регистр углов  лимитированных фокальных линий без учёта коротких линий (с$/;"	m	struct:ocr::OCRRegisterStruct
reg1_1	./GGraph/GGraph.h	/^	uint64 reg1_1; \/\/\/<регистр маски лимитов углов  лимитированных фокальных линий без учёта коротких линий (с$/;"	m	struct:ocr::OCRRegisterStruct
reg2_0	./GGraph/GGraph.h	/^	uint64 reg2_0; \/\/\/<поисковый регистр   углов опорных линий$/;"	m	struct:ocr::OCRRegisterStruct
reg2_1	./GGraph/GGraph.h	/^	uint64 reg2_1; \/\/\/<регистр маски лимитов углов опорных линий$/;"	m	struct:ocr::OCRRegisterStruct
regCount	./GGraph/GGraph.h	/^	uchar regCount; \/\/\/<количество поисковых регистров маски кластера OCRStar$/;"	m	struct:ocr::OCRMaskStruct
regExpReplace	./OCRString/php2stl.cpp	/^bool regExpReplace(string &src, cstr exp) {$/;"	f
regExpReplace	./OCRString/php2stl.cpp	/^bool regExpReplace(string &src, string &exp) {$/;"	f
regY	./GGraph/GGraph.h	/^	uchar regY[32]; \/\/\/<массив координат Y поисковых регистров маски кластера OCRStar$/;"	m	struct:ocr::OCRMaskStruct
register1	./GGraphBezier/GGraphBezier.h	/^        int register1;  \/\/  тестовая переменная для подсчета чего-нибудь. \/\/ count$/;"	m	class:ocr::GGraphBezier
reload	./GMemory/GVector.cpp	/^void GVector::reload(GVector *p) {$/;"	f	class:GVector
reload	./GMemory/GVector.h	/^void GStr<T>::GStr::reload(GVector *p) {$/;"	f	class:ocr::GStr::GStr
reloadGFont	./GFontEditor/GFontEditor.cpp	/^void GFontEditor::reloadGFont(){$/;"	f	class:GFontEditor
reloadIndex	./GMemory/loadDB.cpp	/^void GMemory::reloadIndex(tableRecord &rec, int searchField, int searchMode) {$/;"	f	class:GMemory
reloadMask	./GFontEditor/GLetter.cpp	/^void GLetter::reloadMask(){$/;"	f	class:GLetter
reloadMask	./GFontEditor/GLetter.cpp	/^void GLetter::reloadMask(int m){$/;"	f	class:GLetter
reloadPtr	./GFontEditor/GFont.cpp	/^    void GFont::reloadPtr(){$/;"	f	class:ocr::GFont
reloadPtr	./GMemory/GMap/GMap.cpp	/^void GMap::reloadPtr(){$/;"	f	class:GMap
reloadPtr	./GMemory/GVector.cpp	/^void GVector::reloadPtr() {$/;"	f	class:GVector
reloadPtr	./GMemory/GVector.cpp	/^void TString::reloadPtr() {$/;"	f	class:TString
reloadPtr	./GMemory/GVector.h	/^void GStr<T>::GStr::reloadPtr() {$/;"	f	class:ocr::GStr::GStr
remapString	./GLogicProcessor/spellChecker.cpp	/^string GLogicProcessor::remapString(string &str_){$/;"	f	class:GLogicProcessor
remapTibString	./GLogicProcessor/grammarCorrector.cpp	/^string GLogicProcessor::remapTibString(string &input0, string &input1){$/;"	f	class:GLogicProcessor
remember_unknown_chunks	./PNG/lodepng.h	/^  unsigned remember_unknown_chunks;$/;"	m	struct:LodePNGDecoderSettings
removePaddingBits	./PNG/lodepng.cpp	/^static void removePaddingBits(unsigned char* out, const unsigned char* in,$/;"	f	file:
renderDictSearch	./GLogicProcessor/renderDictSearch.cpp	/^void GLogicProcessor::renderDictSearch(map<vector<int>,ulong>&searchResult,$/;"	f	class:GLogicProcessor
renderDictSearchNew	./GLogicProcessor/renderDictSearchNew.cpp	/^void GLogicProcessor::renderDictSearchNew(map<vector<int>,ulong>&searchResult,$/;"	f	class:GLogicProcessor
renderDictSearchSanskrit	./GLogicProcessor/renderDictSearchSanskrit.cpp	/^void GLogicProcessor::renderDictSearchSanskrit(map<vector<int>,ulong>&searchResult,$/;"	f	class:GLogicProcessor
renderResult	./GMemory/GMap/tableProcessing.cpp	/^void GMap::renderResult(string &result){$/;"	f	class:GMap
rentry	./OCRTypes/OCRTypes.h	/^  string rentry;$/;"	m	class:ocr::OCRDictRecord
rentry	./OCRTypes/OCRTypes_www.h	/^		string rentry;$/;"	m	class:ocr::OCRDictRecord
report	./GLogicProcessor/GLogicProcessor.h	/^	string report;  \/\/string for conversion errors output;$/;"	m	class:ocr::GLogicProcessor
reportKey	./OCRTypes/OCRTypes.h	/^  vector<dictKey> reportKey;$/;"	m	class:ocr::OCRDictRecord
reportKey	./OCRTypes/OCRTypes_www.h	/^		vector <dictKey>reportKey;$/;"	m	class:ocr::OCRDictRecord
res	./GBitsetContour/GBitsetContour.h	/^	short res, xBegin, xEnd, xL,yL,hL, wL, dy_line, y_line, yLine, *ln,*lt;$/;"	m	class:ocr::GBitsetContour
res	./codeStorage.h	/^TCLIST *res;$/;"	v
res	./codeStorage.h	/^cout<<res;$/;"	v
res	./codeStorage.h	/^string res=str.str();$/;"	v
resX	./GBitsetContour/GBitsetContour.h	/^	int w,h,a, resX, resY;$/;"	m	class:ocr::GBitsetContour
resY	./GBitsetContour/GBitsetContour.h	/^	int w,h,a, resX, resY;$/;"	m	class:ocr::GBitsetContour
reserve	./GMemory/GVector.h	/^void GStr<T>::reserve(ulong newSize) {$/;"	f	class:ocr::GStr
reserve	./GMemory/MmapFile.cpp	/^void MemoryFile::reserve(size_t new_capacity)$/;"	f	class:MemoryFile
resetOCR	./GMainEditor/setImageOCR.cpp	/^void GMainEditor::resetOCR(){$/;"	f	class:GMainEditor
resize	./GFontEditor/GLetter.cpp	/^void stringOCR::resize(int length){$/;"	f	class:stringOCR
resize	./GMemory/GVector.cpp	/^void GVector::resize(uint newRecordCount) {$/;"	f	class:GVector
resize	./GMemory/GVector.h	/^void GStr<T>::resize(ulong newSize) {$/;"	f	class:ocr::GStr
resize	./GMemory/MmapFile.cpp	/^void MemoryFile::resize(size_t new_size)$/;"	f	class:MemoryFile
resizeData	./GMemory/GVector.cpp	/^void GVector::resizeData(ulong newRecordCount, ulong newSize) {$/;"	f	class:GVector
resizeMask	./GBitMask/algorithmOCR_32.cpp	/^    void  GBitMask32::resizeMask(int stepW,int stepH,ofstream &c_out){$/;"	f	class:ocr::GBitMask32
resultDelimeter	./GMemory/GMap/GMap.h	/^        ulong *resultDelimeter;$/;"	m	class:ocr::GMap
resultDelimeterVector	./GMemory/GMap/GMap.h	/^        GStr<ulong>*resultDelimeterVector;   \/\/ строка результатов вычисления вероятности разделителей в фразе$/;"	m	class:ocr::GMap
resultText	./GMemory/GMap/GMap.h	/^        mSIZE* resultText;$/;"	m	class:ocr::GMap
resultTextVector	./GMemory/GMap/GMap.h	/^        GStr<mSIZE>*resultTextVector;         \/\/ строка результатов вычисления вероятности букв в фразе$/;"	m	class:ocr::GMap
rexExpFind	./OCRString/php2stl.cpp	/^bool rexExpFind(char *textBuffer, string &exp) {  \/\/ search textBuffer by regular expression exp$/;"	f
rgba16ToPixel	./PNG/lodepng.cpp	/^static void rgba16ToPixel(unsigned char* out, size_t i,$/;"	f	file:
rgba8ToPixel	./PNG/lodepng.cpp	/^static unsigned rgba8ToPixel(unsigned char* out, size_t i,$/;"	f	file:
rootFilter	./GBitsetContour/rootFilterFunction.cpp	/^void rootFilter(char *aFt, short angLen){$/;"	f
rootLetterOCR	./OCRTypes/OCRTypes.h	/^} rootLetterOCR;$/;"	t	namespace:ocr	typeref:struct:ocr::rootLetterOCRStruct
rootLetterOCR	./OCRTypes/OCRTypes_www.h	/^	}rootLetterOCR;$/;"	t	namespace:ocr	typeref:struct:ocr::rootLetterOCRStruct
rootLetterOCRStruct	./OCRTypes/OCRTypes.h	/^typedef struct rootLetterOCRStruct {$/;"	s	namespace:ocr
rootLetterOCRStruct	./OCRTypes/OCRTypes_www.h	/^	typedef struct rootLetterOCRStruct{$/;"	s	namespace:ocr
rotate	./GBitmap/GBitmap.cpp	/^void GBitmap::rotate(int rotation) {$/;"	f	class:ocr::GBitmap
rotate	./GBitset/GBitset_base.cpp	/^GBitset::rotate(int count)$/;"	f	class:GBitset
rotateFast	./GBitmap/GBitmapRotate.cpp	/^  void GBitmap::rotateFast(const GBitmap*src, float scale, float rotation){$/;"	f	class:ocr::GBitmap
rotateFast	./GBitmap/GBitmapRotate.cpp	/^  void GBitmap::rotateFast(float angle){$/;"	f	class:ocr::GBitmap
rows	./GBitmap/GBitmap.cpp	/^inline unsigned int GBitmap::rows() const {$/;"	f	class:ocr::GBitmap
rows	./GBitset/GBitset.h	/^GBitset::rows() const$/;"	f	class:ocr::GBitset
rows	./GBitsetContour/GBitsetContour.h	/^GBitsetContour::rows() const$/;"	f	class:ocr::GBitsetContour
rows	./GBitsetMatrix/GBitsetMatrix.h	/^GBitsetMatrix::rows() const$/;"	f	class:ocr::GBitsetMatrix
rows	./GBitsetOCR/GBitsetOCR.h	/^GBitsetOCR::rows() const$/;"	f	class:ocr::GBitsetOCR
rowsize	./GBitmap/GBitmap.cpp	/^inline unsigned int GBitmap::rowsize() const {$/;"	f	class:ocr::GBitmap
rowsize	./GBitset/GBitset.h	/^GBitset::rowsize() const$/;"	f	class:ocr::GBitset
rowsize	./GBitsetContour/GBitsetContour.h	/^GBitsetContour::rowsize() const$/;"	f	class:ocr::GBitsetContour
rowsize	./GBitsetMatrix/GBitsetMatrix.h	/^GBitsetMatrix::rowsize() const$/;"	f	class:ocr::GBitsetMatrix
rowsize	./GBitsetOCR/GBitsetOCR.h	/^GBitsetOCR::rowsize() const$/;"	f	class:ocr::GBitsetOCR
rsiz	./codeStorage.h	/^int ecode, pksiz, i, rsiz;$/;"	v
run	./OCRString/php2stl.cpp	/^string run(cstr cmd) {$/;"	f
run	./OCRString/php2stl.cpp	/^string run(string cmd) {$/;"	f
s	./GFontEditor/GLetter.h	/^  OCRBox s; \/\/координаты прямоугольника буквы с учетом бордюра в GBitsetMatrix$/;"	m	class:ocr::OCRMatch
s	./GGraph/GGraph.h	/^	OCRBox s; \/\/\/<координаты прямоугольника буквы относительно центра буквы и площадь габарита$/;"	m	struct:ocr::OCRLetterStruct
sData	./GGraphBezier/GGraphBezier.h	/^        vector<OCRPointFloat>sData;   \/\/ - вектор для массива координат интегральных сумм фокальной линии по "x" и "y" (NO Б.Д.).$/;"	m	class:ocr::OCRFocalLineBezier
sData	./OCRTypes/OCRTypes.h	/^typedef struct sData {$/;"	s	namespace:ocr
sData	./OCRTypes/OCRTypes_www.h	/^    typedef struct sData{$/;"	s	namespace:ocr
sIndex	./GBitsetOCR/GBitsetOCR.h	/^  int sIndex;   \/\/current string$/;"	m	class:ocr::GBitsetOCR
sInt	./GBitsetMatrix/GBitsetMatrix.h	/^  unsigned int *sInt;           \/\/\/<буфер транспонированого по вертикали массива горизонтальных строк  short stepBit;$/;"	m	class:ocr::GBitsetMatrix
sMatch	./GGraph/GGraph.h	/^	uchar sMatch[4]; \/\/\/<порядок соответствия фокальных линий OCRStar текста и эталона$/;"	m	struct:ocr::OCRStarStruct
save	./GMemory/GMap/GMap.cpp	/^void GMap::save(){$/;"	f	class:GMap
save	./GMemory/GVector.cpp	/^void TString::save() {$/;"	f	class:TString
save	./GMemory/GVector.h	/^    bool save(cstr path) {$/;"	f	class:ocr::GVector
save	./GMemory/GVector.h	/^    bool save(string &path) {$/;"	f	class:ocr::GVector
save	./GMemory/GVector.h	/^    bool save(void) {$/;"	f	class:ocr::GVector
save	./GMemory/GVector.h	/^void GStr<T>::save(cstr path) {$/;"	f	class:ocr::GStr
saveInDictionary	./GLogicProcessor/dictReport.cpp	/^void GLogicProcessor::saveInDictionary( string &srcStr){$/;"	f	class:GLogicProcessor
saveLetter	./GFontEditor/GFont.cpp	/^    void  GFont::saveLetter(GLetter* letter){$/;"	f	class:ocr::GFont
saveLetter	./GGraphOCR/GGraphOCRFont.cpp	/^void GGraphOCR::saveLetter(OCRLetter &letter) {$/;"	f	class:ocr::GGraphOCR
saveMatch	./GLogicProcessor/letterAssociation.cpp	/^void GLogicProcessor::saveMatch(vector<OCRMatch>&line,const char *path){$/;"	f	class:GLogicProcessor
savePNG	./GBitmap/GBitmap.cpp	/^void GBitmap::savePNG(const char *path) {$/;"	f	class:ocr::GBitmap
savePNG	./GBitmap/GBitmap.h	/^	void savePNG(string &path) { return savePNG(path.c_str()); };$/;"	f	class:ocr::GBitmap
saveToString	./GFontEditor/GLetter.cpp	/^string GLetter::saveToString(){  \/\/\/save letter in string$/;"	f	class:GLetter
saveToTranslationDictionary	./GLogicProcessor/dictReportLocal.cpp	/^void GLogicProcessor::saveToTranslationDictionary(string &srcStr){$/;"	f	class:GLogicProcessor
save_file	./PNG/lodepng.cpp	/^unsigned save_file(const std::vector<unsigned char>& buffer, const std::string& filename)$/;"	f	namespace:lodepng
scale	./GFontEditor/GLetter.h	/^  float scale;$/;"	m	class:ocr::GLetter
scale	./GGraph/GGraph.h	/^	float	scale;$/;"	m	struct:ocr::OCRClusterStruct
scale	./GGraph/GGraph.h	/^	float scale;$/;"	m	struct:ocr::OCRLetterStruct
scale	./GGraph/GGraph.h	/^	float scale;$/;"	m	struct:ocr::OCRStarStruct
scale	./GGraphOCR/GGraphOCR.h	/^	float scale;$/;"	m	struct:ClusterMatchStruct
scale0	./GGraph/GGraph.h	/^	float scale0;	  \/\/\/<масштаб приведения габарита звездочки к maskLine 32х32$/;"	m	struct:ocr::OCRLineStruct
scale0	./GGraph/GGraph.h	/^	float scale0;$/;"	m	struct:ocr::OCRStarStruct
scaleFast	./GBitmap/GBitmapScale.cpp	/^  void GBitmap::scaleFast(const GBitmap*ref, float scale){$/;"	f	class:ocr::GBitmap
scaleFast	./GBitmap/GBitmapScale.cpp	/^  void GBitmap::scaleFast(float scale){$/;"	f	class:ocr::GBitmap
scaleLetter	./GFontEditor/GFont.cpp	/^    void GFont::scaleLetter(GLetter *glyph,float scale){$/;"	f	class:ocr::GFont
scaleTibetanB	./GBitmap/GBitmapTextOrientation.cpp	/^  float  GBitmap::scaleTibetanB(int xB, int yB) {$/;"	f	class:ocr::GBitmap
scaleTibetanBM	./GBitmap/GBitmapTextOrientation.cpp	/^  float  GBitmap::scaleTibetanBM(int xB, int yB) {$/;"	f	class:ocr::GBitmap
searchCodeIndex	./PNG/lodepng.cpp	/^static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value)$/;"	f	file:
searchModeConst	./OCRTypes/OCRTypes.h	/^enum searchModeConst {$/;"	g	namespace:ocr
searchParam	./GMemory/GMap/GMap.h	/^    enum searchParam{$/;"	g	namespace:ocr
searchString	./OCRTypes/OCRTypes.h	/^  string searchString;$/;"	m	class:ocr::OCRDictRecord
searchString	./OCRTypes/OCRTypes_www.h	/^		string searchString;$/;"	m	class:ocr::OCRDictRecord
second	./PNG/lodepng.h	/^  unsigned second;  \/*0-60 (to allow for leap seconds)*\/$/;"	m	struct:LodePNGTime
select	./GMemory/GMemoryRequest.cpp	/^void GMemory::select(string&tableName,vector<int> &field, string &query, int searchMode,vector<TString> &result,int limit){$/;"	f	class:GMemory
selectFlag	./GFontEditor/GLetter.h	/^  int selectFlag;$/;"	m	class:ocr::stringOCR
selectFlag	./GFontEditor/GLetter.h	/^  int selectFlag;$/;"	m	class:ocr::wordOCR
selectFlag	./OCRTypes/OCRTypes.h	/^  short selectFlag;$/;"	m	class:ocr::vectorOCR
selfCorrelation	./GFontEditor/GLetter.h	/^  int selfCorrelation; \/\/\/< test value of self correlation$/;"	m	class:ocr::GLetter
selfPath	./GMemory/GMap/GMap.h	/^        string selfPath;$/;"	m	class:ocr::GMap
selfPath	./GPDF/GPDF.h	/^    string selfPath;             \/\/disk path to PDF document$/;"	m	class:ocr::GPDF
sentenceConstructur	./GLogicProcessor/sentenceConstructor.cpp	/^void GLogicProcessor::sentenceConstructur(vector<OCRMatch>&wLine){$/;"	f	class:GLogicProcessor
sentenceConstructurNew	./GLogicProcessor/sentenceConstructorNew.cpp	/^void GLogicProcessor::sentenceConstructurNew(vector<OCRMatch>&matchLine,$/;"	f	class:GLogicProcessor
serverMonitor	./OCRString/serverMonitor.cpp	/^void serverMonitor()$/;"	f
set	./GBitMask/GBitmask.cpp	/^void GBitMask32::set(){$/;"	f	class:ocr::GBitMask32
setBase	./GFontEditor/setLetter.cpp	/^void GFontEditor::setBase(){$/;"	f	class:GFontEditor
setBit	./GMainEditor/GMainEditor.h	/^		GBitset *setBit;$/;"	m	class:ocr::GMainEditor
setBitOfReversedStream	./PNG/lodepng.cpp	/^static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)$/;"	f	file:
setBitOfReversedStream0	./PNG/lodepng.cpp	/^static void setBitOfReversedStream0(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)$/;"	f	file:
setCenter	./GFontEditor/GLetter.cpp	/^void OCRMatch::setCenter(){\/\/устанавливает центр буквы по габаритам и пересчитывает координаты масок признаков$/;"	f	class:OCRMatch
setContour	./GMainEditor/GMainEditor.h	/^		GBitsetContour *setContour;$/;"	m	class:ocr::GMainEditor
setCorrelation	./GFontEditor/testLetter.cpp	/^int GFontEditor::setCorrelation(GBitmap *img128, GLetter *glyph,float scale,int print){  \/\/function need copy of actual letter. It store OCR information$/;"	f	class:GFontEditor
setCorrelation	./GLogicProcessor/testWordLine.cpp	/^float setCorrelation(vector<OCRMatch>&originalMatch,OCRMatch &a,OCRBox &s){$/;"	f
setCorrelationMask	./GLogicProcessor/testWordLine.cpp	/^float setCorrelationMask(vector<OCRMatch>&originalMatch,OCRMatch &a,OCRBox &s){$/;"	f
setData	./GBitsetContour/contourOCR.cpp	/^void GBitsetContour::setData(vectorOCR *vectorBase_,vector<stringOCR>&strArray_,int iLeft_, int iTop_) {   \/\/main point for GLetter Object. Order of all Letter OCR function$/;"	f	class:GBitsetContour
setData	./GBitsetOCR/GBitset_setDataOCR.cpp	/^void GBitsetOCR::setData(GFont *aliKali_,$/;"	f	class:GBitsetOCR
setDimension	./GGraphBezier/GGraphBezier.cpp	/^void OCRFocalLineBezier::setDimension(int dx,int dy){$/;"	f	class:ocr::OCRFocalLineBezier
setEndStar	./GGraph/GGraphFocalLineRecognition.cpp	/^void GGraph::setEndStar( OCRStar &startStar,$/;"	f	class:ocr::GGraph
setFocalLine	./GFontEditor/GFont.cpp	/^    void GFont::setFocalLine(){$/;"	f	class:ocr::GFont
setFocalLineInLetter	./GFontEditor/GFont.cpp	/^    void GFont::setFocalLineInLetter(uint index){$/;"	f	class:ocr::GFont
setFontData	./GBitsetContour/contourOCR.cpp	/^void GBitsetContour::setFontData(vectorOCR *vectorBase_,GLetter *glyph, string &recordName_, short wScale){$/;"	f	class:GBitsetContour
setFromPtr	./GMemory/GVector.cpp	/^void TString::setFromPtr(uint *index_, uint len_, char *data_, uint dataSize) {$/;"	f	class:TString
setHex	./GMainEditor/GMainEditor.cpp	/^	GMainEditor::setHex(){$/;"	f	class:ocr::GMainEditor
setImageHandler	./GBitsetContour/contourOCR.cpp	/^void GBitsetContour::setImageHandler(){$/;"	f	class:GBitsetContour
setImageOCR	./GMainEditor/setImageOCR.cpp	/^int GMainEditor::setImageOCR(GBitmap *pechaImg_,vector<float*>&param, OCRPointFloat &point){$/;"	f	class:GMainEditor
setImageParamOCR	./GBitsetOCR/setImageParamOCR.cpp	/^int GBitsetOCR::setImageParamOCR(GBitmap *pechaImg_,vector<float*>&param,OCRPointFloat &point){$/;"	f	class:GBitsetOCR
setImagePointCount	./GLogicProcessor/testWordLine.cpp	/^void setImagePointCount(vector<OCRMatch>&originalMatch,GBitmap *lineImg32, OCRMatch &a, int print){$/;"	f
setIndex	./GMemory/GVector.h	/^void GStr2D<T>::setIndex(uint *indexV, uint size) {$/;"	f	class:ocr::GStr2D
setLanguage	./GFontEditor/GFontEditor.cpp	/^void GFontEditor::setLanguage(){$/;"	f	class:GFontEditor
setLetter	./GFontEditor/setLetter.cpp	/^void GFontEditor::setLetter(){$/;"	f	class:GFontEditor
setLetterDimensions	./GFontEditor/GLetter.cpp	/^void GLetter::setLetterDimensions(){$/;"	f	class:GLetter
setLetterMainMask	./GFontEditor/letterOCR.cpp	/^void GFontEditor::setLetterMainMask(GLetter *letter){$/;"	f	class:GFontEditor
setLetterScale	./GFontEditor/setLetterScale.cpp	/^int GFontEditor::setLetterScale(GBitmap *img128, GLetter *glyph_){$/;"	f	class:GFontEditor
setLetterStableFocalPoint	./GFontEditor/GFont.cpp	/^    void GFont::setLetterStableFocalPoint(uint index){$/;"	f	class:ocr::GFont
setLineCombination	./GGraphBezier/GGraphLineMatrixBezier.cpp	/^    void GGraphBezier::setLineCombination(vector<OCRPointFloat>&focalPoint, vector<OCRFocalLineBezier> &focalLine, GStr2D<int>*point2D, GStr2D<int>*line2D){$/;"	f	class:ocr::GGraphBezier
setLineCombination2	./GGraphBezier/GGraphLineMatrixBezier.cpp	/^    void GGraphBezier::setLineCombination2(vector<OCRPointFloat>&focalPoint, vector<OCRFocalLineBezier> &focalLine, GStr2D<int>*point2D, GStr2D<int>*line2D){$/;"	f	class:ocr::GGraphBezier
setLineFromArray	./GFontEditor/GFont.cpp	/^    void GFont::setLineFromArray(vector<stringOCR>&strArray){$/;"	f	class:ocr::GFont
setLineMatrix	./GGraphBezier/GGraphLineMatrixBezier.cpp	/^    void GGraphBezier::setLineMatrix(vector<OCRPointFloat>&focalPoint,$/;"	f	class:ocr::GGraphBezier
setMask	./GBitsetMatrix/GBitsetMatrix_base.cpp	/^void GBitsetMatrix::setMask(GBitMask32 *srcMask, int maskSize){$/;"	f	class:GBitsetMatrix
setMask	./OCRTypes/OCRTypes.cpp	/^void byteMask::setMask(char mask) {$/;"	f	class:ocr::byteMask
setMaskFromBase	./GFontEditor/letterOCR.cpp	/^void GFontEditor::setMaskFromBase(){$/;"	f	class:GFontEditor
setMatchLetters	./GLogicProcessor/testWordLine.cpp	/^void setMatchLetters(vector<OCRMatch>&line,vector<OCRMatch>&originalMatch, GBitmap *lineImg32, OCRMatch &a, OCRMatch &b, OCRBox &s){$/;"	f
setMatrix	./GBitsetOCR/GBitsetOCR.h	/^  GBitsetMatrix *setMatrix;     \/\/matrix object with string bitmap data for string by string letter recognition$/;"	m	class:ocr::GBitsetOCR
setMatrixCorrelation	./GBitsetMatrix/MartixCorrelation.cpp	/^int GBitsetMatrix::setMatrixCorrelation(GBitMask32 *mask32,$/;"	f	class:GBitsetMatrix
setMatrix_Lion	./GBitsetMatrix/Matrix_Lion.cpp	/^int GBitsetMatrix::setMatrix_Lion(GBitMask32 *mask32,$/;"	f	class:GBitsetMatrix
setMatrix_Point	./GBitsetMatrix/setMatrix_Point_32_64C.cpp	/^int GBitsetMatrix::setMatrix_Point(GBitMask32 *mask32,$/;"	f	class:GBitsetMatrix
setMatrix_Point	./GBitsetMatrix/setMatrix_Point_32_64_SSE.cpp	/^int GBitsetMatrix::setMatrix_Point(GBitMask32 *mask32,$/;"	f	class:GBitsetMatrix
setMatrix_Point	./GBitsetMatrix/setMatrix_Point_64ASM_ATT.cpp	/^int GBitsetMatrix::setMatrix_Point(GBitMask32 *mask32,$/;"	f	class:GBitsetMatrix
setMatrix_Point	./GBitsetMatrix/setMatrix_Point_64ASM_INTEL_F.cpp	/^int GBitsetMatrix::setMatrix_Point(GBitMask32 *mask32,$/;"	f	class:GBitsetMatrix
setMatrix_Point	./GBitsetMatrix/setMatrix_Point_64_popcnt_C.cpp	/^int GBitsetMatrix::setMatrix_Point(GBitMask32 *mask32,$/;"	f	class:GBitsetMatrix
setOCR	./GMainEditor/GMainEditor.h	/^        GBitsetOCR *setOCR;$/;"	m	class:ocr::GMainEditor
setOCRCorrelation	./GBitsetOCR/setOCRCorrelation.cpp	/^void GBitsetOCR::setOCRCorrelation(int stackFlag, int mode){$/;"	f	class:GBitsetOCR
setOCRKey	./GFontEditor/GFontEditor.cpp	/^void GFontEditor::setOCRKey(){$/;"	f	class:GFontEditor
setOCRLetterCorrelation	./GBitsetOCR/setOCRCorrelation.cpp	/^int GBitsetOCR::setOCRLetterCorrelation(int letterFlag, int matchNum,int mode){$/;"	f	class:GBitsetOCR
setOCRRecordCorrelation	./GBitsetOCR/setOCRRecordCorrelation.cpp	/^void GBitsetOCR::setOCRRecordCorrelation(){  \/\/SET CORRELATION FOR TWO RECORDS IN BASE$/;"	f	class:GBitsetOCR
setOCRStarHash	./GGraph/GGraphOCRStar.cpp	/^void GGraph::setOCRStarHash(OCRStar &star) {$/;"	f	class:ocr::GGraph
setOnOffInMaskRect	./GBitMask/algorithmOCR_32.cpp	/^    void GBitMask32::setOnOffInMaskRect(int dlt) {$/;"	f	class:ocr::GBitMask32
setOnOffMatrixT	./GBitMask/algorithmOCR_32.cpp	/^    void GBitMask32::setOnOffMatrixT(int stepH,$/;"	f	class:ocr::GBitMask32
setPointCount	./GLogicProcessor/testWordLine.cpp	/^uint setPointCount(OCRMatch &a,OCRBox &s){$/;"	f
setRecordInArray	./GBitsetContour/setRecordInArray.cpp	/^void GBitsetContour::setRecordInArray(char contour, short vCount){$/;"	f	class:GBitsetContour
setRefImgs	./GPDF/CGImageFromPDF.h	/^void setRefImgs(NSMutableArray *ref){$/;"	f
setScale	./GFontEditor/letterOCR.cpp	/^void GFontEditor::setScale(){$/;"	f	class:GFontEditor
setScaleBitsetOCR	./GBitsetOCR/setScaleBitsetOCR.cpp	/^float GBitsetOCR::setScaleBitsetOCR(GLogicProcessor *logicProcessor, int mode){$/;"	f	class:GBitsetOCR
setScaleOCR	./GMainEditor/setScaleOCR.cpp	/^float GMainEditor::setScaleOCR(GBitmap *pechaImg_){$/;"	f	class:GMainEditor
setScaleRecord	./GBitsetOCR/setScaleRecord.cpp	/^short GBitsetOCR::setScaleRecord(){$/;"	f	class:GBitsetOCR
setSearchText	./OCRString/php2stl.cpp	/^void setSearchText(string &key) {$/;"	f
setSize	./GBitsetContour/contourOCR.cpp	/^void GBitsetContour::setSize(){$/;"	f	class:GBitsetContour
setSize	./GFontEditor/GLetter.cpp	/^void OCRMatch::setSize(int sizeMode){$/;"	f	class:OCRMatch
setSize	./GMemory/GVector.cpp	/^void GVector::setSize(ulong newRecordCount, ulong newSize) {  \/\/ datasize указывается в байтах.$/;"	f	class:GVector
setStableFocalPoint	./GFontEditor/GFont.cpp	/^    void GFont::setStableFocalPoint(){$/;"	f	class:ocr::GFont
setStarInCircle	./GGraph/GGraphFocalLineRecognition.cpp	/^void GGraph::setStarInCircle(int x){$/;"	f	class:ocr::GGraph
setTestOCRCorrelation	./GBitsetOCR/setOCRCorrelation.cpp	/^void GBitsetOCR::setTestOCRCorrelation(int sIndex, int wIndex, int mIndex){$/;"	f	class:GBitsetOCR
setVector	./GBitsetContour/setVector.cpp	/^void GBitsetContour::setVector(short contour){  \/\/read angIntSum make Vector record. Here we recognise Vectors in letter$/;"	f	class:GBitsetContour
setVector	./GMemory/GVector.cpp	/^char *GVector::setVector(cstr name, ulong &vectorIDChild) {$/;"	f	class:GVector
setVectorAngle	./GBitsetContour/setVectorAngle.cpp	/^short GBitsetContour::setVectorAngle(short x0, short y0, short x1, short y1){$/;"	f	class:GBitsetContour
set_id	./GFontEditor/GLetter.cpp	/^void stringOCR::set_id(string &desTString){$/;"	f	class:stringOCR
set_sqrt_array	./GBitsetContour/GBitsetContour.cpp	/^void GBitsetContour::set_sqrt_array(){$/;"	f	class:GBitsetContour
sgi	./OCRAlgorithm/f2c.h	211;"	d
shiftMaskX	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int shiftMaskX=0;$/;"	m	namespace:ocr	file:
shiftX	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int shiftX;$/;"	m	namespace:ocr	file:
shiftY	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int shiftY;$/;"	m	namespace:ocr	file:
shortint	./OCRAlgorithm/f2c.h	/^typedef short int shortint;$/;"	t
shortlogical	./OCRAlgorithm/f2c.h	/^typedef short int shortlogical;$/;"	t
sillablyCount	./GFontEditor/GLetter.h	/^  int sillablyCount;$/;"	m	class:ocr::wordOCR
size	./GFontEditor/GContour.h	/^    int size(){return length;}$/;"	f	class:ocr::GContour
size	./GFontEditor/GFont.h	/^        ulong size(void){return *recordCount-1;};$/;"	f	class:ocr::GFont
size	./GFontEditor/GLetter.cpp	/^int stringOCR::size(){$/;"	f	class:stringOCR
size	./GGraphBezier/GGraphBezier.h	/^        int size(){return (uint)data.size();}$/;"	f	class:ocr::OCRFocalLineBezier
size	./GMemory/GMap/GMap.cpp	/^ulong GMap::size(){$/;"	f	class:GMap
size	./GMemory/GVector.h	/^    uint         size() { return len; }$/;"	f	class:ocr::TString
size	./GMemory/GVector.h	/^    uint size(uint i) {$/;"	f	class:ocr::GStr2D
size	./GMemory/GVector.h	/^    ulong size(void) {$/;"	f	class:ocr::GStr
size	./GMemory/GVector.h	/^    ulong size(void) {$/;"	f	class:ocr::GVector
size	./GMemory/MmapFile.h	/^	size_t size() const { return size_; }$/;"	f	class:InputMemoryFile
size	./GMemory/MmapFile.h	/^	size_t size() const { return size_; }$/;"	f	class:MemoryFile
size	./OCRTypes/OCRTypes.h	/^      int size() {$/;"	f	class:ocr::GString
size	./OCRTypes/OCRTypes.h	/^  long size;$/;"	m	class:ocr::GTextBufer
size	./OCRTypes/OCRTypes_www.h	/^		long size;$/;"	m	class:ocr::GTextBufer
size	./PNG/lodepng.cpp	/^  size_t size; \/*size in number of unsigned longs*\/$/;"	m	struct:uivector	file:
size	./PNG/lodepng.cpp	/^  size_t size; \/*used size*\/$/;"	m	struct:ucvector	file:
sizeBufSR	./GGraph/GGraph.h	/^	uint sizeBufSR;	   \/\/\/<количество слайсов$/;"	m	class:ocr::GGraph
sizeData	./GMemory/GVector.h	/^    uint         sizeData;  \/\/размер данных$/;"	m	class:ocr::TString
sizeH	./GBitsetContour/GBitsetContour.h	/^    int sizeH;$/;"	m	class:ocr::GBitsetContour
size_	./GMemory/MmapFile.h	/^	size_t size_;$/;"	m	class:InputMemoryFile
size_	./GMemory/MmapFile.h	/^	size_t size_;$/;"	m	class:MemoryFile
size_BufD	./GMemory/GMap/GMap.h	/^        ulong size_BufD;$/;"	m	class:ocr::GMap
size_BufDR	./GMemory/GMap/GMap.h	/^        ulong size_BufDR;$/;"	m	class:ocr::GMap
size_BufE	./GMemory/GMap/GMap.h	/^        ulong size_BufE;$/;"	m	class:ocr::GMap
size_BufET	./GMemory/GMap/GMap.h	/^        uint size_BufET;$/;"	m	class:ocr::GMap
size_BufLpT	./GMemory/GMap/GMap.h	/^        ulong size_BufLpT;$/;"	m	class:ocr::GMap
size_BufMp	./GMemory/GMap/GMap.h	/^        ulong size_BufMp;$/;"	m	class:ocr::GMap
size_BufMpT	./GMemory/GMap/GMap.h	/^        ulong size_BufMpT;$/;"	m	class:ocr::GMap
size_BufTxt	./GMemory/GMap/GMap.h	/^        uint size_BufTxt;      \/\/ размер массива распознаваемого текста (в байтах), в общем случае size_BufTxt=text_size;$/;"	m	class:ocr::GMap
size_BufUpT	./GMemory/GMap/GMap.h	/^        uint size_BufUpT;$/;"	m	class:ocr::GMap
size_BufUpT1	./GMemory/GMap/GMap.h	/^        uint size_BufUpT1;$/;"	m	class:ocr::GMap
size_GravTxt	./GMemory/GMap/GMap.h	/^        uint size_GravTxt;     \/\/ размер массива суммарных весов (в байтах), в общем случае size_GravTxt=text_size;$/;"	m	class:ocr::GMap
size_SumTxtP	./GMemory/GMap/GMap.h	/^        uint size_SumTxtP;     \/\/ полный размер статистической устойчивости распознаваемого текста, size_SumTxtP=text_size1*nLetterP; $/;"	m	class:ocr::GMap
socketFD	./config.h	/^	int socketFD; \/\/ socket file descriptor$/;"	m	struct:commandData
sortData	./OCRTypes/OCRTypes.h	/^} sortData;$/;"	t	namespace:ocr	typeref:struct:ocr::sData
sortData	./OCRTypes/OCRTypes_www.h	/^    }sortData;$/;"	t	namespace:ocr	typeref:struct:ocr::sData
sortDictKeyL	./GLogicProcessor/dictReportLocal.cpp	/^static bool sortDictKeyL(const dictKey& d1, const dictKey& d2){$/;"	f	file:
sortFocalLine	./GFontEditor/GFont.cpp	/^    static bool  sortFocalLine(const OCRFocalLineBezier &a, const OCRFocalLineBezier &b){$/;"	f	namespace:ocr
sortFocalLineL	./GBitsetOCR/textOCR.cpp	/^static bool sortFocalLineL(const OCRFocalLineBezier& d1, const OCRFocalLineBezier& d2){$/;"	f	file:
sortKey	./GLogicProcessor/loadDictionary.cpp	/^string GLogicProcessor::sortKey(vector<dictKey>&keyArray,string &srcKey,int fullReport){$/;"	f	class:GLogicProcessor
sortKeyC	./GLogicProcessor/GLogicProcessor.h	/^     static bool sortKeyC(const keyOCR& d1, const keyOCR& d2){$/;"	f	namespace:ocr
sortKeyL	./GMemory/loadDB.cpp	/^static bool sortKeyL(string &d1, string &d2) {$/;"	f	file:
sortLetterC	./GGraphOCR/GGraphOCR.h	/^static bool sortLetterC(const OCRLetter &d1, const OCRLetter &d2) { return d1.correlation > d2.correlation; }$/;"	f
sortLetterX	./GGraphOCR/GGraphOCRLetterNeighbors.cpp	/^static bool sortLetterX(const OCRPoint &d1, const OCRPoint &d2) { return d1.x < d2.x; }$/;"	f	file:
sortMatchC	./GBitsetMatrix/letterCorrelation.cpp	/^static bool sortMatchC(const OCRMatch& d1, const OCRMatch& d2){$/;"	f	file:
sortMatchC	./GLogicProcessor/GLogicProcessor.h	/^    static bool sortMatchC(const OCRMatch& d1, const OCRMatch& d2){$/;"	f	namespace:ocr
sortMatchC	./GLogicProcessor/drawGrapeLine.cpp	/^static bool sortMatchC(const OCRMatch& d1, const OCRMatch& d2){$/;"	f	file:
sortMatchCorrelation	./GGraphOCR/GGraphOCR.h	/^static bool sortMatchCorrelation(const ClusterMatch &d1, const ClusterMatch &d2) { return d1.correlation + d1.starIndex * 0.05 > d2.correlation + d2.starIndex * 0.05; }$/;"	f
sortMatchL	./GLogicProcessor/GLogicProcessor.h	/^    static bool sortMatchL(const OCRMatch& d1, const OCRMatch& d2){$/;"	f	namespace:ocr
sortMatchSize	./GGraphOCR/GGraphOCR.h	/^static bool sortMatchSize(const ClusterMatch &d1, const ClusterMatch &d2) { return d1.w + d1.h > d2.w + d2.h; }$/;"	f
sortMatchSize	./GGraphOCR/GGraphOCRFont.cpp	/^static bool sortMatchSize(const ClusterMatch &d1, const ClusterMatch &d2) { return d1.w * d1.h > d2.w * d2.h; }$/;"	f	namespace:ocr
sortMatchW	./GLogicProcessor/GLogicProcessor.h	/^    static bool sortMatchW(const OCRMatch& d1, const OCRMatch& d2){$/;"	f	namespace:ocr
sortMatchX0	./GLogicProcessor/GLogicProcessor.h	/^    static bool sortMatchX0(const OCRMatch& d1, const OCRMatch& d2){$/;"	f	namespace:ocr
sortMatchXCenter	./GLogicProcessor/GLogicProcessor.h	/^    static bool sortMatchXCenter(const OCRMatch& d1, const OCRMatch& d2){$/;"	f	namespace:ocr
sortSearchData	./OCRTypes/OCRTypes_www.h	/^    static bool sortSearchData(const sortData& d1, const sortData& d2){$/;"	f	namespace:ocr
space	./GBitsetOCR/textOCR_.h	/^    int space=(strArray[0][index].MeanSA*10)\/spaceIndex;$/;"	v
space0	./GBitsetOCR/textOCR_.h	/^    int bRightOld=0,lw1,bLeft,space1,space0;$/;"	v
space1	./GBitsetOCR/textOCR_.h	/^    int bRightOld=0,lw1,bLeft,space1,space0;$/;"	v
spaceFlag	./GFontEditor/GLetter.h	/^  int spaceFlag;$/;"	m	class:ocr::wordOCR
sparc	./OCRAlgorithm/f2c.h	212;"	d
spellCheck	./GLogicProcessor/spellChecker.cpp	/^string  GLogicProcessor::spellCheck( string &str_){$/;"	f	class:GLogicProcessor
splitEngWord	./GLogicProcessor/grammarCorrector.cpp	/^string GLogicProcessor::splitEngWord(string &word, int *result){$/;"	f	class:GLogicProcessor
sqrtA	./GBitsetContour/GBitsetContour.cpp	/^int GBitsetContour::sqrtA(int data){$/;"	f	class:GBitsetContour
sqrt_buff	./GBitsetContour/GBitsetContour.h	/^    int sqrt_buff[16000];         \/\/\/<cash of sqrt function$/;"	m	class:ocr::GBitsetContour
srcH	./GBitset/GBitset.h	/^  short srcH;$/;"	m	class:ocr::GBitset
srcH	./GBitsetContour/GBitsetContour.h	/^  int srcH;$/;"	m	class:ocr::GBitsetContour
srcH	./GBitsetMatrix/GBitsetMatrix.h	/^  short srcH;$/;"	m	class:ocr::GBitsetMatrix
srcH	./GBitsetOCR/GBitsetOCR.h	/^  short srcH;$/;"	m	class:ocr::GBitsetOCR
srcInt	./GBitsetMatrix/GBitsetMatrix.h	/^  unsigned int *srcInt;         \/\/\/<буфер массива горизонтальных строк$/;"	m	class:ocr::GBitsetMatrix
srcIntFlag	./GBitsetMatrix/GBitsetMatrix.h	/^  int srcIntFlag;               \/\/\/флаг заполнения массива srcInt и  sInt$/;"	m	class:ocr::GBitsetMatrix
srcKey	./OCRTypes/OCRTypes.h	/^  string srcKey;$/;"	m	struct:ocr::dictKeyStruct
srcKey	./OCRTypes/OCRTypes_www.h	/^		string srcKey;$/;"	m	struct:ocr::dictKey
srcW	./GBitset/GBitset.h	/^  short srcW;$/;"	m	class:ocr::GBitset
srcW	./GBitsetContour/GBitsetContour.h	/^  int srcW;$/;"	m	class:ocr::GBitsetContour
srcW	./GBitsetMatrix/GBitsetMatrix.h	/^  short srcW;$/;"	m	class:ocr::GBitsetMatrix
srcW	./GBitsetOCR/GBitsetOCR.h	/^  short srcW;$/;"	m	class:ocr::GBitsetOCR
srgb_defined	./PNG/lodepng.h	/^  unsigned srgb_defined; \/* Whether an sRGB chunk is present (0 = not present, 1 = present). *\/$/;"	m	struct:LodePNGInfo
srgb_intent	./PNG/lodepng.h	/^  unsigned srgb_intent;  \/* Rendering intent: 0=perceptual, 1=rel. colorimetric, 2=saturation, 3=abs. colorimetric *\/$/;"	m	struct:LodePNGInfo
stability	./OCRTypes/OCRTypes.h	/^  char stability;$/;"	m	class:ocr::OCRPointFloat
stability	./OCRTypes/OCRTypes_www.h	/^        char stability;$/;"	m	class:ocr::OCRPointFloat
stackFlag	./GFontEditor/GLetter.h	/^  int stackFlag;$/;"	m	class:ocr::GLetter
stackFlag	./GFontEditor/GLetter.h	/^  int stackFlag;$/;"	m	class:ocr::wordOCR
stackFlag	./OCRTypes/OCRTypes.h	/^  int stackFlag;$/;"	m	struct:ocr::uniLetterRecord
stackFlag	./OCRTypes/OCRTypes.h	/^enum stackFlag {$/;"	g	namespace:ocr
stackFlag	./OCRTypes/OCRTypes_www.h	/^		int stackFlag;$/;"	m	struct:ocr::uniLetterRecord
stackFlag	./OCRTypes/OCRTypes_www.h	/^        enum  stackFlag{$/;"	g	namespace:ocr
stackIntersectionArea	./GLogicProcessor/intersectionArea.cpp	/^int  GLogicProcessor::stackIntersectionArea(OCRMatch &a, OCRMatch &b,OCRBox *s, GBitmap *lineImg32,GBitmap *letterAImg,GBitmap *letterBImg){$/;"	f	class:GLogicProcessor
star	./GGraph/GGraph.h	/^	OCRStar *star;	 \/\/\/<указатель на массив OCRStar буквы$/;"	m	struct:ocr::OCRLetterStruct
star	./GGraph/GGraph.h	/^	OCRStar star[5];	\/\/\/<OCRStar в OCRCluster$/;"	m	struct:ocr::OCRClusterStruct
star	./GGraph/GGraph.h	/^	uint star[12]; \/\/\/<массив id номеров звездочек соединных с центром OCRStar фокальной или опорной линией$/;"	m	struct:ocr::OCRStarStruct
starArray	./GGraph/GGraph.h	/^	GStr<OCRStar> starArray;$/;"	m	class:ocr::GGraph
starCount	./GGraph/GGraph.h	/^	uchar  starCount;$/;"	m	struct:ocr::OCRClusterStruct
starCount	./GGraph/GGraph.h	/^	uchar starCount;$/;"	m	struct:ocr::OCRStarStruct
starCount	./GGraph/GGraph.h	/^	ushort starCount;  \/\/\/<количество OCRStar в букве$/;"	m	struct:ocr::OCRLetterStruct
starCount	./GGraphOCR/GGraphOCRDrawLetterSVG.cpp	/^int starCount;$/;"	m	namespace:ocr	file:
starData	./GFontEditor/GFontEditor.h	/^        GVector *starData;$/;"	m	class:ocr::GFontEditor
starIndex	./GGraphOCR/GGraphOCR.h	/^	uchar starIndex;  \/\/\/<номер OCRStar кластера в букве в которой размещен кластер.$/;"	m	struct:ClusterMatchStruct
starTIndex	./GGraphOCR/GGraphOCR.h	/^	uchar starTIndex; \/\/\/<номер OCRStar найденного в букве.$/;"	m	struct:ClusterMatchStruct
start	./GFontEditor/GLetter.h	/^  OCRPointFloat start;$/;"	m	class:ocr::OCRMatch
start	./GFontEditor/GLetter.h	/^  OCRPointFloat start;$/;"	m	class:ocr::OCRMatchConst
start	./GGraph/GGraph.h	/^	OCRPoint start; \/\/\/< координаты начала линии.$/;"	m	struct:ocr::OCRLineStruct
start	./GGraphBezier/GGraphBezier.h	/^        OCRPointFloat start;     \/\/ координаты начала линии.$/;"	m	class:ocr::OCRFocalLineBezier
start	./config.h	/^	int start;$/;"	m	struct:commandData
start32	./GGraph/GGraph.h	/^	OCRPoint start32;\/\/\/< координаты начала линии в маске 32х32. $/;"	m	struct:ocr::OCRLineStruct
startConvert	./GLogicProcessor/startConvert.cpp	/^string GLogicProcessor::startConvert(){$/;"	f	class:GLogicProcessor
startDictionary	./GLogicProcessor/startDictionary.cpp	/^string GLogicProcessor::startDictionary(){$/;"	f	class:GLogicProcessor
startDir	./GBitsetContour/GBitsetContour.h	/^	short xMax,xMin,yMin,yMax, XMCenter, YMCenter, startDir;$/;"	m	class:ocr::GBitsetContour
startID	./GGraph/GGraph.h	/^	uint startID;	 \/\/\/< id номер стартовой OCRStar$/;"	m	struct:ocr::OCRLineStruct
startIndex	./GGraph/GGraph.h	/^	uchar startIndex;  \/\/\/< индекс линии в стартовой  OCRStar  $/;"	m	struct:ocr::OCRLineStruct
startIndex	./OCRTypes/OCRTypes.h	/^  int startIndex;$/;"	m	struct:ocr::stringMatch_
startIndex	./OCRTypes/OCRTypes_www.h	/^		int startIndex;$/;"	m	struct:ocr::stringMatch_
startIndex	./config.h	/^	int startIndex;$/;"	m	struct:commandData
startLetter	./GBitsetContour/GBitsetContour.h	/^	short max_down, startLetter, startLine, contourCount, contourIndex, indexFilter;$/;"	m	class:ocr::GBitsetContour
startLine	./GBitsetContour/GBitsetContour.h	/^	short max_down, startLetter, startLine, contourCount, contourIndex, indexFilter;$/;"	m	class:ocr::GBitsetContour
startOCR	./GMainEditor/startOCR.cpp	/^void GMainEditor::startOCR(GBitmap *pechaImg_){$/;"	f	class:GMainEditor
startOCRBatch	./GMainEditor/startOCR.cpp	/^void GMainEditor::startOCRBatch(){$/;"	f	class:GMainEditor
startOCRSystem	./GMainEditor/startOCR.cpp	/^void GMainEditor::startOCRSystem(){$/;"	f	class:GMainEditor
startSVG	./OCRString/php2stl.cpp	/^string startSVG() {$/;"	f
startTest	./GBitset/GBitsetTest.cpp	/^ void GBitset::startTest(){$/;"	f	class:GBitset
startVectorOCR	./GMainEditor/vectorOCR.cpp	/^void GMainEditor::startVectorOCR(){$/;"	f	class:GMainEditor
status	./GBitMask/GBitMask.h	/^		char status;     \/\/ статус маски$/;"	m	class:ocr::GBitMask128
status	./GBitMask/GBitMask.h	/^		int status;                \/\/\/< статус маски$/;"	m	class:ocr::GBitMask32
status	./GFontEditor/GLetter.h	/^  int status;$/;"	m	class:ocr::OCRMatch
status	./GFontEditor/GLetter.h	/^  int status;$/;"	m	class:ocr::OCRMatchConst
status	./GGraph/GGraph.h	/^	char status;$/;"	m	struct:ocr::OCRMaskStruct
status	./GGraph/GGraph.h	/^	char status;$/;"	m	struct:ocr::OCRRegisterStruct
status	./GGraph/GGraph.h	/^	char status;$/;"	m	struct:ocr::OCRStarStruct
status	./GGraph/GGraph.h	/^	uchar  status;$/;"	m	struct:ocr::OCRClusterStruct
status	./GGraph/GGraph.h	/^	uchar status;	   \/\/\/< статус линии$/;"	m	struct:ocr::OCRLineStruct
status	./GGraph/GGraph.h	/^	ushort status;$/;"	m	struct:ocr::OCRLetterStruct
status	./GGraphBezier/GGraphBezier.h	/^        int status;         \/\/ статус линии$/;"	m	class:ocr::OCRFocalLineBezier
status	./GLogicProcessor/dictReportLocal.cpp	/^    int status;$/;"	m	struct:textK	file:
status	./GMemory/GMemory.h	/^	int status;$/;"	m	class:ocr::indexRecord
status	./GMemory/GMemory.h	/^	int status;$/;"	m	class:ocr::tableRecord
status	./OCRTypes/OCRTypes.h	/^  char status;$/;"	m	class:ocr::OCRPointFloat
status	./OCRTypes/OCRTypes.h	/^  int status;$/;"	m	struct:ocr::pidIDStruct
status	./OCRTypes/OCRTypes.h	/^  uchar status;$/;"	m	struct:ocr::OCRPointStruct
status	./OCRTypes/OCRTypes.h	/^  ushort status;$/;"	m	struct:ocr::OCRBoxStruct
status	./OCRTypes/OCRTypes_www.h	/^		char status;$/;"	m	class:ocr::OCRPointFloat
status	./OCRTypes/OCRTypes_www.h	/^		int status;$/;"	m	class:ocr::OCRBox
status	./OCRTypes/OCRTypes_www.h	/^		int status;$/;"	m	struct:ocr::pidIDStruct
stdout	./codeStorage.h	/^clearerr(stdout);$/;"	v
stdout	./codeStorage.h	/^fflush(stdout);$/;"	v
stepBit	./GBitset/GBitset.h	/^  short stepBit;$/;"	m	class:ocr::GBitset
stepBit	./GBitsetContour/GBitsetContour.h	/^  int stepBit;$/;"	m	class:ocr::GBitsetContour
stepBit	./GBitsetOCR/GBitsetOCR.h	/^  short stepBit;$/;"	m	class:ocr::GBitsetOCR
str	./GFontEditor/GLetter.h	/^  string str;$/;"	m	class:ocr::stringOCR
str	./codeStorage.h	/^ostringstream str;$/;"	v
str	./workCode_retreat.h	/^string str;$/;"	v
strArray	./GBitset/GBitset.h	/^  vector<stringOCR>*strArray;$/;"	m	class:ocr::GBitset
strArray	./GBitsetContour/GBitsetContour.h	/^  vector<stringOCR>*strArray;     \/\/\/<массив информации о координатах строк и букв. Используется для передачи результатов распознавания между классами$/;"	m	class:ocr::GBitsetContour
strArray	./GBitsetMatrix/GBitsetMatrix.h	/^  vector<stringOCR>*strArray;     \/\/\/<массив координат строк и букв$/;"	m	class:ocr::GBitsetMatrix
strArray	./GBitsetOCR/GBitsetOCR.h	/^    vector<stringOCR>*strArray;$/;"	m	class:ocr::GBitsetOCR
strArray	./GLogicProcessor/GLogicProcessor.h	/^    vector<stringOCR>*strArray;     \/\/page data of text OCR$/;"	m	class:ocr::GLogicProcessor
strArray	./GMainEditor/GMainEditor.h	/^        vector<stringOCR>strArray;$/;"	m	class:ocr::GMainEditor
strData	./config.h	/^	const char *strData;$/;"	m	struct:commandData
strHTML	./GFontEditor/GLetter.h	/^  string strHTML;$/;"	m	class:ocr::stringOCR
strLen	./OCRString/php2stl.cpp	/^int strLen(string &input) {$/;"	f
strLenW	./OCRString/php2stl.cpp	/^int strLenW(wstring &input) {$/;"	f
strPNG	./GBitmap/GBitmap.cpp	/^void GBitmap::strPNG(string &data) {$/;"	f	class:ocr::GBitmap
strPtr	./OCRTypes/OCRTypes.h	/^  char *strPtr;$/;"	m	struct:ocr::stringEntry_
strPtr	./OCRTypes/OCRTypes_www.h	/^		char *strPtr;$/;"	m	struct:ocr::stringEntry_
strSize	./OCRTypes/OCRTypes.h	/^  int strSize;$/;"	m	struct:ocr::stringEntry_
strSize	./OCRTypes/OCRTypes_www.h	/^		int  strSize;$/;"	m	struct:ocr::stringEntry_
strText	./GLogicProcessor/GLogicProcessor.h	/^    string strText;$/;"	m	class:ocr::GLogicProcessor
strTextW	./GLogicProcessor/GLogicProcessor.h	/^    wstring strTextW; \/\/$/;"	m	class:ocr::GLogicProcessor
strToHash	./OCRString/php2stl.cpp	/^unsigned int strToHash(cstr str, unsigned int len) {$/;"	f
strVector	./GLogicProcessor/GLogicProcessor.h	/^	vector<string>strVector; \/\/\/<source text vector$/;"	m	class:ocr::GLogicProcessor
str_replace	./OCRString/php2stl.cpp	/^string str_replace(cstr srcChar, cstr destChar, cstr srcStringChar) {$/;"	f
str_replace	./OCRString/php2stl.cpp	/^string str_replace(cstr srcChar, cstr destChar, cstr srcStringChar, int count) {$/;"	f
str_replace	./OCRString/php2stl.cpp	/^string str_replace(cstr srcChar, cstr destChar, string &srcString) {$/;"	f
str_replace	./OCRString/php2stl.cpp	/^string str_replace(cstr srcChar, string &dest, string &srcString) {$/;"	f
str_replace	./OCRString/php2stl.cpp	/^string str_replace(string &src, string &dest, string &srcString) {$/;"	f
str_replace	./OCRString/php2stl.cpp	/^string str_replace(string &src, string &dest, string &srcString, int count) {$/;"	f
str_replace	./OCRString/php2stl.cpp	/^string str_replace(vector<string> &srcArray, cstr destData, string &srcString) {$/;"	f
stringDraw	./GBitset/GBitset_algorithm.cpp	/^void GBitset::stringDraw(int color){$/;"	f	class:GBitset
stringEntry	./OCRTypes/OCRTypes.h	/^} stringEntry;$/;"	t	namespace:ocr	typeref:struct:ocr::stringEntry_
stringEntry	./OCRTypes/OCRTypes_www.h	/^	}stringEntry;	$/;"	t	namespace:ocr	typeref:struct:ocr::stringEntry_
stringEntry_	./OCRTypes/OCRTypes.h	/^typedef struct stringEntry_ {$/;"	s	namespace:ocr
stringEntry_	./OCRTypes/OCRTypes_www.h	/^	typedef struct stringEntry_{$/;"	s	namespace:ocr
stringFlag	./GFontEditor/GLetter.h	/^  int stringFlag; \/\/\/ флаг cтроки  =0 (=1), cтрока состоит из линии (букв).$/;"	m	class:ocr::stringOCR
stringIndex	./GMainEditor/GMainEditor.h	/^        int stringIndex, wordIndex, iLeft,iTop;$/;"	m	class:ocr::GMainEditor
stringItemVector	./GLogicProcessor/GLogicProcessor.h	/^	vector <string> stringItemVector;$/;"	m	class:ocr::GLogicProcessor
stringMatch	./OCRTypes/OCRTypes.h	/^} stringMatch;$/;"	t	namespace:ocr	typeref:struct:ocr::stringMatch_
stringMatch	./OCRTypes/OCRTypes_www.h	/^	}stringMatch;$/;"	t	namespace:ocr	typeref:struct:ocr::stringMatch_
stringMatch_	./OCRTypes/OCRTypes.h	/^typedef struct stringMatch_ {$/;"	s	namespace:ocr
stringMatch_	./OCRTypes/OCRTypes_www.h	/^	typedef struct stringMatch_{$/;"	s	namespace:ocr
stringNormalisation	./GBitset/GBitset_Letter.cpp	/^void GBitset::stringNormalisation(){$/;"	f	class:GBitset
stringNum	./GBitsetMatrix/GBitsetMatrix.h	/^  int stringNum;                  \/\/\/<номер строки в тексте$/;"	m	class:ocr::GBitsetMatrix
stringNum	./GFontEditor/GLetter.h	/^  int stringNum;$/;"	m	class:ocr::GLetter
stringOCR	./GFontEditor/GLetter.cpp	/^stringOCR::stringOCR(){$/;"	f	class:stringOCR
stringOCR	./GFontEditor/GLetter.h	/^  stringOCR(int _x, int _y, int _x1, int _y1) {$/;"	f	class:ocr::stringOCR
stringOCR	./GFontEditor/GLetter.h	/^class stringOCR {$/;"	c	namespace:ocr
stringOCR_sort	./GFontEditor/GLetter.h	/^  static bool stringOCR_sort(const stringOCR &d1, const stringOCR &d2) {$/;"	f	class:ocr::stringOCR
stringToHex	./OCRString/php2stl.cpp	/^void stringToHex(string &str) {$/;"	f
string_cleanup	./PNG/lodepng.cpp	/^static void string_cleanup(char** out)$/;"	f	file:
stripLetters	./OCRString/php2stl.cpp	/^void stripLetters(string &str) {  \/\/ remove all letters from str$/;"	f
substr	./GFontEditor/GLetter.cpp	/^stringOCR stringOCR::substr(int position,int length){$/;"	f	class:stringOCR
substr	./OCRString/php2stl.cpp	/^cstr substr(int inInd, int count, cstr str1) {$/;"	f
substr	./OCRString/php2stl.cpp	/^string substr(int inInd, int count, string &srcString) {$/;"	f
substr	./OCRString/php2stl.cpp	/^string substr(int inInd, string &srcString) {$/;"	f
substrH	./OCRString/php2stl.cpp	/^string substrH(cstr buf, string &srcString) {$/;"	f
substrT	./OCRString/php2stl.cpp	/^string substrT(cstr buf, string &srcString) {$/;"	f
sumLen	./GGraph/GGraph.h	/^	ushort sumLen;	  \/\/\/< сумма всех лимитированных длин линий$/;"	m	struct:ocr::OCRStarStruct
sumLen	./GGraph/GGraph.h	/^	ushort sumLen; \/\/\/< сумма длин линий всех звездочек буквы$/;"	m	struct:ocr::OCRLetterStruct
sumLen1	./GGraph/GGraph.h	/^	ushort sumLen1;	  \/\/\/< сумма всех лимитированных длин линий и периметра$/;"	m	struct:ocr::OCRStarStruct
sumLenA	./GGraph/GGraph.h	/^	int sumLenA;	  \/\/\/<сумма длин  линий$/;"	m	struct:ocr::OCRStarStruct
sun	./OCRAlgorithm/f2c.h	213;"	d
sun2	./OCRAlgorithm/f2c.h	214;"	d
sun3	./OCRAlgorithm/f2c.h	215;"	d
sun4	./OCRAlgorithm/f2c.h	216;"	d
syllableCount	./GFontEditor/GLetter.h	/^  int syllableCount;$/;"	m	class:ocr::stringOCR
szf	./GBitset/GBitset.h	/^ int szf;       \/\/\/< обычно в 32р системах sfz=4=32\/8;  szf=sizeof(int);$/;"	m	class:ocr::GBitset
szf	./OCRAlgorithm/OCRAlgorithm.h	/^		 int szf;       \/\/\/< обычно в 32р системах sfz=4=32\/8;  szf=sizeof(int);$/;"	m	class:ocr::OCRFilter
t	./GBitsetContour/GBitsetContour.h	/^	short dlt_y, t, d, xl, yl, n,m;$/;"	m	class:ocr::GBitsetContour
tDictEngIndex	./GLogicProcessor/GLogicProcessor.h	/^    GMap *tDictEngIndex;$/;"	m	class:ocr::GLogicProcessor
tDictRusIndex	./GLogicProcessor/GLogicProcessor.h	/^    GMap *tDictRusIndex;$/;"	m	class:ocr::GLogicProcessor
tLine	./OCRTypes/OCRTypes.h	/^  short tLine[1024];$/;"	m	class:ocr::OCRTextData
tLine	./OCRTypes/OCRTypes_www.h	/^		short tLine[1024];$/;"	m	class:ocr::OCRTextData
tPoint	./GBitsetContour/GBitsetContour.h	/^	bool *tPoint;$/;"	m	class:ocr::GBitsetContour
tabAlpha_1	./GBitmap/GBitmap.h	/^	float tabAlpha_1[361]; \/\/ предпросчитаная таблица коэффициента корреляции уголов. \/\/$/;"	m	class:ocr::GBitmap
table	./GMemory/GMemory.h	/^	map<string, tableRecord> table; \/\/tableRecord data by table name$/;"	m	class:ocr::GMemory
tableLetters	./GMemory/GMap/tableLetters.cpp	/^void GMap::tableLetters(){$/;"	f	class:GMap
tableProcessing	./GMemory/GMap/tableProcessing.cpp	/^void GMap::tableProcessing(int mode){$/;"	f	class:GMap
tableProcessingDict	./GMemory/GMap/tableProcessingDict.cpp	/^void GMap::tableProcessingDict(int mode){$/;"	f	class:GMap
tableProcessingFontMatch	./GMemory/GMap/tableProcessingFontMatch.cpp	/^void GMap::tableProcessingFontMatch(map<vector<int>,ulong>&searchResult,int mode){$/;"	f	class:GMap
tableProcessingFullMatch	./GMemory/GMap/tableProcessing.cpp	/^void GMap::tableProcessingFullMatch(vector<ulong>&searchResult){$/;"	f	class:GMap
tableProcessingFullMatch	./GMemory/GMap/tableProcessingFullMatch.cpp	/^ulong GMap::tableProcessingFullMatch(int mode){$/;"	f	class:GMap
tableProcessingID	./GMemory/GMap/tableProcessingID.cpp	/^void GMap::tableProcessingID(GStr<uint>*result){$/;"	f	class:GMap
tableProcessingMatch	./GMemory/GMap/tableProcessingFullMatch.cpp	/^ulong GMap::tableProcessingMatch(int mode){$/;"	f	class:GMap
tableProcessingMatch	./GMemory/GMap/tableProcessingFullMatch.cpp	/^void GMap::tableProcessingMatch(wstring &key,vector<ulong>&searchResult, uint limit){$/;"	f	class:GMap
tableProcessingOCRMatch	./GMemory/GMap/tableProcessingOCRMatch.cpp	/^void GMap::tableProcessingOCRMatch(vector<ulong>&searchResult,int mode){$/;"	f	class:GMap
tableProcessingStack	./GMemory/GMap/tableProcessingStack.cpp	/^void GMap::tableProcessingStack(GStr<ulong> *searchResult_, int mode){$/;"	f	class:GMap
tableProcessingText	./GMemory/GMap/tableProcessingFullMatch.cpp	/^void GMap::tableProcessingText(wstring &key,vector<dictKey>&searchResult, uint limit){$/;"	f	class:GMap
tableRecord	./GMemory/GMemory.cpp	/^tableRecord::tableRecord()$/;"	f	class:ocr::tableRecord
tableRecord	./GMemory/GMemory.h	/^class tableRecord$/;"	c	namespace:ocr
tableText	./GMemory/GMap/tableText.cpp	/^void GMap::tableText(string&text,uint mode){$/;"	f	class:GMap
table_1	./GBitmap/GBitmap.h	/^	unsigned char table_1[256]; \/\/ предпросчитаная таблица особых точек \/\/$/;"	m	class:ocr::GBitmap
table_2	./GBitmap/GBitmap.h	/^		table_2[256]; \/\/ предпросчитаная таблица адресов смещения точек вдоль фокальной линии (упаковано по 2 short) \/\/$/;"	m	class:ocr::GBitmap
table_3	./GBitmap/GBitmap.h	/^		table_3[256]; \/\/ предпросчитаная таблица адресов точек начала фокальных линий (упаковано по 4 short) \/\/$/;"	m	class:ocr::GBitmap
table_Dict	./GMemory/GMap/tableDict.cpp	/^void GMap::table_Dict(){$/;"	f	class:GMap
tail	./PNG/lodepng.cpp	/^  struct BPMNode* tail; \/*the next nodes in this chain (null if last)*\/$/;"	m	struct:BPMNode	typeref:struct:BPMNode::BPMNode	file:
test	./GGraphBezier/GGraphBezier.h	/^        vector<OCRPointFloat>test;    \/\/ - вектор для вывода на экран нескольких тестовых точек линии (NO Б.Д.).$/;"	m	class:ocr::OCRFocalLineBezier
testBase	./GFontEditor/testLetter.cpp	/^void GFontEditor::testBase(){$/;"	f	class:GFontEditor
testCorrelation	./GGraphOCR/GGraphOCRTextCorrelation.cpp	/^void GGraphOCR::testCorrelation(int letterID) {$/;"	f	class:ocr::GGraphOCR
testDelimeter	./GFontEditor/GLetter.cpp	/^bool wordOCR::testDelimeter(vector<string> &ref){$/;"	f	class:wordOCR
testLetter	./GFontEditor/GFont.h	/^        int testLetter;$/;"	m	class:ocr::GFont
testLetter	./GFontEditor/testLetter.cpp	/^void GFontEditor::testLetter(GLetter *letter, int mode){$/;"	f	class:GFontEditor
testLetter	./GFontEditor/testLetter.cpp	/^void GFontEditor::testLetter(GLetter *letter,vector<OCRMatch>&letterLine,int mode,uint *startIndex){$/;"	f	class:GFontEditor
testLetterInLine	./GFontEditor/testLetter.cpp	/^void GFontEditor::testLetterInLine(GLetter *letter,vector<OCRMatch>&letterLine,vector<OCRMatch>&letterLineNew){$/;"	f	class:GFontEditor
testLetterP	./GMemory/GMap/GMap.cpp	/^int GMap::testLetterP(uint letter1, uint letter2){$/;"	f	class:GMap
testMask	./GFontEditor/buildLetter.cpp	/^void GFontEditor::testMask(){$/;"	f	class:GFontEditor
testMatch	./GGraphOCR/GGraphOCRTextCorrelationHash.cpp	/^int testMatch(OCRLetter &letter, int x, int y) {$/;"	f	namespace:ocr
testPopCnt	./GBitmap/GBitmapPenWidth.cpp	/^  void GBitmap::testPopCnt(){$/;"	f	class:ocr::GBitmap
testStackLetter	./GLogicProcessor/testStack.cpp	/^void GLogicProcessor::testStackLetter(vector<OCRMatch>&line,GBitmap* lineImg32,GBitmap* letterAImg,GBitmap* letterBImg){$/;"	f	class:GLogicProcessor
testStackLetterNew	./GLogicProcessor/testWordLine.cpp	/^void GLogicProcessor::testStackLetterNew(vector<OCRMatch>&line,vector<OCRMatch>&originalMatch,GBitmap* lineImg32,GBitmap* letterAImg,GBitmap* letterBImg){$/;"	f	class:GLogicProcessor
testVector	./GBitMask/algorithmOCR_128.cpp	/^void GBitMask128::testVector(ofstream &c_out){$/;"	f	class:GBitMask128
testWordLine	./GLogicProcessor/testWordLine.cpp	/^void GLogicProcessor::testWordLine(GBitmap *lineImg32,$/;"	f	class:GLogicProcessor
text2Cluster	./GGraphOCR/GGraphOCR.h	/^	vector<vector<int> > text2Cluster; \/\/\/<таблица в которой каждая строка это список базовых кластеров для одной OCRStar текста$/;"	m	class:ocr::GGraphOCR
textBuffer	./GLogicProcessor/GLogicProcessor.h	/^	char *textBuffer;     \/\/main text buffer of grammar dictionary$/;"	m	class:ocr::GLogicProcessor
textCluster	./GGraphOCR/GGraphOCR.h	/^	vector<vector<int> > textCluster; \/\/\/<таблица в которой каждая строка это список OCRStar текста$/;"	m	class:ocr::GGraphOCR
textCorpus	./GLogicProcessor/GLogicProcessor.h	/^    GVector *textCorpus;            \/\/\/vector with all tibetan corpus text data$/;"	m	class:ocr::GLogicProcessor
textCorpus	./GMemory/GMemory.h	/^	GVector *textCorpus;	 \/\/\/vector with all tibetan OCR corpus text data$/;"	m	class:ocr::GMemory
textCorpusGMap	./GLogicProcessor/GLogicProcessor.h	/^    GMap *textCorpusGMap;           \/\/\/map with all tibetan corpus text data$/;"	m	class:ocr::GLogicProcessor
textCorpusGMap	./GMemory/GMemory.h	/^	GMap *textCorpusGMap;	\/\/\/map with all tibetan OCR corpus text data$/;"	m	class:ocr::GMemory
textCorpusLib	./GMemory/GMemory.h	/^	GVector *textCorpusLib;  \/\/\/vector with all tibetan library corpus text data$/;"	m	class:ocr::GMemory
textCorpusLibGMap	./GMemory/GMemory.h	/^	GMap *textCorpusLibGMap; \/\/\/map with all tibetan library corpus text data$/;"	m	class:ocr::GMemory
textCorrector	./GLogicProcessor/grammarCorrector.cpp	/^int GLogicProcessor::textCorrector(vector<OCRMatch>&dLine, string &mainString){$/;"	f	class:GLogicProcessor
textCorrelation	./GGraphOCR/GGraphOCRCorrelation.cpp	/^void GGraphOCR::textCorrelation(GGraph &graph, OCRLetter &letter) {$/;"	f	class:ocr::GGraphOCR
textCorrelationHash	./GGraphOCR/GGraphOCRTextCorrelationHash.cpp	/^void GGraphOCR::textCorrelationHash(GGraph &graph, vector<OCRLetter> &matchLetter, int correlationLimit) {$/;"	f	class:ocr::GGraphOCR
textCorrelationLookup1	./GGraphOCR/GGraphOCRTextCorrelation.cpp	/^void GGraphOCR::textCorrelationLookup1(GGraph &graph) {$/;"	f	class:ocr::GGraphOCR
textDictEng	./GLogicProcessor/GLogicProcessor.h	/^    char *textDictEng;    \/\/main text buffer of English grammar dictionary$/;"	m	class:ocr::GLogicProcessor
textDictEngSize	./GLogicProcessor/GLogicProcessor.h	/^    unsigned long textDictEngSize;$/;"	m	class:ocr::GLogicProcessor
textDictRus	./GLogicProcessor/GLogicProcessor.h	/^    char *textDictRus;    \/\/main text buffer of Russian grammar dictionary$/;"	m	class:ocr::GLogicProcessor
textDictRusSize	./GLogicProcessor/GLogicProcessor.h	/^    unsigned long textDictRusSize;$/;"	m	class:ocr::GLogicProcessor
textDictTib	./GLogicProcessor/GLogicProcessor.h	/^    char *textDictTib;    \/\/main text buffer of Tibetan grammar dictionary$/;"	m	class:ocr::GLogicProcessor
textDictTibSize	./GLogicProcessor/GLogicProcessor.h	/^    unsigned long textDictTibSize;$/;"	m	class:ocr::GLogicProcessor
textDictionary	./GLogicProcessor/GLogicProcessor.h	/^	vector<string> textDictionary; \/\/\/vector for all words and phrases;$/;"	m	class:ocr::GLogicProcessor
textDictionaryKey	./GLogicProcessor/GLogicProcessor.h	/^	vector<string> textDictionaryKey; \/\/\/vector for all words and phrases key without words delimeters;	$/;"	m	class:ocr::GLogicProcessor
textK	./GLogicProcessor/dictReportLocal.cpp	/^struct textK{$/;"	s	file:
textKeyIndex	./GLogicProcessor/GLogicProcessor.h	/^	vector<stringEntry> textKeyIndex; \/\/\/vector for all words and phrases key without grammar particals and words delimeters(about 600mb);$/;"	m	class:ocr::GLogicProcessor
textLineSize	./GBitsetContour/GBitsetContour.h	/^  int textLineSize;	               \/\/\/<установочный размер строки текста. Используется для определения параметров векторизации. text line size for set the parameters of vectorisation	$/;"	m	class:ocr::GBitsetContour
textLineSize	./GFontEditor/GFont.h	/^        int textLineSize;$/;"	m	class:ocr::GFont
textLineSize	./GFontEditor/GLetter.h	/^  int textLineSize; \/\/ size of text line in text in pixels$/;"	m	class:ocr::GLetter
textMatch	./GBitsetOCR/GBitsetOCR.h	/^  vector<OCRMatch>textMatch;$/;"	m	class:ocr::GBitsetOCR
textNegative	./GBitmap/GBitmapTextOrientation.cpp	/^  int  GBitmap::textNegative() {$/;"	f	class:ocr::GBitmap
textNormalisation	./GLogicProcessor/grammarCorrector.cpp	/^void GLogicProcessor::textNormalisation( string &str){$/;"	f	class:GLogicProcessor
textOCR	./GBitsetOCR/textOCR.cpp	/^void GBitsetOCR::textOCR(vector<stringOCR>&correctionTable,GLogicProcessor *logicProcessor, int mode){$/;"	f	class:GBitsetOCR
textOCR	./GGraphOCR/GGraphOCRTextOCR.cpp	/^void GGraphOCR::textOCR() {$/;"	f	class:ocr::GGraphOCR
textOCRData	./GBitsetContour/GBitsetContour.h	/^	OCRTextData* textOCRData; \/\/all OCR data about current pecha$/;"	m	class:ocr::GBitsetContour
textOrientation	./GBitmap/GBitmapTextOrientation.cpp	/^  void  GBitmap::textOrientation(int *lineOrient, int *lineHeight) {$/;"	f	class:ocr::GBitmap
textVerticalRotation	./GBitmap/GBitmapTextOrientation.cpp	/^  void  GBitmap::textVerticalRotation(int Orient, int *lnOrient, int *lnHeight) {$/;"	f	class:ocr::GBitmap
text_compression	./PNG/lodepng.h	/^  unsigned text_compression;$/;"	m	struct:LodePNGEncoderSettings
text_data	./GMemory/GMap/GMap.h	/^        mSIZE  *text_data;       \/\/ массив распознаваемого текста$/;"	m	class:ocr::GMap
text_data_vector	./GMemory/GMap/GMap.h	/^        GStr<mSIZE>*text_data_vector;$/;"	m	class:ocr::GMap
text_keys	./PNG/lodepng.h	/^  char** text_keys; \/*the keyword of a text chunk (e.g. "Comment")*\/$/;"	m	struct:LodePNGInfo
text_num	./PNG/lodepng.h	/^  size_t text_num; \/*the amount of texts in these char** buffers (there may be more texts in itext)*\/$/;"	m	struct:LodePNGInfo
text_size	./GLogicProcessor/GLogicProcessor.h	/^    unsigned int text_size;           \/\/ размер массива распознаваемого текста$/;"	m	class:ocr::GLogicProcessor
text_size	./GMemory/GMap/GMap.h	/^        ulong text_size;           \/\/ размер массива распознаваемого текста$/;"	m	class:ocr::GMap
text_size1	./GMemory/GMap/GMap.h	/^        uint text_size1;       \/\/ размер массива распознаваемого текста(ключей) без переводов каретки Enter$/;"	m	class:ocr::GMap
text_strings	./PNG/lodepng.h	/^  char** text_strings; \/*the actual text*\/$/;"	m	struct:LodePNGInfo
th	./config.h	/^		long tl, th;$/;"	m	struct:ticks::dblword
tib	./OCRTypes/OCRTypes.h	/^  string tib;$/;"	m	struct:ocr::dictKeyStruct
tib	./OCRTypes/OCRTypes_www.h	/^		string tib;$/;"	m	struct:ocr::dictKey
tibKey	./OCRTypes/OCRTypes.h	/^  string tibKey;$/;"	m	struct:ocr::dictKeyStruct
tibKey	./OCRTypes/OCRTypes_www.h	/^		string tibKey;$/;"	m	struct:ocr::dictKey
tibStr	./GLogicProcessor/GLogicProcessor.h	/^	vector<string>tibStr;$/;"	m	class:ocr::GLogicProcessor
tibetanUTFToYagpo	./GLogicProcessor/UniToYagpo.cpp	/^string GLogicProcessor::tibetanUTFToYagpo(string &uniStack,int mode){$/;"	f	class:GLogicProcessor
ticks	./config.h	/^typedef union ticks {$/;"	u
time	./PNG/lodepng.h	/^  LodePNGTime time;$/;"	m	struct:LodePNGInfo
time_defined	./PNG/lodepng.h	/^  unsigned time_defined; \/*set to 1 to make the encoder generate a tIME chunk*\/$/;"	m	struct:LodePNGInfo
tl	./config.h	/^		long tl, th;$/;"	m	struct:ticks::dblword
toolsRadon	./GBitmap/GBitmapDetectorRadon.cpp	/^  void GBitmap::toolsRadon( int sign,$/;"	f	class:ocr::GBitmap
top	./GFontEditor/GLetter.h	/^  int top;$/;"	m	class:ocr::stringOCR
topic	./OCRTypes/OCRTypes.h	/^  string topic;$/;"	m	struct:ocr::sData
topic	./OCRTypes/OCRTypes_www.h	/^        string topic;$/;"	m	struct:ocr::sData
translateHex	./OCRString/php2stl.cpp	/^char translateHex(char hex) {$/;"	f
translationDictEng	./GLogicProcessor/GLogicProcessor.h	/^    GVector *translationDictEng;$/;"	m	class:ocr::GLogicProcessor
translationDictEng	./GMemory/GMemory.h	/^	GVector *translationDictEng;  \/\/\/vector with text data of translation dictionary$/;"	m	class:ocr::GMemory
translationDictGMapEng	./GMemory/GMemory.h	/^	GMap *translationDictGMapEng; \/\/\/main map of translation dictionary$/;"	m	class:ocr::GMemory
translationDictGMapRus	./GMemory/GMemory.h	/^	GMap *translationDictGMapRus; \/\/\/main map of translation dictionary$/;"	m	class:ocr::GMemory
translationDictRus	./GLogicProcessor/GLogicProcessor.h	/^    GVector *translationDictRus;$/;"	m	class:ocr::GLogicProcessor
translationDictRus	./GMemory/GMemory.h	/^	GVector *translationDictRus;  \/\/\/vector with text data of translation dictionary$/;"	m	class:ocr::GMemory
translit	./OCRTypes/OCRTypes.h	/^  string translit;$/;"	m	struct:ocr::uniLetterRecord
translit	./OCRTypes/OCRTypes_www.h	/^		string translit;$/;"	m	struct:ocr::uniLetterRecord
transpose	./GBitmap/GBitmapScale.cpp	/^  void GBitmap::transpose(){$/;"	f	class:ocr::GBitmap
tree1d	./PNG/lodepng.cpp	/^  unsigned* tree1d;$/;"	m	struct:HuffmanTree	file:
tree2d	./PNG/lodepng.cpp	/^  unsigned* tree2d;$/;"	m	struct:HuffmanTree	file:
tsertoFlag	./GFontEditor/GLetter.h	/^  int tsertoFlag;$/;"	m	class:ocr::wordOCR
tt	./test_clang.h	/^int tt=1; float dd=3;$/;"	v
tx	./config.h	/^	unsigned long long tx;$/;"	m	union:ticks
type	./GGraph/GGraph.h	/^	char type;$/;"	m	struct:ocr::OCRStarStruct
type	./GGraph/GGraph.h	/^	uchar type; \/\/\/< тип линии - базовая или линия между точками экстремума или линия круга$/;"	m	struct:ocr::OCRLineStruct
type	./GGraph/GGraph.h	/^	uchar type;$/;"	m	struct:ocr::OCRMaskStruct
type	./GGraph/GGraph.h	/^	uchar type;$/;"	m	struct:ocr::OCRRegisterStruct
type	./OCRAlgorithm/f2c.h	/^	int  type;$/;"	m	struct:Vardesc
type	./OCRTypes/OCRTypes.h	/^  char type;$/;"	m	class:ocr::OCRPointFloat
type	./OCRTypes/OCRTypes.h	/^  uchar type;$/;"	m	struct:ocr::OCRPointStruct
type	./OCRTypes/OCRTypes_www.h	/^        char type;$/;"	m	class:ocr::OCRPointFloat
u370	./OCRAlgorithm/f2c.h	217;"	d
u3b	./OCRAlgorithm/f2c.h	218;"	d
u3b2	./OCRAlgorithm/f2c.h	219;"	d
u3b5	./OCRAlgorithm/f2c.h	220;"	d
uchar	./OCRTypes/OCRTypes.h	/^typedef unsigned char uchar;$/;"	t	namespace:ocr
uchar	./OCRTypes/OCRTypes_www.h	/^    typedef unsigned char		uchar;$/;"	t	namespace:ocr
ucvector	./PNG/lodepng.cpp	/^typedef struct ucvector$/;"	s	file:
ucvector	./PNG/lodepng.cpp	/^} ucvector;$/;"	t	typeref:struct:ucvector	file:
ucvector_cleanup	./PNG/lodepng.cpp	/^static void ucvector_cleanup(void* p)$/;"	f	file:
ucvector_init	./PNG/lodepng.cpp	/^static void ucvector_init(ucvector* p)$/;"	f	file:
ucvector_init_buffer	./PNG/lodepng.cpp	/^static void ucvector_init_buffer(ucvector* p, unsigned char* buffer, size_t size)$/;"	f	file:
ucvector_push_back	./PNG/lodepng.cpp	/^static unsigned ucvector_push_back(ucvector* p, unsigned char c)$/;"	f	file:
ucvector_reserve	./PNG/lodepng.cpp	/^static unsigned ucvector_reserve(ucvector* p, size_t allocsize)$/;"	f	file:
ucvector_resize	./PNG/lodepng.cpp	/^static unsigned ucvector_resize(ucvector* p, size_t size)$/;"	f	file:
uint	./OCRTypes/OCRTypes.h	/^typedef unsigned int uint;$/;"	t	namespace:ocr
uint	./OCRTypes/OCRTypes_www.h	/^    typedef unsigned int		uint;$/;"	t	namespace:ocr
uint16	./OCRTypes/OCRTypes.h	/^typedef unsigned short uint16;$/;"	t	namespace:ocr
uint16	./OCRTypes/OCRTypes_www.h	/^    typedef unsigned short		uint16;$/;"	t	namespace:ocr
uint32	./OCRTypes/OCRTypes.h	/^typedef unsigned int uint32;$/;"	t	namespace:ocr
uint32	./OCRTypes/OCRTypes_www.h	/^    typedef unsigned int		uint32;$/;"	t	namespace:ocr
uint64	./OCRTypes/OCRTypes.h	/^typedef unsigned long long uint64;$/;"	t	namespace:ocr
uint64	./OCRTypes/OCRTypes_www.h	/^    typedef unsigned long long	uint64;$/;"	t	namespace:ocr
uint8	./OCRTypes/OCRTypes.h	/^typedef unsigned char uint8;$/;"	t	namespace:ocr
uint8	./OCRTypes/OCRTypes_www.h	/^    typedef unsigned char		uint8;$/;"	t	namespace:ocr
uinteger	./OCRAlgorithm/f2c.h	/^typedef unsigned long int uinteger;$/;"	t
uivector	./PNG/lodepng.cpp	/^typedef struct uivector$/;"	s	file:
uivector	./PNG/lodepng.cpp	/^} uivector;$/;"	t	typeref:struct:uivector	file:
uivector_cleanup	./PNG/lodepng.cpp	/^static void uivector_cleanup(void* p)$/;"	f	file:
uivector_init	./PNG/lodepng.cpp	/^static void uivector_init(uivector* p)$/;"	f	file:
uivector_push_back	./PNG/lodepng.cpp	/^static unsigned uivector_push_back(uivector* p, unsigned c)$/;"	f	file:
uivector_reserve	./PNG/lodepng.cpp	/^static unsigned uivector_reserve(uivector* p, size_t allocsize)$/;"	f	file:
uivector_resize	./PNG/lodepng.cpp	/^static unsigned uivector_resize(uivector* p, size_t size)$/;"	f	file:
uivector_resizev	./PNG/lodepng.cpp	/^static unsigned uivector_resizev(uivector* p, size_t size, unsigned value)$/;"	f	file:
ulong	./OCRTypes/OCRTypes.h	/^typedef unsigned long ulong;$/;"	t	namespace:ocr
ulong	./OCRTypes/OCRTypes_www.h	/^    typedef unsigned long		ulong;$/;"	t	namespace:ocr
ulongint	./OCRAlgorithm/f2c.h	/^typedef unsigned long long ulongint;	\/* system-dependent *\/$/;"	t
unPackBitMask	./GBitMask/algorithmOCR_32.cpp	/^    void GBitMask32::unPackBitMask(unsigned int *MaskInt,$/;"	f	class:ocr::GBitMask32
unPackMask	./GBitMask/algorithmOCR_128.cpp	/^GBitmap* GBitMask128::unPackMask(){ $/;"	f	class:GBitMask128
unPackMask	./GBitMask/algorithmOCR_32.cpp	/^    GBitmap* GBitMask32::unPackMask(){$/;"	f	class:ocr::GBitMask32
unPackMaskOff	./GBitMask/algorithmOCR_32.cpp	/^    GBitmap* GBitMask32::unPackMaskOff(){$/;"	f	class:ocr::GBitMask32
unfilter	./PNG/lodepng.cpp	/^static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)$/;"	f	file:
unfilterScanline	./PNG/lodepng.cpp	/^static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,$/;"	f	file:
uni	./GFontEditor/GLetter.h	/^  ushort uni;$/;"	m	class:ocr::OCRMatch
uniHexCode	./OCRTypes/OCRTypes.h	/^  vector<short> uniHexCode; \/\/ self Unicode in Hex$/;"	m	struct:ocr::rootLetterOCRStruct
uniHexCode	./OCRTypes/OCRTypes.h	/^  vector<string> uniHexCode; \/\/ self Unicode in Hex in base Tibetan$/;"	m	struct:ocr::uniLetterRecord
uniHexCode	./OCRTypes/OCRTypes_www.h	/^		vector<short> uniHexCode; \/\/self Unicode in Hex$/;"	m	struct:ocr::rootLetterOCRStruct
uniHexCode	./OCRTypes/OCRTypes_www.h	/^		vector<string> uniHexCode; \/\/self Unicode in Hex in base Tibetan$/;"	m	struct:ocr::uniLetterRecord
uniHexKey	./OCRTypes/OCRTypes.h	/^  vector<short> uniHexKey;  \/\/ unicode for typing in Hex$/;"	m	struct:ocr::rootLetterOCRStruct
uniHexKey	./OCRTypes/OCRTypes.h	/^  vector<string> uniHexKey;  \/\/ unicode for typing in Hex$/;"	m	struct:ocr::uniLetterRecord
uniHexKey	./OCRTypes/OCRTypes_www.h	/^		vector<short> uniHexKey;  \/\/ unicode for typing in Hex$/;"	m	struct:ocr::rootLetterOCRStruct
uniHexKey	./OCRTypes/OCRTypes_www.h	/^		vector<string> uniHexKey;  \/\/ unicode for typing in Hex$/;"	m	struct:ocr::uniLetterRecord
uniHexTibetan	./OCRTypes/OCRTypes.h	/^  vector<string> uniHexTibetan; \/\/ unicode in Hex for Tibetan letter$/;"	m	struct:ocr::uniLetterRecord
uniHexTibetan	./OCRTypes/OCRTypes_www.h	/^		vector<string> uniHexTibetan;  \/\/ unicode in Hex for Tibetan letter$/;"	m	struct:ocr::uniLetterRecord
uniKey	./OCRTypes/OCRTypes.h	/^  vector<short> uniKey;      \/\/ unicode for typing$/;"	m	struct:ocr::uniLetterRecord
uniKey	./OCRTypes/OCRTypes_www.h	/^		vector<short> uniKey;  \/\/ unicode for typing$/;"	m	struct:ocr::uniLetterRecord
uniLetterRecord	./OCRTypes/OCRTypes.h	/^typedef struct uniLetterRecord {$/;"	s	namespace:ocr
uniLetterRecord	./OCRTypes/OCRTypes_www.h	/^	typedef struct uniLetterRecord{$/;"	s	namespace:ocr
uniRecord	./OCRTypes/OCRTypes.h	/^} uniRecord;$/;"	t	namespace:ocr	typeref:struct:ocr::uniLetterRecord
uniRecord	./OCRTypes/OCRTypes_www.h	/^	}uniRecord;$/;"	t	namespace:ocr	typeref:struct:ocr::uniLetterRecord
uniTibTable	./GLogicProcessor/GLogicProcessor.h	/^	map<string, uniRecord>uniTibTable; \/\/\/<map of tibetan letters conversion in Unicode and UTF$/;"	m	class:ocr::GLogicProcessor
uniTibTable0F00	./GLogicProcessor/GLogicProcessor.h	/^	vector<uniRecord>uniTibTable0F00;$/;"	m	class:ocr::GLogicProcessor
uniTibTableYagpo	./GLogicProcessor/GLogicProcessor.h	/^	map<string, uniRecord>uniTibTableYagpo;  \/\/\/<main map of tibetan letters in codepage Uni<->Yagpo$/;"	m	class:ocr::GLogicProcessor
uniTibYagpo	./OCRTypes/OCRTypes.h	/^  vector<string> uniTibYagpo; \/\/ unicode in the codepage of standart Uni driver$/;"	m	struct:ocr::uniLetterRecord
uniTibYagpo	./OCRTypes/OCRTypes_www.h	/^		vector<string> uniTibYagpo;   \/\/unicode in the codepage of standart Uni driver$/;"	m	struct:ocr::uniLetterRecord
uniYagpo	./OCRTypes/OCRTypes.h	/^  vector<short> uniYagpo;    \/\/ unicode Yagpo$/;"	m	struct:ocr::uniLetterRecord
uniYagpo	./OCRTypes/OCRTypes_www.h	/^		vector<short> uniYagpo;  \/\/ unicode Yagpo$/;"	m	struct:ocr::uniLetterRecord
unix	./OCRAlgorithm/f2c.h	221;"	d
unknown_chunks_data	./PNG/lodepng.h	/^  unsigned char* unknown_chunks_data[3];$/;"	m	struct:LodePNGInfo
unknown_chunks_size	./PNG/lodepng.h	/^  size_t unknown_chunks_size[3]; \/*size in bytes of the unknown chunks, given for protection*\/$/;"	m	struct:LodePNGInfo
unpackImg	./GBitmap/GBitmap.cpp	/^void GBitmap::unpackImg(int invert) {$/;"	f	class:ocr::GBitmap
unpackImg32	./GBitmap/GBitmap.cpp	/^void GBitmap::unpackImg32(int invert) {$/;"	f	class:ocr::GBitmap
unpackImg32V	./GBitmap/GBitmap32.cpp	/^void GBitmap::unpackImg32V(int invert){$/;"	f	class:GBitmap
updateHashChain	./PNG/lodepng.cpp	/^static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros)$/;"	f	file:
update_adler32	./PNG/lodepng.cpp	/^static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)$/;"	f	file:
use_lz77	./PNG/lodepng.h	/^  unsigned use_lz77; \/*whether or not to use LZ77. Should be 1 for proper compression.*\/$/;"	m	struct:LodePNGCompressSettings
ushort	./OCRTypes/OCRTypes.h	/^typedef unsigned short ushort;$/;"	t	namespace:ocr
ushort	./OCRTypes/OCRTypes_www.h	/^    typedef unsigned short		ushort;$/;"	t	namespace:ocr
utfTibKey	./OCRTypes/OCRTypes.h	/^  string utfTibKey;          \/\/ UTF in the codepage of standart Uni driver$/;"	m	struct:ocr::uniLetterRecord
utfTibKey	./OCRTypes/OCRTypes_www.h	/^		string utfTibKey;   \/\/UTF in the codepage of standart Uni driver$/;"	m	struct:ocr::uniLetterRecord
utfYagpoTibKey	./OCRTypes/OCRTypes.h	/^  string utfYagpoTibKey;     \/\/ letter typing order in the Yagpo typing driver$/;"	m	struct:ocr::uniLetterRecord
utfYagpoTibKey	./OCRTypes/OCRTypes_www.h	/^		string utfYagpoTibKey;   \/\/letter typing order in the Yagpo typing driver$/;"	m	struct:ocr::uniLetterRecord
v	./GFontEditor/GLetter.h	/^  vectorOCR *v;$/;"	m	class:ocr::GLetter
vCenter	./OCRTypes/OCRTypes.h	/^  OCRPointFloat vCenter;$/;"	m	class:ocr::vectorOCR
vData_vector	./GMemory/GMap/GMap.h	/^        GStr<ulong>*vData_vector;   \/\/массив внутренних переменных$/;"	m	class:ocr::GMap
vDest	./GBitsetOCR/GBitsetOCR.h	/^  vectorOCR *vDest,*vSrc; \/\/pointer on array of vector in test and model letter;$/;"	m	class:ocr::GBitsetOCR
vEnd	./OCRTypes/OCRTypes.h	/^  OCRPointFloat vEnd;$/;"	m	class:ocr::vectorOCR
vIndex	./GMemory/GMemory.h	/^	GVector *vIndex;   \/\/pointer on index data$/;"	m	class:ocr::indexRecord
vLim	./GFontEditor/GLetter.h	/^  int vLim; \/\/\/ нижний лимит длинны вектора для данной строки \/\/vector length$/;"	m	class:ocr::stringOCR
vSrc	./GBitsetOCR/GBitsetOCR.h	/^  vectorOCR *vDest,*vSrc; \/\/pointer on array of vector in test and model letter;$/;"	m	class:ocr::GBitsetOCR
vStart	./OCRTypes/OCRTypes.h	/^  OCRPointFloat vStart;$/;"	m	class:ocr::vectorOCR
val	./PNG/lodepng.cpp	/^  int* val; \/*circular pos to hash value*\/$/;"	m	struct:Hash	file:
value	./test_clang.h	/^bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==$/;"	v
valueData_vector	./GMemory/GMap/GMap.h	/^        GVector *valueData_vector;\/\/ массив значений словаря$/;"	m	class:ocr::GMap
variationBorder	./GBitmap/GBitmap.cpp	/^void GBitmap::variationBorder(uint t, uint bord) {$/;"	f	class:ocr::GBitmap
vars	./OCRAlgorithm/f2c.h	/^	Vardesc **vars;$/;"	m	struct:Namelist
vax	./OCRAlgorithm/f2c.h	222;"	d
vectorAngle	./OCRTypes/OCRTypes.h	/^  short vectorAngle;$/;"	m	class:ocr::vectorOCR
vectorBase	./GBitsetContour/GBitsetContour.h	/^	vectorOCR *vectorBase;$/;"	m	class:ocr::GBitsetContour
vectorBase	./GBitsetOCR/GBitsetOCR.h	/^	vectorOCR *vectorBase;$/;"	m	class:ocr::GBitsetOCR
vectorBase	./GMainEditor/GMainEditor.h	/^        vectorOCR vectorBase[300];   \/\/$/;"	m	class:ocr::GMainEditor
vectorCorpus	./GMemory/GMemory.h	/^	GVector *vectorCorpus;  \/\/vector of all lines in corpus$/;"	m	class:ocr::GMemory
vectorCorrelation	./GMainEditor/vectorOCR.cpp	/^void GMainEditor::vectorCorrelation( vector<OCRPointFloat>&strPoint, vector<OCRFocalLineBezier>&lineVec){$/;"	f	class:GMainEditor
vectorCount	./GBitsetContour/GBitsetContour.h	/^  int vectorCount;       \/\/\/<общее количество векторов в тексте$/;"	m	class:ocr::GBitsetContour
vectorCount	./GFontEditor/GLetter.h	/^  uint vectorCount;$/;"	m	class:ocr::GLetter
vectorCount	./GMainEditor/GMainEditor.h	/^        unsigned int vectorCount;$/;"	m	class:ocr::GMainEditor
vectorDict	./GMemory/GMemory.h	/^	GVector *vectorDict;  \/\/\/vector with text data of main dictionary$/;"	m	class:ocr::GMemory
vectorFlag	./OCRTypes/OCRTypes.h	/^  short vectorFlag;$/;"	m	class:ocr::vectorOCR
vectorID	./GMemory/GVector.h	/^    ulong *vectorID;  \/\/твердая копия индекса записи, в которой GStr размещен в родительском$/;"	m	class:ocr::GStr
vectorID	./GMemory/GVector.h	/^    ulong *vectorID;$/;"	m	class:ocr::GVector
vectorID_	./GMemory/GVector.h	/^    ulong  vectorID_;$/;"	m	class:ocr::GVector
vectorID_	./GMemory/GVector.h	/^    ulong vectorID_;  \/\/индех записи, в которой GStr размещен в родительском векторе$/;"	m	class:ocr::GStr
vectorInd	./OCRTypes/OCRTypes.h	/^  short vectorInd;$/;"	m	class:ocr::vectorOCR
vectorIndexModel	./GFontEditor/GLetter.h	/^  int vectorIndexModel; \/\/ index of match vector in base$/;"	m	class:ocr::OCRMatch
vectorIndexModel	./GFontEditor/GLetter.h	/^  int vectorIndexModel; \/\/ index of match vector in base$/;"	m	class:ocr::OCRMatchConst
vectorIndexTest	./GFontEditor/GLetter.h	/^  int vectorIndexTest;  \/\/ index of match vector in base$/;"	m	class:ocr::OCRMatch
vectorIndexTest	./GFontEditor/GLetter.h	/^  int vectorIndexTest;  \/\/ index of match vector in base$/;"	m	class:ocr::OCRMatchConst
vectorLib	./GMemory/GMemory.h	/^	GVector *vectorLib;		\/\/vector of all library catalog$/;"	m	class:ocr::GMemory
vectorLibPath	./GMemory/GMemory.h	/^	GVector *vectorLibPath; \/\/vector of all library data paths$/;"	m	class:ocr::GMemory
vectorLimit	./GBitsetContour/GBitsetContour.h	/^    short vectorLimit;                    \/\/\/<inner constan for set vectorisation parameters$/;"	m	class:ocr::GBitsetContour
vectorLimit	./GFontEditor/GLetter.h	/^  int vectorLimit;$/;"	m	class:ocr::GLetter
vectorMarker	./GBitsetContour/GBitsetContour.h	/^    int vectorMarker[20000];$/;"	m	class:ocr::GBitsetContour
vectorOCR	./OCRTypes/OCRTypes.cpp	/^vectorOCR::vectorOCR() { selectFlag = 0; }$/;"	f	class:ocr::vectorOCR
vectorOCR	./OCRTypes/OCRTypes.h	/^class vectorOCR {$/;"	c	namespace:ocr
voronovDiagramCorrelation	./GGraphOCR/GGraphOCRStarCorrelation.cpp	/^int GGraphOCR::voronovDiagramCorrelation(OCRStar &starT, OCRStar &star, GGraph &graph, OCRLetter &letter) {$/;"	f	class:ocr::GGraphOCR
vowelDraw	./GBitset/GBitset_algorithm.cpp	/^void GBitset::vowelDraw(int color){$/;"	f	class:GBitset
vowelFlag	./GFontEditor/GLetter.h	/^  int vowelFlag;$/;"	m	class:ocr::wordOCR
w	./GBitsetContour/GBitsetContour.h	/^	int w,h,a, resX, resY;$/;"	m	class:ocr::GBitsetContour
w	./GFontEditor/GContour.h	/^    int w;$/;"	m	class:ocr::GContour
w	./GFontEditor/GLetter.h	/^  int w;$/;"	m	class:ocr::TsertoOCR
w	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, w, h;$/;"	m	class:ocr::stringOCR
w	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
w	./GGraphOCR/GGraphOCR.h	/^	uchar w;		  \/\/\/<габарит буквы в которой найден данный кластер.$/;"	m	struct:ClusterMatchStruct
w	./OCRTypes/OCRTypes.h	/^  short w;$/;"	m	class:ocr::OCRTextData
w	./OCRTypes/OCRTypes_www.h	/^		short w;$/;"	m	class:ocr::OCRTextData
wIndex	./GBitsetOCR/GBitsetOCR.h	/^  int wIndex;   \/\/current word$/;"	m	class:ocr::GBitsetOCR
wL	./GBitsetContour/GBitsetContour.h	/^	short res, xBegin, xEnd, xL,yL,hL, wL, dy_line, y_line, yLine, *ln,*lt;$/;"	m	class:ocr::GBitsetContour
wName	./GFontEditor/GLetter.h	/^  wstring wName;$/;"	m	class:ocr::OCRMatch
weight	./PNG/lodepng.cpp	/^  int weight; \/*the sum of all weights in this chain*\/$/;"	m	struct:BPMNode	file:
width	./GFontEditor/GContour.h	/^    int width(){return w;}$/;"	f	class:ocr::GContour
windowsize	./PNG/lodepng.h	/^  unsigned windowsize; \/*must be a power of two <= 32768. higher compresses more but is slower. Default value: 2048.*\/$/;"	m	struct:LodePNGCompressSettings
wordArray	./GFontEditor/GLetter.h	/^  vector<wordOCR> wordArray; \/\/ main point. here is information about every$/;"	m	class:ocr::stringOCR
wordCount	./OCRTypes/OCRTypes.h	/^  int wordCount;$/;"	m	class:ocr::OCRDictRecord
wordCount	./OCRTypes/OCRTypes_www.h	/^		int wordCount;$/;"	m	class:ocr::OCRDictRecord
wordDraw	./GBitset/GBitset_algorithm.cpp	/^void GBitset::wordDraw(int color){$/;"	f	class:GBitset
wordIndex	./GMainEditor/GMainEditor.h	/^        int stringIndex, wordIndex, iLeft,iTop;$/;"	m	class:ocr::GMainEditor
wordListCount	./GMemory/GMap/GMap.h	/^        ulong wordListCount;$/;"	m	class:ocr::GMap
wordOCR	./GFontEditor/GLetter.cpp	/^wordOCR::wordOCR(void){$/;"	f	class:wordOCR
wordOCR	./GFontEditor/GLetter.h	/^class wordOCR {$/;"	c	namespace:ocr
wordOCR_sort	./GFontEditor/GLetter.h	/^struct wordOCR_sort {$/;"	s	namespace:ocr
wordSrc	./GBitsetOCR/GBitsetOCR.h	/^  wordOCR *wordSrc;$/;"	m	class:ocr::GBitsetOCR
write	./GPDF/GPDF.h	/^    void write(const char *path){};$/;"	f	class:ocr::GPDF
write	./GPDF/GPDF.h	/^    void write(string &path){};$/;"	f	class:ocr::GPDF
writeDictReport	./GLogicProcessor/dictReport.cpp	/^string GLogicProcessor::writeDictReport(string &srcStr,int reportLevel, int fullReport){$/;"	f	class:GLogicProcessor
writeDictReportLocal	./GLogicProcessor/dictReportLocal.cpp	/^void GLogicProcessor::writeDictReportLocal(string &srcStr){$/;"	f	class:GLogicProcessor
writeDictReportTranslation	./GLogicProcessor/dictReport.cpp	/^string GLogicProcessor::writeDictReportTranslation(string &srcStr,int reportLevel, int fullReport){$/;"	f	class:GLogicProcessor
writeDictReportXML	./GLogicProcessor/loadDictionary.cpp	/^void GLogicProcessor::writeDictReportXML(vector <vector <OCRDictRecord> >&dictReportPage,string &binPath){$/;"	f	class:GLogicProcessor
writeDictionary	./GLogicProcessor/loadDictionary.cpp	/^void GLogicProcessor::writeDictionary(map<int, OCRDictRecord> &dictRecord, string &filePath){$/;"	f	class:GLogicProcessor
writeDictionaryTXT	./GLogicProcessor/loadDictionary.cpp	/^void GLogicProcessor::writeDictionaryTXT(  map<string, OCRDictRecord>&mainDict){$/;"	f	class:GLogicProcessor
writeFileAppend	./OCRString/php2stl.cpp	/^ulong writeFileAppend(string &outStr, string &outFile) {$/;"	f
writeGFontDB	./GFontEditor/GFont.cpp	/^    void GFont::writeGFontDB(){$/;"	f	class:ocr::GFont
writeGFontStat	./GFontEditor/GFont.cpp	/^    void GFont::writeGFontStat(){$/;"	f	class:ocr::GFont
writeGFontXML	./GFontEditor/GFont.cpp	/^    void GFont::writeGFontXML(){$/;"	f	class:ocr::GFont
writeInCorrectionPage	./GLogicProcessor/grammarCorrector.cpp	/^void GLogicProcessor::writeInCorrectionPage( vector<stringOCR>*strArray, vector<stringOCR> &correctionWordArray,stringOCR &testStr,string &srcStr){$/;"	f	class:GLogicProcessor
writeLZ77data	./PNG/lodepng.cpp	/^static void writeLZ77data(size_t* bp, ucvector* out, const uivector* lz77_encoded,$/;"	f	file:
writePPM	./GBitmap/ppm.h	/^void writePPM(const char *filename, PPMImage *img)$/;"	f
writeSignature	./PNG/lodepng.cpp	/^static void writeSignature(ucvector* out)$/;"	f	file:
writeText	./OCRString/php2stl.cpp	/^ulong writeText(string &outStr, string &outFile) {$/;"	f
writeText	./OCRString/php2stl.cpp	/^void writeText(char *buff, unsigned int size, cstr path) {$/;"	f
writeText	./OCRString/php2stl.cpp	/^void writeText(cstr data, cstr path) {$/;"	f
writeText	./OCRString/php2stl.cpp	/^void writeText(cstr data, string &outFile) {$/;"	f
writeText	./OCRString/php2stl.cpp	/^void writeText(string &outStr, cstr path) {$/;"	f
writeText	./OCRString/php2stl.cpp	/^void writeText(vector<string> &strVector, cstr dest) {$/;"	f
writeText	./OCRString/php2stl.cpp	/^void writeText(vector<string> &strVector, string &outFile) {$/;"	f
writeToLog	./OCRString/php2stl.cpp	/^void writeToLog(string &outStr, cstr path, cstr flagFile) {$/;"	f
writeToStr	./GFontEditor/GLetter.cpp	/^void GLetter::writeToStr(TString *st){$/;"	f	class:GLetter
writeToStr	./GGraphBezier/GGraphBezier.cpp	/^void OCRFocalLineBezier::writeToStr(TString &st){$/;"	f	class:ocr::OCRFocalLineBezier
write_data	./OCRString/php2stl.cpp	/^size_t write_data(void *ptr, size_t size, size_t nmemb, FILE *stream) {$/;"	f
wylieStr	./GLogicProcessor/GLogicProcessor.h	/^	vector<string>wylieStr;$/;"	m	class:ocr::GLogicProcessor
wylieStrVect	./GLogicProcessor/GLogicProcessor.h	/^	vector<string>wylieStrVect;$/;"	m	class:ocr::GLogicProcessor
x	./GBitmap/ppm.h	/^	int x, y;$/;"	m	struct:__anon2
x	./GFontEditor/GLetter.h	/^  int x;  \/\/ horizontal coordinate point$/;"	m	class:ocr::TsertoOCR
x	./OCRTypes/OCRTypes.h	/^  float x;$/;"	m	class:ocr::OCRPointFloat
x	./OCRTypes/OCRTypes.h	/^  short x;$/;"	m	struct:ocr::OCRPointStruct
x	./OCRTypes/OCRTypes_www.h	/^		short x;$/;"	m	class:ocr::OCRPointFloat
x0	./GBitMask/GBitMask.h	/^		int x0,x1,y0,y1;           \/\/\/< габариты прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask32
x0	./GBitMask/GBitMask.h	/^		int x0,y0,x1,y1; \/\/ габариты прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask128
x0	./GFontEditor/GLetter.h	/^  int x0, x1, y0, y1; \/\/координаты буквы на странице$/;"	m	class:ocr::OCRMatch
x0	./GFontEditor/GLetter.h	/^  int x0, x1;$/;"	m	class:ocr::OCRMatchConst
x0	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, w, h;$/;"	m	class:ocr::stringOCR
x0	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
x0	./GFontEditor/GLetter.h	/^  int x0; \/\/ first horizontal coordinate point$/;"	m	class:ocr::TsertoOCR
x0	./OCRTypes/OCRTypes.h	/^  short x0;$/;"	m	struct:ocr::OCRBoxStruct
x0	./OCRTypes/OCRTypes_www.h	/^		short x0;$/;"	m	class:ocr::OCRBox
x0	./config.h	/^	int x0, y0, x1, y1;$/;"	m	struct:commandData
x0st	./GBitMask/GBitMask.h	/^		char x0st, x1st, y0st, y1st; \/\/ статус прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask128
x0st	./GBitMask/GBitMask.h	/^		char x0st, x1st, y0st, y1st; \/\/\/< статус прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask32
x1	./GBitMask/GBitMask.h	/^		int x0,x1,y0,y1;           \/\/\/< габариты прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask32
x1	./GBitMask/GBitMask.h	/^		int x0,y0,x1,y1; \/\/ габариты прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask128
x1	./GFontEditor/GLetter.h	/^  int x0, x1, y0, y1; \/\/координаты буквы на странице$/;"	m	class:ocr::OCRMatch
x1	./GFontEditor/GLetter.h	/^  int x0, x1;$/;"	m	class:ocr::OCRMatchConst
x1	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, w, h;$/;"	m	class:ocr::stringOCR
x1	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
x1	./GFontEditor/GLetter.h	/^  int x1; \/\/ last horizontal coordinate point$/;"	m	class:ocr::TsertoOCR
x1	./OCRTypes/OCRTypes.h	/^  int x1; \/\/ first horizontal coordinate slice$/;"	m	struct:ocr::pointLine
x1	./OCRTypes/OCRTypes.h	/^  short x1;$/;"	m	struct:ocr::OCRBoxStruct
x1	./OCRTypes/OCRTypes_www.h	/^        int x1;      \/\/ first horizontal coordinate slice$/;"	m	struct:ocr::pointLine
x1	./OCRTypes/OCRTypes_www.h	/^        short x1;$/;"	m	class:ocr::OCRBox
x1	./config.h	/^	int x0, y0, x1, y1;$/;"	m	struct:commandData
x1st	./GBitMask/GBitMask.h	/^		char x0st, x1st, y0st, y1st; \/\/ статус прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask128
x1st	./GBitMask/GBitMask.h	/^		char x0st, x1st, y0st, y1st; \/\/\/< статус прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask32
x2	./OCRTypes/OCRTypes.h	/^  int x2; \/\/ last horizontal coordinate slice$/;"	m	struct:ocr::pointLine
x2	./OCRTypes/OCRTypes_www.h	/^        int x2;      \/\/ last horizontal coordinate slice$/;"	m	struct:ocr::pointLine
x86	./OCRString/cpuTest.cpp	/^namespace x86$/;"	n	file:
xBegin	./GBitsetContour/GBitsetContour.h	/^	short res, xBegin, xEnd, xL,yL,hL, wL, dy_line, y_line, yLine, *ln,*lt;$/;"	m	class:ocr::GBitsetContour
xCenter	./GFontEditor/GLetter.h	/^  int xCenter;      \/\/ letter center$/;"	m	class:ocr::OCRMatch
xCenter	./GFontEditor/GLetter.h	/^  int xCenter;      \/\/ letter center$/;"	m	class:ocr::OCRMatchConst
xCenter	./GGraph/GGraph.h	/^	short xCenter;$/;"	m	struct:ocr::OCRLetterStruct
xCenter	./GGraphOCR/GGraphOCR.h	/^	uint xCenter;$/;"	m	struct:ClusterMatchStruct
xEnd	./GBitsetContour/GBitsetContour.h	/^	short res, xBegin, xEnd, xL,yL,hL, wL, dy_line, y_line, yLine, *ln,*lt;$/;"	m	class:ocr::GBitsetContour
xL	./GBitsetContour/GBitsetContour.h	/^	short res, xBegin, xEnd, xL,yL,hL, wL, dy_line, y_line, yLine, *ln,*lt;$/;"	m	class:ocr::GBitsetContour
xL0	./GFontEditor/GLetter.h	/^  int xL0, yL0, xL1, yL1;$/;"	m	class:ocr::lineOCR
xL0C	./GFontEditor/GLetter.h	/^  int xL0C; \/\/центр первой буквы в паре$/;"	m	class:ocr::OCRMatch
xL1	./GFontEditor/GLetter.h	/^  int xL0, yL0, xL1, yL1;$/;"	m	class:ocr::lineOCR
xL1C	./GFontEditor/GLetter.h	/^  int xL1C; \/\/центр второй буквы в паре$/;"	m	class:ocr::OCRMatch
xLC	./GFontEditor/GLetter.h	/^  int xLC;  \/\/центр пары букв$/;"	m	class:ocr::OCRMatch
xMask	./GBitMask/GBitMask.h	/^		int xMask,yMask;           \/\/\/< координаты крайне верхне-левого угла маски в исходном изображении$/;"	m	class:ocr::GBitMask32
xMask	./GBitMask/GBitMask.h	/^		int xMask,yMask; \/\/ координаты крайне верхне-левого угла маски относительно центра буквы$/;"	m	class:ocr::GBitMask128
xMatch	./GGraph/GGraph.h	/^	short xMatch; \/\/\/< центр буквы на странице$/;"	m	struct:ocr::OCRLetterStruct
xMax	./GBitMask/GBitMask.h	/^        int xMax,yMax;             \/\/\/< координаты крайне верхне-левого угла маски в исходном изображении при оптимальной корреляции$/;"	m	class:ocr::GBitMask32
xMax	./GBitsetContour/GBitsetContour.h	/^	short xMax,xMin,yMin,yMax, XMCenter, YMCenter, startDir;$/;"	m	class:ocr::GBitsetContour
xMax	./GFontEditor/GLetter.h	/^  int xMax;$/;"	m	class:ocr::GLetter
xMax	./GGraph/GGraph.h	/^	short xMax;$/;"	m	struct:ocr::OCRLineStruct
xMax	./GGraph/GGraph.h	/^	short xMax;$/;"	m	struct:ocr::OCRStarStruct
xMaxEnd	./GMemory/GMap/GMap.h	/^        uint xMaxEnd;                   \/\/ координаты конца нечеткого непрерывного фрагмента текста максимальной длинны$/;"	m	class:ocr::GMap
xMaxEndDict	./GMemory/GMap/GMap.h	/^        ulong xMaxEndDict;               \/\/ координаты конца нечеткого непрерывного фрагмента фразы словаря максимальной длинны$/;"	m	class:ocr::GMap
xMaxStart	./GMemory/GMap/GMap.h	/^        uint xMaxStart;                 \/\/ координаты начала нечеткого непрерывного фрагмента текста максимальной длинны$/;"	m	class:ocr::GMap
xMaxStartDict	./GMemory/GMap/GMap.h	/^        ulong xMaxStartDict;             \/\/ координаты начала нечеткого непрерывного фрагмента фразы словаря максимальной длинны$/;"	m	class:ocr::GMap
xMin	./GBitsetContour/GBitsetContour.h	/^	short xMax,xMin,yMin,yMax, XMCenter, YMCenter, startDir;$/;"	m	class:ocr::GBitsetContour
xMin	./GFontEditor/GLetter.h	/^  int xMin;$/;"	m	class:ocr::GLetter
xMin	./GGraph/GGraph.h	/^	short xMin;$/;"	m	struct:ocr::OCRLineStruct
xMin	./GGraph/GGraph.h	/^	short xMin;$/;"	m	struct:ocr::OCRStarStruct
xSum	./GFontEditor/GLetter.h	/^  int xSum;$/;"	m	class:ocr::GLetter
xb0	./GFontEditor/GLetter.h	/^  int xb0, yb0, xb1, yb1;$/;"	m	class:ocr::blockOCR
xb1	./GFontEditor/GLetter.h	/^  int xb0, yb0, xb1, yb1;$/;"	m	class:ocr::blockOCR
xbr0	./GFontEditor/GLetter.h	/^  int xbr0, xbr1, ybr0, ybr1;$/;"	m	class:ocr::frameOCR
xbr1	./GFontEditor/GLetter.h	/^  int xbr0, xbr1, ybr0, ybr1;$/;"	m	class:ocr::frameOCR
xc0	./GFontEditor/GLetter.h	/^  int xc0, yc0, xc1, yc1;$/;"	m	class:ocr::columnOCR
xc1	./GFontEditor/GLetter.h	/^  int xc0, yc0, xc1, yc1;$/;"	m	class:ocr::columnOCR
xf0	./GFontEditor/GLetter.h	/^  int xf0, yf0, xf1, yf1;$/;"	m	class:ocr::frameOCR
xf1	./GFontEditor/GLetter.h	/^  int xf0, yf0, xf1, yf1;$/;"	m	class:ocr::frameOCR
xfg0	./GFontEditor/GLetter.h	/^  int xfg0, yfg0, xfg1, yfg1;$/;"	m	class:ocr::frameOCR
xfg1	./GFontEditor/GLetter.h	/^  int xfg0, yfg0, xfg1, yfg1;$/;"	m	class:ocr::frameOCR
xl	./GBitsetContour/GBitsetContour.h	/^	short dlt_y, t, d, xl, yl, n,m;$/;"	m	class:ocr::GBitsetContour
xmlString	./GBitsetOCR/GBitsetOCR.h	/^  string xmlString;$/;"	m	class:ocr::GBitsetOCR
xp	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
xp0	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
xp1	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
xr0	./GFontEditor/GLetter.h	/^  int xr0, xr1;$/;"	m	class:ocr::recordOCR
xr1	./GFontEditor/GLetter.h	/^  int xr0, xr1;$/;"	m	class:ocr::recordOCR
xt0	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
xt1	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
xv0	./GFontEditor/GLetter.h	/^  int xv0, yv0, xv1, yv1;$/;"	m	class:ocr::wordOCR
xv1	./GFontEditor/GLetter.h	/^  int xv0, yv0, xv1, yv1;$/;"	m	class:ocr::wordOCR
y	./GBitmap/ppm.h	/^	int x, y;$/;"	m	struct:__anon2
y	./GFontEditor/GLetter.h	/^  int y;  \/\/ vertical coordinate point$/;"	m	class:ocr::TsertoOCR
y	./OCRTypes/OCRTypes.h	/^  float y;$/;"	m	class:ocr::OCRPointFloat
y	./OCRTypes/OCRTypes.h	/^  int y;  \/\/ vertical coordinate slice$/;"	m	struct:ocr::pointLine
y	./OCRTypes/OCRTypes.h	/^  short y;$/;"	m	struct:ocr::OCRPointStruct
y	./OCRTypes/OCRTypes_www.h	/^		short y;$/;"	m	class:ocr::OCRPointFloat
y	./OCRTypes/OCRTypes_www.h	/^        int y;       \/\/ vertical coordinate slice$/;"	m	struct:ocr::pointLine
y0	./GBitMask/GBitMask.h	/^		int x0,x1,y0,y1;           \/\/\/< габариты прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask32
y0	./GBitMask/GBitMask.h	/^		int x0,y0,x1,y1; \/\/ габариты прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask128
y0	./GFontEditor/GLetter.h	/^  int x0, x1, y0, y1; \/\/координаты буквы на странице$/;"	m	class:ocr::OCRMatch
y0	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, w, h;$/;"	m	class:ocr::stringOCR
y0	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
y0	./GFontEditor/GLetter.h	/^  int y0; \/\/ first vertical coordinate point$/;"	m	class:ocr::TsertoOCR
y0	./GFontEditor/GLetter.h	/^  int y0; \/\/верхний габарит строки относительно центра изображения буквы$/;"	m	class:ocr::GLetter
y0	./OCRTypes/OCRTypes.h	/^  short y0;$/;"	m	struct:ocr::OCRBoxStruct
y0	./OCRTypes/OCRTypes_www.h	/^		short y0;$/;"	m	class:ocr::OCRBox
y0	./config.h	/^	int x0, y0, x1, y1;$/;"	m	struct:commandData
y0Base	./GLogicProcessor/GLogicProcessor.h	/^    int y0Base;           \/\/координаты средней области распознаваемой строки текста относительно всей страницы.     $/;"	m	class:ocr::GLogicProcessor
y0st	./GBitMask/GBitMask.h	/^		char x0st, x1st, y0st, y1st; \/\/ статус прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask128
y0st	./GBitMask/GBitMask.h	/^		char x0st, x1st, y0st, y1st; \/\/\/< статус прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask32
y1	./GBitMask/GBitMask.h	/^		int x0,x1,y0,y1;           \/\/\/< габариты прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask32
y1	./GBitMask/GBitMask.h	/^		int x0,y0,x1,y1; \/\/ габариты прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask128
y1	./GFontEditor/GLetter.h	/^  int x0, x1, y0, y1; \/\/координаты буквы на странице$/;"	m	class:ocr::OCRMatch
y1	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, w, h;$/;"	m	class:ocr::stringOCR
y1	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
y1	./GFontEditor/GLetter.h	/^  int y1; \/\/ last vertical coordinate point$/;"	m	class:ocr::TsertoOCR
y1	./GFontEditor/GLetter.h	/^  int y1; \/\/нижний габарит строки относительно центра изображения буквы$/;"	m	class:ocr::GLetter
y1	./OCRTypes/OCRTypes.h	/^  short y1;$/;"	m	struct:ocr::OCRBoxStruct
y1	./OCRTypes/OCRTypes_www.h	/^		short y1;$/;"	m	class:ocr::OCRBox
y1	./config.h	/^	int x0, y0, x1, y1;$/;"	m	struct:commandData
y1Base	./GLogicProcessor/GLogicProcessor.h	/^    int y1Base;$/;"	m	class:ocr::GLogicProcessor
y1st	./GBitMask/GBitMask.h	/^		char x0st, x1st, y0st, y1st; \/\/ статус прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask128
y1st	./GBitMask/GBitMask.h	/^		char x0st, x1st, y0st, y1st; \/\/\/< статус прямоугольной однопиксельной маски пересечений$/;"	m	class:ocr::GBitMask32
yCenter	./GFontEditor/GLetter.h	/^  int yCenter;$/;"	m	class:ocr::OCRMatch
yCenter	./GFontEditor/GLetter.h	/^  int yCenter;$/;"	m	class:ocr::OCRMatchConst
yCenter	./GGraph/GGraph.h	/^	short yCenter; \/\/\/<координаты центра буквы в изображении буквы$/;"	m	struct:ocr::OCRLetterStruct
yCenter	./GGraphOCR/GGraphOCR.h	/^	uint yCenter;$/;"	m	struct:ClusterMatchStruct
yDown	./GBitsetContour/GBitsetContour.h	/^	short yUp, yDown;$/;"	m	class:ocr::GBitsetContour
yL	./GBitsetContour/GBitsetContour.h	/^	short res, xBegin, xEnd, xL,yL,hL, wL, dy_line, y_line, yLine, *ln,*lt;$/;"	m	class:ocr::GBitsetContour
yL0	./GFontEditor/GLetter.h	/^  int xL0, yL0, xL1, yL1;$/;"	m	class:ocr::lineOCR
yL1	./GFontEditor/GLetter.h	/^  int xL0, yL0, xL1, yL1;$/;"	m	class:ocr::lineOCR
yLimit0	./OCRTypes/OCRTypes.h	/^  short yLimit0; \/\/координаты верхней полки буквы (верхняя точка буквы без$/;"	m	struct:ocr::OCRBoxStruct
yLimit1	./OCRTypes/OCRTypes.h	/^  short yLimit1; \/\/координаты нижней полки буквы$/;"	m	struct:ocr::OCRBoxStruct
yLine	./GBitsetContour/GBitsetContour.h	/^	short res, xBegin, xEnd, xL,yL,hL, wL, dy_line, y_line, yLine, *ln,*lt;$/;"	m	class:ocr::GBitsetContour
yMask	./GBitMask/GBitMask.h	/^		int xMask,yMask;           \/\/\/< координаты крайне верхне-левого угла маски в исходном изображении$/;"	m	class:ocr::GBitMask32
yMask	./GBitMask/GBitMask.h	/^		int xMask,yMask; \/\/ координаты крайне верхне-левого угла маски относительно центра буквы$/;"	m	class:ocr::GBitMask128
yMatch	./GGraph/GGraph.h	/^	short yMatch;$/;"	m	struct:ocr::OCRLetterStruct
yMax	./GBitMask/GBitMask.h	/^        int xMax,yMax;             \/\/\/< координаты крайне верхне-левого угла маски в исходном изображении при оптимальной корреляции$/;"	m	class:ocr::GBitMask32
yMax	./GBitsetContour/GBitsetContour.h	/^	short xMax,xMin,yMin,yMax, XMCenter, YMCenter, startDir;$/;"	m	class:ocr::GBitsetContour
yMax	./GFontEditor/GLetter.h	/^  int yMax;$/;"	m	class:ocr::GLetter
yMax	./GGraph/GGraph.h	/^	short yMax;$/;"	m	struct:ocr::OCRLineStruct
yMax	./GGraph/GGraph.h	/^	short yMax;$/;"	m	struct:ocr::OCRStarStruct
yMin	./GBitsetContour/GBitsetContour.h	/^	short xMax,xMin,yMin,yMax, XMCenter, YMCenter, startDir;$/;"	m	class:ocr::GBitsetContour
yMin	./GFontEditor/GLetter.h	/^  int yMin;$/;"	m	class:ocr::GLetter
yMin	./GGraph/GGraph.h	/^	short yMin;$/;"	m	struct:ocr::OCRLineStruct
yMin	./GGraph/GGraph.h	/^	short yMin;$/;"	m	struct:ocr::OCRStarStruct
ySum	./GFontEditor/GLetter.h	/^  int ySum;$/;"	m	class:ocr::GLetter
yUp	./GBitsetContour/GBitsetContour.h	/^	short yUp, yDown;$/;"	m	class:ocr::GBitsetContour
y_line	./GBitsetContour/GBitsetContour.h	/^	short res, xBegin, xEnd, xL,yL,hL, wL, dy_line, y_line, yLine, *ln,*lt;$/;"	m	class:ocr::GBitsetContour
yagpoStrVect	./GLogicProcessor/GLogicProcessor.h	/^	vector<string>yagpoStrVect;$/;"	m	class:ocr::GLogicProcessor
yb0	./GFontEditor/GLetter.h	/^  int xb0, yb0, xb1, yb1;$/;"	m	class:ocr::blockOCR
yb1	./GFontEditor/GLetter.h	/^  int xb0, yb0, xb1, yb1;$/;"	m	class:ocr::blockOCR
ybr0	./GFontEditor/GLetter.h	/^  int xbr0, xbr1, ybr0, ybr1;$/;"	m	class:ocr::frameOCR
ybr1	./GFontEditor/GLetter.h	/^  int xbr0, xbr1, ybr0, ybr1;$/;"	m	class:ocr::frameOCR
yc0	./GFontEditor/GLetter.h	/^  int xc0, yc0, xc1, yc1;$/;"	m	class:ocr::columnOCR
yc1	./GFontEditor/GLetter.h	/^  int xc0, yc0, xc1, yc1;$/;"	m	class:ocr::columnOCR
year	./PNG/lodepng.h	/^  unsigned year;    \/*2 bytes used (0-65535)*\/$/;"	m	struct:LodePNGTime
yf0	./GFontEditor/GLetter.h	/^  int xf0, yf0, xf1, yf1;$/;"	m	class:ocr::frameOCR
yf1	./GFontEditor/GLetter.h	/^  int xf0, yf0, xf1, yf1;$/;"	m	class:ocr::frameOCR
yfg0	./GFontEditor/GLetter.h	/^  int xfg0, yfg0, xfg1, yfg1;$/;"	m	class:ocr::frameOCR
yfg1	./GFontEditor/GLetter.h	/^  int xfg0, yfg0, xfg1, yfg1;$/;"	m	class:ocr::frameOCR
yl	./GBitsetContour/GBitsetContour.h	/^	short dlt_y, t, d, xl, yl, n,m;$/;"	m	class:ocr::GBitsetContour
yp	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
yp0	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
yp1	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
yt0	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
yt1	./GFontEditor/GLetter.h	/^  int x0, y0, x1, y1, xp0, yp0, xp1, yp1, xp, yp, xt0, yt0, xt1, yt1, w, h;$/;"	m	class:ocr::wordOCR
yv0	./GFontEditor/GLetter.h	/^  int xv0, yv0, xv1, yv1;$/;"	m	class:ocr::wordOCR
yv1	./GFontEditor/GLetter.h	/^  int xv0, yv0, xv1, yv1;$/;"	m	class:ocr::wordOCR
z	./OCRAlgorithm/f2c.h	/^	doublecomplex z;$/;"	m	union:Multitype
zeros	./PNG/lodepng.cpp	/^  unsigned short* zeros; \/*length of zeros streak, used as a second hash chain*\/$/;"	m	struct:Hash	file:
zlib_compress	./PNG/lodepng.cpp	/^static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,$/;"	f	file:
zlib_decompress	./PNG/lodepng.cpp	/^static unsigned zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,$/;"	f	file:
zlibsettings	./PNG/lodepng.h	/^  LodePNGCompressSettings zlibsettings; \/*settings for the zlib encoder, such as window size, ...*\/$/;"	m	struct:LodePNGEncoderSettings
zlibsettings	./PNG/lodepng.h	/^  LodePNGDecompressSettings zlibsettings; \/*in here is the setting to ignore Adler32 checksums*\/$/;"	m	struct:LodePNGDecoderSettings
~GBitset	./GBitset/GBitset_base.cpp	/^GBitset::~GBitset(){$/;"	f	class:GBitset
~GBitsetContour	./GBitsetContour/GBitsetContour.cpp	/^GBitsetContour::~GBitsetContour()$/;"	f	class:GBitsetContour
~GBitsetMatrix	./GBitsetMatrix/GBitsetMatrix_base.cpp	/^GBitsetMatrix::~GBitsetMatrix(){}$/;"	f	class:GBitsetMatrix
~GContour	./GFontEditor/GContour.cpp	/^GContour::~GContour(){}$/;"	f	class:ocr::GContour
~GFont	./GFontEditor/GFont.cpp	/^    GFont::~GFont(){}$/;"	f	class:ocr::GFont
~GGraph	./GGraph/GGraph.cpp	/^GGraph::~GGraph() {$/;"	f	class:ocr::GGraph
~GGraphOCR	./GGraphOCR/GGraphOCR.cpp	/^GGraphOCR::~GGraphOCR() {} \/\/____________________________________________________________$/;"	f	class:ocr::GGraphOCR
~GLogicProcessor	./GLogicProcessor/GLogicProcessor.cpp	/^    GLogicProcessor::~GLogicProcessor(){}$/;"	f	class:ocr::GLogicProcessor
~GStr	./GMemory/GVector.h	/^GStr<T>::~GStr() {$/;"	f	class:ocr::GStr
~GVector	./GMemory/GVector.cpp	/^GVector::~GVector() {}$/;"	f	class:GVector
~InputMemoryFile	./GMemory/MmapFile.cpp	/^InputMemoryFile::~InputMemoryFile()$/;"	f	class:InputMemoryFile
~LodePNGState	./PNG/lodepng.h	/^  virtual ~LodePNGState(){}$/;"	f	struct:LodePNGState
~MemoryFile	./GMemory/MmapFile.cpp	/^MemoryFile::~MemoryFile()$/;"	f	class:MemoryFile
~OCRFilter	./OCRAlgorithm/OCRAlgorithm.cpp	/^OCRFilter::~OCRFilter(){}$/;"	f	class:ocr::OCRFilter
~OCRMatchConst	./GFontEditor/GLetter.cpp	/^OCRMatchConst::~OCRMatchConst(){}$/;"	f	class:OCRMatchConst
~State	./PNG/lodepng.cpp	/^State::~State()$/;"	f	class:lodepng::State
~TString	./GMemory/GVector.cpp	/^TString::~TString(void){};$/;"	f	class:TString
~blockOCR	./GFontEditor/GLetter.cpp	/^blockOCR::~blockOCR(){}$/;"	f	class:blockOCR
~columnOCR	./GFontEditor/GLetter.cpp	/^columnOCR::~columnOCR(){}$/;"	f	class:columnOCR
~frameOCR	./GFontEditor/GLetter.cpp	/^frameOCR::~frameOCR(void){}$/;"	f	class:frameOCR
~lineOCR	./GFontEditor/GLetter.cpp	/^lineOCR::~lineOCR(){}$/;"	f	class:lineOCR
~recordOCR	./GFontEditor/GLetter.cpp	/^recordOCR::~recordOCR(){}$/;"	f	class:recordOCR
~stringOCR	./GFontEditor/GLetter.cpp	/^stringOCR::~stringOCR(void){$/;"	f	class:stringOCR
~vectorOCR	./OCRTypes/OCRTypes.cpp	/^vectorOCR::~vectorOCR() {}$/;"	f	class:ocr::vectorOCR
~wordOCR	./GFontEditor/GLetter.cpp	/^wordOCR::~wordOCR(){$/;"	f	class:wordOCR
