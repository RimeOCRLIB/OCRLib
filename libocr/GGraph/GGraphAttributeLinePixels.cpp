//@_________GGraphAttributeLinePixels.cpp
// Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru
// ****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
// ****************************************************************************
//
// C- This software is subject to, and may be distributed under, the
// C- GNU General Public License, either Version 2 of the license,
// C- or (at your option) any later version. The license should have
// C- accompanied the software or you may obtain a copy of the license
// C- from the Free Software Foundation at http://www.fsf.org.

#include "GGraph.h"

namespace ocr
{
/**
 @bref
 Функция создает для каждой фокальной линии структуру хранения черных пикселов
 которые образуют данную фокальную линию.
 @img img1.jpg 256
 @main
 АЛГОРИТМ ОПРЕДЕЛЕНИЯ МНОЖЕСТВА ЧЕРНЫХ ПИКСЕЛОВ ДИПОЛЯ
 Для решения задачи сравнения кривых по диаграмме Воронова, определении толщины
 штриха фокальной линии, выделении изображения буквы из узора и выделении
 протобукв и модификаторов из базовых букв возникает задача точного определения
 множества черных пикселов принадлежащих к данной фокальной линии. Математически
 это задача разделения множества точек по диаграмме Воронова. Общее описание
 практическай реализация алгоритма:
 1. Организуем первый массив integer в размер изображения страницы текста и
 заполняем каждый integer значениями ID номера фокальной линии, ID номера точки
 фокальной линии и ID номера контура, который соответствует пиксельному
 расстоянию от точки контура до ближайшей точки фокальной линии.
 3. Для всех фокальных линий последовательно выполняем растискивание
 (деривацию).
 4. Если при растискивании новый пиксел не является черным в исходном
 изображения и не занят ID-номером от предыдущего цикла деривации, устанавливаем
 его значение равное ID-номеру вектора для которого выполняется деривация и
 заносим его во второй массив пикселов этого вектора.
 5. Прекращаем цикл деривации если для всех векторов не найдено свободных черных
 пикселов.

 Функция создает для каждой фокальной линии структуру хранения черных пикселов
 которые соответствуют данной фокальной линии. Это позволяет применить для
 фокальных линий алгоритмы битовой обработки, а также хранить битовые
 изображения в компрессированном формате векторного описания.

 @main
 Описание оптимизированного алгоритма:
 Перед началом выполнения алгоритма создается массив int размером в исходное
 изображение. В этом массиве первый short заполняеися значением ID номерами
 фокальный линий. Второй short заполняется нулями. Производится "m" циклов
 выполнения где "m" это половина толщины штриха буквы текста в пикселах или это
 число удаленных слоев (слой это периметр символов графического текста) в
 graphFocalLine(int n_RemovLayers). Для каждого цикла выполнения, для каждого
 черного пиксела исходного изображения выполняется проверка по обоих массивов.
 Если оба массивова не заняты (нулевое значение int), то применяется матрица
 деривации 3х3 описанная в функции вычисления числа Мандельброта. В процессе
 применения матрицы для каждого пиксела матрицы выполняется следующие проверки:
 - является ли данный пиксел черным в исходном изобраении (первый массив).
 - не содержит ли второй массив ID номер.
 Т.е. int равен нулю.
 Если пиксел соответствует этому условию, то он заполняется значением ID номера
 центрального пиксела матрицы деривации. Такое растискивание и маркировка
 повторяется "m" раз. Готовый массив ID номеров short анализируется и для каждой
 фокальной линии и формируется структура ее черных пикселов в формате GBitMask32
 Вычисляем габарит множества черных пикселов принадлежащий каждой фокальной
 линии. Для того из структуры линии получаем координаты начала и конца каждой
 фокальной линии start x:y, end x:y т.е.габарит фокальной линии. К габариту
 фокальной линии прибавляем число слоев маски (число слоев деривации) d_line и
 получаем габарит множества черных пикселов принадлежащий данной фокальной
 линии. По габариту из массива, в размер изображения страницы текста, можно
 скопировать нужное множество. Фактически этот алгоритм является разновидностью
 диаграммы Воронова.

 БЫСТРОДЕЙСТВИЕ
 Для увеличения скорости работы алгоритма выгодно пробегать несколько раз не
 весь массив исходного изображениея, а только черное в изображении. Для этого
 однократно создается таблица начала и окончания горизонтальных черных слайсов
 исходного изображения. И алгоритм получая данные из таблицы и работает только в
 пределах черных слайсов исходного изображения.
 */

// Функция определения множества черных пикселов принадлежащих к фокальной
// линии. // Основная рабочая. _начало_окт_2019_   _продолжение_29_окт_2019_
// Также вычисляется среднея толщина штриха каждой фокальной линии в пикселах,
// по всему исходному изображению. Более простой функции attributeLinePixels, за
// счет двух циклов вместо четырех, отказа от массива long и иного принципа
// вычисления матрицы (1,25 раза быстрее). Полное описание функции см. выше.
// Время выполнения attributeLinePixels time=0.7  Gaussian time=0.3   F/L
// time=0.17     F/P time=0.03.

void GGraph::attributeLinePixels() {
  int w = ncolumns;  // ширина массива   IMAGE_WIDTH
  int h = nrows;     // высота массива   IMAGE_HEIGHT
  int w_h = w * h;   // размер массива   IMAGE_SIZE

  int GrafT = 0;
  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if
  // (GrafT) {  }
  DG("Функция определения множества черных пикселов принадлежащих к фокальной "
     "линии, n_RemovLayers="
     << nRemovLayers << endl);

  uint size = (uint)focalLine.size();  // количество фокальных линий на странице или ID номеров.
  if(GrafT) { cout << "Количество фокальных линий на странице size=" << size << endl; }
  if(!size) {
    cout << "no focal line on page" << endl;
    return;
  }

  // TIME_START
  // Факт перебора внутреннего цикла 6 раз дает 2/3 времени выполнения алгоритма
  // 0,27с  (graphFocalLine(15) 0,17с) Нужно прыгать через нули.

  // n_RemovLayers это число удаленных слоев (слой это периметр символов
  // графического текста) в graphFocalLine(int n_RemovLayers). d_line это число
  // слоев маски (число слоев деривации).
  // n_RemovLayers/=4;
  // int d_line=nRemovLayers/2 + nRemovLayers%2 + 1; // +1 запас // Обычно
  // n_RemovLayers=6-7.
  int d_line = nRemovLayers;
  if(d_line < 1) d_line = 1;
  // if(d_line>4) d_line=4; //для больших букв ограничиваем d_line
  // среднея толщина штриха в пикселах по всему исходному изображению.
  DG("Число слоев маски (число слоев деривации) d_line=" << d_line << " nRemovLayers:" << nRemovLayers << endl);

  // Массивы.//
  // Вспомогательный массив для работы маски.
  // Массив uint размером в исходное изображение, где каждый pix фокальной линии
  // заполнен структурой из ID номеров.

  memset(line_data, 0, w_h * sizeof(uint));
  uint *bytes_data_32 = (uint *)line_data;

  // typedef struct OCRDataStruct {
  //    uchar d2;  ///<номер слоя деривации.
  //(расстояние от пиксела до линии)
  //    uchar d1;  ///< ID номер точки фокальной линии
  //    short d0;  ///< ID номер фокальной линии.
  //} OCRData;
  //в данной функции структура OCRData для увеличения быстродействия
  // используется как данные типа uint.
  // ФОРМАТ структуры uint состоящий из двух ID номеoров и номера слоя
  // деривации. // во втором старшим ushort каждого uint хранится ID номер
  // исходной фокальной линии. в первом младшим ushort каждого uint хранится ID
  // номер точки фокальной линии char и ID номер контура деривации char. второй
  // старший байт первого short ID содержит номер точки фокальной линии. первый
  // младший байт первого short содержит ID номер контура деривации. Заполняется
  // в основном цикле.

  // Запись ID номеров в фокальные линии буквы. //
  // В каждую фокальную линию буквы записывается своя структура из ID номеров.

  // цикл по количеству фокальных линий в букве.
  OCRData p;
  uint *  reg = (uint *)&p;
  for(int i = 0; i < size; i++) {
    OCRLine &line = focalLine[i];
    int      pIndex = line.pointIndex;
    /// printLine(line); // вывод структуры линии.
    // длина фокальной линии буквы.
    ushort line_lenA = line.lenA;
    // ID номер фокальной линии буквы.  // Формально line.index начинается с
    // "0".
    ushort line_id = line.index + 1;  // Растискивание ID номерами не умеет работать с "0".
    // cout<<"ID номер line_id="<<line_id<<"   длина ф.л.
    // line_lenA="<<line_lenA<<endl; цикл по длинне фокальной линии.
    uchar c;
    for(int n = 0; n < line_lenA; n++) {
      OCRPoint &pt = pointArray[pIndex + n];
      /// cout<<n<<" pt x:y "<<pt.x<<":"<<pt.y<<endl; // вывод координат x:y
      // Запись ID номера фокальной линии буквы во второй старший short.
      p.d0 = line_id;
      // Заполняем второй байт первого short ID номером точки фокальной линии.
      n > 254 ? c = 255 : c = n + 1;  // ограничение на переполнение uchar
      p.d1 = c;
      // Заполняем первый байт первого short единицей, т.к.
      // номер контура должен начинаться с 1.
      p.d2 = 1;
      bytes_data_32[pt.x + pt.y * w] = *reg;
      // серый тест по ID номеру фокальной линии (i+1)*44.
      // bytes_data_64[pt.x + pt.y*w]=64+(line_id%2)*32; ///////
      // bytes_data_64[pt.x + pt.y*w]=(n+1)*255/line_lenA;
    }  // int n=0
  }    // int i=0
  //*/
  // TIME_PRINT_

  ///        cout<<"w_h/m="<<w_h/m<<endl;

  //*
  // Создание маски состоящей из структуры ID номеров на основе алгоритма
  // выделения внешних контуров. //

  int s0, s1;
  int w_h_1 = w_h - 1;
  int w_h_w = w_h - w;

  // цикл по числу слоев деривации.    // time=0.7     F/L time=0.17     F/P
  // time=0.03
  for(uint m = 0; m < d_line; m++) {  // d_line
    // вычисление ID номеров контура деривации (цикл можно начать с 2 и
    // использовать m ).
    uint m1 = m + 2;  // номер контура фокальной линии 1 (reg+=1;), а первый слой
                      // контура деривации уже 2.

    // Добавление пикселов с левой и с правой стороны символа.
    s0 = bytes_data_32[0] = 0;        // уровни в битмапе: 0-белый или >0 структура из
                                      // ID номеров. // time=0.2
    for(int x = 0; x < w_h_1; x++) {  // w_h_1=w_h-1;
      s1 = bytes_data_32[x + 1];
      // Добавление пиксела с левой стороны символа.
      if(s1 > 0 & s0 == 0) bytes_data_32[x] = (s1 & 0xFFFFFF00) + m1;  // |
      // Добавление пиксела с правой стороны символа.
      if(s0 > 0 & s1 == 0) bytes_data_32[x + 1] = (s0 & 0xFFFFFF00) + m1;
      // (s1 & 0xFFFFFF00) + m1  сохранение ID номеров контура деривации.
      // при варианте с (s1+1) на углах происходит удвоение количества слоев.
      s0 = s1;
    }  // for x

    // Добавление пикселов с верхней и с нижней стороны символа.
    s0 = bytes_data_32[0] = 0;
    for(int x = 0; x < w; x++) {           // time=0.54
      for(int y = x; y < w_h_w; y += w) {  // w_h_w=w_h-w // y=0;
        s1 = bytes_data_32[y + w];         // +x
        // Добавление пиксела с верхней стороны символа.
        if(s1 > 0 & s0 == 0) bytes_data_32[y] = (s1 & 0xFFFFFF00) + m1;  // +x  // time=0.3
        // Добавление пиксела с нижней стороны символа.
        if(s0 > 0 & s1 == 0) bytes_data_32[y + w] = (s0 & 0xFFFFFF00) + m1;  // +x
        s0 = s1;
        ///////if((bytes_data_32[x] & 0xFF)>0) cout<<"m1="<<(bytes_data_32[x] &
        /// 0xFF)<<endl;
      }  // for y
    }    // for x

  }  // m

  //*/
  // Размер полученного изображения задается массивом начала и конца слайсов
  // исходного изображения BufS[] и на 1 pix больше исходного (из-за применения
  // матрицы).

  // Вспомогательный массив для определения средней толщины штриха фокальной
  // линии. Массив ushort размером в количество ID номеров в исходном
  // изображении. Каждый элемент массива ushort соответствует фокальной линии и
  // равен площади ее региона.
  ushort *id_sum_16;
  id_sum_16 = (ushort *)calloc(size + 32, sizeof(uint));

  uint   b;
  uint   b_old = 0;
  ushort n_id = 0;  // переменная количества ID номеров каждого типа.
  int    w1 = w + 1;

  // Сборка выходного изображения поделенного на регионы с применением слайсовой
  // маски. //

  // Выборка адресов начала и конца черных слайсов исходного изображения:
  // - обеспечивает обработку только черных пикселов в тексте, игнорируя белые
  // области.
  // - эквивалентно применению маски в размер исходного изображения.
  // необходимо для выделения пикселов принадлежащих фокальной линии и
  // вычисления толщины штриха линии

  // цикл перебора черных слайсов по всей исходной картинке.
  for(int g = 0; g < sizeBufSR; g += 2) {
    // адреса начала и концов слайсов.
    // в массиве слайсов созданном в @fn focalLine координаты сдвинуты на w+1
    // поэтому копируем данные со смещением.
    uint bufS = BufS[g] + w1;
    uint bufS1 = BufS[g + 1] + w1;
    // Вычисление стартового значения b_old из старшего short в uint.
    b = bytes_data_32[bufS];
    b_old = b >> 16;
    n_id = 0;  // количества ID номеров каждой фокальной линии буквы в массиве.

    // цикл от начала черного слайса до конца.
    // Обработка изображения в пределах задаваемых слайсами, в точностим
    // эквивалентно применению маски.
    for(int x = bufS; x < bufS1; x++) {  // 0,1с вместо 0,2с
      ////for ( int x=w_1; x < w_h_; x++ ){
      b = bytes_data_32[x];
      //                bytes_data[x]=(uchar)((b & 0xFF)*16); // это тест на
      //                растискивание с применением маски, для удобства
      //                визуализации. //////////////////////
      if(b > 0) {
        // Вычисление текущего значения b старшего short в uint, т.е. ID номера
        // фокальной линии буквы.
        b = b >> 16;
        // cout<<"b="<<b<<"   b_old="<<b_old<<endl;
        // Подсчет количества ID номеров в пределах одного слайса.
        if((b - b_old) != 0) {
          // Накопление количества ID номеров каждой фокальной линии буквы в
          // массиве.
          id_sum_16[b_old] += n_id;
          // cout<<"запись в массив ID номера b="<<b<<"  b_old="<<b_old<<"
          // количества n_id="<<n_id<<endl; фиксация окончания непрерывного
          // блока ID номеров.
          n_id = 0;
        }
        // Подсчет длины непрерывных блоков ID номеров фокальной линии, в
        // пределах одного слайса.
        n_id++;  // переменная количества ID номеров каждой фокальной линии буквы
                 // в массиве.
        b_old = b;
        //                    bytes_data[x]=(uchar)((b & 0xFFFF)*16); // это
        //                    тест на ID номер ф.л. с применением маски, для
        //                    удобства визуализации. //////////////////////
      }
    }  // x

    // фиксация окончания слайса заполненного ID номерами
    if(b > 0) {
      // Накопление количества ID номеров каждого типа в массиве.
      id_sum_16[b_old] += n_id;  // b_old за пределами маски не сдвинута >>16
                                 // ////////////////////////////////////
                                 // cout<<"++++запись в массив ID номера b="<<b<<"  b_old="<<b_old<<"
                                 // количества n_id="<<n_id<<endl;
    }

  }  // g

  // В массиве id_sum_16 находится количество pix региона фокальной линии.
  // Адресом элемента массива является ID номер. Каждый элемент массива ushort
  // соответствует фокальной линии и равен площади ее региона.

  // Вычисление средней толщины штриха фокальной линии. //
  // цикл по количеству фокальных линий в букве.
  for(int i = 0; i < size; i++) {
    OCRLine &line = focalLine[i];
    /// int pIndex=line.pointIndex;  //////
    // длина фокальной линии буквы.
    ushort line_lenA = line.lenA;
    // ID номер фокальной линии буквы.  
    // Формально line.index начинается с "0".   
    ushort line_id = line.index + 1;  // Растискивание ID номерами не умеет работать с "0".
    /// код для вывода на экран диагоаммы Воронова. (не отлажен, вылет за границы массива) 
    /// ushort tmp_line_id = 64 + (line_id % 2) * 32;
    /// if(tmp_line_id > size + 32 ){cout<<"size error"<<endl; exit(0); }
    /// if(line_lenA > 0) {
    ///  id_sum_16[tmp_line_id] = id_sum_16[tmp_line_id] / line_lenA;
      //изменение яркости четных и нечетных слайсов
    ///} else{continue;}
    //ushort tmp_s = 0;
    int    S = id_sum_16[line_id];  // площадь штриха
    int    L = line_lenA;           //  длина фокальной линии штриха
    float  D1 = 0;

    DG("ID номер line_id=" << line_id - 1 << "   длина OCRLine line_lenA=" << line_lenA << endl);
    if(L == 0) {
      D1 = 0;
      if(GrafT) { cout << "   Линия нулевой длины средняя толщина штриха D1=" << D1 << "   L=" << L << endl; }
    } else if(line.start.type != L_POINT && line.end.type != L_POINT) {
      if(line_lenA > 0) D1 = (float)id_sum_16[line_id] / line_lenA;  // 100*
      if(GrafT) { cout << "   Линия между T-точек средняя толщина штриха D1=" << D1 << "   L=" << L << endl; }
    } else if(line.start.type == L_POINT && line.end.type == L_POINT) {
      // Вычисление средней толщины штриха "D" отдельно стоящей линии (две
      // подставки  d/2+d/2). Решение квадратного уравнения D*D+D*L-S=0;
      // a*x*x+b*x+c ;     x1,2=(-b+-sqrt(b*b-4*a*c))/2*a;
      float Discriminant = L * L + 4 * S;  //
      if(Discriminant < 0) {
        cout << "Ошибка в функции attributeLinePixels(),  Discriminant=" << Discriminant << " < 0" << endl;
        return;
      }
      float sqrt_D = sqrtf(Discriminant);  // корень квадратный из дискриминанта (Discriminant)
      D1 = (float)(-L + sqrt_D) / 2;       //  средняя толщина штриха D1
      if(GrafT) {
        cout << "   Решение квадратного уравнения, (две подставки  d/2+d/2) "
                "средняя толщина штриха D1="
             << D1 << "   L=" << L << endl;
      }
    } else {
      // Вычисление средней толщины штриха "D" присоединенной линии (одна
      // подставка d/2). Решение квадратного уравнения D*D+2*L*D-2*S=0;
      // a*x*x+b*x+c ;     x1,2=(-b+-sqrt(b*b-4*a*c))/2*a;
      float Discriminant = L * L * 4 + 8 * S;  //
      if(Discriminant < 0) {
        cout << "Ошибка в функции attributeLinePixels(),  Discriminant=" << Discriminant << " < 0" << endl;
        return;
      }
      float sqrt_D = sqrtf(Discriminant);  // корень квадратный из дискриминанта (Discriminant)
      D1 = (float)(-L * 2 + sqrt_D) / 2;   //  средняя толщина штриха D1
      if(GrafT) {
        cout << "   Решение квадратного уравнения, (одна подставка d/2) "
                "средняя толщина штриха D1="
             << D1 << "   L=" << L << endl;
      }
    }
    line.lineW = D1;
    //cout<<"line:"<<line.index<<" lineW:"<<int(line.lineW)<<endl; 
  }  // int i=0
  // Теперь в массиве id_sum_16 ushort находится средняя толщина штриха каждой
  // фокальной линии в пикселах. Массив id_sum_16 ushort использается временно,
  // для удобства визуализации. Более чем достаточно uchar.

  //вычисляем среднюю толщину линий OCRStar
  int starCount = (int)starArray.size();
  for(int n = 0; n < starCount; n++) {
    OCRStar &star = starArray[n];
    star.pointCount = star.starCount;
    float lineWSum = 0;
    float lineWCount = 0;
    for(int j = 0; j < star.starCount; j++) {
      OCRLine &line = focalLine[star.line[j]];
      OCRStar &star_ = starArray[star.star[j]];
      if(line.lineW < 3) {
        line.lineW = LINE_SIZE;
      } else if(line.lenA > line.lineW * 0.75) {
        lineWSum += line.lineW;
        lineWCount++;
      }
      //проверяем толщины линий соседних OCRStar
      for(int g = 0; g < star_.starCount; g++) {
        OCRLine &line = focalLine[star_.line[g]];
        if(line.lineW < 3) {
          line.lineW = LINE_SIZE;
        } else if(line.lenA > line.lineW * 0.75) {
          lineWSum += line.lineW;
          lineWCount++;
        }
      }
    }
    if(!lineWCount) {
      star.lineW = LINE_SIZE;
    } else {
      star.lineW = (float)lineWSum / lineWCount;
    }
  }
  // cout<<"ID номер  line_id="<<line_id<<b_old<<"   количества
  // n_id="<<n_id<<endl;

  // РАЗВИТИЕ //

  // 2. Если фокальная линия очень короткая и составляе всего 1-3 пикселов, то
  // среднею толщину штриха лучше считать по формуле площади круга
  // s=3.1415926*r*r
  /// char full_line=s(char)qrt((float)id_sum_16[line_id]/3.1415926); // средняя
  /// толщина штриха фокальной линии.

  // 3.Если фокальная линия короткая и составляе 3-10 pix, то среднею толщину
  // штриха лучше считать по формуле как в функции LineWidthImg() в виде решение
  // квадратного уравнения вида D*D-D*P/2+S=0;

  // Все 3 подхода объединяет алгоритм описанный в функции LineWidthImg() в виде
  // решение квадратного уравнения вида D*D-D*P/2+S=0; Площать черного по всему
  // тексту "S" и длина периметра "P" этого черного, равна площади больщого
  // сильно вытянутого прямоугольника с такой же площадью "S" и тем же
  // периметром "P". "D" искомая ширина прямоугольника.

  // TIME_PRINT_

  /*
  //========
  // Вывод графики. Тест.//
  //for ( int x=0; x < w_h; x++ ){ bytes_data[x]=bytes_data_32[x]; }
  invert();
  colorModeOut=1; // позволяет рисовать серую картинку
  savePNG("/_Image2OCR/___1Draw__1A_2.png");
  //========
  */

  // освобождение массивов.
  if(id_sum_16 != NULL) free(id_sum_16);

}  //____________________________________________________________

void GGraph::attributeLinePixelsG(GBitmap *img) {
  int w = ncolumns;  // ширина массива   IMAGE_WIDTH
  int h = nrows;     // высота массива   IMAGE_HEIGHT
  int w_h = w * h;   // размер массива   IMAGE_SIZE

  int GrafT = 0;
  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if
  // (GrafT) {  }
  DG("Функция определения множества черных пикселов принадлежащих к фокальной "
     "линии, n_RemovLayers="
     << nRemovLayers << endl);

  // TIME_START
  // Факт перебора внутреннего цикла 6 раз дает 2/3 времени выполнения алгоритма
  // 0,27с  (graphFocalLine(15) 0,17с) Нужно прыгать через нули.

  // n_RemovLayers это число удаленных слоев (слой это периметр символов
  // графического текста) в graphFocalLine(int n_RemovLayers). d_line это число
  // слоев маски (число слоев деривации).
  // n_RemovLayers/=4;
  int d_line = nRemovLayers + nRemovLayers % 2 + 1;  // +1 запас // Обычно n_RemovLayers=6-7.
  if(d_line < 1) d_line = 1;
  if(d_line > LINE_SIZE) d_line = LINE_SIZE;
  // среднея толщина штриха в пикселах по всему исходному изображению.
  DG("Число слоев маски (число слоев деривации) d_line=" << d_line << endl);

  // Массивы.//
  // Вспомогательный массив line_data для работы маски.
  // Массив uint размером в исходное изображение.
  // В массиве line_data находится исходное изображение поделенное на регионы
  // (диаграмма Воронова). в каждом пикселе региона каждой фокальной линии
  // записан её ID номер, ID номер ближайшего пиксела фокальной линии и
  // расстояние до ближайшего пиксела фокальной линии. Массив необходим для
  // работы @fn GGraphOCR::OCRStarCorrelationLookup4

  memset(line_data, 0, w_h * sizeof(OCRData));
  uint *bytes_data_32 = (uint *)line_data;

  // ФОРМАТ структуры uint состоящий из двух ID номеров и номера слоя деривации.
  // // во втором старшим ushort каждого uint хранится ID номер исходной
  // фокальной линии. в первом младшим ushort каждого uint хранится ID номер
  // точки фокальной линии char и ID номер контура деривации char. второй
  // старший байт первого short ID содержит номер точки фокальной линии. первый
  // младший байт первого short содержит ID номер контура деривации. Заполняется
  // в основном цикле.

  //*
  ushort size = (ushort)focalLine.size();  // количество фокальных линий на странице или ID номеров.
  if(GrafT) { cout << "Количество фокальных линий на странице size=" << size << endl; }

  // Запись ID номеров в фокальные линии буквы. //
  // В каждую фокальную линию буквы записывается своя структура из ID номеров.

  // цикл по количеству фокальных линий в букве.
  for(int i = 0; i < size; i++) {
    OCRLine &line = focalLine[i];
    int      pIndex = line.pointIndex;
    /// printLine(line); // вывод структуры линии.
    // длина фокальной линии буквы.
    ushort line_lenA = line.lenA;
    // ID номер фокальной линии буквы.  // Формально line.index начинается с
    // "0".
    ushort line_id = line.index + 1;  // Растискивание ID номерами не умеет работать с "0".
    // cout<<"ID номер line_id="<<line_id<<"   длина ф.л.
    // line_lenA="<<line_lenA<<endl; цикл по длинне фокальной линии.
    uchar c;
    for(int n = 0; n < line_lenA; n++) {
      OCRPoint &pt = pointArray[pIndex + n];
      OCRData   p;
      /// cout<<n<<" pt x:y "<<pt.x<<":"<<pt.y<<endl; // вывод координат x:y
      // Запись ID номера в фокальную линию буквы.
      // bytes_data_64[pt.x + pt.y*w]=(uint)(line_id);
      // ID номер линии.
      p.d0 = line_id;
      // ID номер точки фокальной линии.
      n > 254 ? c = 255 : c = n + 1;  // ограничение на переполнение uchar
      p.d1 += c;
      // Заполняем первый байт первого short единицей, т.к.
      // номер контура должен начинаться с 1.
      p.d2 = 1;
      uint *reg = (uint *)&p;
      bytes_data_32[pt.x + pt.y * w] = *reg;
      // серый тест по ID номеру фокальной линии (i+1)*44.
      // bytes_data_64[pt.x + pt.y*w]=64+(line_id%2)*32; ///////
      // bytes_data_64[pt.x + pt.y*w]=(n+1)*255/line_lenA;
    }  // int n=0
  }    // int i=0
  //*/

  //*
  // Создание маски состоящей из структуры ID номеров на основе алгоритма
  // выделения внешних контуров. //

  int s0, s1;
  int w_h_1 = w_h - 1;
  int w_h_w = w_h - w;

  // цикл по числу слоев деривации.
  for(uint m = 0; m < d_line; m++) {  // d_line
    // вычисление ID номеров контура деривации (цикл можно начать с 2 и
    // использовать m ).
    uint m1 = m + 2;  // номер контура фокальной линии 1 (reg+=1;), а первый слой
                      // контура деривации уже 2.

    // Добавление пикселов с левой и с правой стороны символа.
    s0 = bytes_data_32[0] = 0;        // уровни в битмапе: 0-белый или >0 структура из ID номеров.
    for(int x = 0; x < w_h_1; x++) {  // w_h_1=w_h-1;
      s1 = bytes_data_32[x + 1];
      // Добавление пиксела с левой стороны символа.
      if(s1 > 0 & s0 == 0) bytes_data_32[x] = (s1 & 0xFFFFFF00) + m1;  // |
      // Добавление пиксела с правой стороны символа.
      if(s0 > 0 & s1 == 0) bytes_data_32[x + 1] = (s0 & 0xFFFFFF00) + m1;
      // (s1 & 0xFFFFFF00) + m1  сохранение ID номеров контура деривации.
      // при варианте с (s1+1) на углах происходит удвоение количества слоев.
      s0 = s1;
    }  // for x

    // Добавление пикселов с верхней и с нижней стороны символа.
    s0 = bytes_data_32[0] = 0;
    for(int x = 0; x < w; x++) {
      for(int y = x; y < w_h_w; y += w) {  // w_h_w=w_h-w // y=0;
        s1 = bytes_data_32[y + w];         // +x
        // Добавление пиксела с верхней стороны символа.
        if(s1 > 0 & s0 == 0) bytes_data_32[y] = (s1 & 0xFFFFFF00) + m1;  // +x
        // Добавление пиксела с нижней стороны символа.
        if(s0 > 0 & s1 == 0) bytes_data_32[y + w] = (s0 & 0xFFFFFF00) + m1;  // +x
        s0 = s1;
        ///////if((bytes_data_32[x] & 0xFF)>0) cout<<"m1="<<(bytes_data_32[x] &
        /// 0xFF)<<endl;
      }  // for y
    }    // for x

  }  // m
  //*/

  // Размер полученного изображения задается массивом начала и конца слайсов
  // исходного изображения BufS[] и на 1 pix больше исходного (из-за применения
  // матрици).

  // Вспомогательный массив для определения средней толщины штриха фокальной
  // линии. Массив ushort размером в количество ID номеров в исходном
  // изображении. Каждый элемент массива ushort соответствует фокальной линии и
  // равен площади ее региона.
  ushort *id_sum_16;
  id_sum_16 = (ushort *)calloc(size + 32, sizeof(ushort));

  uint   b;
  uint   b_old = 0;
  ushort n_id = 0;  // переменная количества ID номеров каждого типа.
  int    w1 = w + 1;

  // Сборка выходного изображения поделенного на регионы с применением слайсовой
  // маски. //

  // Выборка адресов начала и конца черных слайсов исходного изображения:
  // - обеспечивает обработку только черных пикселов в тексте, игнорируя белые
  // области.
  // - эквивалентно применению маски в размер исходного изображения.
  // необходимо для выделения пикселов принадлежащих фокальной линии и
  // вычисления толщины штриха линии

  // цикл перебора черных слайсов по всей исходной картинке.
  for(int g = 0; g < sizeBufSR; g += 2) {
    // адреса начала и концов слайсов.
    // в массиве слайсов созданном в @fn focalLine координаты сдвинуты на w+1
    // поэтому копируем данные со смещением.
    uint bufS = BufS[g] + w1;
    uint bufS1 = BufS[g + 1] + w1;
    // Вычисление стартового значения b_old из старшего short в uint.
    b = bytes_data_32[bufS];
    b_old = b >> 16;
    n_id = 0;  // количества ID номеров каждой фокальной линии буквы в массиве.

    // цикл от начала черного слайса до конца.
    // Обработка изображения в пределах задаваемых слайсами, в точностим
    // эквивалентно применению маски.
    for(int x = bufS; x < bufS1; x++) {  // 0,1с вместо 0,2с
      ////for ( int x=w_1; x < w_h_; x++ ){
      b = bytes_data_32[x];
      //                bytes_data[x]=(uchar)((b & 0xFF)*16); // это тест на
      //                растискивание с применением маски, для удобства
      //                визуализации. //////////////////////
      if(b > 0) {
        // Вычисление текущего значения b старшего short в uint, т.е. ID номера
        // фокальной линии буквы.
        b = b >> 16;
        // cout<<"b="<<b<<"   b_old="<<b_old<<endl;
        // Подсчет количества ID номеров в пределах одного слайса.
        if((b - b_old) != 0) {
          // Накопление количества ID номеров каждой фокальной линии буквы в
          // массиве.
          id_sum_16[b_old] += n_id;
          // cout<<"запись в массив ID номера b="<<b<<"  b_old="<<b_old<<"
          // количества n_id="<<n_id<<endl; фиксация окончания непрерывного
          // блока ID номеров.
          n_id = 0;
        }
        // Подсчет длинны непрерывных блоков ID номеров фокальной линии, в
        // пределах одного слайса.
        n_id++;  // переменная количества ID номеров каждой фокальной линии буквы
                 // в массиве.
        b_old = b;
        //                    bytes_data[x]=(uchar)((b & 0xFFFF)*16); // это
        //                    тест на ID номер ф.л. с применением маски, для
        //                    удобства визуализации. //////////////////////
      }
    }  // x

    // фиксация окончания слайса заполненного ID номерами
    if(b > 0) {
      // Накопление количества ID номеров каждого типа в массиве.
      id_sum_16[b_old] += n_id;  // b_old за пределами маски не сдвинута >>16
                                 // ////////////////////////////////////
                                 // cout<<"++++запись в массив ID номера b="<<b<<"  b_old="<<b_old<<"
                                 // количества n_id="<<n_id<<endl;
    }

  }  // g

  // В массиве id_sum_16 находится количество pix региона фокальной линии.
  // Адресом элемента массива является ID номер. Каждый элемент массива ushort
  // соответствует фокальной линии и равен площади ее региона.

  /*
  for (int x=w+1; x<w_h_1; x++) {   //for (int x=w_1; x<w_h_; x++){

      b=bytes_data_32[x];
      // если в текущим пикселе "b" записан ID номер фокальной линии.
      if (b>0 ) {
          ///line_data[x]=(uint)b;  //
          //b=(b>>16);        // получение второго short (ID номер линии)
          //b=(b>>8) & 0xFF;  // получение второго байта первого short в integer
  (ID номер пиксела линии) b=(b & 0xFF);       // получение первого байта ineger
  (ID номер контура, соответствует кратчайшему расстоянию до линии)

          //bytes_data[x]=(uchar)(b*16); // это тест на растискивание без маски,
  для удобства визуализации. //////////////////////
      }

  } // x
  //*/

  // Вычисление средней толщины штриха фокальной линии. //
  // цикл по количеству фокальных линий в букве.
  for(int i = 0; i < size; i++) {
    OCRLine &line = focalLine[i];
    /// int pIndex=line.pointIndex;  //////
    // длина фокальной линии буквы.
    ushort line_lenA = line.lenA;
    // ID номер фокальной линии буквы.  // Формально line.index начинается с
    // "0".
    ushort line_id = line.index + 1;  // Растискивание ID номерами не умеет работать с "0".
    	/// код для вывода на экран диагоаммы Воронова. (не отлажен, вылет за границы массива)
    	/// ushort tmp_line_id=64+(line_id%2)*32;
    	/// if (line_lenA>0)
    	/// id_sum_16[tmp_line_id]=id_sum_16[tmp_line_id]/line_lenA; 
    	//изменение яркости четных и нечетных слайсов
   
    ushort tmp_s = 0;
    if(line_lenA > 0) tmp_s = id_sum_16[line_id] / line_lenA;  // 100*
    DG("ID номер line_id=" << line_id << "   длина ф.л. line_lenA=" << line_lenA);
    DG("   id_sum_16[line_id]=" << id_sum_16[line_id] << "   средняя толщина штриха tmp_s=" << tmp_s << endl);
    line.lineW = tmp_s;

  }  // int i=0

  // Теперь в массиве id_sum_16 ushort находится средняя толщина штриха каждой
  // фокальной линии в пикселах. Массив id_sum_16 ushort использается временно,
  // для удобства визуализации. Более чем достаточно uchar.

  //вычисляем среднюю толщину линий OCRStar
  int starCount = (int)starArray.size();
  for(int n = 0; n < starCount; n++) {
    OCRStar &star = starArray[n];
    star.pointCount = star.starCount;
    int lineWSum = 0;
    int lineWCount = 0;
    for(int j = 0; j < star.starCount; j++) {
      OCRLine &line = focalLine[star.line[j]];
      OCRStar &star_ = starArray[star.star[j]];
      if(line.lineW < 3) {
        line.lineW = LINE_SIZE;
      } else if(line.lenA > line.lineW * 0.75) {
        lineWSum += line.lineW;
        lineWCount++;
      }
      //проверяем толщины линий соседних OCRStar
      for(int g = 0; g < star_.starCount; g++) {
        OCRLine &line = focalLine[star_.line[g]];
        if(line.lineW < 3) {
          line.lineW = LINE_SIZE;
        } else if(line.lenA > line.lineW * 0.75) {
          lineWSum += line.lineW;
          lineWCount++;
        }
      }
    }
    if(!lineWCount) {
      star.lineW = LINE_SIZE;
    } else {
      star.lineW = (float)lineWSum / lineWCount;
    }
  }

  // cout<<"ID номер  line_id="<<line_id<<b_old<<"   количества
  // n_id="<<n_id<<endl;

  // РАЗВИТИЕ //

  // 2. Если фокальная линия очень короткая и составляе всего несколько пикселй
  // 1-3, то среднею толщину штриха лучше считать по формуле площади круга
  // s=3.1415926*r*r
  /// char full_line=s(char)qrt((float)id_sum_16[line_id]/3.1415926); // средняя
  /// толщина штриха фокальной линии.

  // 3.Если фокальная линия короткая и составляе 3-10 pix, то среднею толщину
  // штриха лучше считать по формуле как в функции LineWidthImg() в виде решение
  // квадратного уравнения вида D*D-D*P/2+S=0;

  // Все 3 подхода объединяет алгоритм описанный в функции LineWidthImg() в виде
  // решение квадратного уравнения вида D*D-D*P/2+S=0; Площать черного по всему
  // тексту "S" и длина периметра "P" этого черного, равна площади больщого
  // сильно вытянутого прямоугольника с такой же площадью "S" и тем же
  // периметром "P". "D" искомая ширина прямоугольника.

  // TIME_PRINT_

  //*
  //========
  // Вывод графики. Тест.//
  /////for ( int x=0; x < w_h; x++ ){ bytes_data[x]=bytes_data_32[x]; }
  // тест.
  // Функция быстрого инвертирования массива bytes_data.
  // invert();

  // тест.
  // colorModeOut=1; // позволяет рисовать серую картинку
  // savePNG("/_Image2OCR/___1Draw__1A_2.png");
  //========
  //*/

  // освобождение массивов.
  if(id_sum_16 != NULL) free(id_sum_16);

}  //____________________________________________________________

// Функция определения определения множества черных пикселов принадлежащих к
// фокальной линии. // _начало_окт_2019_
void GGraph::attributeLinePixelsF(GBitmap *img) {
  int w = ncolumns;  // ширина массива   IMAGE_WIDTH
  int h = nrows;     // высота массива   IMAGE_HEIGHT
  int w_h = w * h;   // размер массива   IMAGE_SIZE

  int GrafT = 1;
  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if
  // (GrafT) {  }
  if(GrafT) {
    DG("G Функция получения исходного изображения принадлежащих к данной "
       "фокальной линии, n_RemovLayers="
       << nRemovLayers << endl);
  }

  TIME_START
  // Факт перебора внутреннего цикла 6 раз дает 2/3 времени выполнения алгоритма
  // 0,27с  (graphFocalLine(15) 0,17с) Нужно прыгать через нули.

  // n_RemovLayers это число удаленных слоев (слой это периметр символов
  // графического текста) в graphFocalLine(int n_RemovLayers). d_line это число
  // слоев маски (число слоев деривации).
  ///        int d_line=n_RemovLayers+1; // +1 запас // Обычно
  ///        n_RemovLayers=6-7.
  int d_line = nRemovLayers / 2 + nRemovLayers % 2 + 1;  // +1 запас // Обычно n_RemovLayers=6-7.
  if(d_line < 1) d_line = 1;
  if(d_line > 16) d_line = 16;
  // среднея толщина штриха в пикселах по всему исходному изображению.

  // uchar *p0=bytes_data;        // входной массив состоящий из фокальных
  // линий, 0-черный 255-белый.
  uchar *p1 = img->bytes_data;  // входной массив исходной картинки.

  // указатели на массив bytes_data_32
  uint *bytes_data_32,
      *d;  // массив uint размером в исходное изображение, где каждый pix
           // фокальной линии заполнен id_num (ushort).

  // Массивы. Каждый элемент инициализируется в 0.
  bytes_data_32 = (uint *)calloc(w_h + 8, sizeof(uint));
  // В начале работы алгоритма:
  // в первом ushort каждого uint хранится ID номер исходной фокальной линии.
  // во второй ushort каждого uint заносится тот же ID номер контура исходной
  // фокальной линии.

  /*
  ushort size = (ushort)focalLine.size();  // количество фокальных линий на странице или ID номеров.
  if(GrafT) { cout << "Количество фокальных линий на странице size=" << size << endl; }

  // Запись ID номеров в фокальные линии буквы. В каждую фокальную линию буквы
  // записывается свой ID номер. // цикл по количеству фокальных линий в букве.

  for(int i = 0; i < size; i++) {
    OCRLine &line = focalLine[i];
    int      pIndex = line.pointIndex;
    /// printLine(line); // вывод структуры линии.
    ushort line_lenA = line.lenA;  // длина фокальной линии буквы.
    //ushort line_id = line.index;   // ID номер фокальной линии буквы.
    // цикл по длинне фокальной линии.
    //for(int n = 0; n < line_lenA; n++) {
      //OCRPoint &pt = pointArray[pIndex + n];
      /// cout<<n<<" pt x:y "<<pt.x<<":"<<pt.y<<endl; // вывод координат x:y
      // Запись ID номера в фокальную линию буквы (в первый ushort слова uint).
      ///////bytes_data_32[pt.x + pt.y*w]==(uint)line_id;
      // серый тест по ID номеру фокальной линии (i+1)*44
      // bytes_data_32[pt.x + pt.y*w]=(i+1)*255/size;
      // серый тест по ID номеру точки фокальной линии
      ////bytes_data_32[pt.x + pt.y*w]=(n+1)*255/line_lenA;
      ////            if ((n & 1)==0) bytes_data_32[pt.x +
      /// pt.y*w]=(n+1)*255/line_lenA;  else bytes_data_32[pt.x + pt.y*w]=255;
      ////if ((n & 1)==0) bytes_data_32[pt.x + pt.y*w]=127;  else
      /// bytes_data_32[pt.x + pt.y*w]=255;
    //}  // int n=0
  }    // int i=0
  */

  // Создание маски на основе алгоритма выделения внешних контуров. //

  uint b;   // d=bytes_data_32+x;
  uint b2;  // переменные для хранения половинок uint b
  // переменные предотврощающие выход за пределы массива
  int w_1 = w + 1;
  int w_h_ = w_h - w_1;

  //*
  // цикл по числу слоев маски
  for(int m = 0; m < d_line; m++) {
    // цикл по всей исходной картинке.
    for(int x = w_1; x < w_h_; x++) {
      d = bytes_data_32 + x;
      b = *d;
      // если в текущим пикселе "b" первого или второго массива записан ID номер
      // фокальной линии. ((b & 0xFFFF)>0 )
      if(b > 0) {  // проверка двух массивов одновременно.

        // Поочередная запись ID номера фокальной линии в первый или второй
        // массивы. // res<<16  *65535
        if((m & 1) == 0)
          b2 = b << 16;
        else
          b2 = b >> 16;  // если младший бит 0, то "m" четное, 1 то "m" нечетное.

        // Выделение внешнего контура (периметра), проведенного вокруг черного,
        // по всей исходной картинке. Используется Матрица простейшего
        // пространственного Лапласиана:

        //      d2                -w                  *(d0-w)

        // d8   d0   d4      -1        +1        *(d0-1)   *(d0+1)

        //      d6                +w                  *(d0+w)

        // Если центральная точка исходной картинки "b" (первый или второй
        // массив bytes_data_32) содержит ID номер, то в любой окружающей ее
        // пиксел матрици (d2, d4, d6, d8) равный нулю, записывается ID номер,
        // но уже в другой массив "b2", постепенно вырисовывая серый контур из
        // ID номеров (серый условно, для наглядности). Запись ID номеров
        // происходит поочередно, то в первый, то во второй массивы
        ///             if(*(d-w)==0)*(d-w)=b2;  if(*(d-1)==0)*(d-1)=b2;
        ///             if(*(d+1)==0)*(d+1)=b2;  if(*(d+w)==0)*(d+w)=b2; //
        ///             0,17с

        // Использование полной матрица простейшего пространственного Лапласиана
        // дает более аккуратрые и красивые граници разделения размножества
        // черных пикселов разных фокальных линиий.
        //    -w-1,                           -w,                         -w+1,
        //    // величины смещения маски //
        if(*(d - w - 1) == 0) *(d - w - 1) = b2;
        if(*(d - w) == 0) *(d - w) = b2;
        if(*(d - w + 1) == 0) *(d - w + 1) = b2;  // 0,2с
        //    -1,                                                          1,
        if(*(d - 1) == 0) *(d - 1) = b2;
        if(*(d + 1) == 0) *(d + 1) = b2;
        //     w-1,                            w,                          w+1
        if(*(d + w - 1) == 0) *(d + w - 1) = b2;
        if(*(d + w) == 0) *(d + w) = b2;
        if(*(d + w + 1) == 0) *(d + w + 1) = b2;

        // ID номер берем из первого ushort слова uint массива  bytes_data_32 и
        // кладем в соответствии с алгоритмом во второй ushort этого же uint.

      }  // if
    }    // x
  }      // m
  //*/

  //*
  // Сборка маски и ее применение к исходному изображению.
  for(int x = w_1; x < w_h_; x++) {
    int b = bytes_data_32[x];
    if(b > 0) {
      // Суммируем содержимое первого и второго массива.
      // Суммируем первый и второй ushort какждого uint. Второй массив обнуляем
      // "b & 0xFFFF".
      b = (b >> 16) + (b & 0xFFFF);  // (b>>16) скобки обязательны.
      // Применяем маску "b" к инвертированному исходному изображению "~*(p+x);"
      bytes_data_32[x] = b & ~*(p1 + x);  // ~ инверсия // входной массив, 0-черный 255-белый.
      // Инверсия.
      bytes_data_32[x] = (b);
    }
  }
  //*/
  // В массиве bytes_data_32 находится исходное изображение поделенное на
  // регионы. В каждый pix региона записан ID номер фокальной линии
  // соответствующий этому региону. ID номер это ushort.

  TIME_PRINT_

  //-----------------------------------------------------------------------------------------------------
  //*
  // Вывод графики. Тест.//
  for(int x = 0; x < w_h; x++) {
    bytes_data[x] = bytes_data_32[x];
  }
  // тест.
  // Функция быстрого инвертирования массива bytes_data.
  invert();

  // тест.
  img->colorModeOut = 1;  // позволяет рисовать серую картинку
  img->savePNG("/_Image2OCR/___1Draw__1A_1.png");

  img->bytes_data = bytes_data;  /////////////
  img->savePNG("/_Image2OCR/___1Draw__1A_2.png");
  //*/

  //-----------------------------------------------------------------------------------------------------

  // освобождение массивов
  if(bytes_data_32 != NULL) free(bytes_data_32);

}  //____________________________________________________________

// Вычисление первой производной (угла наклона касательной) по всей кубической кривой Безье. //
// Рабочий код. Можно сделать итерационный, более быстрый вариант. 14 мая 2021.
// -----------------------------------------------------------------------------

void firstDerivativeLine() {
    
    
    // Функция используя координаты главных точек пиксельной кривой (t=0, t=L*1/3, t=L*2/3  t=L)
    // вычисляет первую производную по всей кубической кривой Безье.
    // Считаем что сглаженная исходная пиксельная кривая и кривая Безье примерно совпадают.
    // Алгоритм выполняется предрасчетом и является масштаб-независимым.
    // Теория подробнее и основной вывод формул в функции:
    // "Вычисление первой производной (угла наклона касательной) в главных точках кубической кривой Безье."
    // firstDerivativePoint 15 мая 2021.
    
    // Вычисление atan2 дорогая операция поэтому ориентацию кривых  можно задавать не углом а тангенсом угла и
    // сравнивать тангенсы углов одной кривой с тангенсами углов другой кривой. Графики от 0 до 30 градусов
    // почти совпадают, дальше начинают расходится и в самой конечной точке отличаются на 20 градусов.
    
    /// Теория ///
    
    /**
     Каждая кривая Безье произошла от сглаженной пиксельной кривой, поэтому можно считать координаты
     не по кривым Безье, а по соответствующим им сглаженным пиксельным кривым.
     Каждой сглаженной пиксельной кривой можно сопоставить кубическую кривую Безье. Сопоставление кривых Безье
     со сглаженным фокальным линиям осуществляется по четырем точкам пиксельных кривых:
     начальной точки, точки 1/3 длины, точки 2/3 длины и конечной точки.
     По сути выполняется апроксимация сглаженных пиксельных кривых еще более гладкими
     кривыми Безье. Это особенно важно в начале и в конце кривых, где сглаживание усреднением не эффективно.
     По кривыми Безье аналитически (по формулам предпросчетом) можно вычислить много полезной информации например:
     первая производная, вторая производная, кривизна (K=1/R), точки перегиба, вплоть до классификации кривых.
     Следует отметить что характеристики кривой не изменяются при разбиении кривой Безье на части.
     */
    
    // Функция получает на вход Декартовы координаты пиксельной кривой:
    // float x00, y00 	// координаты начала пиксельной кривой t=0.
    // float x13, y13 	// координаты точки находящийся на 1/3 длинны пиксельной кривой t=L*1/3.
    // float x23, y23  	// координаты точки находящийся на 2/3 длинны пиксельной кривой t=L*2/3.
    // float x11, y11  	// координаты конца пиксельной кривой t=L.
    //int LengthLine=line.lenA;	// длинна пиксельной кривой.
    int LengthLine=14;			// тест, длинна пиксельной кривой.
    
    // float Alpha	угол в градусах между касательной и осью "x" по всей пиксельной кривой.
    
    
    int GrafT=1;
    // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    if (GrafT)  cout<<"// Вычисление первой производной (угла наклона касательной) по всей кубической кривой Безье."<<endl;
    
    // ТЕСТ. //
    // Координаты исходных точек, расположенных на сглаженной пиксельной кривой по X и Y.
    float x00=1,  x13=5.2963,   x23=10.037,   x10=15;
    float y00=6,  y13=7.7037,   y23=7.62963,  y10=4;
    if (GrafT) { cout<<"x00="<<x00<<"   x13="<<x13<<"   x23="<<x23<<"   x10="<<x10<<endl; }
    
    // Вычисляем координаты управляющих точек кривой Безье, по координатам исходных точек, расположенных на сглаженной пиксельной кривой:
    // Управляющие точки кривой Безье это точки, которые таскаем мышкой, при визуальном построении кривой, “усы” в графических редакторах.
    // Формулы Безье используют координаты именно управляющих точек.
    float x0=x00;
    float y0=y00;
    float x1=(-5.0f*x00 + 18.0f*x13 - 9.0f*x23  + 2.0f*x10)/6.0f;  // x1 координата по “x” первой управляющей точки.
    float y1=(-5.0f*y00 + 18.0f*y13 - 9.0f*y23  + 2.0f*y10)/6.0f;  // y1 координата по “y” первой управляющей точки.
    float x2=( 2.0f*x00 -  9.0f*x13 + 18.0f*x23 - 5.0f*x10)/6.0f;  // x2 координата по “x” второй управляющей точки.
    float y2=( 2.0f*y00 -  9.0f*y13 + 18.0f*y23 - 5.0f*y10)/6.0f;  // y2 координата по “y” второй управляющей точки.
    float x3=x10;   // Начальные и конечные управляющие точки кривой Безье совпадают
    float y3=y10;   // с начальными и конечными точками (узлами) пиксельной кривой.
    // где x00:y00, x13:y13, x23:y23, x10:y10 координаты исходных точек, расположенных на сглаженной пиксельной кривой:
    // Источники:
    // Роджерс Д., Адамс Дж. Математические основы машинной графики. М.: Мир, 2001. 604 с.
    // http://sernam.ru/book_mm3d.php?id=92 // это Адамс
    // http://alex-black.ru/article.php?content=109
    
    
    // ТЕСТ. //
    // координаты управляющих точек по X и Y (управляющие вектора), которые таскаем мышкой при визуальном построении кривой.
    ///int x0=1, x1=5, x2=10, x3=15;
    ///int y0=6, y1=8, y2=10, y3=4;
    
    
    
    // Кубические кривая Безье. //
    // Кривая Безье задана параметрической функцией вида x=x(t), y=y(t) где 0<=t<=1.
    
    // B(t) = (1-t)^3*P0 + 3*(1-t)^2*t*P1 + 3*(1-t)*t^2*P2 + t^3*P3	// 0<=t<=1
    ///float x = (1-t)*(1-t)*(1-t)*x0 + 3*t*(1-t)*(1-t)*x1 + 3*t*t*(1-t)*x2 + t*t*t*x3;		// y=x(t)
    ///float y = (1-t)*(1-t)*(1-t)*y0 + 3*t*(1-t)*(1-t)*y1 + 3*t*t*(1-t)*y2 + t*t*t*y3;		// x=y(t)
    // где x0:y0, x1:y1, x2:y2, x3:y3 координаты управляющих точек, которые таскаем мышкой при визуальном построении кривой (управляющие вектора).
    
    // Первая производная кубической кривой Безье по t равна:
    // B'(t) = 3*(1-t)^2*(P1-P0) + 6*(1-t)*t*(P2-P1) + 3*t^2*(P3-P2)
    ///float dx_dt = 3*(1-t)*(1-t)*(x1-x0) + 6*(1-t)*t*(x2-x1) + 3*t*t*(x3-x2);  // x'(t)=dx/dt
    ///float dy_dt = 3*(1-t)*(1-t)*(y1-y0) + 6*(1-t)*t*(y2-y1) + 3*t*t*(y3-y2);  // y'(t)=dy/dt
    
    // прямые вычисления (не итерационные) первой производной кубической кривой Безье по t.
    float t=0.0f; // параметр уравнений кривой Безье 0<=t<=1.
    float dlt=1.0f/LengthLine;
    //float f1_dlt2=1.0f+dlt/2.0f;
    float x1_0=x1-x0, x2_1=2.0f*(x2-x1), x3_2=x3-x2;
    float y1_0=y1-y0, y2_1=2.0f*(y2-y1), y3_2=y3-y2;
    if (GrafT) { cout<<endl; }
    
    /**
     ///for ( int index=0; index<=LengthLine index++ ) { ///t+=dlt;
     for ( t=0.0f; t<f1_dlt2; t+=dlt ) {
     
     float tt=t*t;   float d=1.0f-t;   float dd=d*d;   float dt=d*t;
     //float dx_dt = 3*dd*(x1-x0) + 6*d*t*(x2-x1) + 3*tt*(x3-x2);  	// x'(t)=dx/dt
     //float dy_dt = 3*dd*(y1-y0) + 6*d*t*(y2-y1) + 3*tt*(y3-y2);  	// y'(t)=dy/dt
     float dx_dt = dd*x1_0 + dt*x2_1 + tt*x3_2;  	// x'(t)=dx/dt
     float dy_dt = dd*y1_0 + dt*y2_1 + tt*y3_2;  	// y'(t)=dy/dt
     
     // Первая производная является тангенсом угла наклона касательной прямой в точке "t".
     float Alpha=57.29747f*atan2f(dy_dt, dx_dt); // (atan2f вычисляет float)
     ///float Alpha=57.29747f*(dy_dt/dx_dt); // проверка квадрантов ?
     
     // таблица для рисования в http://yotx.ru
     if (GrafT) { cout<<"   ("<<t<<";"<<Alpha<<") "<<endl; }
     
     }
     if (GrafT) { cout<<endl; }
     */
    
    float f1_dlt=1.0f+dlt;
    float dlt2=dlt+dlt;		// *2
    // Первая производная кубической кривой Безье в начале кривой в точке t=0. //
    float oldAlpha=57.29747f*atan2f(y1_0, x1_0);  // Alpha00
    //float oldAlpha=57.29747f*(y1_0/x1_0);  // Alpha00
    // таблица для рисования в http://yotx.ru
    if (GrafT) { cout<<"   ("<<0<<";"<<oldAlpha<<") "<<endl; }
    
    // Первая производная кубической кривой Безье во всех остальных точках кривой. //
    // По сложной формуле точки считаем через одну, промежуточные точки считаем как среднее соседних.
    for ( t=dlt2; t<f1_dlt; t+=dlt2 ) {
        
        float tt=t*t;   float d=1.0f-t;   float dd=d*d;   float dt=d*t;
        //float dx_dt = 3*dd*(x1-x0) + 6*d*t*(x2-x1) + 3*tt*(x3-x2);  	// x'(t)=dx/dt
        //float dy_dt = 3*dd*(y1-y0) + 6*d*t*(y2-y1) + 3*tt*(y3-y2);  	// y'(t)=dy/dt
        float dx_dt = dd*x1_0 + dt*x2_1 + tt*x3_2;  	// x'(t)=dx/dt
        float dy_dt = dd*y1_0 + dt*y2_1 + tt*y3_2;  	// y'(t)=dy/dt
        
        // Первая производная является тангенсом угла наклона касательной прямой в точке "t".
        float Alpha=57.29747f*atan2f(dy_dt, dx_dt);
        ///float Alpha=57.29747f*(dy_dt/dx_dt); // проверка квадрантов ?
        
        float Alpha_1=(Alpha+oldAlpha)/2.0f; // среднее соседних точек (линейная интерполяция).
        
        oldAlpha=Alpha;
        
        // таблица для рисования в http://yotx.ru
        if (GrafT) { cout<<"   ("<<t-dlt<<";"<<Alpha_1<<") "<<endl; }
        if (GrafT) { cout<<"   ("<<t<<";"<<Alpha<<") "<<endl; }
        
    }
    if (GrafT) { cout<<endl; }
    /**	*/
    
    // количество точек обсчета можно существенно уменьшить с помощью адаптивного разбиения
    // http://rsdn.ru/article/multimedia/Bezier.xml#
    // Автор: Maxim Shemanarev.
    // Для кривой второго порядка (Первая производная кубической кривой Безье) в тексте Безье.txt
    // написана "// Рекурсивная функция предназначена для быстрой растеризации и вычисления длины кубической кривой Безье."
    
    // Возвращаем угол в градусах между касательной и осью "x" по всей пиксельной кривой.
    
    
    /**
     // 	Вывод формулы прямых вычисления (не итерационные) первой производной кубической кривой Безье по t.
     float x1_0=x1-x0, x2_1=2.0f*(x2-x1), x3_2=x3-x2;
     float y1_0=y1-y0, y2_1=2.0f*(y2-y1), y3_2=y3-y2;
     float tt=t*t;   float d=1.0f-t;   float dd=d*d;   float dt=d*t;
     //float dx_dt = 3*dd*(x1-x0) + 6*d*t*(x2-x1) + 3*tt*(x3-x2);  	// x'(t)=dx/dt
     //float dy_dt = 3*dd*(y1-y0) + 6*d*t*(y2-y1) + 3*tt*(y3-y2);  	// y'(t)=dy/dt
     //float dx_dt = dd*(x1-x0) + 2.0f*d*t*(x2-x1) + tt*(x3-x2);  	// сокращаем на 3
     //float dy_dt = dd*(y1-y0) + 2.0f*d*t*(y2-y1) + tt*(y3-y2);  	
     float dx_dt = dd*x1_0 + dt*x2_1 + tt*x3_2;  	// x'(t)=dx/dt 
     float dy_dt = dd*y1_0 + dt*y2_1 + tt*y3_2;  	// y'(t)=dy/dt
     // Источники:
     // https://en.wikipedia.org/wiki/Bézier_curve 
     // http://netlib.narod.ru/library/book0039/ch13_06.htm 
     // https://www.cyberforum.ru/mathematical-analysis/thread950544.html
     */
    
    /** 
     function RationalBezier(3,t,w[],r[]):
     t2 = t * t
     t3 = t2 * t
     mt = 1-t
     mt2 = mt * mt
     mt3 = mt2 * mt
     f = [
     r[0] * mt3,
     3 * r[1] * mt2 * t,
     3 * r[2] * mt * t2,
     r[3] * t3
     ]
     basis = f[0] + f[1] + f[2] + f[3]
     return (f[0] * w[0] + f[1] * w[1] + f[2] * w[2] + f[3] * w[3])/basis
     */ 
    
    
}//___________________________________________________________________________
    
// Вычисление первой производной (угла наклона касательной) в главных точках кубической кривой Безье. //
// Основная рабочая. 15 мая 2021.
// -----------------------------------------------------------------------------

void firstDerivativePoint(OCRPoint &p0, OCRPoint &p1, OCRPoint &p2, OCRPoint &p3) {
    
    
    // Функция по координатам главных точек пиксельной кривой (t=0, t=L*1/3, t=L*2/3  t=1)
    // вычисляет первую производную в главных точках кубической кривой Безье.
    // Считаем что сглаженная исходная пиксельная кривая и кривая Безье примерно совпадают.
    // Алгоритм выполняется предпросчетом и является масштаб-независимым.
    
    
    /// Теория ///
    
    /**
     Каждая кривая Безье произошла от сглаженной пиксельной кривой, поэтому можно считать координаты
     не по кривым Безье, а по соответствующим им сглаженным пиксельным кривым.
     Каждой сглаженной пиксельной кривой можно сопоставить кубическую кривую Безье. Сопоставление кривых Безье
     со сглаженным фокальным линиям осуществляется по четырем точкам пиксельных кривых:
     начальной точки, точки 1/3 длины, точки 2/3 длины и конечной точки.
     По сути выполняется апроксимация сглаженных пиксельных кривых еще более гладкими
     кривыми Безье. Это особенно важно в начале и в конце кривых, где сглаживание усреднением не эффективно.
     По кривыми Безье аналитически (по формулам, предпросчетом) можно получить много полезной информации например:
     первая производная, вторая производная, кривизна (K=1/R), точки перегиба, вплоть до классификации кривых.
     Следует отметить что характеристики кривой не изменяются при разбиении кривой Безье на части.
     */
    
    // Функция получает на вход Декартовы координаты исходных точек, расположенных на сглаженной пиксельной кривой по X и Y.:
    ///float x00=p0.x, y00=p0.y; 	// координаты начала пиксельной кривой t=0.
    ///float x13=p1.x, y13=p1.y; 	// координаты точки находящийся на 1/3 длинны пиксельной кривой t=L*1/3.
    ///float x23=p2.x, y23=p2.y;  	// координаты точки находящийся на 2/3 длинны пиксельной кривой t=L*2/3.
    ///float x10=p3.x, y10=p3.y;  	// координаты конца пиксельной кривой t=1.
    
    // Функция возвращает уголы в градусах между касательными и осью "x" в этих же точках сглаженной пиксельной кривой.
    // float Alpha00, Alpha13, Alpha23, Alpha10;
    
    
    int GrafT=1;
    // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    if (GrafT)  cout<<"// Вычисление первой производной (угла наклона касательной) в главных точках кубической кривой Безье."<<endl;
    
    
    // ТЕСТ. //
    // Координаты исходных точек, расположенных на сглаженной пиксельной кривой по X и Y.
    float x00=1,  x13=5.2963,   x23=10.037,   x10=15;
    float y00=6,  y13=7.7037,   y23=7.62963,  y10=4;
    if (GrafT) { cout<<"x00="<<x00<<"   x13="<<x13<<"   x23="<<x23<<"   x10="<<x10<<endl; }
    
    
    // Вычисление первой производной (угла наклона касательной) в главных точках кубической кривой Безье.
    
    // Вычисляем координаты управляющих точек кривой Безье, по координатам исходных точек, расположенных на сглаженной пиксельной кривой:
    // Управляющие точки кривой Безье это точки, которые таскаем мышкой, при визуальном построении кривой.
    // Формулы Безье используют координаты именно управляющих точек.
    float x0=x00;
    float y0=y00;
    float x1=(-5.0f*x00 + 18.0f*x13 - 9.0f*x23  + 2.0f*x10)/6.0f;  // x1 координата по “x” первой управляющей точки.
    float y1=(-5.0f*y00 + 18.0f*y13 - 9.0f*y23  + 2.0f*y10)/6.0f;  // y1 координата по “y” первой управляющей точки.
    float x2=( 2.0f*x00 -  9.0f*x13 + 18.0f*x23 - 5.0f*x10)/6.0f;  // x2 координата по “x” второй управляющей точки.
    float y2=( 2.0f*y00 -  9.0f*y13 + 18.0f*y23 - 5.0f*y10)/6.0f;  // y2 координата по “y” второй управляющей точки.
    float x3=x10;   // Начальные и конечные управляющие точки кривой Безье совпадают
    float y3=y10;   // с начальными и конечными точками (узлами) пиксельной кривой.
    // где x00:y00, x13:y13, x23:y23, x10:y10 координаты исходных точек, расположенных на сглаженной пиксельной кривой:
    // Источники:
    // Роджерс Д., Адамс Дж. Математические основы машинной графики. М.: Мир, 2001. 604 с.
    // http://sernam.ru/book_mm3d.php?id=92 // это Адамс
    // http://alex-black.ru/article.php?content=109
    
    if (GrafT) { cout<<"x0="<<x0<<"   x1="<<x1<<"   x2="<<x2<<"   x3="<<x3<<endl; }
    
    // ТЕСТ. //
    // координаты управляющих точек по X и Y (управляющие вектора), которые таскаем мышкой при визуальном построении кривой.
    ///x0=1, x1=5, x2=10, x3=15;
    ///y0=6, y1=8, y2=10, y3=4;
    
    
    /**
     // Кубические кривая Безье. Исходные формулы. //
     // Кривая Безье задана параметрической функцией вида x=x(t), y=y(t) где 0<=t<=1.
     float t=0.0f; // параметр уравнений кривой Безье 0<=t<=1. Тип float, точность не менее шести значащих десятичных цифр, разрядность-32.
     
     // B(t) = (1-t)^3*P0 + 3*(1-t)^2*t*P1 + 3*(1-t)*t^2*P2 + t^3*P3	// 0<=t<=1
     float x = (1-t)*(1-t)*(1-t)*x0 + 3*t*(1-t)*(1-t)*x1 + 3*t*t*(1-t)*x2 + t*t*t*x3;		// y=x(t)
     float y = (1-t)*(1-t)*(1-t)*y0 + 3*t*(1-t)*(1-t)*y1 + 3*t*t*(1-t)*y2 + t*t*t*y3;		// x=y(t)
     // где x0:y0, x1:y1, x2:y2, x3:y3 координаты управляющих точек, которые таскаем мышкой при визуальном построении кривой (управляющие вектора).
     
     // Первая производная кубической кривой Безье по t равна:
     // B'(t) = 3*(1-t)^2*(P1-P0) + 6*(1-t)*t*(P2-P1) + 3*t^2*(P3-P2)
     float dx_dt = 3*(1-t)*(1-t)*(x1-x0) + 6*(1-t)*t*(x2-x1) + 3*t*t*(x3-x2);  	// x'(t)=dx/dt
     float dy_dt = 3*(1-t)*(1-t)*(y1-y0) + 6*(1-t)*t*(y2-y1) + 3*t*t*(y3-y2);  	// y'(t)=dy/dt
     
     // Прямые вычисления (не итерационные) первой производной кубической кривой Безье по t. //
     // Исходные формулы.
     // Первая производная кубической кривой Безье в начале кривой в точке t=0. //
     // Первая производная по t кубической кривой Безье равна:
     float dx_dt = x1-x0;  	// float dx_dt = 3*dd*(x1-x0);
     float dy_dt = y1-y0;	// float dx_dt = 3*dd*(y1-y0);
     // Первая производная по x кубической кривой Безье равна:
     // x'(t)=dy/dx=(dx/dt)/(dy/dt)=dy/dx
     float dy_dx = dy_dt/dx_dt;
     // Первая производная является тангенсом угла наклона касательной прямой в точке "t".
     float Alpha00=57.29747f*atan(dy_dx);
     // Функция atan2, в отличии от atan определена во всех квадрантах, в котором находится угол.
     
     // Источники:
     // https://en.wikipedia.org/wiki/Bézier_curve
     // http://netlib.narod.ru/library/book0039/ch13_06.htm
     // https://www.cyberforum.ru/mathematical-analysis/thread950544.html
     */
    
    
    // Вычисление. //
    
    // Первая производная кубической кривой Безье в начале кривой в точке t=0. //
    float Alpha00=57.29747f*atan2f(y1-y0, x1-x0);	// угол наклона касательной проведенной к кривой Безье в точке t=0.
    
    // Первая производная кубической кривой Безье в середине кривой в точке t=1/3. //
    float Alpha13=57.29747f*atan2f(4.0f*(y2-y0) + (y3-y2), 4.0f*(x2-x0) + (x3-x2));
    
    // Первая производная кубической кривой Безье в середине кривой в точке t=2/3. //
    float Alpha23=57.29747f*atan2f((y1-y0) + 4.0f*(y3-y1), (x1-x0) + 4.0f*(x3-x1));
    
    // Первая производная кубической кривой Безье в конце кривой в точке t=1. //
    float Alpha10=57.29747f*atan2f(y3-y2, x3-x2); // (у-координата, x-координата)
    
    
    if (GrafT) { cout<<"Alpha00="<<Alpha00<<"   Alpha13="<<Alpha13<<"   Alpha23="<<Alpha23<<"   Alpha10="<<Alpha10<<endl; }
    
    // Возвращаем углы наклона касательных в градусах  Alpha00, Alpha13, Alpha23, Alpha10.
    
    
    
    
    /**
     // Вывод формул для точек t=0, t=1/3, t=2/3, t=1
     // Прямые вычисления (не итерационные) первой производной кубической кривой Безье по t. //
     
     float tt=t*t;   float d=1-t;   float dd=d*d;  // Переменные параметрического уравнения общего вида.
     // Упрощаем выражения для вычисления  float dy_dx = dy_dt/dx_dt;
     dx_dt = 3*dd*(x1-x0) + 6*d*t*(x2-x1) + 3*tt*(x3-x2);  // x'(t)=dx/dt
     dy_dt = 3*dd*(y1-y0) + 6*d*t*(y2-y1) + 3*tt*(y3-y2);
     dx_dt = dd*(x1-x0) + 2.0f*d*t*(x2-x1) + tt*(x3-x2);   // сокращаем на 3
     dy_dt = dd*(y1-y0) + 2.0f*d*t*(y2-y1) + tt*(y3-y2);
     
     // Первая производная кубической кривой Безье в середине кривой в точке t=1/3.
     // Подставляем в уравнение t=1/3 и упрощаем.
     dx_dt = 4/9*(x1-x0) + 2.0f*2/3*1/3*(x2-x1) + 1/9*(x3-x2);  // x'(t)=dx/dt
     dx_dt = 4*(x1-x0) + 2.0f*2*(x2-x1) + (x3-x2);
     dx_dt = 4*(x2-x0) + (x3-x2);
     
     // Первая производная кубической кривой Безье в середине кривой в точке t=2/3.
     // Подставляем в уравнение t=2/3 и упрощаем.
     dx_dt = 1/9*(x1-x0) + 2.0f*1/3*2/3*(x2-x1) + 4/9*(x3-x2);  // x'(t)=dx/dt
     dx_dt = (x1-x0) + 2.0f*2*(x2-x1) + 4*(x3-x2);
     dx_dt = (x1-x0) + 4*(x3-x1);
     */
    
    /**
     // Тест. //
     // Координаты управляющих точек кривой Безье:
     float x0, y0; 	// координаты начала пиксельной кривой.
     float x1, y1; 	// координаты первой управляющей точки.
     float x2, y2;  	// координаты второй управляющей точки.
     float x3, y3;  	// координаты конца пиксельной кривой.
     // координаты управляющих точек по X и Y (управляющие вектора), которые таскаем мышкой при визуальном построении кривой.
     x0=1.0f, x1=5.0f, x2=10.0f, x3=15.0f;
     y0=6.0f, y1=8.0f, y2=10.0f, y3=4.0f;	
     // Обратные формулы (проверено).
     // По координатам управляющих точек кривой Безье вычисляем исходные точки (для t=1/3 и t=2/3), расположенных на сглаженной пиксельной кривой:
     x00=x0;
     y00=y0;
     x13=(12.0f*x1 + 6.0f*x2 + 8.0f*x0 + x3)/27.0f;     
     y13=(12.0f*y1 + 6.0f*y2 + 8.0f*y0 + y3)/27.0f;
     if(GrafT)cout<<"x13=(12*Px1 + 6*Px2 + 8*x0 + x3)/27="<<x13<<"     y13="<<y13<<endl;
     x23=(6.0f*x1 + 12.0f*x2 + x0 + 8.0f*x3)/27.0f;     
     y23=(6.0f*y1 + 12.0f*y2 + y0 + 8.0f*y3)/27.0f;
     if(GrafT)cout<<"x23=(6*x1 + 12*x2 + x0 + 8*x3)/27="<<x23<<"     y23="<<y23<<endl;
     x10=x3;
     y10=y3;
     // Получили координаты исходных точек, расположенных на сглаженной пиксельной кривой по X и Y.
     ///x00=x0,  x13==5.2963,  x23==10.037,  x10=x3;
     ///y00=y0,  y13=7.7037,   y23=7.62963,  y10=y3;	
     */
    
    
}//___________________________________________________________________________
    
// Вычисление координат начала и конца касательной к кубической кривой Безье. //
// Основная. 17 мая 2021.
// -----------------------------------------------------------------------------

void drawingTangent () {
    
    // Функция используя угол наклона касательной в градусах, координаты начала касательной
    // и ее длинну, вычисляет координаты конца касательной.
    // Используется для визуализации в SVG line.
    // Можно нарисовать двустороннюю касательную ("-" перед  r/sqrt ).
    
    
    // Функция получает на вход:
    float r=6.0f; 			// длинну касательной "r" в pix.
    float x1=5.2963;		// Декартовы координаты начала касательной по "x".
    float y1=7.7037;		// Декартовы координаты начала касательной по "y".
    float Alpha=13.7074;	// угол наклона касательной в градусах.
    
    int GrafT=1;
    // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    if (GrafT)  cout<<"// Вычисление координат начала и конца касательной к кубической кривой Безье."<<endl;
    
    // Вычисление координат конца касательной к точке x0, y0 лринадлежащей сглаженной пиксельной кривой.
    // Получаем координаты конца касательной x2 и y2.
    float k=tan(Alpha/57.29747f);
    float x2=x1 + r/sqrt(k*k+1);	// "-" перед  r/sqrt меняет направление касательной
    float y2=y1 + k*(x2-x1);
    
    if (GrafT) { cout<<"x1="<<x1<<"   y1="<<y1<<"   x2="<<x2<<"   y2="<<y2<<endl; }
    // координаты концов касательной для рисования в http://yotx.ru
    if (GrafT) { cout<<"   ("<<x1<<";"<<y1<<")("<<x2<<";"<<y2<<")"<<endl; }
    
    // Возвращает координаты начала касательной x1, y1  и координаты конца касательной x2, y2.
    
    
    
    /**
     // Вывод формул для получения координат конца касательной x, y. //
     // Для визуализации в SVG line. //
     // Вычисление координат конца касательной к точке x0, y0 лринадлежащей сглаженной пиксельной кривой.
     
     // Исходные данные:
     // k=dy_dx=tan(Alpha) угловой коэффициент.
     // "r" длинна касательной.
     // x1, y1 координаты начала касательной.
     // Необходимо вычислить:
     // x, y координаты конца касательной.
     // Составляем систему уравнений: уравнение касательной в точке x1, y1 и теорема Пифагора.
     y=у1 + k*(x-x1)  и  r^2=(x-x1)^2 + (y-y1)^2
     // подставляем первое уравнение во второе.
     r^2=(x-x1)^2 + (у1 + k*(x-x1)-y1)^2
     // Решаем по "x" и в результате получаем:
     x=x1 + r/sqrt(k^2+1);	// (k^2+1)!=0 всегда,  +/- перед r/sqrt меняет направление касательной
     y=у1 + k*(x-x1)
     // https://mathforyou.net/online/equation/arbitrary/
     */
    
    // SVG line вместе с атрибутами x1, x2, y1, y2,
    // <svg>
    // <line x1="12" y1="49" x2="186" y2="110" stroke="black" />
    // </svg>
    // http://shpargalkablog.ru/2015/11/svg.html#razsvgline
    
}//___________________________________________________________________________	    
    
    
}  // namespace ocr


