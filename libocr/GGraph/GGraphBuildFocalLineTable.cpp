//@___________GGraphBuildFocalLineTable.cpp

//  OCRLib  2015 http://www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org.

//*******************************************************************************



#include "GGraph.h"
/// Базовая версия - buildOCRLineTable ///

// Функция построения таблиц распознавания фокальных линий.
// Предназначена для построения таблиц, необходимых для функции распознования фокальных линий focalLineRecognition.

void GGraph::buildOCRLineTable(){
    
    // Функция создает 3 предпросчитанные таблици (заполняет 3 глобальных массива, объявленые в GBitmap.h):
    // - таблицу для вычисления особых точек table_1. //
    // - таблицу для вычисления адресов смещения точек при движении вдоль фокальной линии table_2 //
    // - таблицу для вычисления адресов точек начала фокальных линий table_3. Из каждой точки может выходить до 4 линий. //
    
    // Вычисление матрицы (3*3-1) по предпросчитанным таблицам быстрее в несколько раз чем просчитывать матрицу в теле основного цикла.
    // Принцип и конкретная реализация работы матрицей (маской) обсчета (3*3-1) по таблице описана в функции GGraphFocalPoint.cpp
    
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    if (GrafT) {DG("Функция построения таблиц распознавания фокальных линий   buildOCRLineTable() \n"); }
    uint w=ncolumns;
    
    /// вспомогательные переменные.
    unsigned char d2=0,d3=0,d4=0,d5=0,d6=0,d7=0,d8=0,d9=0; // d1,  // переменные маски.
    short dm9=-w-1, dm2=-w, dm3=1-w, dm8=-1, dm4=1, dm7=w-1, dm6=w, dm5=w+1; // переменные координат смещения маски /
                                                                             //        -w-1,     -w,     1-w,     -1,     1,     w-1,     w,     w+1  // величины смещения маски //
    unsigned char a01, a10, b; // переменные условий.
    short dl_1=0, dl_2=0, dl_3=0, dl_4=0;  // Координаты точек (например dl_1, dl_2 координаты входящих и выходящих точек).
    
    // вспомогательный регистры (переменные таблиц), где table_1[256], table_2[256], table_3[256] и table_4[256] глобальные массивы.
    unsigned char rg0=0;  // байтовый регистр для хранения отдельных 8 бит маски.
    int rg_tab2=1;
    long long rg_tab3=1;
    
    
    
    // переменные для вывода графики
    short g9=0, g2=0, g3=0, g8=0, g4=0, g7=0, g6=0, g5=0;
    if (GrafT) {
        // вывод на экран шаблона матрицы
        DG("d9   d2   d3\nd8           d4\nd7   d6   d5\n");
        // вывод на экран бит регистра rg0 по шаблону матрицы
        ///cout<<(short)d9<<"     "<<(short)d2<<"     "<<(short)d3<<endl<<(short)d8<<"            "<<(short)d4<<endl<<(short)d7<<"     "<<(short)d6<<"     "<<(short)d5<<endl;
    }
    
    
    //rg0=1+64+16;  // тест
    
    //матрица обсчета    //ортогональная маска  //диагональная маска   //адреса смещения     //сокращение     // пример rg0
    
    // d9   d2   d3            0    1   0           1    0   1         -w-1  -w   1-w         dm9 dm2 dm3        1   2   4
    
    // d8   d1   d4            1        1           0        0          -1         1          dm8     dm4        8       16
    
    // d7   d6   d5            0    1   0           1    0   1          w-1   w   w+1         dm7 dm6 dm5        32  64 128
    
    // матрица (маска) обсчета (3*3-1), где d1 центральной точка по которой принимается решение.
    // d2, d3, d4, d5, d6, d7, d8, d9  точки окружения, по которым работает алгоритм принятия решения.
    
    
    /////
    
    // Создание предпросчитанной таблицы особых точек table_1. //
    // Создание предпросчитанных адресов смещения точек при движении вдоль фокальной линии table_2 //
    // Создание предпросчитанной таблицы адресов точек начала фокальных линий table_3. //
    // Цикл перебора всех возможных значений матрицы (3*3-1 без центральной точки).
    for (int index=0; index < 256; index++){
        rg0=index;
        table_1[index]=table_2[index]=table_3[index]=0; // заполнение таблиц нулями
        dl_1=dl_2=dl_3=dl_4=0;
        
        // разборка байтового регистра на отдельные 8 бит //
        d9=rg0 & 1;    d2=rg0>>1 & 1; d3=rg0>>2 & 1; d8=rg0>>3 & 1;
        d4=rg0>>4 & 1; d7=rg0>>5 & 1; d6=rg0>>6 & 1; d5=rg0>>7 & 1;
        // Подготовка данных для алгоритма //
        a01=0; // "a01" это число паттернов "01" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)
        if(d3-d2>0)a01++; if(d4-d3>0)a01++; if(d5-d4>0)a01++; if(d6-d5>0)a01++;
        if(d7-d6>0)a01++; if(d8-d7>0)a01++; if(d9-d8>0)a01++; if(d2-d9>0)a01++;
        a10=0; // "a10" это число паттернов "10" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)
        if(d3-d2<0)a10++; if(d4-d3<0)a10++; if(d5-d4<0)a10++; if(d6-d5<0)a10++;
        if(d7-d6<0)a10++; if(d8-d7<0)a10++; if(d9-d8<0)a10++; if(d2-d9<0)a10++;
        // "b" это число ненулевых соседей центральной точки d1, например, она имеет по крайней мере, 3 ненулевых соседа, но не более 5.
        b=d2+d3+d4+d5+d6+d7+d8+d9;
        
        // Заполнение таблиц //
        
        // АЛГОРИТМ подсчета особых точек. Заполнение таблици table_1 //
        // Точно такой же как в GGraphFocalPoint.cpp . При изменениях синхронизировать.
        // Ставит точки только в "Т" стыках (базовый вариант). //
        if ( b<6 && b>2 && a01==3 && a10==3 ) table_1[index]+=1;  // проверяется a01=3 && a10=3  // 56 (int mn=0; {mn++;})
        
        // Ставит точки не только в "Т" стыках, но и в "Х" стыках. //
        //if ( b<7 && b>2 && a01>2 && a01<5 && a10>2 && a10<5 ) table_1[index]+=2; // проверяются a01=3=4 && a10=3=4
        // Ставит точки только в "Х" стыках. Основное правило  //
        if ( b<7 && b>2 && a01>2 && a01<5 && a10>2 && a10<5 && table_1[index]!=1) table_1[index]+=2; // 2
                                                                                                     //cout<<" "<<(unsigned short)table_1[index];
        
        // Основное правило ("Т" или "Х" стыков) ситуацию с квадратом из четырех точек не отрабатывает.
        // Варианты отработки ситуации, если на месте Х образной точки квадрат из четырех точек,
        // с выходящими из всех углов ломаными линиями. //
        // отрабатывает не все ситуации
        ///if ( d8==1 && d9 && d2==1 && b==5 && a01==2 && a10==2 ) table_1[index]+=2; // d8==d9==d2==1 описание квадрата 2x2 pix, // 6
        
        // Ставит точки в случае, если на месте Х образной точки квадрат из четырех точек.
        // В этом варианте мы ставим одну фокальную точку в правый нижний угол квадрата
        ///if ( d8==1 && d9 && d2==1 && a01==2 && a10==2 ) table_1[index]+=2;
        
        // Ставит точки в случае, если на месте Х образной точки квадрат из четырех точек.
        // В этом варианте мы ставим четыре фокальных точеки в каждом уголу квадрата
        if ( ((d8==1 && d9==1 && d2==1) || (d2==1 && d3==1 && d4==1) ||
              (d4==1 && d5==1 && d6==1) || (d6==1 && d7==1 && d8==1)) && b<7 && a01==2 && a10==2 ) table_1[index]+=2;
        // центральная точка d1==1 проверяется в основном цикле ниже
        
        // Ставит точки на концах линий "L_End" и не забыть поставить в главном цикле if ( rg0>0 && table_1[rg0]==0 )
        if ( b<3 && b>0 && a01==1 && a10==1 ) table_1[index]+=4;  // 16
        
        // Ставит точки когда фокальная линия вырожденна в один пиксел "P_Point"
        if ( b==0 ) table_1[index]+=8; // также как и во всех предыдущих случаях запаковываем этот бит в char. // 1
        
        // (GrafT) // вывод на экран стыков типа "Т", "Х" и "L_End" по шаблону матрици (параметр соответственно ==1, ==2, ==4)
        if (GrafT && table_1[index]==4) {
            cout<<"index="<<index<<endl;
            cout<<(short)d9<<"     "<<(short)d2<<"     "<<(short)d3<<endl<<(short)d8<<"     "<<1<<"     "<<(short)d4<<endl<<(short)d7<<"     "<<(short)d6<<"     "<<(short)d5<<endl<<endl;
        }
        if (GrafT){
            cout<<"table_1[188]="<<(short)table_1[188]<<endl;
            cout<<"b="<<(short)b<<" a01="<<(short)a01<<" a10="<<(short)a10<<endl;
        }
        
        // АЛГОРИТМ вычисления адресов промежуточных точек.  Заполнение таблици table_2  //
        // Вычисление координат входящей и выходящей точки. Одна из них станет координатой смещения маски.
        //          b>0
        if ( b<7 && b>1 && a01==2 && a10==2 && table_1[index]==0 ) { // и не особая точка // Условие заполнения таблицы. 5
            
            // Сначала ищем самые "ближайшие" входящие и выходящие точки (они м.б. только слева или справа, снизу или сверху).
            // Координаты входящих и выходящих точек это и есть одна из координат смещения маски dl1 или dl2.
            dl_1=0, dl_2=0;
            if (d2==1) { if (dl_1==0) dl_1=dm2; }
            if (d4==1) { if (dl_1==0) dl_1=dm4; else if (dl_2==0) dl_2=dm4; }
            if (d6==1) { if (dl_1==0) dl_1=dm6; else if (dl_2==0) dl_2=dm6; }
            if (d8==1) { if (dl_1==0) dl_1=dm8; else if (dl_2==0) dl_2=dm8; }
            //cout<<(short)rg0<<"   dl_1="<<dl_1<<"   dl_2="<<dl_2<<endl;
            
            // За тем ищем диаганальные "более дальние" входящие и выходящие точки (они м.б. только по диаганали)
            // и проверяем только те у которых не заняты соседние точки.
            if (d9==1 && d8==0 && d2==0) { if (dl_1==0) dl_1=dm9; else if (dl_2==0 ) dl_2=dm9; }
            if (d3==1 && d2==0 && d4==0) { if (dl_1==0) dl_1=dm3; else if (dl_2==0 ) dl_2=dm3; }
            if (d5==1 && d4==0 && d6==0) { if (dl_1==0) dl_1=dm5; else if (dl_2==0 ) dl_2=dm5; }
            if (d7==1 && d6==0 && d8==0) { if (dl_1==0) dl_1=dm7; else if (dl_2==0 ) dl_2=dm7; }
            //cout<<(short)rg0<<"   dl_1="<<dl_1<<"   dl_2="<<dl_2<<endl;
            /**/
            
            // Запаковка в int (table_2) двух знаковых short с двумя вариантами смещения маски на dl1 или dl2.
            *(short*)&rg_tab2=dl_1;   *((short*)&rg_tab2+1)=dl_2;
            table_2[index]=rg_tab2;
            
            // (GrafT) // распакованная координата входящей и выходящей точки по шаблону матрици (центральная точка забита 1)
            if (GrafT) {
                // тест
                // Роспаковка координат из table_2 (int) в два знаковых short с двумя вариантами смещения маски на dl1 или dl2.
                dl_1=*(short*)&table_2[index];   dl_2=*((short*)&table_2[index]+1);
                // DG("index=",index);DG("  table_2[index]=",table_2[index]);DG("   распакованные  dl_1=",dl_1);DG(",   dl_2=",dl_2);DG(END);
                //dm9=-w-1,  dm2=-w,  dm3=1-w, dm8=-1, dm4=1, dm7=w-1, dm6=w, dm5=w+1;
                g9=0, g2=0, g3=0, g8=0, g4=0, g7=0, g6=0, g5=0;
                if (dl_1==dm9 || dl_2==dm9) g9=1;  if (dl_1==dm2 || dl_2==dm2) g2=1;  if (dl_1==dm3 || dl_2==dm3) g3=1;
                if (dl_1==dm8 || dl_2==dm8) g8=1;  if (dl_1==dm4 || dl_2==dm4) g4=1;  if (dl_1==dm7 || dl_2==dm7) g7=1;
                if (dl_1==dm6 || dl_2==dm6) g6=1;  if (dl_1==dm5 || dl_2==dm5) g5=1;
                //p(g9);DG("     ",g2);DG("     ",g3);DG("\n",g8);DG("     1     ",g4);DG("\n",g7);DG("     ",g6);DG("     ",g5)DG("\n\n");
            } // (GrafT)
            
        } // if ( b<5
        
        
        
        // АЛГОРИТМ вычисления координат начала фокальных линий, выходящих из особых точек.  //
        // получение координат начала фокальных линий, выходящих из особых точек (их м.б. 3,4,1 максимум 4).
        if ( table_1[index]!=0 ) { // если особая точка, то заполняем таблицу.
            
            // Сначала ищем самые "ближайшие" входящие и выходящие точки (они м.б. только слева или справа, снизу или сверху).
            // Координаты выходящих точек это и есть стартовые координаты dl1, dl2, dl3, dl4 начала движения маски по фокальной линии.
            dl_1=0;dl_2=0;dl_3=0;dl_4=0;
            //dl_1=0, dl_2=0, dl_3=0, dl_4=0
            
            if (d2==1) { dl_1=dm2; }
            if (d4==1) { if (dl_1==0) dl_1=dm4; else if (dl_2==0) dl_2=dm4; }
            if (d6==1) { if (dl_1==0) dl_1=dm6; else if (dl_2==0) dl_2=dm6; else if (dl_3==0) dl_3=dm6; }
            if (d8==1) { if (dl_1==0) dl_1=dm8; else if (dl_2==0) dl_2=dm8; else if (dl_3==0) dl_3=dm8; else if (dl_4==0) dl_4=dm8; }
            ///cout<<(short)rg0<<"   dl_1="<<dl_1<<"   dl_2="<<dl_2<<"   dl_3="<<dl_3<<"   dl_4="<<dl_4<<endl;
            
            // За тем ищем диаганальные "более дальние" входящие и выходящие точки (они м.б. только по диаганали)
            // и проверяем только те у которых не заняты соседние точки.
            if (d9==1&&d8==0&&d2==0) {if (dl_1==0)dl_1=dm9; else if (dl_2==0 )dl_2=dm9; else if (dl_3==0 )dl_3=dm9; else if (dl_4==0 )dl_4=dm9;}
            if (d3==1&&d2==0&&d4==0) {if (dl_1==0)dl_1=dm3; else if (dl_2==0 )dl_2=dm3; else if (dl_3==0 )dl_3=dm3; else if (dl_4==0 )dl_4=dm3;}
            if (d5==1&&d4==0&&d6==0) {if (dl_1==0)dl_1=dm5; else if (dl_2==0 )dl_2=dm5; else if (dl_3==0 )dl_3=dm5; else if (dl_4==0 )dl_4=dm5;}
            if (d7==1&&d6==0&&d8==0) {if (dl_1==0)dl_1=dm7; else if (dl_2==0 )dl_2=dm7; else if (dl_3==0 )dl_3=dm7; else if (dl_4==0 )dl_4=dm7;}
            //cout<<(short)rg0<<"+++   dl_1="<<dl_1<<"   dl_2="<<dl_2<<"   dl_3="<<dl_3<<"   dl_4="<<dl_4<<endl;
            //Упорядочивание значений table_3 в соответствии с порядком занесения линий в структуру OCRStar (звездочку)
            short id[8]; //массив записи величин смещений
            memset((char*)&id,0,sizeof(short)*8);
            short dm[8]; //массив соответствия величины смещения и порядкового номера пиксела в маске
                         //новый порядок значений для table_3
            dm[0]=dm4;dm[1]=dm3;dm[2]=dm2;dm[3]=dm9;dm[4]=dm8;
            dm[5]=dm7;dm[6]=dm6;dm[7]=dm5;
            //проверяем соответствие смещения значению в массиве dm и заносим
            //величину смещения в массив id на соответствующую позицию
            for(int n=0;n<8;n++){ if(dl_1==dm[n]){ id[n]=dl_1; break; }}
            for(int n=0;n<8;n++){ if(dl_2==dm[n]){ id[n]=dl_2; break; }}
            for(int n=0;n<8;n++){ if(dl_3==dm[n]){ id[n]=dl_3; break; }}
            for(int n=0;n<8;n++){ if(dl_4==dm[n]){ id[n]=dl_4; break; }}
            
            // Запаковка в long (table_3) четырех неупорядоченных знаковых short с координатами начала фокальных линий,
            // выходящих из особых точек, в виде смещения маски на dl1, dl2, dl3, dl4.
            //*(short*)&rg_tab3=dl_1;   *((short*)&rg_tab3+1)=dl_2;   *((short*)&rg_tab3+2)=dl_3;   *((short*)&rg_tab3+3)=dl_4;
            
            //запаковываем четыре упорядоченых знаковых short с координатами начала фокальных линий из массива смещений id в ячейку table_3
            int id_num=0;
            for(int n=0;n<8;n++){
                if(id[n]!=0){
                    *((short*)&rg_tab3+id_num)=id[n];
                    id_num++;
                }
            }
            
            
            table_3[index]=rg_tab3;
            ///cout<<"запакованный table_3"<<table_3<<endl;
            
            // (GrafT)
            // распакованные координаты начала фокальных линий, выходящих из особых точек, по шаблону матрици (центральная точка забита 1)
            /*
            if (0) {
                // Распаковка координат из table_3 (long) в четыре знаковых short с координатами начала фокальных линий.
                rg_tab3=table_3[index];
                dl_1=*(short*)&rg_tab3;   dl_2=*((short*)&rg_tab3+1);   dl_3=*((short*)&rg_tab3+2);   dl_4=*((short*)&rg_tab3+3);
                cout<<"dl_1="<<dl_1<<"  dl_2="<<dl_2<<"  dl_3="<<dl_3<<"  dl_4="<<dl_4<<endl<<endl; cout<<"rg_tab3:"<<rg_tab3<<endl;
                // заполнение шаблона матрицы
                DG("\n\nраспакованные координаты начала фокальных линий. index:"<<index);
                //dm9=-w-1,  dm2=-w,  dm3=1-w, dm8=-1, dm4=1, dm7=w-1, dm6=w, dm5=w+1;
                g9=0, g2=0, g3=0, g8=0, g4=0, g7=0, g6=0, g5=0;
                if (dl_1==dm9||dl_2==dm9||dl_3==dm9||dl_4==dm9)g9=1;
                if (dl_1==dm2||dl_2==dm2||dl_3==dm2||dl_4==dm2) g2=1;
                if (dl_1==dm3||dl_2==dm3||dl_3==dm3||dl_4==dm3)g3=1;
                if (dl_1==dm8||dl_2==dm8||dl_3==dm8||dl_4==dm8) g8=1;
                if (dl_1==dm4||dl_2==dm4||dl_3==dm4||dl_4==dm4)g4=1;
                if (dl_1==dm7||dl_2==dm7||dl_3==dm7||dl_4==dm7) g7=1;
                if (dl_1==dm6||dl_2==dm6||dl_3==dm6||dl_4==dm6)g6=1;
                if (dl_1==dm5||dl_2==dm5||dl_3==dm5||dl_4==dm5) g5=1;
                cout<<g9<<"     "<<g2<<"     "<<g3<<endl<<g8<<"     "<<0<<"     "<<g4<<endl<<g7<<"     "<<g6<<"     "<<g5<<endl<<endl;
            } // (GrafT)
            */
        } // if ( table_1
        
    } // for (index
    
    /////
    
    /**/
    if (GrafT) {
        cout<<"значение байтового регистра для хранения отдельных 8 бит маски, в конце цикла   rg0="<<(unsigned short)rg0<<endl;
        // вывод на экран бит регистра rg0 по шаблону матрицы
        cout<<(short)d9<<"     "<<(short)d2<<"     "<<(short)d3<<endl<<(short)d8<<"            "<<(short)d4<<endl<<(short)d7<<"     "<<(short)d6<<"     "<<(short)d5<<endl;
    }
    // cout<<endl;
    /**/
    
    // Глобальные массивы table_1[256], table_2[256] и table_3[256] заполнены и готовы к использованию в
    
    
    //--------------------------------------------------------------------------------------------------------------------------
    /*           // таблица работает, но не понадобилась. Углы слишком грубые 45, 90 градусов и еще скачут.
     // предпросчитаная таблица вычисления тангенциальных углов при движении вдоль фокальной линии.
     char table_4[256];   // глобольный, заявленв GGraph.
     =table_4[index]=0;
     char rg4;
     // АЛГОРИТМ вычисления тангенциальных углов промежуточных точек.  Заполнение таблици table_4  //
     // Вычисление разности углов между вектором центральной и входящей точкой и вектором между центральной и выходящей точкой.
     // Т.е. вычисление тангенциальных углов при движении вдоль фокальной линии.
     // Получает данные dl_1 и dl_2 от алгоритма вычисления адресов промежуточных точек.
     
     // d9   d2   d3            0    1   0           1    0   1         -w-1  -w   1-w         dm9 dm2 dm3        1   2   4
     
     // d8   d1   d4            1        1           0        0          -1         1          dm8     dm4        8       16
     
     // d7   d6   d5            0    1   0           1    0   1          w-1   w   w+1         dm7 dm6 dm5        32  64 128
     
     //dm9=-w-1,  dm2=-w,  dm3=1-w, dm8=-1, dm4=1, dm7=w-1, dm6=w, dm5=w+1;
     
     // Знак угла определяется в основной функции
     //if (dl_1==dm2) { if(dl_2==dm4)rg4=90; if(dl_2==dm5)rg4=45; if(dl_2==dm6)rg4=0; }
     //else if (dl_1==dm3) { if(dl_2==dm5)rg4=90; if(dl_2==dm6)rg4=45; if(dl_2==dm7)rg4=0; }
     //else if (dl_1==dm4) { if(dl_2==dm6)rg4=90; if(dl_2==dm7)rg4=45; if(dl_2==dm8)rg4=0; }
     //else if (dl_1==dm5) { if(dl_2==dm7)rg4=90; if(dl_2==dm8)rg4=45; if(dl_2==dm9)rg4=0; }
     //else if (dl_1==dm6) { if(dl_2==dm8)rg4=90; if(dl_2==dm9)rg4=45; if(dl_2==dm2)rg4=0; }
     //else if (dl_1==dm7) { if(dl_2==dm9)rg4=90; if(dl_2==dm2)rg4=45; if(dl_2==dm3)rg4=0; }
     //else if (dl_1==dm8) { if(dl_2==dm2)rg4=90; if(dl_2==dm3)rg4=45; if(dl_2==dm4)rg4=0; }
     //else if (dl_1==dm9) { if(dl_2==dm3)rg4=90; if(dl_2==dm4)rg4=45; if(dl_2==dm5)rg4=0; }
     // dl2 и dl1 величины смещения маски по входящим или выходящим точкам пересечения фокальные линии с маской. //
     
     
     if (dl_1==dm2) { if(dl_2==dm4)rg4=90; if(dl_2==dm5)rg4=45; if(dl_2==dm6)rg4=0; if(dl_2==dm7)rg4=-45; if(dl_2==dm8)rg4=-90; }
     else if (dl_1==dm3) { if(dl_2==dm5)rg4=90; if(dl_2==dm6)rg4=45; if(dl_2==dm7)rg4=0; if(dl_2==dm8)rg4=-45; if(dl_2==dm9)rg4=-90; }
     else if (dl_1==dm4) { if(dl_2==dm6)rg4=90; if(dl_2==dm7)rg4=45; if(dl_2==dm8)rg4=0; if(dl_2==dm9)rg4=-45; if(dl_2==dm2)rg4=-90; }
     else if (dl_1==dm5) { if(dl_2==dm7)rg4=90; if(dl_2==dm8)rg4=45; if(dl_2==dm9)rg4=0; if(dl_2==dm2)rg4=-45; if(dl_2==dm3)rg4=-90; }
     else if (dl_1==dm6) { if(dl_2==dm8)rg4=90; if(dl_2==dm9)rg4=45; if(dl_2==dm2)rg4=0; if(dl_2==dm3)rg4=-45; if(dl_2==dm4)rg4=-90; }
     else if (dl_1==dm7) { if(dl_2==dm9)rg4=90; if(dl_2==dm2)rg4=45; if(dl_2==dm3)rg4=0; if(dl_2==dm4)rg4=-45; if(dl_2==dm5)rg4=-90; }
     else if (dl_1==dm8) { if(dl_2==dm2)rg4=90; if(dl_2==dm3)rg4=45; if(dl_2==dm4)rg4=0; if(dl_2==dm5)rg4=-45; if(dl_2==dm6)rg4=-90; }
     else if (dl_1==dm9) { if(dl_2==dm3)rg4=90; if(dl_2==dm4)rg4=45; if(dl_2==dm5)rg4=0; if(dl_2==dm6)rg4=-45; if(dl_2==dm7)rg4=-90; }
     
     
     //if (dl_2==dm2) { if(dl_1==dm4)rg4=90; if(dl_1==dm5)rg4=45; if(dl_1==dm6)rg4=0; if(dl_1==dm7)rg4=-45; if(dl_1==dm8)rg4=-90; }
     //else if (dl_2==dm3) { if(dl_1==dm5)rg4=90; if(dl_1==dm6)rg4=45; if(dl_1==dm7)rg4=0; if(dl_1==dm8)rg4=-45; if(dl_1==dm9)rg4=-90; }
     //else if (dl_2==dm4) { if(dl_1==dm6)rg4=90; if(dl_1==dm7)rg4=45; if(dl_1==dm8)rg4=0; if(dl_1==dm9)rg4=-45; if(dl_1==dm2)rg4=-90; }
     //else if (dl_2==dm5) { if(dl_1==dm7)rg4=90; if(dl_1==dm8)rg4=45; if(dl_1==dm9)rg4=0; if(dl_1==dm2)rg4=-45; if(dl_1==dm3)rg4=-90; }
     //else if (dl_2==dm6) { if(dl_1==dm8)rg4=90; if(dl_1==dm9)rg4=45; if(dl_1==dm2)rg4=0; if(dl_1==dm3)rg4=-45; if(dl_1==dm4)rg4=-90; }
     //else if (dl_2==dm7) { if(dl_1==dm9)rg4=90; if(dl_1==dm2)rg4=45; if(dl_1==dm3)rg4=0; if(dl_1==dm4)rg4=-45; if(dl_1==dm5)rg4=-90; }
     //else if (dl_2==dm8) { if(dl_1==dm2)rg4=90; if(dl_1==dm3)rg4=45; if(dl_1==dm4)rg4=0; if(dl_1==dm5)rg4=-45; if(dl_1==dm6)rg4=-90; }
     //else if (dl_2==dm9) { if(dl_1==dm3)rg4=90; if(dl_1==dm4)rg4=45; if(dl_1==dm5)rg4=0; if(dl_1==dm6)rg4=-45; if(dl_1==dm7)rg4=-90; }
     
     table_4[index]=rg4;
     
     // в основнрй функции
     uint LengthLine90;  // длина фокальной линии состоящая только из ортогональных pix.
     uint LengthLine45;  // длина фокальной линии состоящая только из диаганальных pix.
     LengthLine90=1; LengthLine45=0; // первый pix особая точка // подумать почему LengthLine45=0 // SumLengthLine++;
     
     // длина фокальной линии состоящая только из ортогональных и диагональных pix.
     if ( dl_nl==1||dl_nl==-1||dl_nl==w||dl_nl==-w ) LengthLine90++;  else LengthLine45++; // (параметр функции focalLineRecDirect1)
     
     // Длинна фокальной линии состоящая только из ортогональных и только диагональных pix.
     // Параметр функции focalLineRecDirect1 и focalLineRecCircle2
     if ( dl0==1||dl0==-1||dl0==w||dl0==-w ) LengthLine90++; else LengthLine45++;
     
     //  Переменные для подпрограммы подсчета тангенциального угла:
     //int angl_t; // среднее значение тангенциального угла при движении вдоль одной фокальной линии.
     ///       int sign;   // знак тангенциального угла при движении вдоль одной фокальной линии равен +1 или -1.
     // Вычисление среднего значения тангенциального угла при движении вдоль одной фокальной линии.
     
     // dl2 и dl1 величины смещения маски по входящим или выходящим точкам пересечения фокальные линии с маской. //
     
     // координаты маски в следующей итерации в абсолютной линейной системе координат.
     if ( sl+dl1==sl_old ) { sl+=dl2; p0+=dl2; dl0=dl2; sign=-1;}  // это следующая стартовая точка.
     if ( sl+dl2==sl_old ) { sl+=dl1; p0+=dl1; dl0=dl1; sign=1;}   // или эта
     
     angl_t=0; // среднее значение тангенциального угла при движении вдоль одной фокальной линии.
     angl_t+=sign*table_4[rg0];
     */
    //--------------------------------------------------------------------------------------------------------------------------
    
}//____________________________________________________________________________
