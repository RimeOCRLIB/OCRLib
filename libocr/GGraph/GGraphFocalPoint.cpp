//  Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .

#include "GGraph.h"

namespace ocr{
  
  //*****************************************************************************
  
  /// Базовая версия - focalPointXTL ///
  
  // Функция выделения фокальных точек на фокальных линиях (графемах) букв. Ставит точки в "Т" стыках, в "Х" стыках и концах линий "L_End".
  // Определяет тип точки и записывает его в статус
  // Используется после применения функцией стандартизации начертания текста путем определения фокальной линии (графемы) букв.
  // Работает только с черно-белой картинкой.
  
  int  GGraph::focalPointXTL() {
    
    // Адреса фокальных точек в виде int расположенны в массиве векторов focalPoint, где int это расстояние
    // от начала координат до фокальной точки. Количество адресов равно sizeAdr.
    // Функция возвращает суммарное количество особых точек (адресов) sizeAdr по всему графическому тексту.
    
    // Общая идеология и терминология взята из работ:
    // A Fast Parallel Algorithm for Thinning Digital Patterns. T. Y. ZHANG and C. Y. SUEN.
    // http://www-prima.inrialpes.fr/perso/Tran/Draft/gateway.cfm.pdf
    // Каждая точка графическомуго текста просчитывается матрицей (маской) обсчета (3*3-1), где d1 центральной точка по которой
    // принимается решение является ли она точкой пересечения трех (и более) линий.
    // d2, d3, d4, d5, d6, d7, d8, d9  точки окружения, по которым работает алгоритм принятия решения. Точки окружения последовательно
    // записываются в байтовый регистр rg0. Подсчитывается число паттернов "01" и число паттернов "10" в упорядоченном множестве
    // d2, d3, d4, d5, d6, d7, d8, d9,(d2). Число паттернов "01" и число паттернов "10" должно быть три и более, т.к. каждая линия,
    // пересекая периметр маски, дает в регистре по одному паттерну "01" и "10". Дополнительно проверяется количество ненулевых соседей
    // центральной точки d1, т.е. она имеет по крайней мере, 3 ненулевых соседа, но не более 5. Все эти алгоритмы реализуются в виде
    // предпросчитанной таблицы table_1 по условию  b<6 && b>2 && a01>2 && a10>2 (для "Т" стыков). Отдельно, уже в цикле вычисления координат
    // особых (фокальных) точек проверяется центральная точка d1, и если она черная, то только тогда запускастся проверка по таблице,
    // что сильно уменьшает общее количество обращений к таблице. При положительном ответе таблицы данная точка считается особой точкой
    // и ее декартовы координаты "x", "y" заносятся в массив переменной длинны focalPoint в виде short количеством sizeAdr.
    // Сама функция возвращает количество особых точек sizeAdr по всему графическому тексту.
    // При необходимости, может ставить точки не только в "Т" стыках и "Х" стыках, но и на концах линий.
    // Условия (примерно) для разных типов особых точек:
    // Точки только в "Т" стыках (базовый вариант).  b<6 && b>2 && a01==3 && a10==3
    // Точки не только в "Т" стыках, но и в "Х" стыках.  b<7 && b>2 && a01>2 && a01<5 && a10>2 && a10<5
    // Точки на концах линий "L_End".  b==1 && a01==1 && a10==1  и не забыть в главном цикле if ( rg0>0 && table_1[rg0]==0 )
    
    //  * Особенности *
    // Вычисление матрицы (3*3-1) выполняется по предпросчитанным таблицам, что быстрее
    // чем просчитывать матрицу в теле цикла (более чем в 2 раза).
    
    //  * Особенности применения *
    // Используется после применения функцией стандартизации начертания текста путем определения фокальной линии (графемы) букв.
    
    ///printToScreen(); exit(0);
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    if (GrafT) { cout<<"Функция выделения фокальных точек на фокальных линиях букв   focalPointXTL() "<<endl; }
    
    /*
     // На сером данная функция focalPoint() вешается в трудно отлавливаемом варианте. Лучше проверить с помрщью функции
     // автоопределение наличие серого или черно-белого в битмапе int graduation=img_pecha->DetectGradations();. // time=0.006
     */
    
    //TIME_START_ASM
    //TIME_START
    
    int x;
    int w,h;
    w=ncolumns;  // ширина массива  IMAGE WIDTH
    h=nrows;     // высота массива  IMAGE HEIGHT
    int w_h=w*h; // длина массива  IMAGE
    
    if (GrafT) { cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
    // w*h=10 млн.  time=0.033
    
    /// вспомогательные переменные
    int n=0;     // переменная адресов
    unsigned char rg0=0;  // байтовый регистр для хранения отдельных 8 бит маски
    unsigned char d2,d3,d4,d5,d6,d7,d8,d9; // d1,  // переменные маски
    unsigned char a01, a10, b; // переменные условий
    unsigned int sizeAdr; // возвращаемое количество особых точек по всему графическому тексту.
    //short nPoint; // накопительная переменная, имеет смысл при многократном вызове данной функции
    // и обозначает сколько раз по данному адресу была найдена особая точека.
    
    int w_1=w+1; // смещение с угла в центр матрицы (маски)
    int w_h_=w*h-(w+w+4);   // -(0)
    int sf_rg=sizeof(unsigned long);  // размер unsigned long в байтах // sizeof(unsigned long)=8
    int w_h_64=w_h/sf_rg;   // размер массива bytes_data в unsigned long
    ///cout<<"w_h="<<w_h<<"  sf_rg="<<sf_rg<<"  w_h_64="<<w_h_64<<endl;
    
    
    /// Массивы ///
    // указатели типа uchar
    unsigned char *p0=bytes_data, *pw;   // входной массив, 0-черный 255-белый ( с 0-черный 1-белый не работает)
    //unsigned int *bytes_data0_32=(unsigned int*)bytes_data;    // приведение к unsigned int
    
    // выделение памяти под массивы.
    unsigned char table_1[256];  // таблица наличия особой точки.
    // содержимое байтов таблицы, если особая точка;
    // типа "Т" то в байте находится 1, если типа "Х" то 2, если окончание линии "L_end" то 4, если точка перегиба то 8 и
    // т.д. по степени 2. Во время отладки на одном месте могут оказаться точки разного типа.
    
    // указатели типа ulong на те же массивы для быстрых циклов.
    unsigned long *bytes_data0_64=(unsigned long*)bytes_data;    // приведение к unsigned long
    
    
    // матрица (маска) обсчета (3*3-1), где d1 центральной точка по которой принимается решение является ли она точкой пересечения трех линий.
    // d2, d3, d4, d5, d6, d7, d8, d9  точки окружения, по которым работает алгоритм принятия решения.
    /*
     d9   d2   d3
     
     d8   d1   d4
     
     d7   d6   d5
     */
    
    // Создание предпросчитанной таблицы table_1, например по условию (a01 = 3) && (a10 = 3) && (2 < b < 6)
    //В таблице типам точек соответствует свои индексы
    //T_POINT=1,
    //X_POINT=2,
    //L_POINT=4,
    //P_POINT=5,
    
    // цикл перебора всех возможных значений матрицы (3*3-1) без центральной точки d1 // time=0
    for (int index=0; index < 256; index++){
      rg0=index;
      table_1[index]=0; // заполнение нулями таблицы
      
      // разборка байтового регистра на отдельные 8 бит //
      d9=rg0 & 1;    d2=rg0>>1 & 1; d3=rg0>>2 & 1; d8=rg0>>3 & 1;
      d4=rg0>>4 & 1; d7=rg0>>5 & 1; d6=rg0>>6 & 1; d5=rg0>>7 & 1;
      // Подготовка данных для алгоритма //
      a01=0; // "a01" это число паттернов "01" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)
      if(d3-d2>0)a01++; if(d4-d3>0)a01++; if(d5-d4>0)a01++; if(d6-d5>0)a01++;
      if(d7-d6>0)a01++; if(d8-d7>0)a01++; if(d9-d8>0)a01++; if(d2-d9>0)a01++;
      a10=0; // "a10" это число паттернов "10" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)
      if(d3-d2<0)a10++; if(d4-d3<0)a10++; if(d5-d4<0)a10++; if(d6-d5<0)a10++;
      if(d7-d6<0)a10++; if(d8-d7<0)a10++; if(d9-d8<0)a10++; if(d2-d9<0)a10++;
      // "b" это число ненулевых соседей центральной точки d1, т.е, она имеет по крайней мере, 3 ненулевых соседа, но не более 5.
      b=d2+d3+d4+d5+d6+d7+d8+d9;
      
      // АЛГОРИТМ (заполнение таблицы) //
      
      // Ставит точки только в "Т" стыках (базовый вариант). //
      if ( b<6 && b>2 && a01==3 && a10==3 ) table_1[index]+=1;  // проверяется a01=3 && a10=3
      
      // Ставит точки не только в "Т" стыках, но и в "Х" стыках. //
      //if ( b<7 && b>2 && a01>2 && a01<5 && a10>2 && a10<5 ) table_1[index]+=2; // проверяются a01=3=4 && a10=3=4
      // Ставит точки только в "Х" стыках. Основное правило  //
      if ( b<7 && b>2 && a01>2 && a01<5 && a10>2 && a10<5 && table_1[index]!=1) table_1[index]+=2; // 2
      //cout<<" "<<(unsigned short)table_1[index];
      
      // Основное правило ("Т" или "Х" стыков) ситуацию с квадратом из четырех точек не отрабатывает.
      // Варианты отработки ситуации, если на месте Х образной точки квадрат из четырех точек,
      // с выходящими из всех углов ломаными линиями. //
      // отрабатывает не все ситуации
      ///if ( d8==1 && d9 && d2==1 && b==5 && a01==2 && a10==2 ) table_1[index]+=2; // d8==d9==d2==1 описание квадрата 2x2 pix, // 6
      
      // Ставит точки в случае, если на месте Х образной точки квадрат из четырех точек.
      // В этом варианте мы ставим одну фокальную точку в правый нижний угол квадрата
      ///if ( d8==1 && d9 && d2==1 && a01==2 && a10==2 ) table_1[index]+=2;
      
      // Ставит точки в случае, если на месте Х образной точки квадрат из четырех точек.
      // В этом варианте мы ставим четыре фокальных точеки в каждом уголу квадрата
      if ( ((d8==1 && d9==1 && d2==1) || (d2==1 && d3==1 && d4==1) ||
            (d4==1 && d5==1 && d6==1) || (d6==1 && d7==1 && d8==1)) && b<7 && a01==2 && a10==2 ) table_1[index]+=2;
      // центральная точка d1==1 проверяется в основном цикле ниже
      
      // Ставит точки на концах линий "L_End" и не забыть в главном цикле if ( rg0>0 && table_1[rg0]==0 )
      if ( b<3 && b>0 && a01==1 && a10==1 ) table_1[index]+=4;
      
      // Ставит точки когда фокальная линия вырожденна в один пиксел "P_Point"
      if ( b==0 ) table_1[index]+=8;
      
      // Ставит точки не только в "Т" стыках, но и в "произвольном числе" стыков.
      ///if ( b<6 && b>2 && a01>2 && a10>2 ) table_1[index]=0;    // проверяются a01>2 && a10>2
      //приводим значение типа точки к количеству лучей
      //O_POINT=0,
      //L_POINT=1,
      //P_POINT=2,
      //T_POINT=3,
      //X_POINT=4,
      if(table_1[index]==1){
        table_1[index]=T_POINT;
      }else if(table_1[index]==2){
        table_1[index]=X_POINT;
      }else if(table_1[index]==4){
        table_1[index]=L_POINT;
      }else if(table_1[index]==8){
        table_1[index]=Z_POINT;
      }
      
    } // for
    
    if (GrafT) cout<<"значение байтового регистра для хранения отдельных 8 бит маски, в конце цикла   rg0="<<(unsigned short)rg0<<endl;
    // cout<<endl;
    
    
    
    // инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный
    //for ( x=0; x < w_h; x++ ) { if (bytes_data[x]) bytes_data[x]=0;  else bytes_data[x]=255;} // по 1 байту
    //for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data0_64[x]; } // по 8 байт одновременно // time=0.005 w*h=10 млн. пикселей
    
    // Вычисление координат особых (фокальных) точек //
    
    // цикл обеспечивает принятие решения с помощью таблицы, является ли точка фокальной линии букв особой.
    OCRPoint pt; // обьявление локальной переменной
    pw=bytes_data + w_1;  // w_1=(w+1); смещение с угла в центр матрицы (маски)
    for ( x=0; x < w_h_; x++ ) {
      
      //if(x%w<650||x%w>700){  p0=bytes_data + x;    *p0=0;  continue;} // отладка. проверка области поиска
      
      // если точка контура d1 белая, то ее не зачем просчитывать по таблице (белых больше чем черных в 30 и более раз).
      if (*(pw + x)!=0) {  // d1=*(p0+w+1);    // в 2.8 быстрее
        p0=bytes_data + x;
        // сборка байтового регистра rg0 из отдельных 8 бит матрицы с помощью единичных масок
        rg0=(*(p0)&1) + (*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w+2)&16) + (*(p0+w+w)&32) + (*(p0+w+w+1)&64) + (*(p0+w+w+2)&128);
        
        // запись координат и статуса особых точек типа "Т", "Х", "L_end" в массив
        ///if ( rg0>2 && table_1[rg0]==0 ) { bytes_data0_32[n]=x + (w+1);  n++; } // сохраняем в исходный графический массив
        if ( table_1[rg0]>0 ){ // (rg0>0 && table_1[rg0]==4) смотрим только "L_end"      ///if ( rg0>2 && table_1[rg0]>0 ){
          // Пересчет координат из линейных в декартовы (снижакт общее быстродействие на 20 процентрв).
          pt.y=(x+w_1)/w;   // w_1=w+1;
          pt.x=(x+w_1)%w;   // pt.status=0; // компактный вариант
          // Сохранение в структуру статуса особых точек
          pt.type=table_1[rg0];      // точки типа "Т", "Х", "L_end", P_Point кодируются соответственно 1, 2, 4, 8
          // Сохранение в структуру адресов особых точек в декартовых координатах "x", "y".
          focalPoint.push_back(pt);
        }
        /**/
        //cout<<(unsigned short)*p0;
        //cout<<" "<<(unsigned short)rg0;
      } // if
    } // x
    
    ///sizeAdr=n;
    sizeAdr=(uint)focalPoint.size();
    if (GrafT) cout<<"значение    sizeAdr="<<sizeAdr<<endl;
    /**/
    
    if (GrafT) {
      // визуализация серым фокальных линий (графем) по 8 байт одновременно. ( внутренний формат программы 255-черный, 0-белый ).
      for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=(bytes_data0_64[x]>>1)&0x7F7F7F7F7F7F7F7F; } // деление на 2 и прим. 64 р маски.
      // Черное (255) становится серым (127), блое (0) остается белым.
      // 0x7F7F7F7F7F7F7F7F  64 р маска для деление на 2, маска убирает передвинувшиеся (при сдвиге) из соседних байт разряды.
      
      // визуализация черным особых точек (фокальных точек)
      for ( n=0; n < sizeAdr; n++ ) { bytes_data[(int)(focalPoint[n].y*w+focalPoint[n].x)]=255; } // читаем из массива векторов
    }
    
    // приведение массива к общепринятому стандарту, 0-черный 255-белый ( внутренний формат программы 0-белый 255-черный ).
    // по 1 байту,  time=0.03  w_h=w*h=10 млн. пикселей
    ///for ( x=0; x < w_h; x++ ) { if (bytes_data[x]>0) bytes_data[x]=0;  else bytes_data[x]=255; }
    // по 8 байт одновременно,  time=0.005  w*h=10 млн. пикселей
    //for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data0_64[x]; }
    
    /*
     if (GrafT) {
     // визуализация серым фокальных линий (графем)
     for ( x=0; x < w_h; x++ ) { bytes_data[x]=(255+bytes_data[x])/2; } // для серого, =255 для чб
     // визуализация черным особых точек (фокальных точек)
     for ( n=0; n < sizeAdr; n++ ) { bytes_data[focalPoint[0][n]->y*w+focalPoint[0][n]->x]=0; } // читаем из массива векторов
     }
     */
    
    //TIME_PRINT_ASM
    ///TIME_PRINT_   cout<<"TIME_PRINT_   фокальных точек   focalLine"<<endl;
    
    
    
    // Возвращаем количество особых точек sizeAdr по всему графическому тексту.
    return sizeAdr;
    // Адреса фокальных точек в декартовых координат "x", "y" (short) расположенны в массиве переменной длинны focalPoint.
    // Количество адресов равно sizeAdr=focalPoint->size();.
    
    
    ///int y_;
    // пересчет координат из линейных в декартовы (снижает общее быстродействие на 20 процентрв).
    ///y_=(w_1+x)/w;  // w_1=w+1;
    ///pt.x=(w_1+x)-w*y_; pt.y=y_;  // pt.type=0;  // x+w_1
    
    /// int w_2=w+2;  int w_w=w+w;  int w_w_1=w+w+1;  int w_w_2=w+w+2;
    /// rg0=(*(p0)&1) + (*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w_2)&16) + (*(p0+w_w)&32) + (*(p0+w_w_1)&64) + (*(p0+w_w_2)&128);
    
  }//____________________________________________________________________________
}
