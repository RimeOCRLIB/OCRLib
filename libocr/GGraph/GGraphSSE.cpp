//
// Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru
// ****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
// ****************************************************************************
//
// C- This software is subject to, and may be distributed under, the
// C- GNU General Public License, either Version 2 of the license,
// C- or (at your option) any later version. The license should have
// C- accompanied the software or you may obtain a copy of the license
// C- from the Free Software Foundation at http://www.fsf.org.

#include "../OCRString/php2stl.h"
#include "GGraph.h"


namespace ocr {
    
    // Функция тестирования хеш регистра на 64 разряда. //
    // Основная рабочая версия. _12_окт_2019_
    // -----------------------------------------------------------------------------
    void GGraph::hash_register64(){
        
        // Теория //
        
        // Циклический сдвиг влево на n разрядов:
        ///rg0=(rg0<<n0) | (rg0>>n1);		// Циклический сдвиг влево (*) на n разрядов:  // x=(x<<n)|(x>>(64-n));
        ///rg0=(rg0>>n0) | (rg0<<n1);		// Циклический сдвиг вправо (/) на n разрядов: // x=(x>>n)|(x<<(64-n));
        
        // вычисление углов.
        // делим окружность на четыре квадранта.
        
        //  |  II  квадрант  |  I квадрант   |
        //  |----------------+---------------|
        //  |  III квадрант  |  IV квадрант  |
        
        // угол отсчитываем от горизонтальной оси против часовой стрелки
        
        // Генри Уоррен, мл. - Алгоритмические трюки для программистов 2014.pdf
        // 2.15. Циклический сдвиг стр 59
        // 2.17. Сдвиг двойного слова стр 62
        
        
        
        ulong rg0=0; // регистр маски.
        ulong rg1=0; // регистр проверяемого параметра.
        int s_rg=8*sizeof(ulong); // длина регистра в битах // 64
        int n0=0; // циклический сдвиг на n разрядов:
        ///int n1=s_rg-n0;
        // cout<<"s_rg="<<s_rg<<"   n0="<<n0<<endl;
        
        // rad коэффициент для перевода угла из радиан в градусы.
        float rad = 57.2958; //  rad=180.0/pi=57.2958; float pi=3.14159265;
        
        rg0=4295032834; // тест  // 4295032834
        cout<<"rg0="<<rg0<<"   n0="<<n0<<endl;
        
        
        // Изготовление эталонного хеш регистра (маски) "rg0". Области проверки получаем с помощью растискивания. //
        // НЕ забыть проверить симметричность при создании формулы растискивания.
        
        // Растискивание на 2 бита вправо и 3 бита влево, с циклическим сдвигом. 5 подряд идущих единиц.
        ///rg0=rg0 | ((rg0<<1) | (rg0>>(s_rg-1)));     // Растискивание на 1 бит влево (*).
        ///rg0=rg0 | ((rg0<<1) | (rg0>>(s_rg-1)));     // Растискивание на 2 бит влево (*).
        ///rg0=rg0 | ((rg0>>2) | (rg0<<(s_rg-2)));     // Растискивание на 3 бит вправо (/).
        
        // Растискивание на 3 бита вправо и 3 бита влево, с циклическим сдвигом. 7 подряд идущих единиц.
        ///rg0=rg0 | ((rg0<<1) | (rg0>>(s_rg-1)));     // Растискивание на 1 бит влево (*).
        ///rg0=rg0 | ((rg0<<2) | (rg0>>(s_rg-2)));     // Растискивание на 2 бит влево (*).
        ///rg0=rg0 | ((rg0>>3) | (rg0<<(s_rg-3)));     // Растискивание на 3 бит вправо (/).
        
        // Растискивание на 4 бита вправо и 4 бита влево, с циклическим сдвигом. 9 подряд идущих единиц.
        ///rg0=rg0 | ((rg0<<1) | (rg0>>(s_rg-1)));     // Растискивание на 1 бит влево (*).
        ///rg0=rg0 | ((rg0<<1) | (rg0>>(s_rg-1)));     // Растискивание на 1 бит влево (*).
        ///rg0=rg0 | ((rg0<<2) | (rg0>>(s_rg-2)));     // Растискивание на 2 бит влево (*).
        ///rg0=rg0 | ((rg0>>4) | (rg0<<(s_rg-4)));     // Растискивание на 4 бит вправо (/).
        
        // Растискивание на 5 бит вправо и 5 бит влево, с циклическим сдвигом. 11 подряд идущих единиц (или 1,1,3,5).
        rg0=rg0 | ((rg0<<1) | (rg0>>(s_rg-1)));     // Растискивание на 1 бит влево (*).
        rg0=rg0 | ((rg0<<2) | (rg0>>(s_rg-2)));     // Растискивание на 2 бит влево (*).
        rg0=rg0 | ((rg0<<2) | (rg0>>(s_rg-2)));     // Растискивание на 3 бит влево (*).
        rg0=rg0 | ((rg0>>5) | (rg0<<(s_rg-5)));     // Растискивание на 5 бит вправо (/).
        cout<<"rg0="<<rg0<<"   n0="<<n0<<endl;
        
        
        // Заполнение проверяемого хеш регистра "rg1" значениями проверяемого параметра (угла). //
        
        // тест
        ushort x0=0, y0=0;          // координаты начальной точки (звездочки).
        ushort x1=16, y1=6;         // координаты конечной точки.
        
        ushort dx=x1-x0, dy=y1-y0;  // координаты конечной точки относительно центра звездочки.
        
        
        // вычисление угла линии в градусах.
        // цикл по количеству фокальных линий в звездочке.
        //for (int index=0; index < 256; index++){
        float alpha = rad * atan2f((float)dy, (float)dx); // стандартная область определнеия atan2f  -pi<=atan2f<=pi (f-float)
        // получение области определнеия atan2f от 0 до 360 градусов (от 0 до 2*pi).
        if (alpha < 0) alpha += 360.0; // переопределение atan2f для отрицательных углов  pi<=atan2f+2*pi<=2*pi
        ///star.mA[i] = (ushort)mAf;
        
        int rg1_alpha=(int)(alpha*s_rg/360.0);
        rg1=rg1 | (1<<rg1_alpha);
        cout<<"alpha="<<alpha<<"   rg1_alpha="<<rg1_alpha<<"   rg1="<<rg1<<endl;
        //} // окончание цикла по количеству фокальных линий в звездочке.
        
        
        
        
    } //____________________________________________________________________________
    
    
    // Функция тестирования хеш регистра на 128 разрядов. //
    // Основная рабочая. _16_окт_2019_
    // -----------------------------------------------------------------------------
    void GGraph::hash_register128(){
        
        // Теория //
        
        // Циклический сдвиг одного 64 разрного регистра на n разрядов. //
        // y=(x<<n)|(x>>(64-n));		// Циклический сдвиг влево (*) на n разрядов:
        // y=(x>>n)|(x<<(64-n));		// Циклический сдвиг вправо (/) на n разрядов:
        
        // Сдвиг двух 64 разрядных регистров как одного 128 разрядого регистра на n разрядов влево с переходом через стык.
        // y2=(x2<<n)|(x1>>(64-n))|(x1<<(n-64)); // Если известно, что 0<=n<=64 , то последний член в первом присваивании можно опустить,
        // y1=x1<<n;
        
        // Сдвиг двух 64 разрядных регистров как одного 128 разрядого регистра на n разрядов вправо с переходом через стык.
        // y1=(x1>>n)|(x2<<(64-n))|(x2>>(n-64)); // Если известно, что 0<=n<=64 , то последний член в первом присваивании можно опустить,
        // y2=x2>>n;
        
        
        // Генри Уоррен, мл. - Алгоритмические трюки для программистов 2014.pdf
        // 2.15. Циклический сдвиг стр 59
        // 2.17. Сдвиг двойного слова стр 62
        
        
        //ulong s1=0;     // первый 64 разрядный регистр проверяемого параметра. Search
        //ulong s2=0;     // второй 64 разрядный регистр проверяемого параметра. Search
        ulong m1=0;     // первый 64 разрядный регистр маски. Mask
        ulong m2=0;     // второй 64 разрядный регистр маски. Mask
        ulong yy1=0, yy2=0; // вспомогательные регистры
        int s_rg=8*sizeof(ulong);       // длина регистра в битах. // 64
        int n=1;            // величина циклического сдвига в битах.
        if (n>64)n=64;   if (n<0)n=0;   // ограничения на величину циклического сдвига.
        //int ns=s_rg-n;
        cout<<"s_rg="<<s_rg<<"   n="<<n<<endl;
        
        //m0=9223372041149743105; // тест  // 4295032834
        cout<<"m1="<<m1<<"   n="<<n<<endl;
        
        //*
        // Тест //
        //63                             m1                                  0
        m1=0b0000000000000000000000000000010000000000000000000000000000000001;
        m2=0b0000000000000000000000000000010000000000000000000000000000000001;
        //128                            m2                                  64
        // в отладчике ровно такое же расположение бит и также совпадает направления сдвига, соответствеено влево и вправо.
        
        // Работающий код //
        
        // Сдвиг двух 64 разрядных регистров как одного 128 разрядого регистра на n разрядов с переходом через стык. //
        
        // Сдвиг влево регистров m1 и m2 с переносом через стык,  left (<< *)
        ///yy1=m1<<n; // обычный сдвиг первого регистра m1.
        ///yy2=(m2<<n)|(m1>>(64-n)); // сдвиг окончания первого регистра m1 в начало m2 с переходом через стык двух регистров.
        
        // Сдвиг вправо регистров m1 и m2 с переносом через стык, right (>> /)
        ///yy1=(m1>>n)|(m2<<(64-n)); // сдвиг начала второго регистра m2 в окончание m1 с переходом через стык двух регистров.
        ///yy2=m2>>n;  // обычный сдвиг второго регистра m2.
        
        
        // Циклический сдвиг двух 64 разрядных регистров как одного 128 разрядого регистра на n разрядов с переходом через стык. //
        
        // Циклический сдвиг влево регистров m1 и m2 с переносом через стык,  left (<< *).
        ///yy1=(m1<<n)|(m2>>(64-n));  // Циклический сдвиг окончания регистра m2 в начало регистра m1.
        ///yy2=(m2<<n)|(m1>>(64-n));  // сдвиг окончания первого регистра m1 в начало m2 с переходом через стык двух регистров.
        
        // Циклический сдвиг вправо регистров m1 и m2 с переносом через стык, right (>> /)
        ///yy1=(m1>>n)|(m2<<(64-n)); // сдвиг начала второго регистра m2 в окончание m1 с переходом через стык двух регистров.
        ///yy2=(m2>>n)|(m1<<(64-n));  // Циклический сдвиг начала регистра m1 в окончание регистра m2.
        //*/
        
        
        
        // Изготовление эталонных хеш регистров (маски) "m1" и "m2". Области проверки получаем с помощью растискивания. //
        
        // Растискивание на 3 бита вправо и 3 бита влево, с циклическим сдвигом. 7 подряд идущих единиц. //
        
        // Циклический сдвиг влево регистров m1 и m2 с переносом через стык,  left (<< *).
        // Растискивание на 1 бит влево (*). Растискивание это оператор m1 | ().
        m1=m1 | (m1<<1) | (m2>>(s_rg-1));  // Циклический сдвиг окончания регистра m2 в начало регистра m1. (m1<<1) | (m2>>(s_rg-1)).
        m2=m2 | (m2<<1) | (m1>>(s_rg-1));  // Сдвиг окончания первого регистра m1 в начало m2 с переходом через стык двух регистров.
        // Растискивание на 2 бит влево (*).
        m1=m1 | (m1<<2) | (m2>>(s_rg-2));
        m2=m2 | (m2<<2) | (m1>>(s_rg-2));
        // Циклический сдвиг вправо регистров m1 и m2 с переносом через стык, right (>> /).
        // Растискивание на 3 бит вправо (/). Растискивание это оператор m1 | ().
        m1=m1 | (m1>>3) | (m2<<(s_rg-3));  // Сдвиг начала второго регистра m2 в окончание m1 с переходом через стык двух регистров.
        m2=m2 | (m2>>3) | (m1<<(s_rg-3));  // Циклический сдвиг начала регистра m1 в окончание регистра m2. (m2>>3) | (m1<<(s_rg-3)).
        // в "m1" и "m2" получилось 7 подряд идущих единиц, в центре находится исходная единица.
        
        
        binaryPrint64(m1, 2); // вывод двух 32 разрядных слов
        
        cout<<"yy1="<<yy1<<"   yy2="<<yy2<<endl;
        
        
    } //____________________________________________________________________________
    
    
} // namespace ocr



//____________________________________________________________________________
//____________________________________________________________________________

//for(int n=pIndex+s; n<line_lenA+pIndex-s; n++){
// Прямое сглаживание скользящей трехточкой координат фокальных линий (кроме концов).
///             px[n] = (px[n-3] + px[n-2] + px[n-1] + px[n] + px[n+1] + px[n+2] + px[n+3])/s2; // -3
///             py[n] = (py[n-3] + py[n-2] + py[n-1] + py[n] + py[n+1] + py[n+2] + py[n+3])/s2;
//for(int n=pIndex; n<line_lenA+pIndex-s2; n++){
//px[n+3] = (px[n] + px[n+1] + px[n+2] + px[n+3] + px[n+4] + px[n+5] + px[n+6])/s2;
//py[n+3] = (py[n] + py[n+1] + py[n+2] + py[n+3] + py[n+4] + py[n+5] + py[n+6])/s2;

///for(int n=line_lenA+pIndex-s-1; n>pIndex+s; n--){ // n<pIndex+s+1;
// Реверсивное сглаживание скользящей трехточкой координат фокальных линий (кроме концов).
// Компенсирует фазовые сдвиги.
//            px[n+3] = (px[n-3] + px[n-2] + px[n-1] + px[n] + px[n+1] + px[n+2] + px[n+3])/s2; // +3
//            py[n+3] = (py[n-3] + py[n-2] + py[n-1] + py[n] + py[n+1] + py[n+2] + py[n+3])/s2;
//for(int n=line_lenA+pIndex-1; n>pIndex+s2; n--){
//px[n] = (px[n] + px[n-1] + px[n-2] + px[n-3] + px[n-4] + px[n-5] + px[n-6])/s2; // -3
//py[n] = (py[n] + py[n-1] + py[n-2] + py[n-3] + py[n-4] + py[n-5] + py[n-6])/s2;
//cout<<"n="<<n<<endl;
///} // int n=0

/*
 // прямоугольная весовая функция
 // y(n)= y(n-1)+x(n)-x(n-2k-1)
 // треугольная весовая функция
 // y(n)= -y(n-2)+2y(n-1)+x(n-2k-2)-2x(n-k-1)+x(n)
 
 // сглаживание Безье (квадратичной кривой):
 for (var j=0, m=4; j<m; j++)
 for (var i=1, l=a.length-1; i<l; i++)
 a[i] = 0.5*(0.5*(a[i-1]+a[i+1]) + a[i]);
 https://ru.stackoverflow.com/questions/323753/Аппроксимация-кривой-сглаживание-шума-и-пиков-в-числовом-ряду
 http://www.cyberforum.ru/geometry/thread2186974.html
 //*/

//_____________

/*      // интринсики intrinsics. НЕ рабочая версия //
 
 // константы для алгоритма подсчета единиц в 128 или в 64р словах
 static const ulong constF[2]={              // 0b
 //63                                                                    0
 0b1100000000000000000000000000000000000000000000000000000000000000,
 0b0000000000000000000000000000000000000000000000000000000000000000
 //128                                                                   64
 //0x0f0f0f0f0f0f0f0f, 0x0f0f0f0f0f0f0f0f  // ,
 };
 
 int s_rg=8*sizeof(__m128i);     // длина регистра в битах.
 
 __m128i *p=(__m128i*)constF;  // приведение
 /// __m128 m0 = _mm_load_ps(mat[0]);
 __m128i rg_0 = _mm_load_si128 (p); // __m128i _mm_load_si128 (__m128i *p)
 __m128i rg_1, rg_2;
 //rg_0 = _mm_stream_load_si128 (p); // __m128i _mm_stream_load_si128 (__m128i* v1)
 
 int count=32; // __m128i a;
 
 // Циклический сдвиг влево на n разрядов:
 // сдвигает в только в пределах 64 бит, нет переноса.
 rg_1 =_mm_slli_epi64 (rg_0, count);     // << left  влево   // __m128i _mm_slli_epi64 (__m128i a, int count)
 const int q=4;
 // сдвигает по всем 128 битам, но только с шагом по 8 и шаг не может быть переменной.
 ////rg_1 =_mm_slli_si128 (rg_0, q);  // __m128i _mm_slli_si128 (__m128i a, int imm)
 
 //rg_2 =_mm_srli_si128 (rg_0, count);	// __m128i _mm_srli_si128 (__m128i a, int imm)  // psrld // right
 ///rg_2 =_mm_srli_epi64 (rg_0, (s_rg-count));     // >> right  вправо // __m128i _mm_srli_epi64 (__m128i a, int count)
 ///rg_2 =_mm_srli_si128 (rg_0, 1);
 
 //const int  cc=s_rg-count;
 
 const int cc=4;
 ////rg_2 =_mm_srli_si128 (rg_0, cc);
 
 
 ///       rg_2 =_mm_or_pd (rg_1, rg_2); // Оператор логического ИЛИ Logical OR operator |
 
 //rg_1 =_mm_xor_si128 (_mm_slli_epi64 (rg_0, count), _mm_srli_epi64 (rg_0, (s_rg-count)));
 
 ///rg_1 =_mm_xor_si128 (rg_0, rg_1);
 
 cout<<"cc="<<cc<<"   n0="<<n0<<endl;
 
 //*/




