//@_____________//GGraphFindExtremPoints.cpp
// Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru
// ****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
// ****************************************************************************
//
// C- This software is subject to, and may be distributed under, the
// C- GNU General Public License, either Version 2 of the license,
// C- or (at your option) any later version. The license should have
// C- accompanied the software or you may obtain a copy of the license
// C- from the Free Software Foundation at http://www.fsf.org.

#include "GGraph.h"

namespace ocr
{

    
// Функция выделения точек перегиба и максимумов (экстремумов) сглаженной фокальной линии по углам //
// Основная рабочая версия. Использует измерительные вектора разной длинны, в середине фокальной линии больше чем на концах.
// _4_ноября-27_дек_2019_.
// -----------------------------------------------------------------------------
void GGraph::findExtremAlpha(){
    
    /** @bref
     Вычисление функции зависимости угла Alpha от координат точек сглаженной фокальной линии.
     Предварительно сглаживаем двумерную фокальную линию с помощью функции сглаживания фокальной линии focalLineMid().
     Вычисляем координаты концов векторов (не имеющих общей точки) скользящих по сглаженной фокальной линии.
     По стандартному скалярному произведению векторов вычисляем угол между векторами, который является вторай
     производной. Угол  Alpha получаем значених косинуса и в градусах. Проверяем угол, а еще лучше значения
     косинуса, по лимиту. Лимит угла составляет примерно 120 градусов.
     // Нахождение угла между векторами с помощью векторного произведения
     // vec a*b=ax*by - ay*bx
     // http://www.cyberforum.ru/pascal/thread1589027.html
     Измерительные вектора разной длинны, в середине фокальной линии больше чем на концах.
     Половина длинны одного из измерительных векторов в начале фокальной линии "k"=2, в середине "k"=5-6.
     Официальный термин "k"  кривизна,
     //Лимит угла делаем адаптивным и считаем как процент от среднего угла по всей фокальной линии,
     //как в функции адаптивного порога по яркости?
     
     Вычисление точек перегиба.
     Точки перегиба вычисляем по одномерному графику функции зависимости угла Alpha от длинны сглаженной фокальной линии.
     Локальные максимумы одномерного графика угла Alpha являются точками перегиба двумерной фокальной линии.
     Говорят, что функция  f(x) имеет локальный максимум в точке, если f(x)<=f(x0) для всех значений "x" в некоторой окрестности точки.
     Это означает, что функция f(x):
     - является возрастающей для значений "x", расположенных в непосредственной близости к точке локального максимума слева от нее.
     - является убывающей для значений  "x", достаточно близких к этой точке и расположенных справа.
     если x<x0, то f(x)<=f(x0).
     если x>x0, то f(x)<=f(x0).
     http://portal.tpu.ru:7777/SHARED/k/KONVAL/Sites/Russian_sites/Calc1-ru/5/02.htm
     
     // ТЕОРИЯ //
     если в некотором промежутке f’’(x) > 0, то кривая выпукла вниз на этом промежутке; если же f’’(x) < 0,
     то кривая выпукла вверх на этом промежутке.
     https://math.semestr.ru/math/inflection.php
     Точкой перегиба графика функции y=f(x) называется точка M(x1;f(x1)), разделяющая промежутки выпуклости и вогнутости.
     https://www.webmath.ru/poleznoe/formules_8_24.php
     http://nuclphys.sinp.msu.ru/mathan/p1/m1503.html
     
     Вычисление точек максимума.
     Точки максимума также вычисляем по одномерному графику функции зависимости угла Alpha от длинны сглаженной фокальной линии.
     Находим все точки меньше лимита угла по одномерному графику. Среди этих точек находим непрерывные блоки.
     Вычисляем количество точек непрерывных блоков попавших лимит угла и в каждом находим его середину.
     Вычисление координат середины непрерывного блока точек попавших в лимит угла и есть вычисление точек максимума.
     
     // РАЗВИТИЕ //
     Алгоритмы для существенно рукописных текстов:
     
     Кривизна (точка фокуса) сглаженной фокальной линии позволит рассматривать кривую как точку (круг) или несколько точек,
     в зависимости от характера кривой, (см. табличку ниже). Такой подход не чувствителен к скусыванию-раскусыванию и
     его применение отработано на примере круге (центр круга это центр масс).
     Фактически это апроксимация кривой частью круга - дугой. Радиус круга величина обратная кривизне и может иметь знак.
     Средний радиус части круга (кривизна) функционально эквивалентен длинне прямого луча и может использоватся при подсчете
     масштаба звездочки.
     Если часть сглаженной фокальной линии по форме близка к прямой, то ее среднея кривизна близка к нулю.
     Если часть сглаженной фокальной линии по форме близка к дуге, то ее среднея кривизна отлична от нуля и обладает знаком.
     
     Средний радиус (кривизна) не чувствителен не только к скусыванию-раскусыванию, но и к длинне отсечки - части круга.
     Сейчас величина отсечки берется от толщины штриха. По короткой части фокальной линии, полученной с помощью отсечки,
     вычисляется кривизна. Исходная фокальная линия обрезается еще раз, но уже по длинне численно равной радиусу (кривизне?).
     Радиус также как и остальные прямые лучи звездочки является носителем масштаба и помогает его вычислению.
     //Т.о. удалось свести все фокальные линии звездочки к прямым лучам без потери формы кривых.
     
     Полярные координаты.
     Аналогичный результат может дать применение полярных координат.
     По оси "X" откладываем sin(Alpha), по оси "Y" cos(Alpha). В зависимости от характера кривой получаем:
     - точку на оси "X" это прямая.
     - точку на плоскости "X" "Y" это круг.
     - короткую прямую на плоскости "X" "Y" это спираль.
     - и т.д.
     Алгоритм можно применять многократно (итерациями) все время понижая мерность пространства.
     
     // ЗАГОТОВКА //
     // Написать выкусывание одиночных черных и белых точек при помощи матриц.
     // алгоритм дискретной интерполяции точек на плоскости псевдоспиралями формы  r=a*S, где r – радиус кривини, S – длина кривой.
     
     */
    
    
    ///TIME_START
    
    int GrafT=0;
    // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    DG("// Функция выделения плавных экстремумов сглаженной фокальной линии по углам"<<endl);
    
    
    // пользовательские ПАРАМЕТРЫ поиска экстремуиов  //
    
    ///////////////////
    // Лимит угла в градусах для поиска точек ПЕРЕГИБА.
    ///float lim_AlphaExt=120.0f; // 180.0-40.0 // назначаемый лимит угла в градусах -180<=lim_Alpha<=180.
    // Вычисление лимита угла в значениях косинуса.
    ///float lim_cosAlphaExt=cos(lim_AlphaExt/57.29747f); // -1<=lim_cosAlpha<=1.
    
    
    ///////////////////
    // Лимит угла в градусах для поиска точек МАКСИМУМА. Больше лимит - больше точек максимума.
    float lim_AlphaMax=90.0f; // 130.0; назначаемый лимит угла в градусах -180<=lim_Alpha<=180. //было 110.0f;
    // Вычисление лимита угла в значениях косинуса.
    float lim_cosAlphaMax=cos(lim_AlphaMax/57.29747f); // -1<=lim_cosAlpha<=1.
    // лимит угла делаем адаптивным и считаем как процент от среднего угла по всей фокальной линии,
    // как в функции адаптивного порога по яркости?
    
    // Коэффициент ОГРАНИЧЕНИЯ области поиска точек МАКСИМУМА factor_lineW.
    // Коэффициент ограничения больше  - больше начальный и конечный участок блокировки точек максимума.
    // Точки максимумы ищем по всей кривой, но учитываем только не попадающие на начальные и конечные участки.
    // Длинна начального и конечного участков прямо пропорциональна толщине штриха.
    float factor_lineW=1.0f; //1.7f // 8*1.5f блокирует нахождение точек максимума по всем кривым короче 24pix.
    ///////////////////.
    
    uint size=(uint)focalLine.size(); // количество фокальных линий на странице или ID номеров.
    DG("Количество фокальных линий на странице size="<<size<<endl);
    
    float *px=coord_fx, *py=coord_fy; // указатели на сглаженные массивы координат по "x" и "y"
    //float *pA=alpha_fl; // указатель на массив углов вдоль фокальной линии (вторая производная).
    
    // цикл перебора фокальных ЛИНИЙ на странице.
    for(int m=0; m<size; m++){ // size
        
        OCRLine &line=focalLine[m];
        
        //GrafT = 0; if(line.index == 1){GrafT = 1;}	
        DG(endl<<"цикл по количеству фокальных линий в букве  m="<<m<<endl);
        
        uchar &eCount=line.extremCount;
        eCount=0;
        int pIndex=line.pointIndex;
        OCRPoint *lineData = (OCRPoint *)&pointArray[line.pointIndex];  //используется для записи результата
        
        
        //if(GrafT)
        //	for(int c=pIndex;c<pIndex+line.lenA;c++)DG("////_________x_y:"<<px[c]<<"_"<<py[c]<<endl;)
        
        
        // длинна фокальной линии буквы.
        ushort line_lenA=line.lenA;
        if ( line_lenA==0) continue;
        if ( line_lenA>255) line_lenA=255;
        //DG("   pIndex="<<pIndex<<"   line_lenA="<<line_lenA<<endl);
        
        // Вычисляемые параметры "kMax", "w" вычисляются от длинны фокальной линии и являются слабой функцией длинны.
        
        // Параметры вычисления углов Alpha вдоль фокальной линии.
        // "k" половина длинны одного из векторов лежащих на фокальной линии, k=3 тест.
        // Фиксированное минимальное стартовое значение параметра "k=kMin" в начале и в конце фокальной линии.
        int kMin=2;
        // Макимальное значение "kMax" параметра "k" в середине фокальной линии как функция от длинны фокальной линии.
    //    int kMax=(int)sqrt((float)(line_lenA)/3.0f); // Эмпирическая формула.  // 4.0f
        // Макимальное значение "kMax" параметра "k" в середине фокальной линии как функция от толщины фокальной линии.
        int kMax=line.lineW*0.75f; // Эмпирическая формула.
        DG("   line.lineW="<<line.lineW<<endl);    
    
        // Ограничения на "kMax", kMax от 2 до 6.
        if ( kMax<2 ) kMax=2;   if ( kMax>32 ) kMax=32;		// 32 техническое не содержательное ограничение //if ( kMax>6 ) kMax=6;
        DG("   kMin="<<kMin<<"   kMax="<<kMax<<endl);
        /// kMax=6; // ТЕСТ
        
        // Вычисление области поиска точек максимума в pix в зависимости от толщины фокальной линии (штриха).
        // Точки максимума ищем по всей кривой, кроме начального и конечного участков длинной по protect_n.
        // Начальные и конечные участки короткой кривой могут смыкаться, блокируя нахождение точек по всей кривой.
        int protect_n=line.lineW * factor_lineW; // line.lineW толщина штриха.
        // ограничения на "protect_n" в pix.
        if ( protect_n<0 ) protect_n=0;   if ( protect_n>line_lenA/2 ) protect_n=line_lenA/2;
        ///protect_n=0; // ТЕСТ
        DG("   factor_lineW="<<factor_lineW<<"   protect_n="<<protect_n<<"   max line_lenA/2="<<line_lenA/2<<endl);
        
        /*
         // Параметры вычисления точек перегиба. "Ширина" области поиска максимума т.е,
         // окрестности +-w, по которым происходит вычисление точек перегиба.
         // Чем меньне "w" тем более локальные максимумы находит алгоритм.
         int w=(int)sqrt((float)(line_lenA)/8.0f); // Эмпирическая формула.
         ///w=3; // ТЕСТ
         // ограничения "w".
         if ( w<1 ) w=1;   if ( w>3 ) w=3;
         //DG("   w="<<w<<endl);
         
         // Переменные для вычисление координат точек плавных перегибов по углу.
         uint flag0=0, flag1=0;     // флаг, задает последовательность работы алгоритма.
         int n0=0;                  // длинна непрерывного возрастающего блока.
         int n1=0;                  // длинна непрерывного убыввающего блока.
         int n0_old=0, n1_old=0;    // предидущие значения длинн непрерывных блоков.
         //// n=0;          // расстояние от начала данной фокальной линии до текущей точки.
         int nn=0;          // расстояние от начала данной фокальной линии до текущей точки с учетом лимита угла.
         int n_max=0;       // расстояние от начала данной фокальной линии до точки перегиба.
         ushort alp_max=0;  // значение угла alp в точке перегиба, соответствующий n_max-1.
         ushort alp_old=0;  // предидущее значение угла   alp=(ushort)(10*Alpha);
         //*/
        
        // Переменные для вычисление координат плавных точек максимума.
        int n_sum=0; // сумма расстояний от точек непрерывного блока попавших лимит угла, до начала фокальной линии.
        int q=0;     // длинна непрерывного блока точек попавших лимит угла.
        int n_extr=0;  // расстояние от начала данной фокальной линии до точки экстремума n_extr=n_sum/q;
        
        // Переменные для вычисления уголов Alpha вдоль фокальной линии.
        int nn=0;    // расстояние от начала данной фокальной линии до текущей точки с учетом лимита угла.
        int k=kMin;  // половина длинны одного из измерительных векторов лежащих на фокальной линии. Стартовое значение.
        int kMin3=kMin*3;
        //int k2=k*2;    // длинна одного измерительного вектора лежащего на фокальной линии. Стартовое значение.
        int k3=k*3;      // k2+k+1 полторы длинны измерительного вектора. Стартовое значение.
        int k3_start=k3; // шаг или скорость увеличения (уменьшения) длинны изм. вектора от стартового значения k=2 до k=kMax.
        
        int pIndex1=pIndex+k3+1;           // начало области вычисления уголов Alpha
        int pIndex2=pIndex+line_lenA-k3 ;  // -1 // окончание области вычисления уголов Alpha
        int lenA_k6=pIndex2-pIndex1;       // -0 область вычисления (существования) уголов Alpha фокальной линии.
        DG("   pIndex="<<pIndex<<"   pIndex1="<<pIndex1<<"   pIndex2="<<pIndex2<<"   lenA_k6="<<lenA_k6<<endl);
        
        int n_s=(kMax-kMin)*k3; // величина участка увеличения (уменьшения) длинны измерительного вектора. // ns=(kMax-2)*6;
        if ( n_s>lenA_k6/2 ) n_s=lenA_k6/2;
        int ns=n_s;            // переменная участка увеличения (уменьшения) длинны измерительного вектора.
        DG("   k=kMin="<<k<<"   line_lenA="<<line_lenA<<"   ns="<<ns<<"   k3_start="<<k3_start<<endl);
        // цикл перебора ТОЧЕК фокальных линий на странице.
        DG("////___________pIndex1:"<<pIndex1 - pIndex <<" pIndex2:"<<pIndex2 - pIndex<<endl;)
        for(int n=pIndex1; n<pIndex2; n++){ // pIndex2+1
            
            //*
            // Вычисление возрастающей длинны измерительных векторов в начале фокальной линии, постоянной в середине и убывающей в конце. //
            
            // Вычисление возрастающей длинны измерительных векторов "k" от стартового значения kMin=2 до kMax=5.
            if ( nn<=n_s ){ // в начале фокальной линии.
                k3=nn*3/k3_start + kMin3; // половина расстояния между дальними концами векторов вдоль кривой k3=6,6,7,7,...15,...7,7,6,6
                //k=k3/3; // половина расстояния между ближайшими концами векторов вдоль кривой, оставляем фиксированным, например k=kMin=2;
            }
            // Макимальное значение параметров "k", "k2", "k3" находятся в середине фокальной линии.
            
            // Вычисление убывающей длинны измерительных векторов "k" от максимального значения kMax=5 до стартового kMin=2.
            if ( nn>=lenA_k6-n_s ){ // в конце фокальной линии.         // 6 шаг=Min*3,  kMax-2=3, ns=6*3=18 // kMax=5
                k3=ns*3/k3_start + kMin3;
                //k=k3/3;
                //DG("#   n="<<n<<"   nn="<<nn<<"   ns="<<ns<<"   k3/3="<<k3/3<<"   k3="<<k3<<endl);
                ns--;
            }
            //*/
            DG("   n="<<n<<"   nn="<<nn<<"   ns="<<ns<<"   k3/3="<<k3/3<<"   k3="<<k3<<endl);
            nn++;
            // Не большие ступеньки
            
            
            // Вычисление  cosAlpha между векторами. //
            
            // координаты отсчитанны от точки "n" фокальной линии лежащей на расстоянии "k"
            // от конца первого вектора и начала второго вектора.
            ///float x1=px[n-k],      y1=py[n-k];     // координаты начала первого вектора    -k.
            ///float x2=px[n-k2-k],   y2=py[n-k2-k];  // координаты конца первого вектора     -k2-k=-k21.
            ///float x3=px[n+k],      y3=py[n+k];     // координаты начала второго вектора    +k.
            ///float x4=px[n+k2+k],   y4=py[n+k2+k];  // координаты конца второго вектора     +k2+k=+k21.
            
            ///float dx1=x2-x1;  float dy1=y2-y1;     // длинна первого вектора по оси "x" и сответственно по "y"
            ///float dx2=x4-x3;  float dy2=y4-y3;     // длинна второго вектора по оси "x" и сответственно по "y"
            //////
            
            // для получения острого угла для ровных фокальных линий поворачиваем первый вектор на 180 градусов,
            // для этого меняем местами начало и конец вектора т.е. меняем знаки dx1=-dx1;  dy1=-dy1;
            
            // длинна первого и второго вектора по оси "x"
            //float dx1=px[n-k2-k] - px[n-k];    float dx2=px[n+k2+k] - px[n+k];
            float dx1= - px[n-k3] + px[n-k];    float dx2= - px[n+k] + px[n+k3];
            
            // длинна первого и второго вектора по оси "y"
            ///float dy1=py[n-k2-k] - py[n-k];    float dy2=py[n+k2+k] - py[n+k];
            float dy1= - py[n-k3] + py[n-k];    float dy2= - py[n+k] + py[n+k3];
            
            
            
            // Вычисление модулей векторов по Теореме Пифагора (м.б. уже вычисленно).
            ///float mod=sqrt((dx1*dx1 + dy1*dy1) * (dx2*dx2 + dy2*dy2)); //+++
            //float mod2=sqrt(dx2*dx2 + dy2*dy2);
            
            // для вычисления координат точек плавных максимумов.
            // скалярное произведение векторов:
            ///float scalar_v = dx1*dx2 + dy1*dy2;
            
            // cosAlpha между векторами:
            ///float cosAlpha=scalar_v/mod;      // -1<=cosAlpha<=1
            
            // для вычисления координат точек перегиба.
            // векторное произведение векторов:
            ///float vector_v = dx1*dy2 - dy1*dx2; // vec a*b=ax*by - ay*bx
            
            // sinAlpha между векторами:
            ///float sinAlpha=vector_v/mod;      // -1<=sinAlpha<=1
            
            // cosAlpha между векторами в компактном виде.
            // Где Alpha угол между векторами с концами "x1, y1" - "x2, y2" и "x3, y3" - "x4, y4"  не имеющих общей точки "x0, y0"
            ///float cosAlpha = (dx1*dx2 + dy1*dy2)/(sqrt(dx1*dx1 + dy1*dy1) * sqrt(dx2*dx2 + dy2*dy2));
            float cosAlpha = (dx1*dx2 + dy1*dy2)/sqrt((dx1*dx1 + dy1*dy1) * (dx2*dx2 + dy2*dy2));
            if( cosAlpha<-0.9999f ) cosAlpha=-0.9999f;  // практически м.б. cosAlpha=-1.000023f, тогда acos не определен т.е. nan.
            ////float Alpha=57.29747f*acos(cosAlpha);    // -180<=lim_Alpha<=180.  // -pi<=cos(arccos(x))<=pi при -1<=x<=1  3.14159265
            // Для восстановления тупого угла для ровных фокальных линий.
            ////Alpha=180.0f-Alpha;
            
            ///float Alpha=57.29747f*asin(sinAlpha);    // -180<=lim_Alpha<=180. 
            ////DG("#n="<<n<<"   Alpha1="<<Alpha<<endl);///////////////////////////////
            
            // ТЕСТ //
            // Заполнение массива координат углов вдоль фокальной линии (вторая производная).
            // Необходимо только для рисования (визуализации) аналогового графика alpha_fl[n].
            ////alpha_fl[n]=Alpha; ////////////////////////////////
            //float Alpha=-180.0f*cosAlpha;
            
            DG("Alpha2="<<180.0f-57.29747f*acos(cosAlpha)<<endl);
            
            //------------------------------------------------------------------------------------------------------
            
            /*
             // Вычисление координат точек плавных перегибов //
             // Точки перегиба вычисляем по одномерному графику зависимости угла Alpha от длинны сглаженной фокальной линии.
             // Надо доделать параметр управления выделением точек перегиба //
             
             if( -cosAlpha < lim_cosAlphaExt) {
             
             // Приведение координат углов float к целочисленному значению ushort 0<=alp<=1800.
             // Соседние значения углов должны отличаться не менее чем на десятые доли градуса.
             // Чем меньше коэффициент, тем грубее отсчеты и грубее выделяются перегибы
             // ushort alp=(ushort)Alpha; //
             ushort alp=(ushort)(2.0f*Alpha);
             
             // Вычисление локальных максимумумов функции угла Alpha от длинны фокальной линии f(x)<=f(x0).
             // Локальные максимумы одномерного графика угла Alpha являются точками перегиба двумерной фокальной линии.
             // Функция f(x) является возрастающей для значений "x", расположенных в непосредственной близости к точке
             // локального максимума "x0" слева от нее.
             if( alp_old<alp ) { n0++; }  else { n0=0; } // непрерывные блоки возрастания длинной "n0".
             // Фиксация окончания непрерывно возрастающего блока n0_old>n0, который заканчивается максимумом alp_max=alp_old.
             if( n0_old>w && n0_old>n0 ){ flag0=nn; n_max=n-1; alp_max=alp_old; } //else { flag0=0; }
             
             // Функция f(x) является убывающей для значений "x", достаточно близких к точке "x0" и расположенных справа.
             if( alp_old>alp ) { n1++; }  else { n1=0; } // непрерывные блоки убыввания длинной "n1"
             // Фиксация окончания непрерывно убыввающего блока n1_old>n1.
             if( n1_old>w && n1_old>n1 ){ flag1=nn-n1_old; } else { flag1=0; }
             // блоки д.б. не менее "w",  n0_old>w и n1_old>w.
             
             DG("   n="<<n<<"   nn="<<nn<<"  alp="<<alp<<"   n0="<<n0<<"   flag0="<<flag0<<"   n1="<<n1<<"   flag1="<<flag1<<endl);
             
             // Вычисление точек перегиба сглаженной фокальной линии по углам.
             // Если flag0 или flag1 больше ноля, то формирмируем непрерывные блоки возрастания и убывания. Если адрес
             // конца возрастающего блока flag0=nn, совпадает со смещенным адресом убывающего блока flag1=(nn-n1_old),
             // ну и максимум почти равен 180 градусам. То тогда проверяемая точка является точкой перегиба.
             if( (flag0|flag1)>0 && flag0==flag1 && alp_max>176) {
             //if( (flag0|flag1)>0 && flag0==flag1 && alpha_fl[n_max]>176.0 ) {
             DG("# Точка перегиба <P> типа, n_max-1="<<n_max<<"   alp_max="<<alp_max<<"   n="<<n<<endl);
             //DG("# Точка перегиба <P> типа, n_max-1="<<n_max<<"   alp_max="<<alp_max<<"   n="<<n<<"   alpha_fl[n_max]="<<alpha_fl[n_max]<<endl);
             // создаем точку экстремума - точку перегиба.
             line.extrem[eCount]=n_max-pIndex; //-pIndex, точка экстремума "max_n" должна отсчитываться от начала данной фокальной линии.
             lineData[n_max-pIndex].type=I_POINT;
             eCount++; // подсчет количества точек экстремума.
             if(eCount>MAX_EXTREM)break;
             flag0=0;
             }
             nn++;
             n0_old=n0;
             n1_old=n1;
             alp_old=alp;
             
             } // if( cosAlpha < lim_cosAlphaExt)
             //*/
            
            //------------------------------------------------------------------------------------------------------
            
            // Вычисление координат точек плавных максимумов //
            
            //*
            // Вычисление плавных максимумов (экстремумов) сглаженной фокальной линии по углам.
            // Проверка лимита угла в значениях косинуса ( не нужно вычислять float Alpha=57.29747*acos(cosAlpha); )
            // Для восстановления тупого угла для ровных фокальных линий меням знак cosAlpha (-cosAlpha).
            if(-cosAlpha > lim_cosAlphaMax ) { // >, угол больше, а косинус угла меньше. Для острого угла.
                ///if(cosAlpha > lim_cosAlphaMax ) { // >, угол больше, а косинус угла меньше. Для тупого угла.
            ////if( Alpha < lim_AlphaMax) { // lim_AlphaMax // 125.0
                // Вычисление суммы расстояний от всех точек непрерывного блока, до начала фокальной линии.
                n_sum+=n-pIndex;  // -pIndex, точка экстремума "n_sum" должна отсчитываться от начала данной фокальной линии.
                q++;              // количество точек непрерывного блока попавших лимит угла.
                DG("#n="<<n<<"   q="<<q<<"   n_sum="<<n_sum<<"   n_extr="<<n_extr<<"   Alpha2="<<180.0f-57.29747f*acos(cosAlpha)<<endl);
            }  else {
                if(q>2) { // минимальное количество точек лежащих ниже порога, по которым создаются точки экстремума.
                    // Вычисление координат середины непрерывного блока точек попавших в лимит угла.
                    n_extr=n_sum/q; // расстояние от начала данной фокальной линии до точки экстремума.
                    // Исключение из области поиска точек максимума начального и конечного участка фокальной линии.
                    if(protect_n<n_extr & n_extr<(line_lenA-protect_n)) {
                        // создаем точку экстремума - максимум.
                        line.extrem[eCount]=n_extr;
                        lineData[n_extr].type=E_POINT;
                        eCount++; // подсчет количества точек экстремума.
                        if(eCount>=MAX_EXTREM)break;
                        DG("Точка <P> типа - максимум, n="<<n<<"   n_extr="<<n_extr<<"   q="<<q<<endl);
                        /////////DG("n="<<n<<"   n_extr="<<n_extr<<"   Alpha="<<57.29747*acos(cosAlpha)<<endl);
                    }
                } // if(q>0)
                n_sum=0; q=0;
            } // else
            // Отработка краевого эффекта непрерывного блока в конце фокальной линии.
            // Если непрерывный блок точек упирается в конец фокальной линии то нет его окончания
            // по котрому осущкствляется фиксация координат середины то.
            if(q>2 & n==pIndex2-1) { //-1 // условие фиксации координат середины непрерывного блока точек.
                // Вычисление координат середины непрерывного блока точек попавших в лимит угла.
                n_extr=n_sum/q; // расстояние середины непрерывного блока до начала данной фокальной линии.
                // Исключение из области поиска точек максимума начального и конечного участка фокальной линии.
                if(protect_n<n_extr & n_extr<(line_lenA-protect_n)) {
                    // создаем точку экстремума - максимум.
                    line.extrem[eCount]=n_extr;
                    lineData[n_extr].type=E_POINT;
                    eCount++; // подсчет количества точек экстремума.
                    if(eCount>=MAX_EXTREM)break;
                    DG("Точка <P> типа - максимум близкий к концу, n="<<n<<"   n_extr="<<n_extr<<"   q="<<q<<endl);
                }
            } // if(q>0)
        } // int n=0
        //DG("цикл по количеству фокальных линий в букве  m="<<m<<endl<<endl);
    } // int m=0
    
    //------------------------------------------------------------------------------------------------------
    
    // Освобождение массивов. Освобождаются глобально. Пока это последняя функция где нужны эти массивы.
    // массив координат точек всех фокальных линий по "y", float.
    //if(coord_fx !=NULL) free(coord_fx);
    // массив координат точек всех фокальных линий по "x", float
    //if(coord_fy !=NULL) free(coord_fy);
    // массив углов (второй производной) вдоль фокальной линии, float.
    //if(alpha_fl !=NULL) free(alpha_fl);
    
    ///TIME_PRINT_
    
    //------------------------------------------------------------------------------------------------------
    
    
    // поворот второго вектора на 180 градусов вокруг точки "n" для получения острого угла.
    ///float x_1= 2*x2 - x1;
    ///float y_1= 2*y2 - y1;
    // http://espressocode.top/reflection-point-180-degree-rotation-another-point/
    
    // Параметры acos: agl Значение с плавающей точкой в интервале [-1,+1].
    // Возвращаемое значение Значение арккосинуса agl, в интервале [0, Pi].
    
    ////float AlphaM=0; // средний угол фокальной линии в градусах.
    ////AlphaM=AlphaM/(line_lenA-k2*4); // средний угол фокальной линии в градусах.
    ////DG("средний угол фокальной линии в градусах.  AlphaM="<<AlphaM<<endl);
    
    
    // ТЕСТЫ //
    
    /*
     ushort test[15]={ 0,5,10,20,40,60,80,100,120,140,160,180,200,400,600 }; // { 0 };
     
     for(int n=0; n<15; n++){
     float line_lenA=test[n];
     
     // k=3 как функция от длинны фокальной линии.
     k=(int)sqrt((float)(line_lenA/8.0)); // Эмпирическая формула.
     // Ограничения на "k", k от 2 до 4.
     if ( k==0) continue;
     if ( k<2.0 ) k=2.0;   if ( k>4.0 ) k=4.0;
     ///k=3.0; // Тест. 3.0   ////////////////////////////////
     DG("n="<<n<<"   test[n]="<<test[n]<<"   k="<<k<<endl);
     
     // dltAlpha как функция от длинны фокальной линии.
     float ds=sqrt((float)(line_lenA/16.0)); // Эмпирическая формула.
     // Ограничения на "ds", ds от 2 до 4.
     if ( ds<0.0001 ) continue;
     if ( ds<2.0 ) ds=2.0;   if ( ds>4.0 ) ds=4.0;
     //ds=3.0; // Тест. 1.0   ////////////////////////////////
     DG("n="<<n<<"   test[n]="<<test[n]<<"   ds="<<ds<<endl);
     
     } // int n=0
     //*/
    
    
} //____________________________________________________________________________



// Функция сглаживания фокальной линии.
// Основная рабочая версия. _20_октября_2019
// -----------------------------------------------------------------------------
void GGraph::focalLineMid(){
    
    /** @bref
     //  Функция сглаживания фокальной линии. //
     После завершения работы функуции получаем:
     - сглаженный массив float  координат по "x" и "y" coord_fx, coord_fy
     - максимальную длинну фокальной линии на странице maxLine_lenA.
     ТЕОРИЯ.
     Сглаживаем (усредняем) середину фокальной линии с помощью прямоугольной рекурсивной весовой функции.
     Т.е. скользящей многоточкой длинной "s2" pix. Для исключения фазовых сдвигов применяется сглаживание
     как вперед так и назад. Это соответствует применению одномерного фильтра с прямоугольной импульсной
     характеристикой вида:
     y(n)=y(n-1)+x(n)-x(n-s2) два раза.
     Сглаживание начальных участков фокальной линии.
     Сглаживаем координаты начала и конца фокальной линии (первые "s" pix).
     - координаты "0" точки фокальной линии оставляем как есть
     - координаты "1" точки сглаживаем симметричной трехточкой.
     - координаты "2" точки сглаживаем симметричной пятиточкой.
     - и т.д. до "s".
     На начальном участке фокальной линии применяется сглаживание только вперед (первые "s" pix).
     На конечном участке применяется сглаживание только назад (последние "s" pix).
     В результате координаты "x" и "y" становятся float и хранятся в исходном глобальном массиве.
     
     При больших значениях "радиуса" области сглаживаня "s" больше 16 становится виден стык
     начального и среднего участка фокальной линии. Реально "s" больше 8 не применяется.
     */
    
    int GrafT=0;
    // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    DG("// Функция сглаживания фокальной линии"<<endl);
    
    //TIME_START
    
    uint size=(uint)focalLine.size(); // количество фокальных линий на странице или ID номеров.
    DG("Количество фокальных линий на странице size="<<size<<endl);
    
    // Вычисление максимальной длины линии на всей странице.
    // цикл перебора фокальных линий на странице.
    ushort maxLine_lenA=0; // Максимальная длина фокальной на странице.
    for(int m=0; m<size; m++){
        OCRLine &line=focalLine[m];
        // длина фокальной линии буквы.
        ushort line_lenA=line.lenA;
        // Максимальная длина фокальной линии на странице.
        if (line_lenA > maxLine_lenA) maxLine_lenA = line_lenA;
    } // int m=0
    
    // Вспомогательные массивы координат для работы сглаживающей маски.
    // Массивы float размером в максимальную длинну всех линий на странице.
    float *crd_x, *crd_y;
    crd_x = (float*)calloc(maxLine_lenA+4,sizeof(float));
    crd_y = (float*)calloc(maxLine_lenA+4,sizeof(float));
    float *px=crd_x, *py=crd_y;
    
    
    // Суммарная длина всех линий на странице.
    uint sumLine_lenA=(int)pointArray.size();
    DG("Суммарная длина всех линий на странице  sumLine_lenA="<<sumLine_lenA<<endl);
    
    // Глобальный массив координат точек всех фокальныэх линий по "x", float.
    coord_fx = (float*)calloc(sumLine_lenA+32,sizeof(float));
    // Глобальный массив координат точек всех фокальныэх линий по "y", float.
    coord_fy = (float*)calloc(sumLine_lenA+32,sizeof(float)); // Каждый элемент инициализируется в 0.
    ////float *px=coord_fx, *py=coord_fy;
    
    // Глобальный массив углов вдоль фокальной линии (массив вторай производной). Пока не заполнен. 
    // Используется только для рисования, можно заремачить, 25 окт 2020.
    alpha_fl = (float*)calloc(sumLine_lenA+32,sizeof(float));
    ///float *pα=alpha_fl; // указатель на массив углов вдоль фокальной линии (вторая производная).
    
    /*
     // ТЕСТ
     // Заполнение массивов координатами всех линий по всей странице.
     // цикл по суммарной длинне всех фокальной линий на странице.
     for(int n=0; n<sumLine_lenA; n++){
     OCRPoint &pt=pointArray[n];
     // cout<<n<<" pt x:y "<<pt.x<<":"<<pt.y<<endl; // вывод координат x:y
     // Запись координат фокальных линий в массивы.
     coord_fx[n]=(float)pt.x;
     coord_fy[n]=(float)pt.y;
     } // int n=0
     //*/
    
    
    //*
    // Сглаживание фокальных линий по очереди. //
    float sum_x, sum_y;
    int s;        // "радиус" области сглаживаня.
    int s2;       // "диаметр" области сглаживаня. s2=s*2+1;
    int pIndex1;  // разметка глобальных массивов координат точек.
    
    // цикл перебора фокальных линий на странице.
    for(int m=0; m<size; m++){
        OCRLine &line=focalLine[m];
        int pIndex=line.pointIndex;
        // длина фокальной линии буквы.
        ushort line_lenA=line.lenA;
        if(line_lenA<LINE_SIZE)continue;
        
        // "радиус" области сглаживания как функция sqrt от толщины штриха // было от длины фокальной линии.
        s=(int)sqrt((float)(line.lineW*3.2f)); // Эмпирическая формула.  /////////////////////////
        // "радиус" области сглаживания как линейная функция от толщины штриха. 25 окт 2020. ПРОВЕРИТЬ!
 ////       s=(int)(line.lineW*0.75f); // Эмпирическая формула.
        
        // Ограничения на "радиус" области сглаживаня в пикселях, s от 2 до 8.
        if ( s==0 ) continue;
        if ( s<2 ) s=2;   if ( s>8 ) s=8;  // s не больше 16
        //s=32; // Тест. 5   ////////////////////////////////
        s2=s*2+1;  // "диаметр" области сглаживаня как функция от толщины штриха.
        DG("line.lineW="<<line.lineW<<"  s="<<s<<endl);
        
        // Ограничение "радиуса" области сглаживаня "s" координат начала и конца фокальной линии.
        // Например область сглаживание начального участка становится больше длины фокальной линии.
        // Актуально для коротких фокальных линий и больших значений "s".
        int s1=s; // "s1" ограничение значение "радиуса" области сглаживаня "s"
        if ( line_lenA < s2 ) s1=(line_lenA-1)/2; // n<s & n<line_lenA-s2;
        // ограничение сглаживаня начала и конца фокальной линии ее серединой
        //if ( line_lenA/2 < s2 ) s1=(line_lenA-1)/2; // n<s & n<line_lenA/2-s2
        
        // Вспомогательные переменные
        int ls1=line_lenA-1;
        int ls2=line_lenA-s2;
        
        // Заполнение вспомогательных локальных массивов координатами  линии.
        // цикл по длинне фокальной линии.
        for(int n=0; n<line_lenA; n++){ // sumLine_lenA
            OCRPoint &pt=pointArray[pIndex+n];
            // cout<<n<<" pt x:y "<<pt.x<<":"<<pt.y<<endl; // вывод координат x:y
            // Запись координат фокальных линий в массивы.
            px[n]=(float)pt.x;
            py[n]=(float)pt.y;
        } // int n=0
        
        //*
        // вместо ТЕСТ который ниже
        // Заполнение глобальных массивов координат точек, только координатами начала и конца линии.
        coord_fx[pIndex]=px[0];
        coord_fy[pIndex]=py[0];
        coord_fx[pIndex+ls1]=px[ls1]; // ls1=line_lenA-1;
        coord_fy[pIndex+ls1]=py[ls1];
        //*/
        
        /*
         // ТЕСТ
         // Заполнение глобальных массивов координат точек фокальных линий по "x" и "y", float.
         // цикл по длинне фокальной линии.
         for(int n=0; n<line_lenA; n++){
         coord_fx[pIndex+n]=px[n];
         coord_fy[pIndex+n]=py[n];
         } // int n=0
         //*/
        
        // ПРЯМОЕ СГЛАЖИВАНИЕ //
        
        //*
        // Прямое рекурсивное сглаживание координат НАЧАЛА (T точка) фокальной линии (первые "s" pix).
        // Вычисление стартовых значений sum_x и sum_y для сглаживание середины ф.л.
        sum_x=px[0];    sum_y=py[0];    // стартовые значения.
        for(int n=0; n<s1; n++){ // n<s & n<line_lenA-s2; // "s1" ограничение значение "радиуса" области сглаживаня "s"
            int n1=n+n;
            // Усреднение по мере движения вперед вдоль фокальной линии на 3, 5, ... "s" pix.
            sum_x=sum_x + px[n1+1] + px[n1+2];        coord_fx[pIndex+n+1]=sum_x/(3+n+n);
            sum_y=sum_y + py[n1+1] + py[n1+2];        coord_fy[pIndex+n+1]=sum_y/(3+n+n);
        } // int n=0
        //*/
        
        /*
         // ТЕСТ
         // Прямое сглаживание координат НАЧАЛА фокальной линии (для фиксированного s2=7).
         // Вычисление стартовых значений sum_x и sum_y.
         int n=pIndex;
         n=0;
         // Сглаживание координат 1 точки от начала фокальной линии (точки нумеруются с нуля).
         sum_x=px[n] + px[n+1] + px[n+2];        coord_fx[pIndex+n+1]=sum_x/3.0;
         sum_y=py[n] + py[n+1] + py[n+2];        coord_fy[pIndex+n+1]=sum_y/3.0;
         // Сглаживание координат 2 точки от начала фокальной линии.
         sum_x=sum_x + px[n+3] + px[n+4];        coord_fx[pIndex+n+2]=sum_x/5.0;
         sum_y=sum_y + py[n+3] + py[n+4];        coord_fy[pIndex+n+2]=sum_y/5.0;
         // Сглаживание координат 3 точки от начала фокальной линии.
         sum_x=sum_x + px[n+5] + px[n+6];        coord_fx[pIndex+n+3]=sum_x/7.0;
         sum_y=sum_y + py[n+5] + py[n+6];        coord_fy[pIndex+n+3]=sum_y/7.0;
         //*/
        
        //*
        // Прямое рекурсивное сглаживание координат СЕРЕДИНЫ фокальной линии скользящей многоточкой.
        // Нужны стартовые значений sum_x и sum_y полученные от сглаживание координат начала фокальной линии.
        for(int n=0; n<ls2+0; n++){ // ls2=line_lenA-s2; // s2=s*2+1;
            // Прямоугольная рекурсивная весовая функция. Усредняет "s2" pix.
            // Соответствует одномерному фильтру с прямоугольной импульсной характеристикой.
            // y(n)=y(n-1)+x(n)-x(n-2k-1)
            sum_x = sum_x + (px[n+s2] - px[n]);     coord_fx[pIndex+n+s+1] = sum_x/s2; // +1 устраняет петельку
            sum_y = sum_y + (py[n+s2] - py[n]);     coord_fy[pIndex+n+s+1] = sum_y/s2;
            //coord_fx[n+3] = (px[n] + px[n+1] + px[n+2] + px[n+3] + px[n+4] + px[n+5] + px[n+6])/s2;
            //coord_fy[n+3] = (py[n] + py[n+1] + py[n+2] + py[n+3] + py[n+4] + py[n+5] + py[n+6])/s2;
        } // int n=0
        //*/
        
        
        // РЕВЕРСИВНОЕ СГЛАЖИВАНИЕ //
        
        //*
        // Обратное рекурсивное сглаживание координат КОНЦА фокальной линии (последние "s" pix).
        // Вычисление стартовых значений sum_x и sum_y для реверсивного сглаживание середины ф.л.
        pIndex1=pIndex+line_lenA-1;       // -1;
        sum_x=px[ls1];    sum_y=py[ls1];  // стартовые значения. ls1=line_lenA-1;
        for(int n=0; n<s1; n++){          // & s<line_lenA-n // "s1" ограничение значение "радиуса" области сглаживаня "s"
            int n1=ls1-n-n;
            // Усреднение по мере движения назад вдоль фокальной линии на 3, 5, ... "s" pix.
            sum_x=sum_x + px[n1-1] + px[n1-2];        coord_fx[pIndex1-n-1]=sum_x/(3+n+n); // pIndex1=pIndex+line_lenA;
            sum_y=sum_y + py[n1-1] + py[n1-2];        coord_fy[pIndex1-n-1]=sum_y/(3+n+n);
        } // int n=0
        // можно объеденить циклы начала и конца фокальной линии.
        // ввести переменную n3=(3.0+n+n) и n2=n+n. Но цикл реально всего на 2-5 тактов и так нагляднее.
        //*/
        
        /*
         // ТЕСТ
         // Реверсивное сглаживание координат КОНЦА фокальной линии (для фиксированного s2=7).
         int n=line_lenA-1; ///n=pIndex+line_lenA-1;
         // Сглаживание координат 1 точки от конца фокальной линии.
         sum_x=px[n] + px[n-1] + px[n-2];        coord_fx[pIndex-n+1]=sum_x/3.0;
         sum_y=py[n] + py[n-1] + py[n-2];        coord_fy[pIndex-n+1]=sum_y/3.0;
         // Сглаживание координат 2 точки от конца фокальной линии.
         sum_x=sum_x + px[n-3] + px[n-4];        coord_fx[pIndex-n+2]=sum_x/5.0;
         sum_y=sum_y + py[n-3] + py[n-4];        coord_fy[pIndex-n+2]=sum_y/5.0;
         // Сглаживание координат 3 точки от конца фокальной линии.
         sum_x=sum_x + px[n-5] + px[n-6];        coord_fx[pIndex-n+3]=sum_x/7.0;
         sum_y=sum_y + py[n-5] + py[n-6];        coord_fy[pIndex-n+3]=sum_y/7.0;
         //*/
        
        //*
        // Обратное рекурсивное сглаживание координат СЕРЕДИНЫ фокальной линии скользящей многоточкой.
        // Нужны стартовые значений sum_x и sum_y полученные от реверсивного сглаживание координат конца фокальной линии.
        pIndex1=pIndex+line_lenA-1; //-1
        for(int n=0; n<ls2; n++){   // ls2=line_lenA-s2;
            int n1=ls1-n;           // ls1=line_lenA-1;
            // Прямоугольная рекурсивная весовая функция. Усредняет "s2" pix.
            // Соответствует одномерному фильтру с прямоугольной импульсной характеристикой.
            // y(n)=y(n-1)+x(n)-x(n-2k-1)
            sum_x = sum_x + (px[n1-s2] - px[n1]);     coord_fx[pIndex1-n-s] = sum_x/s2;
            sum_y = sum_y + (py[n1-s2] - py[n1]);     coord_fy[pIndex1-n-s] = sum_y/s2;
            //DG("n="<<n<<"  n1="<<n1<<endl);
        } // int n=0
        //*/
        
        DG("цикл по количеству фокальных линий в букве  m="<<m<<endl);
        
    } // int m=0
    
    
    // Возвращаем максимальную длинну фокальной на странице.
    DG("Максимальная длина фокальной на странице="<<maxLine_lenA<<endl);
    
    // освобождение локальных массивов.
    if(crd_x !=NULL) free(crd_x);
    if(crd_y !=NULL) free(crd_y);
    
    //TIME_PRINT_
    
    /*
     // ТЕСТ
     // Вычисление стартовых значений sum_x и sum_y для сглаживание середины ф.л.
     sum_x=0;    sum_y=0;
     for(int n=0; n<s2; n++){ // n<s & n<line_lenA-s2;
     // Усреднение по мере движения вдоль фокальной линии на 3, 5, ... "s" pix.
     sum_x=sum_x + px[pIndex+n];
     sum_y=sum_y + py[pIndex+n];
     } // int n=0
     //*/
    
    /*
     // Прямое сглаживание координат середины фокальной линии скользящей многоточкой. /////////   /////////
     // Нужны стартовые значений sum_x и sum_y полученные от сглаживание координат начала фокальной линии.
     DG("   px[1]="<<px[1]<<"   py[1]="<<py[1]<<"   px[2]="<<px[2]<<"   py[2]="<<py[2]<<endl);
     sum_x=px[1]+px[2];    sum_y=py[1]+py[2];  int n=0;
     DG("   n="<<n<<"   sum_x="<<sum_x<<"   sum_y="<<sum_y<<"   s="<<s<<endl);
     //sum_x=px[1]+px[2]+px[3];    sum_y=py[1]+py[2]+py[3];
     ///sum_x=px[1];    sum_y=py[1];
     ///sum_x=0;    sum_y=0;
     //for(int n=0; n<(s+s-0); n++){ sum_x+=px[n];  sum_y+=py[n]; }
     int s_=s;
     for(int n=1; n<ls2-s2; n++){ // ls2=line_lenA // s2=s*2+1;
     // Прямоугольная рекурсивная весовая функция. Усредняет "s2" pix.
     // Соответствует одномерному фильтру с прямоугольной импульсной характеристикой.
     // y(n)=y(n-1)+x(n)-x(n-2k-1)
     if ( s_>n ) s=n;  //if ( s==0 ) s=1;                //s2=s*2+1;
     sum_x = sum_x + (px[n+s+s] - px[n]);     coord_fx[pIndex+n+s+0] = sum_x/(s+s); // +1 устраняет петельку
     sum_y = sum_y + (py[n+s+s] - py[n]);     coord_fy[pIndex+n+s+0] = sum_y/(s+s);
     //coord_fx[n+3] = (px[n] + px[n+1] + px[n+2] + px[n+3] + px[n+4] + px[n+5] + px[n+6])/s2;
     //coord_fy[n+3] = (py[n] + py[n+1] + py[n+2] + py[n+3] + py[n+4] + py[n+5] + py[n+6])/s2;
     DG("   n="<<n<<"   sum_x="<<sum_x<<"   sum_y="<<sum_y<<"   s="<<s<<endl);
     } // int n=0
     //*/
    
} //____________________________________________________________________________


    
/// LineM ///
// Функция для подсчета реальной длины сглаженной фокальной линии.
// Распознование прямых линий.
void GGraph::focalLineLengthMid(){
    
    /** @bref
     // ТЕОРИЯ //
     Подсчитывается реальная длина сглаженной фокальной линии line_lenM, по не регулярной сетке float.
     Расстояние между точками сглаженной фокальной линии вычисляется по Теореме Пифагора.
     Реальная длина сглаженной фокальной линии м.б. меньше пиксельной длины на 20-30%
     Реально хватает быстродействия обычного извлечения корня.
     На выходе функциии получаем реальную длинну сглаженной фокальной линии  float line_lenM.
     
     // ПРИМЕНЕНИЕ //
     Распознование прямых линий.
     По критерию разности истинной длины фокальной линии и расстояния между концами фокальной линии
     можно понять необходимость поиска экстремумов в данной фокальной линии. Т.к. фокальная линия
     уже сглажена, ее истинную длинну можно считать через несколько pix, точнее через "s" (типично 3),
     где s "радиус" области сглаживаня.
     
     // Управляющие параметры //
     Вычисляются как функция от длины фокальной линии.
     int dlt_n=1;        Шаг оцифровки в pix с которым проиходит вычисление длины плавной фокальной линии.
     int protect_n=1;    Защитный итервал в начале и в конце фокальной линии в pix по которому не происходит
     вычисление длины фокальной линии. Начало и конец фокальной линии практически малоинформативен.
     */
    
    //TIME_START
    
    
    int GrafT=0;
    // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    DG("----------------------------------------------------------------------------"<<endl);
    DG("// Функция для подсчета реальной длины сглаженной фокальной линии   focalLineLengthMid() "<<endl);
    
    // Пользовательское назначение лимита распознования прямых линий в процентах.
    // lim_line это число процентов, на сколько истинная длинна сглаженной фокальной линии больше
    //  расстояния между началом и концом луча фокальной линии, с учетом защитных итервалов protect_n.
    float lim_line=8; // %
    // разность длинн меньше порога lim_line это прямая.
    // разность длинн больше порога lim_line это кривая.
    DG("Лимит распознования прямых линий в %  lim_line="<<lim_line<<endl);
    
    uint sumLine_lenA=(int)pointArray.size();
    DG("Суммарная длинна всех линий на странице  sumLine_lenA="<<sumLine_lenA<<endl);
    
    float *px=coord_fx, *py=coord_fy;
    
    //*
    uint size=(uint)focalLine.size(); // количество фокальных линий на странице или ID номеров.
    DG("Количество фокальных линий на странице size="<<size<<endl);
    
    // Вычислениея реальной длины сглаженной фокальной линии line_lenA, по не регулярной сетке float. //
    
    // Параметры вычисляются как слабая функция от длины фокальной линии.
    int dlt_n=1;     // Шаг оцифровки в pix с которым проиходит вычисление длины плавной фокальной линии.
    int protect_n=1; // Защитный итервал в начале и в конце фокальной линии в pix по которому
    // не происходит вычисление длины фокальной линии.
    
    // цикл перебора фокальных линий на странице.
    for(int m=0; m<size; m++){
        
        OCRLine &line=focalLine[m];
        int pIndex=line.pointIndex;
        // длинна фокальной линии буквы.
        ushort line_lenA=line.lenA;
        // Реальная длина сглаженной фокальной линии.
        float line_lenM=0.0f;
        //line_lenA=7; // Тест. 8
        
        // Вычисление шага оцифровки фокальной линии как функции от длины фокальной линии.
        if ( line_lenA<1 ) continue;
        dlt_n=(int)sqrt((float)(line_lenA/16.0f)); // Эмпирическая формула.
        // ограничения dlt_n.
        if ( dlt_n<1 ) dlt_n=1;   if ( dlt_n>3 ) dlt_n=3;
        ///dlt_n=1; // Тест. 1
        // Вычисление защитного итервала в начале и в конце фокальной линии.
        protect_n=(int)sqrt((float)(line_lenA/8.0f)); // Эмпирическая формула.
        if ( protect_n<0 ) protect_n=0;   if ( protect_n>3 ) protect_n=3;
        protect_n=0; // Тест.0
        DG(endl<<"m="<<m<<" line_lenA="<<line_lenA<<"  dlt_n="<<dlt_n<<"  protect_n="<<protect_n<<endl);
        
        //*
        // стартовые значения координат точек фокальной линии.
        float x0=px[pIndex+protect_n];      float y0=py[pIndex+protect_n];
        //  DG("  x0="<<x0<<"  y0="<<y0<<endl<<endl);
        // защитный итервал в начале и в конце фокальной линии в pix.
        int st1=dlt_n+protect_n;     int st2=line_lenA-protect_n;
        // цикл перебора точек фокальных линий.
        for(int n=st1; n<st2; n+=dlt_n) {
            ///for(int n=dlt_n; n<line_lenA; n+=dlt_n) {
            int n1=pIndex+n;
            // Декартовы координаты текущих точек фокальной линии.
            float x1=px[n1];
            float y1=py[n1];
            // Разности декартовых координат соседних точек фокальной линии.
            float dx=x1-x0;
            float dy=y1-y0;
            // Вычисление расстояний между соседними точками фокальной линии по Теореме Пифагора.
            // Реальное расстояние между пикселями сглаженной фокальной линии.
            line_lenM+=sqrt(dx*dx + dy*dy);
            // Декартовы координаты предидущих точек фокальной линии.
            x0=x1;   // сдвиг влево виртуального двухразрядного регистра "x1, x0"  по "х".
            y0=y1;   // сдвиг влево виртуального двухразрядного регистра "x1, x0"  по "y".
            //DG("n="<<n<<endl);
        } // int n=0
        //*/
        
        // Сохраняем реальную длинну сглаженной фокальной линии  float line_lenM.
        
        // Вычисление длины луча фокальной линии, с учетом защитного итервала. //
        // Разности декартовых координат начала и конца луча фокальной линии, с учетом защитного итервала.
        float dx=px[pIndex+line_lenA-protect_n-1]-px[pIndex+protect_n];
        float dy=py[pIndex+line_lenA-protect_n-1]-py[pIndex+protect_n];
        // Вычисление расстояний между началом и концом луча фокальной линии, с учетом защитного итервала.
        float line_lenP=sqrt(float(dx*dx + dy*dy));
        
        // Разность длинн сглаженной фокальной линии и ее луча в процентах, с учетом защитного итервала.
        float dltFL=(line_lenM-line_lenP)*100.0f/line_lenP;
        DG("  float line_lenP="<<line_lenP<<"  float line_lenM="<<line_lenM<<"  dltFL="<<dltFL<<endl);
        
        // ТЕСТ //
        // Разность длинн сглаженной и пиксельной фокальной линии в процентах, с учетом защитного итервала.
        ///float dltFL=((float)line_lenA-2*protect_n-line_lenM)*100.0f/(line_lenA-2*protect_n);
        ///DG("  int line_lenA="<<line_lenA<<"  float line_lenM="<<line_lenM<<"  dltFL="<<dltFL<<endl);
        
        DG("  Реальная длинна сглаженной фокальной линии  float line_lenM="<<line_lenM<<endl);
        //DG("m="<<m<<endl);
        
        // Распознование прямых линий.
        // Прямая это разность длинн в нескольких процентов и меньше.
        // Кривая это разность длинн в несколько десятков процентов.
        if ( dltFL<lim_line ){
            DG("  прямая линия dltFL="<<dltFL<<endl);
        }
        else{
            DG("  #кривая dltFL="<<dltFL<<endl);
            line.type=EXTREM_LINE;
        }
        
    } // int m=0
    
    
    
    /*
     m=0  int line_lenA=17  float line_lenM=16.2221  dlt=4.57571
     Реальная длинна сглаженной фокальной линии  float line_lenM=16.2221
     m=1  int line_lenA=13  float line_lenM=12.2232  dlt=5.97566
     Реальная длинна сглаженной фокальной линии  float line_lenM=12.2232
     m=2  int line_lenA=104  float line_lenM=93.5242  dlt=10.0729
     Реальная длинна сглаженной фокальной линии  float line_lenM=93.5242
     //*/
    //TIME_PRINT_
    
}//____________________________________________________________________________




// Функция выделения точек перегиба и максимумов (экстремумов) сглаженной фокальной линии по углам //
// Основная тестовая версия. _4_ноября - 10 дек_2019_
// -----------------------------------------------------------------------------
void GGraph::findExtremAlphaFl(){
    
    /** @bref
     Вычисление функции зависимости угла Alpha от координат точек сглаженной фокальной линии.
     Предварительно сглаживаем двумерную фокальную линию с помощью функции сглаживания фокальной линии focalLineMid().
     Вычисляем координаты концов векторов (не имеющих общей точки) скользящих по сглаженной фокальной линии.
     По стандартному скалярному произведению векторов вычисляем угол между векторами, который является вторай
     производной. Угол  Alpha получаем значених косинуса и в градусах. Проверяем угол, а еще лучше значения
     косинуса, по лимиту. Лимит угла составляет примерно 120 градусов.
     // Нахождение угла между векторами с помощью векторного произведения
     // vec a*b=ax*by - ay*bx
     // http://www.cyberforum.ru/pascal/thread1589027.html
     //Лимит угла делаем адаптивным и считаем как процент от среднего угла по всей фокальной линии,
     //как в функции адаптивного порога по яркости?
     
     Вычисление точек перегиба.
     Точки перегиба вычисляем по одномерному графику функции зависимости угла Alpha от длины сглаженной фокальной линии.
     Локальные максимумы одномерного графика угла Alpha являются точками перегиба двумерной фокальной линии.
     Говорят, что функция  f(x) имеет локальный максимум в точке, если f(x)<=f(x0) для всех значений "x" в некоторой окрестности точки.
     Это означает, что функция f(x):
     - является возрастающей для значений "x", расположенных в непосредственной близости к точке локального максимума слева от нее.
     - является убывающей для значений  "x", достаточно близких к этой точке и расположенных справа.
     если x<x0, то f(x)<=f(x0).
     если x>x0, то f(x)<=f(x0).
     http://portal.tpu.ru:7777/SHARED/k/KONVAL/Sites/Russian_sites/Calc1-ru/5/02.htm
     
     // ТЕОРИЯ //
     если в некотором промежутке f’’(x) > 0, то кривая выпукла вниз на этом промежутке; если же f’’(x) < 0,
     то кривая выпукла вверх на этом промежутке.
     https://math.semestr.ru/math/inflection.php
     Точкой перегиба графика функции y=f(x) называется точка M(x1;f(x1)), разделяющая промежутки выпуклости и вогнутости.
     https://www.webmath.ru/poleznoe/formules_8_24.php
     http://nuclphys.sinp.msu.ru/mathan/p1/m1503.html
     
     Вычисление точек максимума.
     Точки максимума также вычисляем по одномерному графику функции зависимости угла Alpha от длины сглаженной фокальной линии.
     Находим все точки меньше лимита угла по одномерному графику. Среди этих точек находим непрерывные блоки.
     Вычисляем количество точек непрерывных блоков попавших лимит угла и в каждом находим его середину.
     Вычисление координат середины непрерывного блока точек попавших в лимит угла и есть вычисление точек максимума.
     */
    
    
    ///TIME_START
    
    int GrafT=0;
    // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    DG("// Функция выделения плавных экстремумов сглаженной фокальной линии по углам"<<endl);
    
    // параметры "k", "w", "ds" вычисляются от длины фокальной линии и являются слабой функцией длины.
    
    // пользовательские ПАРАМЕТРЫ поиска экстремуиов  //
    ///////////////////
    // Лимит угла в градусах для поиска точек перегиба.
    //float lim_AlphaExt=120.0f; // 180.0-40.0 // назначаемый лимит угла в градусах -180<=lim_Alpha<=180.
    // Вычисление лимита угла в значениях косинуса.
    //float lim_cosAlphaExt=cos(lim_AlphaExt/57.29747f); // -1<=lim_cosAlpha<=1.
    ///////////////////
    // Лимит угла в градусах для поиска точек максимума. Больше лимит - больше точек максимума.
    float lim_AlphaMax=130.0f; // 125.0; назначаемый лимит угла в градусах -180<=lim_Alpha<=180.
    // Вычисление лимита угла в значениях косинуса.
    float lim_cosAlphaMax=cos(lim_AlphaMax/57.29747f); // -1<=lim_cosAlpha<=1.
    
    // лимит угла делаем адаптивным и считаем как процент от среднего угла по всей фокальной линии,
    // как в функции адаптивного порога по яркости?
    
    // Коэффициент ограничения области поиска точек максимума factor_lineW.
    // Больше коэффициент ограничения - больше начальный и конечный участок.
    // Точки максимумы ищем по всей кривой, кроме начального и конечного участков.
    // Длинна начального и конечного участков прямо пропорциональна толщине штриха.
    float factor_lineW=1.0f;
    ///////////////////.
    
    uint size=(uint)focalLine.size(); // количество фокальных линий на странице или ID номеров.
    DG("Количество фокальных линий на странице size="<<size<<endl);
    
    float *px=coord_fx, *py=coord_fy; // указатели на сглаженные массивы координат по "x" и "y"
    //float *pA=alpha_fl; // указатель на массив углов вдоль фокальной линии (вторая производная).
    
    // цикл перебора фокальных ЛИНИЙ на странице.
    for(int m=0; m<size; m++){ // size
        DG(endl<<"цикл по количеству фокальных линий в букве  m="<<m<<endl);
        
        OCRLine &line=focalLine[m];
        line.type=BASE_LINE;
        uchar &eCount=line.extremCount;
        eCount=0;
        OCRPoint *lineData=(OCRPoint *)&pointArray[line.pointIndex];
        int pIndex=line.pointIndex;
        
        // длинна фокальной линии буквы.
        ushort line_lenA=line.lenA;
        if ( line_lenA==0) continue;
        if ( line_lenA>255) line_lenA=255;
        DG("pIndex="<<pIndex<<"   line_lenA="<<line_lenA<<endl);
        
        // Параметр вычисления вторай производной (уголов Alpha) вдоль фокальной линии, как функция от длины фокальной линии.
        // "k" половина длины пары измерительных векторов лежащих на фокальной линии, k=3 тест.
        int k=(int)sqrt((float)(line_lenA)/8.0f); // Эмпирическая формула.
        // Ограничения на "k", k от 2 до 4.
        if ( k<2 ) k=2;   if ( k>4 ) k=4;
        //    k=3; // Тест. 3     ////////////////////////////////
        int k2=k*2;     // длинна пары векторов лежащих на фокальной линии.
        //int k21=k2+k; // полторы длины векторов.
        
        // Параметр вычисления точек перегиба. "Ширина" области поиска максимума т.е,
        // окрестности +-w, по которым происходит вычисление точек перегиба.
        // Чем меньне "w" тем более локальные максимумы находит алгоритм.
        int w=k; ///int w=k-1;
        ///w=3; // Тест 3   ////////////////////////////////
        // ограничения "w".
        if ( w<1 ) w=1;   if ( w>3 ) w=3;
        DG("   k="<<k<<"   k2="<<k2<<"   w="<<w<<endl);
        
        // Вычисление области поиска точек максимума в pix в зависимости от толщины фокальной линии (штриха).
        // Точки максимумы ищем по всей кривой, кроме начального и конечного участков длинной по searchAr.
        int protect_n=line.lineW * factor_lineW; // line.lineW толщина штриха.
        int k4=k2+k2; //  для коротких линий k=2 pix,  k4=k*4=8.  Для длиных линий k=4 pix,  k4=k*4=16.
        ///int k8=k4+k4; //  для коротких линий k=2 pix,  k8=k*8=16. Для длиных линий k=4 pix,  k8=k*8=32.
        // ограничения на "protect_n" в pix.
        if ( protect_n<k4 ) protect_n=k4;   if ( protect_n>line_lenA/2 ) protect_n=line_lenA/2;
        DG("   protect_n="<<protect_n<<"   min k4="<<k4<<"   max line_lenA/2="<<line_lenA/2<<endl);
        
        /*
         // Переменные для вычисление координат точек плавных перегибов по углу.
         uint flag0=0, flag1=0;     // флаг, задает последовательность работы алгоритма.
         int n0=0;                  // длинна непрерывного возрастающего блока.
         int n1=0;                  // длинна непрерывного убыввающего блока.
         int n0_old=0, n1_old=0;    // предидущие значения длинн непрерывных блоков.
         //// n=0;          // расстояние от начала данной фокальной линии до текущей точки.
         int nn=0;          // расстояние от начала данной фокальной линии до текущей точки с учетом лимита угла.
         int n_max=0;       // расстояние от начала данной фокальной линии до точки перегиба.
         ushort alp_max=0;  // значение угла alp в точке перегиба, соответствующий n_max-1.
         ushort alp_old=0;  // предидущее значение угла   alp=(ushort)(10*Alpha);
         //*/
        
        // Переменные для вычисление координат плавных точек максимума.
        int n_sum=0; // сумма расстояний от точек непрерывного блока попавших лимит угла, до начала фокальной линии.
        int q=0;     // длинна непрерывного блока точек попавших лимит угла.
        int n_extr;  // расстояние от начала данной фокальной линии до точки экстремума n_extr=n_sum/q;
        
        int pIndex1=pIndex+k2+k2;
        int pIndex2=pIndex+line_lenA-k2-k2;
        DG("   pIndex="<<pIndex<<"   pIndex1="<<pIndex1<<"   pIndex2="<<pIndex2<<endl);
        
        // цикл перебора ТОЧЕК фокальных линий на странице.
        for(int n=pIndex1; n<pIndex2; n++){
            
            // Вычисление  cosAlpha между векторами. //
            
            // координаты отсчитанны от точки "n" фокальной линии лежащей на расстоянии "k"
            // от конца первого вектора и начала второго вектора.
            ///float x1=px[n-k],      y1=py[n-k];     // координаты начала первого вектора    -k.
            ///float x2=px[n-k2-k],   y2=py[n-k2-k];  // координаты конца первого вектора     -k2-k=-k21.
            ///float x3=px[n+k],      y3=py[n+k];     // координаты начала второго вектора    +k.
            ///float x4=px[n+k2+k],   y4=py[n+k2+k];  // координаты конца второго вектора     +k2+k=+k21.
            
            ///float dx1=x2-x1;  float dy1=y2-y1;     // длинна первого вектора по оси "x" и сответственно по "y"
            ///float dx2=x4-x3;  float dy2=y4-y3;     // длинна второго вектора по оси "x" и сответственно по "y"
            //////
            // длинна первого вектора по оси "x" и сответственно по "y"
            float dx1=px[n-k2-k] - px[n-k];    float dy1=py[n-k2-k] - py[n-k];
            
            // длинна второго вектора по оси "x" и сответственно по "y"//
            float dx2=px[n+k2+k] - px[n+k];    float dy2=py[n+k2+k] - py[n+k];
            
            
            // Вычисление модулей векторов по Теореме Пифагора (м.б. уже вычисленно).
            ///float mod=sqrt(float(dx1*dx1 + dy1*dy1)) * sqrt(float(dx2*dx2 + dy2*dy2));
            //float mod2=sqrt(float(dx2*dx2 + dy2*dy2));
            
            // для вычисления координат точек плавных максимумов.
            // скалярное произведение векторов:
            ///float scalar_v = dx1*dx2 + dy1*dy2;
            
            // cosAlpha между векторами:
            ///float cosAlpha=scalar_v/mod;      // -1<=cosAlpha<=1
            
            // для вычисления координат точек перегиба.
            // векторное произведение векторов:
            ///float vector_v = dx1*dy2 - dy1*dx2; // vec a*b=ax*by - ay*bx
            
            // sinAlpha между векторами:
            ///float sinAlpha=vector_v/mod;      // -1<=sinAlpha<=1
            
            // cosAlpha между векторами в компактном виде.
            // Где Alpha угол между векторами с концами "x1, y1" - "x2, y2" и "x3, y3" - "x4, y4"  не имеющих общей точки "x0, y0"
            float cosAlpha = (dx1*dx2 + dy1*dy2)/(sqrt(dx1*dx1 + dy1*dy1) * sqrt(dx2*dx2 + dy2*dy2));
            if(cosAlpha<-1)cosAlpha=-1;
            
            //float Alpha=57.29747f*acos(cosAlpha);    // -180<=lim_Alpha<=180.     // -pi<=cos(arccos(x))<=pi при -1<=x<=1
            ///float Alpha=57.29747f*asin(sinAlpha);    // -180<=lim_Alpha<=180.
            //DG("#n="<<n<<"   Alpha="<<Alpha<<endl);
            // ТЕСТ //
            // Заполнение массива координат углов вдоль фокальной линии (вторая производная).
            // Необходимо только для рисования аналогового графика alpha_fl[n].
       /////alpha_fl[n]=Alpha; ////////////////////////////////
            //float Alpha=-180.0f*cosAlpha;
            
            
            
            //------------------------------------------------------------------------------------------------------
            
            /*
             // Вычисление координат точек плавных перегибов //
             // Точки перегиба вычисляем по одномерному графику зависимости угла Alpha от длины сглаженной фокальной линии.
             // Надо доделать параметр управления выделением точек перегиба //
             
             if( cosAlpha < lim_cosAlphaExt) {
             
             // Приведение координат углов float к целочисленному значению ushort 0<=alp<=1800.
             // Соседние значения углов должны отличаться не менее чем на десятые доли градуса.
             // Чем меньше коэффициент, тем грубее отсчеты и грубее выделяются перегибы
             // ushort alp=(ushort)Alpha; //
             ushort alp=(ushort)(2.0f*Alpha);
             
             // Вычисление локальных максимумумов функции угла Alpha от длины фокальной линии f(x)<=f(x0).
             // Локальные максимумы одномерного графика угла Alpha являются точками перегиба двумерной фокальной линии.
             
             // Функция f(x) является возрастающей для значений "x", расположенных в непосредственной близости к точке
             // локального максимума "x0" слева от нее.
             if( alp_old<alp ) { n0++; }  else { n0=0; } // непрерывные блоки возрастания длинной "n0".
             // Фиксация окончания непрерывно возрастающего блока n0_old>n0, который заканчивается максимумом alp_max=alp_old.
             if( n0_old>w && n0_old>n0 ){ flag0=nn; n_max=n-1; alp_max=alp_old; } //else { flag0=0; }
             
             // Функция f(x) является убывающей для значений "x", достаточно близких к точке "x0" и расположенных справа.
             if( alp_old>alp ) { n1++; }  else { n1=0; } // непрерывные блоки убыввания длинной "n1"
             // Фиксация окончания непрерывно убыввающего блока n1_old>n1.
             if( n1_old>w && n1_old>n1 ){ flag1=nn-n1_old; } else { flag1=0; }
             // блоки д.б. не менее "w",  n0_old>w и n1_old>w.
             
             DG("   n="<<n<<"   nn="<<nn<<"  alp="<<alp<<"   n0="<<n0<<"   flag0="<<flag0<<"   n1="<<n1<<"   flag1="<<flag1<<endl);
             
             // Вычисление точек перегиба сглаженной фокальной линии по углам.
             // Если flag0 или flag1 больше ноля, то формирмируем непрерывные блоки возрастания и убывания. Если адрес
             // конца возрастающего блока flag0=nn, совпадает со смещенным адресом убывающего блока flag1=(nn-n1_old),
             // ну и максимум почти равен 180 градусам. То тогда проверяемая точка является точкой перегиба.
             if( (flag0|flag1)>0 && flag0==flag1 && alp_max>176) {
             //if( (flag0|flag1)>0 && flag0==flag1 && alpha_fl[n_max]>176.0 ) {
             DG("# Точка перегиба <P> типа, n_max-1="<<n_max<<"   alp_max="<<alp_max<<"   n="<<n<<endl);
             //DG("# Точка перегиба <P> типа, n_max-1="<<n_max<<"   alp_max="<<alp_max<<"   n="<<n<<"   alpha_fl[n_max]="<<alpha_fl[n_max]<<endl);
             // создаем точку экстремума - точку перегиба.
             line.extrem[eCount]=n_max-pIndex; //-pIndex, точка экстремума "max_n" должна отсчитываться от начала данной фокальной линии.
             lineData[n_max-pIndex].type=I_POINT;
             eCount++; // подсчет количества точек экстремума.
             if(eCount>MAX_EXTREM)break;
             flag0=0;
             }
             nn++;
             n0_old=n0;
             n1_old=n1;
             alp_old=alp;
             
             } // if( cosAlpha < lim_cosAlphaExt)
             //*/
            
            //------------------------------------------------------------------------------------------------------
            
            // Вычисление координат точек плавных максимумов //
            
            //*
            // Вычисление плавных максимумов (экстремумов) сглаженной фокальной линии по углам.
            // Проверка лимита угла в значениях косинуса ( не нужно вычислять float Alpha=57.29747*acos(cosAlpha); )
            if(cosAlpha > lim_cosAlphaMax ) { // >, угол больше, а косинус угла меньше.
                ///if( Alpha < lim_AlphaMax) { // lim_AlphaMax // 125.0
                // Вычисление суммы расстояний от всех точек непрерывного блока, до начала фокальной линии.
                n_sum+=n-pIndex;  // -pIndex, точка экстремума "n_sum" должна отсчитываться от начала данной фокальной линии.
                q++;              // количество точек непрерывного блока попавших лимит угла.
                ///DG("#n="<<n<<"   q="<<q<<"   n_sum="<<n_sum<<"   n_extr="<<n_extr<<"   Alpha="<<57.29747*acos(cosAlpha)<<endl);
            }  else {
                if(q>0) {
                    // Вычисление координат середины непрерывного блока точек попавших в лимит угла.
                    n_extr=n_sum/q; // расстояние от начала данной фокальной линии до точки экстремума.
                    // Исключение из области поиска точек максимума начального и конечного участка фокальной линии.
                    if(protect_n<n_extr & n_extr<(line_lenA-protect_n)) {
                        // создаем точку экстремума - максимум.
                        line.extrem[eCount]=n_extr;
                        lineData[n_extr].type=E_POINT;
                        eCount++; // подсчет количества точек экстремума.
                        if(eCount>=MAX_EXTREM)break;
                        DG("Точка <P> типа - максимум., n="<<n<<"   n_extr="<<n_extr<<"   q="<<q<<endl);
                        /////////DG("n="<<n<<"   n_extr="<<n_extr<<"   Alpha="<<57.29747*acos(cosAlpha)<<endl);
                    }
                } // if(q>0)
                n_sum=0; q=0;
            } // else
            // Отработка краевого эффекта непрерывного блока в конце фокальной линии.
            // Если непрерывный блок точек упирается в конец фокальной линии и нет его окончания
            // по котрому осуществляется фиксация координат середины то.
            if(q>0 & n==pIndex2-1) { //-1 // k/2 // условие фиксации координат середины непрерывного блока точек.
                // Вычисление координат середины непрерывного блока точек попавших в лимит угла.
                n_extr=n_sum/q; // расстояние середины непрерывного блока до начала данной фокальной линии.
                // Исключение из области поиска точек максимума начального и конечного участка фокальной линии.
                if(protect_n<n_extr & n_extr<(line_lenA-protect_n)) {
                    // создаем точку экстремума - максимум.
                    line.extrem[eCount]=n_extr;
                    lineData[n_extr].type=E_POINT;
                    eCount++; // подсчет количества точек экстремума.
                    if(eCount>=MAX_EXTREM)break;
                    DG("Точка <P> типа - максимум близко к концу, n="<<n<<"   n_extr="<<n_extr<<"   q="<<q<<endl);
                }
            } // if(q>0)
            //*/
        } // int n=0
        //DG("цикл по количеству фокальных линий в букве  m="<<m<<endl<<endl);
    } // int m=0
    
    //------------------------------------------------------------------------------------------------------
    
    // Освобождение массивов. Освобождаются глобально. Пока это последняя функция где нужны эти массивы.
    // массив координат точек всех фокальных линий по "y", float.
    //if(coord_fx !=NULL) free(coord_fx);
    // массив координат точек всех фокальных линий по "x", float
    //if(coord_fy !=NULL) free(coord_fy);
    // массив углов (второй производной) вдоль фокальной линии, float.
    //if(alpha_fl !=NULL) free(alpha_fl);
    
    ///TIME_PRINT_
    
    
    
    
    // ТЕСТЫ //
    /*
     ushort test[15]={ 0,5,10,20,40,60,80,100,120,140,160,180,200,400,600 }; // { 0 };
     
     for(int n=0; n<15; n++){
     float line_lenA=test[n];
     //*/
    /*
     // "радиус" области сглаживаня как функция от длины фокальной линии.
     float s=(int)sqrt((float)(line_lenA/3.0)); // Эмпирическая формула. 4.0
     // Ограничения на "радиус" области сглаживаня в пикселях, s от 2 до 6.
     if ( s==0 ) continue;
     if ( s<2 ) s=2;   if ( s>16 ) s=16;
     //s=6; // Тест. 5   ////////////////////////////////
     DG("n="<<n<<"   test[n]="<<test[n]<<"   s="<<s<<endl);
     //*/
    
    /*
     // k=3 как функция от длины фокальной линии.
     k=(int)sqrt((float)(line_lenA/8.0)); // Эмпирическая формула.
     // Ограничения на "k", k от 2 до 4.
     if ( k==0) continue;
     if ( k<2.0 ) k=2.0;   if ( k>4.0 ) k=4.0;
     ///k=3.0; // Тест. 3.0   ////////////////////////////////
     DG("n="<<n<<"   test[n]="<<test[n]<<"   k="<<k<<endl);
     //*/
    
    /*
     // dltAlpha как функция от длины фокальной линии.
     float ds=sqrt((float)(line_lenA/16.0)); // Эмпирическая формула.
     // Ограничения на "ds", ds от 2 до 4.
     if ( ds<0.0001 ) continue;
     if ( ds<2.0 ) ds=2.0;   if ( ds>4.0 ) ds=4.0;
     //ds=3.0; // Тест. 1.0   ////////////////////////////////
     DG("n="<<n<<"   test[n]="<<test[n]<<"   ds="<<ds<<endl);
     //*/
    ///     } // int n=0
    
    /*
     // "ds" как функция от длины фокальной линии. ТМП
     // тоже что и "w" для алгоритма прямого не итерационного вычисление точек перегиба.
     float ds=sqrt((float)(line_lenA/8.0)); // Эмпирическая формула. small
     // Ограничения на "ds", ds от 2 до 4.;
     if ( ds<2.0 ) ds=2.0;   if ( ds>4.0 ) ds=4.0;
     ///ds=3.0; // Тест. 1.0     ////////////////////////////////
     DG("line_lenA="<<line_lenA<<"   k="<<k<<"   w="<<w<<"   ds="<<ds<<endl);
     
     int n_1=n-2;
     // Вычисление точек перегиба сглаженной фокальной линии по углам float.
     if( (alpha_fl[n_1]-ds) > alpha_fl[n_1-2] && alpha_fl[n_1] > (180.0-ds) && (alpha_fl[n_1]-ds) > alpha_fl[n_1+2] ) {
     DG("Точка перегиба <P> типа, n="<<n<<"   Alpha="<<Alpha<<"   ds="<<ds<<endl);
     //создаем точку экстремума - точку перегиба.
     line.extrem[eCount]=n_1-pIndex;
     lineData[n_p].type=E_POINT;
     eCount++; // подсчет количества точек экстремума.
     }
     //*/
    
    ////float AlphaM=0; // средний угол фокальной линии в градусах.
    ////AlphaM=AlphaM/(line_lenA-k2*4); // средний угол фокальной линии в градусах.
    ////DG("средний угол фокальной линии в градусах.  AlphaM="<<AlphaM<<endl);
    
    
    // Параметр вычисления вторай производной (уголов Alpha) вдоль фокальной линии.
    //int k=3;        // "k" половина длины измерительных векторов лежащих на фокальной линии, k=3 тест.
    //int k2=k*2;   // длинна векторов лежащих на фокальной линии.
    //int k21=k2+k; // полторы длины векторов.
    
    // Параметр вычисления точек максимума. "Ширина" области поиска максимума.
    // Чем меньне "w" тем более локальные максимумы находит алгоритм.
    //int w=0; // Окрестности точки +-w, по которым происходит вычисление точек максимумов.
    
} //____________________________________________________________________________


    
    
/**
Функция выделения точек экстремума (перегиба) фокальной линии
найденые точки экстремума записываются в массив extremPoint
базовой линии, а также используются для создания дочерних фокальных линий
образованных участками кривой между точками экстремума.
Эти дополнительные фокальные линии имеют вспомогательный
характер и используются при распознавании рукописного, поврежденного и неразборчивого  текста.
*/
void GGraph::findExtremPoints() {
    int GrafT=0;
    DG("\nфункция определения точек экстремума фокальной линии\nlineCount:"<<focalLine.size()
                                                                           <<endl);

    /** дополнено 3 октября 2019. MAX_H 8 это лимит высоты точки фокальной лини относительно
    базового отрезка Равен средней толщине штриха текста

    функция проверяет расстояние от каждой точки фокальной линии до отрезка
    соединяющего ее концы.
    Если максимальное расстояние превышает MAX_H то массив данных линии  делится на два
    промежутка по найденой точке с наибольшим расстоянием. каждый из промежутков обрабатывается
    по данному алгоритму.

    В большинстве случаев
     точка  с наибольшим расстоянием до прямой соединяющей концы кривой совпадает с экстремумом
    кривой.
    !!! не работает если линия строго вертикальна или горизонтальна
    примечание. Для хранения данных о начале и конце промедутка
    используется структура OCRPoint в котором х:y обозначает начало и конец промежутка.

    Расстояние_от_точки_до_прямой_на_плоскости ///
    Если прямая проходит через две точки с координатами P1=(x1,y1) и P2=(x2,y2),
    то расстояние от точки (x0,y0) до прямой равно:
    distance P=(x0,y0)=abc((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1)/distance P1=(x1,y1) и
    P2=(x2,y2) Знаменатель этого выражения равен расстоянию между точками P1 и P2,  distance
    P1=(x1,y1) и P2=(x2,y2) и равен: sqrt ((y2-y1)*(y2-y1) + (x2-x1)*(x2-x1)) и наверника уже
    подсчитан
     
    информацию о точках экстремума фокальной динии записывем в соответствующую точку отцифровки линии
    в массиве line.extrem каждой фокальной линии записываем индекс точки экстремума в отцифровке
    линии относительно начала линии в массиве точек отцифровки (line.pointIndex)
    */

    //инициализация массива id_data размеров w*h в котором записаны id номера фокальных точек
    //по их координатам
    if(!initID_flag) initID();
    
    // общая формула вычисления расстояния между точкой и отрезком
    // sqrt и y2-y1 и x2-x1 и x2*y1-y2*x1 зависит только от координат базового отрезка и могут
    // быть вынесены из цикла вычисления (l1, l2, l3) int h=abs(
    // ((y2-y1)*x0-(x2-x1)*y0+x2*y1-y2*x1)/sqrt((float)((y2-y1)*(y2-y1)+(x2-x1)*(x2-x1)))  );
    // x0,y0 - точки на фокальной линии
    // x1,y1 x2,y2 - координаты концов фокальной линии

    OCRPoint dataRange[20];  //массив хранения данных о промежутках линии
    int size=(int)focalLine.size();

    for(int n=0; n < size; n++) {
        OCRLine  &line=focalLine[n];
        OCRPoint *lineData=(OCRPoint *)&pointArray[line.pointIndex];
        uchar    &eCount=line.extremCount;
        eCount=0;
        int       lenA=line.lenA-1;
        if(lenA < MAX_H) continue;

        DG("start extrem for line index: "<<line.index<<" lenA:"<<lenA<<endl);

        int       rangeCount=1;
        OCRPoint &lineRange=dataRange[0];
        lineRange.status=0;  // range need to process
        lineRange.x=0;
        lineRange.y=lenA;
        int limit=MAX_H;  //лимит высоты кривой над хордой в этом промежутке. Равен средней
        //толщине штриха текста
        lineRange.data=limit;
        
        int needProcess=1;
        while(needProcess) {
            needProcess=0;
            for(int index=0; index < rangeCount; index++) {
                OCRPoint &range=dataRange[index];
                DG("range:"<<range.x<<":"<<range.y<<" limit:"<<range.data<<endl);
                if(range.status) continue;
                OCRPoint *pData=lineData + range.x;
                int       len=range.y - range.x - 1;
                int       l1=pData[len].y - pData[0].y;
                int       l2=pData[len].x - pData[0].x;
                int       l3=pData[len].x * pData[0].y - pData[len].y * pData[0].x;

                if(l1==0 && l2==0) {
                    //если начало и конец фокальной линии совпадает, то отступаем
                    //по два пиксела от начала и конца линии
                    l1=pData[len - 2].y - pData[2].y;
                    l2=pData[len - 2].x - pData[2].x;
                    l3=pData[len - 2].x * pData[2].y - pData[len - 2].y * pData[2].x;
                }

                float l4=sqrt((float)(l1 * l1 + l2 * l2));

                float max=0;
                int   maxM=0;
                float hL;
                for(int m=0; m < len; m++) {
                    OCRPoint &p=pData[m];
                    //DG("\n    x:"<<lineData[m].x<<"  y:"<<lineData[m].y<<endl;);
                    hL=fabs((float)(l1 * p.x - l2 * p.y + l3)/l4);
                    //DG("\nhL:"<<hL<<endl;);
                    if(hL > max) {
                        max=hL;
                        maxM=m;
                    }
                }
                DG(" max:"<<max<<" maxM:"<<maxM<<endl);

                if(max > range.data) {
                    int indexM=range.x + maxM;  //вычисляем индекс найденной точки в массиве точек
                    line.extrem[eCount]=indexM;
                    lineData[indexM].type=E_POINT;
                    eCount++;
                    if(eCount>MAX_EXTREM)eCount=MAX_EXTREM-1;

                    //создаем два промежутка обрабоотки
                    OCRPoint newRange;
                    newRange.x=range.x;
                    newRange.y=range.x + maxM;
                    newRange.status=0;
                    newRange.data=limit;
                    if(newRange.y - newRange.x > LINE_SIZE && lenA - newRange.y > LINE_SIZE) {
                        dataRange[rangeCount]=newRange;
                        rangeCount++;
                    }

                    newRange.x=range.x + maxM;
                    newRange.y=range.y;
                    newRange.status=0;
                    newRange.data=limit;
                    if(newRange.y - newRange.x > LINE_SIZE) {
                        dataRange[rangeCount]=newRange;
                        rangeCount++;
                    }

                } else {
                    //если анализ промежутка не выявил экстремума
                    //проверяем есть ли расхождение между апроксимацией Безъе
                    //и отцифровкой линии
                    
                    
                    // Вычисление координат кривой Безье с помощью параметрического уравнения общего вида 2 порядка. //
                    //Кривая Безье начинается в точке с координатами (x0, y0) при t=0
                    //Заканчивается в точке с координатами (x2, y2) при t=1
                    //p1 - точка кривой  на расстоянии 1/2 от начала необходима для вычисления
                    //координат управляющей точкии кривой Безъе x1,y1
                    //коэффициент t может изменятся от 0 до 1 и соответствует части кривой Безъе от начала
                    //в которой вычисляется координаты xt1 и yt1 точки на кривой Безъе
                    
                    int x0=pData[0].x;
                    int y0=pData[0].y;
                    int x2=pData[len].x;
                    int y2=pData[len].y;
                    OCRPoint &p1=pData[len/2];
                    
                    
                    //вычисляем управляющую точку квадратичной апроксимации Безъе
                    float x1=-0.5 * x0 + 2.0 * p1.x - 0.5 * x2;
                    // координата “x” первой управляющей точки.
                    float y1=-0.5 * y0 + 2.0 * p1.y - 0.5 * y2;
                    // координата “y” первой управляющей точки.

                    float t=0.33333;  // (t=0.33333 или t=0.66666)
                    float xt1=x1 + (1-t)*(1-t)*(x0 - x1) + t*t*(x2 - x1);  // 0<=t<=1
                    float yt1=y1 + (1-t)*(1-t)*(y0 - y1) + t*t*(y2 - y1);  // 0<=t<=1
                    t=0.66666;  // (t=0.33333 или t=0.66666)
                    float xt2=x1 + (1-t)*(1-t)*(x0 - x1) + t*t*(x2 - x1);  // 0<=t<=1
                    float yt2=y1 + (1-t)*(1-t)*(y0 - y1) + t*t*(y2 - y1);  // 0<=t<=1
                    
                     
                    OCRPoint &pt1=pData[(int)(len * 0.33)];
                    //точка фокальной линии на расстоянии 1/3 от начала промежутка
                    OCRPoint &pt2=pData[(int)(len * 0.66)];
                    //точка фокальной линии на расстоянии 2/3 от начала промежутка
                    
                    if(sqrt((pt1.x - xt1) * (pt1.x - xt1) +
                            (pt1.y - yt1) * (pt1.y - yt1)) < limit/3 &&
                       sqrt((pt2.x - xt2) * (pt2.x - xt2) +
                            (pt2.y - yt2) * (pt2.y - yt2)) < limit/3 ){
                       
                        range.status=1;  //исключаем промежуток из разбора
                    }else{
                        //отмечаем что для этого промежутка необходимо применить
                        //меньший лимит проверки экстремумов
                        range.data/=2;
                        //возвращаемся к разбору этого промежутка
                        index--;
                    
                    }
                    
                    
                    
                }
            }  // for (int index=0; index < dataRange.size(); index++)
        }      // while(needProcess)

        //для каждой базовой линии выполняем сортировку точек экстремума относительно начала
        //линии
        DG("line.extremCount:"<<(int)line.extremCount<<endl);
        for(int index=0; index < line.extremCount; index++) {
            int min=0xFF;
            int id=-1;
            // cout<<"index:"<<index<<" x:"<<lineExtrem[index].x<<" y:"<<lineExtrem[index].y<<"
            // s:"<<(int)lineExtrem[index].stability<<endl;
            for(int i=index; i < eCount; i++) {
                if(line.extrem[i] < min) {
                    min=line.extrem[i];
                    id=i;
                }
            }
            // cout<<"id0:"<<id<<" s:"<<(int)lineExtrem[id].stability<<endl;
            if(index==id) continue;
            uchar p=line.extrem[index];
            line.extrem[index]=line.extrem[id];
            line.extrem[id]=p;
        }

    }
    //printStars("",0);

}  //____________________________________________________________

}  // namespace ocr
