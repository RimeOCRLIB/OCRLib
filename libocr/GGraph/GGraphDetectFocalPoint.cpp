//@_________________GGraphFocalLineCorrelation.cpp

// Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru
// ****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
// ****************************************************************************
//
// C- This software is subject to, and may be distributed under, the
// C- GNU General Public License, either Version 2 of the license,
// C- or (at your option) any later version. The license should have
// C- accompanied the software or you may obtain a copy of the license
// C- from the Free Software Foundation at http://www.fsf.org.

#include "../OCRString/php2stl.h"
#include "GGraph.h"

namespace ocr
{
//------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------

/** @bref Функция поиска координат фокальных точек.
    Функция получает на вход координаты и размер прямоугольника области поиска.
    Отдает координаты фокальных точек попавших в прямоугольник области поиска и их
   количество.*/

ushort GGraph::detectFocalPoint(short search_x,
                                short search_y,
                                ushort search_dx,
                                ushort search_dy,
                                ushort w,
                                ushort h,
                                uint *data_32,
                                OCRPoint *adrFocalPoint) {
    
    // Алгоритм поиска позиций фокальных точек в транспонированном массиве integer
    // в котором каждая точка битмепа это один бит, один ряд integer соответствует
    // колонке битмепа шириной 32 пиксела и по координатам фокальнх точек установлены единицы.
    
    // Особенности применения:
    
    // - Перед применением необходимо запустиь функцию упаковки в массив по 32 разряда вертикальными
    // колонками graph.packImg32V(1) в варианте "прямой порядок пикселей".
    // - Размеры исходного массива (w и h) д.б. кратны 32.
    // - По периметру исходного массива наверняка пробов 1 pix состоящий из 0.
    // - До скелетизации очень желательно удалить 1-4 pix точки (шум), что увеличит скорость работы функции.
    // - Если высота области поиска search_dy будет не четным числом, то функция округлит его до ближайшего
    // большего четного.
    // - Обратить внимание на параметр среднея толщина штриха или средний период повторения
    // точек line_width=4; (3-8 pix). От него считаются ограничения на количество точек в регистре и
    // в области поиска.
    
    
    
    int print=0;
    // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    DR("\n Функция поиска позиций фокальных точек   detectFocalPoint\n");    
    
    //uint *td=(uint*)bites_data;
    //for(int i=0;i<nrows;i++){ binaryPrint(td[i], 2); cout<<" "<<i<<" "<<endl; }

    
    
    // Формирование координат области поиска //
    if(search_x>w-1 || search_y>h-1) return 0;
    
    if (search_dx>32){
        // ограничение размера прямоугольной области поиска
        //определяем величину превышения
        int dl=(search_dx-32)/2;
        search_dx=32;
        search_x+=dl/2;
    }
    
    if(search_x<0){
        search_x=0;
    }
    if(search_y<0){
        search_y=0;
    }
    
        
    // ограничение размера прямоугольной области поиска
    if (search_x + search_dx >= w) search_dx=w - search_x - 1;
    if (search_y + search_dy >= h) search_dy=h - search_y - 1;

    
    // Координаты отсчитываются от верхнего левого угла картинки текста.
    DR("  w:"<<w<<" h:"<<h<<" search_x:"<<search_x<<" search_y:"<<search_y<<endl); // w*h - размер исходного массива
    
    // размер прямоугольной области поиска.
    //uchar search_dx=31,  search_dy=2; // search_dy д.б. четным 2<=search_dy<=32
    //////search_dy=(search_dy>>1)<<1;  // округление размера области поиска по "y" до меньшего четного числа  /2*2;
    DR("  search_dx="<<(ushort)search_dx<<"  search_dy="<<(ushort)search_dy<<endl);
    
    
    
    
    // Декартовы координаты верхнего левого угла прямоугольной области поиска по "x" и "y"
    // ushort search_x=434,  search_y=180;
    if (search_x>0)search_x-=1; // тонкая подгонка положения левой граници прямоугольной области поиска
                                // 4pix 434*180 и 464*181 еще 512*240 и 546*241 // x*y 1024*512  _1Draw_pix32_.jpg
                                // search_x=433,  search_y=180;  и  search_dx=1,  search_dy=1; Цикл <a>   ищет 1pix 434*180
                                // search_x=463,  search_y=181;  и  search_dx=1,  search_dy=1; Цикл <a>   ищет 1pix 464*181
                                // search_x=511,  search_y=240;  и  search_dx=1,  search_dy=1; Цикл <a>   ищет 1pix 512*240
                                // search_x=545,  search_y=241;  и  search_dx=1,  search_dy=1; Цикл <a>   ищет 1pix 546*241
    
    // смещение для изготовления масок
    ushort dltx=search_x%32; // сдвиг прямоугольной области поиска "search_dx" внутри регистра (колонки)
    
    // учет номера колонки по "x".
    ushort ncol=search_x/32;  // подсчитываем количество колонок ncolumns
    DR("  w:"<<w<<" h:"<<h<<" search_x:"<<search_x<<" search_y:"<<search_y<<" search_dx:"<<search_dx<<" search_dy:"<<search_dy<<endl);
    DR(" dltx:"<<dltx<<" ncol:"<<ncol<<endl);
    
    
    // Формирование масок для выделения области поиска // mask column
    
    ulong mask64=0xFFFFFFFF00000000;   // маска для выделения слайса в колонке "a"
    ulong rg64w =0xFFFFFFFF00000000;   // заготовка для получения маски в ширину прямоугольной области поиска
    ulong mask64a=0; // маска выделения области поиска для колонки "a"
    ulong mask64b=0; // маска выделения области поиска для колонки "b"
    
    // Получение 32 разрядной маски прямоугольной области поиска "search_dx" сдвинутую на "dltx"
    rg64w=((rg64w<<(32-search_dx)) & mask64)>>(dltx);
    // сдвигаем маску rg64w на (32-search_dx), применяем маску mask64 и еще раз сдвигаем на dltx
    // 0000000000000000000000000001111111111111111111111111111111000000
    if (print) {binaryPrint64(rg64w,2); cout<<"\n";}
    
    // Запаковка 32 разрядного слайса в регистры колонок "a" и "b"
    
    // получение первой 32 разрядной маски поиска "a" в 64 разрядном регистре mask64a
    mask64a=rg64w & mask64;
    // 0000000000000000000000000001111100000000000000000000000000000000
    if (print) {binaryPrint64(mask64a,2); cout<<"\n";}
    
    // получение первой и второй 32 разрядной маски поиска "a"
    mask64a=(mask64a>>32)+mask64a; // сдвигаем регистр mask64a на 32 и прибавляем исходныйрегистр mask64a
                                   // 0000000000000000000000000001111100000000000000000000000000011111
    if (print) {binaryPrint64(mask64a,2); cout<<"\n";}
    
    // маска для выделения слайса в колонке "b"
    mask64=~mask64; // после инверсии mask64=0x00000000FFFFFFFF; // mask64>>=32;
                    // получение первой 32 разрядной маски поиска "b" в 64 разрядном регистре mask64b
    mask64b=rg64w & mask64;
    // 0000000000000000000000000000000011111111111111111111111111000000
    if (print) {binaryPrint64(mask64b,2); cout<<"\n";}
    // получение первой и второй 32 разрядной маски поиска "b"
    mask64b=(mask64b<<32)+mask64b; // сдвигаем регистр mask64b на 32 и прибавляем исходный регистр mask64b
                                   // 1111111111111111111111111100000011111111111111111111111111000000
    if (print) {binaryPrint64(mask64b,2); cout<<"\n";}
    
    
    uint *p32=data_32; // получение указателя на первый элемент массива интерпретируемого как uint
                                 ///ulong rg64=*(ulong*)(p32+5);  // ulong *p0=(ulong*)bites_data;
    ushort line_width=4; // 3-7 // среднея толщина штриха или средний пероид повторения точек
                         // Ограничение по количеству точек в 64х разрядном регистре (2 слайса по 32)
    ushort lim_rg64=1+(search_dx+search_dx) /line_width;
    // Ограничение по количеству точек в области поиска
    ushort lim_search=lim_rg64*(1+search_dy/(line_width+line_width));
    if (lim_search>64) lim_search=64; // В области поиска не м.б. больше 64 точек.
                                      // Выходной массив координат фокальных точек попавших в прямоугольник области поиска.
                                      //uint adrFocalPoint [64]={0}; // обнуление при объявлении  [lim_search]
                                      //    DR("  line_width="<<line_width<<"  lim_rg64="<<lim_rg64<<"  lim_searchl="<<lim_search<<endl);
                                      //    uint adrFPoint=0;   // переменная для хранения двух ushort с координатами точки в pix по "x" и "y".
    uint index=0;   // порядковый номер адресов фокальных точек попавших в прямоугольник области поиска.
    ushort x_rg;    // полученная координата точки по "x" в пределах регистра
    
    
    
    // Получение позиций фокальных точек в области поиска. //
    // Обработка колонки "a"
    
    uint start_i=search_y + h*ncol; // h*ncol - суммарное число слайсов в всех целых колонках
    uint end_i=start_i + search_dy;
    DR("  Цикл <a>  "<<"  search_y="<<search_y<<", h*ncol="<<h*ncol<<", start_i="<<start_i<<endl);
    
    // Цикл перебирает регистры колонки "a" по вертикали, по 64 бита за один такт. // if(mask64a>0){} mask64a>0 && i<end_i;
    for(int i=start_i; mask64a>0 && i<end_i; i+=2){ // (end_i-start_i) размер прямоугольной области поиска по "y"
        
        // 64х разрядный регистр, в котором по координатам фокальнх точек установлены единицы.
        ulong rg0=*(ulong*)(p32+i); // читаем ulong, передвигаясь дискретами по uint
                                    // Регистр обрабатывает последовательно всю вертикальную колонку сразу по два 32х разрядых слайса int.
        DR(i<<"  Цикл <a>  "<<endl);   DR("rg0="<<rg0<<endl);
        
        // отсев лишних точек вне области поиска с помощью 64 разрядной маски поиска в колонке "a"
        rg0=rg0 & mask64a;
        
        if(rg0>0){ // если в регистре есть хоть одна единица
            
            // Цикл по количеству точек в регистре. Цикл крутится пока в регистре rg0 есть хоть одна единица.
            for(int j=0; rg0>0 && j<lim_rg64; j++){ // В 64х разрядном регистре не м.б. больше lim_rg64 точек.
                
                //if (print) {binaryPrint64(rg0,2); cout<<"\n";}
                
                // Алгоритм подсчета завершающих нулевых битов бинарным поиском в слове
                // длинной 64 битав обратном направлении, где "x_rg" это номер позиции единицы.
                // При вычислениях требуется выполнить от 12 до 21 базовой RISC-команды
                ulong a=rg0;    // сохраняем rg0
                ulong b;        // вспомогательная переменная
                                // получение координаты точки по "x" в пределах регистра, например 01011000 => 3
                x_rg=63;
                b=a<<32; if(b!=0) {x_rg-=32; a=b;}
                b=a<<16; if(b!=0) {x_rg-=16; a=b;}
                b=a<<8;  if(b!=0) {x_rg-=8;  a=b;}
                b=a<<4;  if(b!=0) {x_rg-=4;  a=b;}
                b=a<<2;  if(b!=0) {x_rg-=2;  a=b;}
                b=a<<1;  if(b!=0) {x_rg-=1;}
                // Если координата точки "x" находится во второй половине 64 разрядного регистра x_rg
                // 32<=x<=63, то устанавливаем flag=1 иначе 0.
                ushort flag=x_rg/32;
                //поскольку при запаковке пикселов в integer мы применяли обратный порядок битов
                //первоначально x_rg соответствует количеству пикселов отсчитанных от правого края колонки шириной 32
                //поскольку x_rg вычисляется как координата по X в колонке шириной 32 то для получения
                //координаты точки необходимо отнять от макимального значения координаты по X количество
                //пикселов до правого края колонки. 31  - x_rg;
                x_rg=31 - x_rg;
                //добавляем к x_rg ширину колонки 32 в зависимостти от состояния флага
                x_rg+=flag * 32;
                
                //DR("x_rg:"<<x_rg<<endl);
                
                // Запаковка в adrFPoint (int) двух  ushort с координатами точки в pix по "x" и "y".
                //*(ushort*)&adrFPoint=x_rg + ncol*32; // запаковка координаты "x" c учетом количества колонок ncol*32
                // добавляем к адресу "i" 0 или 1 (flag) в зависимости от того в какой половине регистра находится точка
                //*((ushort*)&adrFPoint+1)=i%h + flag; // запаковка координаты "y" c учетом количества колонок i%h
                // "i" прыгает через 2, flag через 1
                //adrFocalPoint[index]=adrFPoint;
                
                adrFocalPoint[index].x=x_rg + ncol*32;  // запаковка координаты "x" c учетом количества колонок ncol*32
                                                        // добавляем к адресу "i" 0 или 1 (flag) в зависимости от того в какой половине регистра находится точка
                adrFocalPoint[index].y=i%h + flag;      // запаковка координаты "y" c учетом количества колонок i%h
                                                        // "i" прыгает через 2, flag через 1
                
                index++; if (index>lim_search) index=lim_search; // В области поиска не м.б. больше 64 точек.
                
                // Алгоритм обнуления крайне правого единичного бита 01011000 => 01010000
                rg0=rg0&(rg0-1); // убираем из регистра "подсчитанную" единицу, стоящею на крайне правой позиции
                                 //               binaryPrint(rg0,2,64); cout<<"\n";
                
            } // окончание цикла поиска по регистру
            
        } // if(rg0>0)
        
    } // Окончание цикла обработки области поиска "a".
    
    
    // Обработка колонки "b"
    start_i+=h;     end_i+=h; // h - смещение на одну колонку регистров
                              //    cout<<"  Цикл <b>  "<<"  search_y="<<search_y<<", h="<<h<<", start_i="<<start_i<<endl;
    
    // Цикл перебирает регистры колонки "b" по вертикали, по 64 бита за один такт.
    for(int i=start_i; mask64b>0 && i<end_i; i+=2){ //// end_i-start_i=search_dy  размер прямоугольной области поиска по "y"
        
        // 64х разрядный регистр, в котором по координатам фокальнх точек установлены единицы.
        ulong rg0=*(ulong*)(p32+i); // читаем ulong, передвигаясь дискретами по uint
                                    // Регистр обрабатывает последовательно всю вертикальную колонку сразу по два 32х разрядых слайса int.
        DR(i<<"  Цикл <b>  "<<endl);   DR("rg0="<<rg0<<endl);
        
        // отсев лишних точек вне области поиска с помощью 64 разрядной маски поиска в колонке "b"
        rg0=rg0 & mask64b; //// отличие кода от "b" от кода "a" обозначено ////
        
        if(rg0>0){ // если в регистре есть хоть одна единица
            
            // Цикл по количеству точек в регистре. Цикл крутится пока в регистре rg0 есть хоть одна единица.
            for(int j=0; rg0>0 && j<lim_rg64; j++){ // В 64х разрядном регистре не м.б. больше lim_rg64 точек.
                
                //if (print) {binaryPrint64(rg0,2); cout<<"\n";}
                
                // Алгоритм подсчета завершающих нулевых битов бинарным поиском в слове
                // длинной 64 битав обратном направлении, где "x_rg" это номер позиции единицы.
                // При вычислениях требуется выполнить от 12 до 21 базовой RISC-команды
                ulong a=rg0;    // сохраняем rg0
                ulong b;        // вспомогательная переменная
                                // получение координаты точки по "x" в пределах регистра, например 01011000 => 3
                x_rg=63;
                b=a<<32; if(b!=0) {x_rg-=32; a=b;}
                b=a<<16; if(b!=0) {x_rg-=16; a=b;}
                b=a<<8;  if(b!=0) {x_rg-=8;  a=b;}
                b=a<<4;  if(b!=0) {x_rg-=4;  a=b;}
                b=a<<2;  if(b!=0) {x_rg-=2;  a=b;}
                b=a<<1;  if(b!=0) {x_rg-=1;}
                // Если координата точки "x" находится во второй половине 64 разрядного регистра x_rg
                // 32<=x<=63, то устанавливаем flag=1 иначе 0.
                ushort flag=x_rg/32;
                //поскольку при запаковке пикселов в integer мы применяли обратный порядок битов
                //первоначально x_rg соответствует количеству пикселов отсчитанных от правого края колонки шириной 32
                //поскольку x_rg вычисляется как координата по X в колонке шириной 32 то для получения
                //координаты точки необходимо отнять от макимального значения координаты по X количество
                //пикселов до правого края колонки. 31  - x_rg;
                x_rg=31 - x_rg;
                //добавляем к x_rg ширину колонки 32 в зависимостти от состояния флага
                x_rg+=flag * 32;
                //DR("x_rg:"<<x_rg<<endl);
                
                // Запаковка в adrFPoint (int) двух  ushort с координатами точки в pix по "x" и "y".
                //*(ushort*)&adrFPoint=x_rg + (ncol+1)*32; //// запаковка координаты "x" c учетом количества колонок (ncol+1)*32 плюс одна колонка
                // добавляем к адресу "i" 0 или 1 (flag) в зависимости от того в какой половине регистра находится точка
                //*((ushort*)&adrFPoint+1)=i%h + flag; // запаковка координаты "y" c учетом количества колонок i%h
                // "i" прыгает через 2, flag через 1
                //adrFocalPoint[index]=adrFPoint;
                
                adrFocalPoint[index].x=x_rg + (ncol+1)*32;      // запаковка координаты "x" c учетом количества колонок ncol*32
                adrFocalPoint[index].y=i%h + flag;              // запаковка координаты "y" c учетом количества колонок i%h
                                                                // линейно строчная координата найденной точки search_xy в pix ?
                
                index++;    if (index>lim_search) index=lim_search; // В области поиска не м.б. больше 64 точек.
                                                                    ////////cout<<"  i%h="<<i%h<<", i="<<i<<", search_y="<<search_y<<endl;
                
                // Алгоритм обнуления крайне правого единичного бита 01011000 => 01010000
                rg0=rg0&(rg0-1); // убираем из регистра "подсчитанную" единицу, стоящею на крайне правой позиции
                                 //                binaryPrint(rg0,2,64); cout<<"\n";
                
            } // окончание цикла поиска по регистру
            
        } // if(rg0>0)
        
    } // Окончание цикла обработки области поиска "b".
    
    // Функция отдает координаты фокальных точек adrFocalPoint попавших в прямоугольник области поиска и их количество index.
    
    
    
    /*
     //    cout<<"  4pix 434*180 и 464*181 еще 512*240 и 546*241 размер x*y 1024*512"<<endl;
     //    cout<<"  1 колонка="<<ncol*32<<", середина колонок="<<ncol*32+32<<", 2 колонка="<<ncol*32+64<<endl;
     
     // Просмотр координат фокальных точек.
     cout<<endl;
     for(int ind=0; ind<index; ind++){
     // Распаковка координат из массива adrFocalPoint (int) в два ushort с координатами точки по "x" и "y".
     ushort x_FPoint=*(ushort*) & adrFocalPoint[ind];
     ushort y_FPoint=*((ushort*) & adrFocalPoint[ind]+1);
     DR(  координаты фокальных точек"<<"  index="<<index<<", x_FPoint="<<x_FPoint<<", y_FPoint="<<y_FPoint<<endl);
     }
     
     // Алгоритмы: Уоррен Г.С. Алгоритмические трюки для программистов: стр 23 глава 2, стр 85 глава 5.6,  стр 93 глава 5.13
     
     // y=x/0x100000000; if(b!=0){n-=32; a=b;} // версия для iOS, компилятор не умеет сдвигать >>32
     
     DR_("\n@@@\n");
     */
    return index;
     
}  //____________________________________________________________

}  // namespace ocr


/*
 //------------------------------------------------------------------------------------------------------
 
 // Коэффициент корреляции звездочки текста и эталона по форме кривых образующих звездочку в
 // %. // Алгоритм масштабонезависим  //
 
 // Для описания форме кривых используются экстремумы. На одной кривой их м.б. несколько.
 // Сам экстремум описывается двумя числами uchar:
 // - расстоянием между лучем звездочки (прямой) и точкой экстремума "h".
 // - расстоянием между особой точкой звездочки и точкой экстремума "l" вдоль кривой.
 // Оба числа вычисляются в % относительно длинны кривой луча звездочки.
 // Коэффициент корреляции (к.к.) соответствующих точек экстремума текста и эталона
 // по "h" и "l" вычисляется по стандартной формуле в %.
 // kkh=100-(ht-he)*100/he;      kkl=100-(lt-le)*100/le;
 // Коэффициент корреляции соответствующих кривых текста и эталона вычичисляется по
 // стандартной формуле в % как среднея сумма к.к. нескольких точек экстремума. Коэффициент
 // корреляции звездочки текста и эталона по форме кривых вычичисляется по стандартной
 // формуле в % как среднея сумма к.к. ее кривых.
 // КОД
 
 // для одного луча
 
 // uchar h_bank=4;     // - расстояние между лучем звездочки (прямой) и точкой экстремума
 // "h_bank" в эталоне uchar h_text=3;     // - расстояние между лучем звездочки (прямой) и
 // точкой экстремума "h_text" в тексте. uchar l_bank=7;    // - расстояние между особой
 // точкой звездочки и точкой экстремума "l_bank" вдоль кривой. uchar l_text=5;    // -
 // расстояние между особой точкой звездочки и точкой экстремума "l_text" вдоль кривой.
 
 // DR("   ls_bank="<<(short)ls_bank<<"   l_bank="<<(short)l_bank<<"
 // lp_bank="<<(short)lp_bank<<"%"<<endl);
 
 // Коэффициент корреляции как расстояние по т Пифагора между точками экстремума эталона и
 // текста или сумма модулей разности координат
 ushort x1_test=40;  // кордината точки экстремума кривой в эталоне относительно особой точки звездочки
 ushort y1_test=41;
 ushort x1_text=49;  // кордината точки экстремума кривой в тексте относительно особой точки звездочки
 ushort y1_text=42;
 
 ushort x2_test=45;  // кордината конца кривой в эталоне относительно особой точки звездочки
 ushort y2_test=46;
 ushort x2_text=54;  // кордината конца кривой в тексте относительно особой точки звездочки
 ushort y2_text=47;
 
 uchar l1_test=8;  // - длина кривой луча от особой точки звездочки до экстремума в pix.
 uchar l2_test=28;  // - полная длина кривой луча звездочки эталона "l" в pix.
 uchar l2_text=20;  // - полная длина кривой луча звездочки текста "l" в pix
 uchar dltExtr;       // расстояние между точками экстремума эталона и текста в pix
 uchar exCor;         // коэффициент корреляции
 
 // Оба числа вычисляются в % относительно длинны кривой луча звездочки.
 // uchar xp_test=x_test*100/ls_test;
 
 uchar l1pr_test=l1_test * 100/l2_test;  // - длина кривой луча от особой точки звездочки до экстремума в %.
 
 //  совмещение
 char dltx2=x2_test - x2_text;
 char dlty2=y2_test - y2_text;
 
 // Расстояние между точками экстремума эталона и текста в pix
 // особые точки звездочек и конци кривой совмещены
 dltExtr=sqrt((x1_test - x1_text) * (x1_test - x1_text) + (y1_test - y1_text) * (y1_test - y1_text));
 
 // Коэффициент корреляции (к.к.) соответствующих точек экстремума текста и эталона.
 // Расстояние между точками экстремума эталона и текста в % относительно длинны кривой луча
 // звездочки.
 exCor=dltExtr * 100/l2_test;
 
 DR("   l2_text="<<(ushort)l2_text<<"   dltExtr="<<(ushort)dltExtr<<"   exCor="<<(ushort)exCor<<"%"<<endl);
 
 // Расстояние между точками экстремума эталона и текста как сумма модулей разности
 // координат в %
 
 // коэффициент корреляции звездочки "T" текста и эталона по относительным длинам лучей в %
 // lCor=100-lCor/6;
 
 // Треугольник. Прямоугольный. АВС. В - прямой угол.
 // Вычисление координаты 3-й вершины С <xc_, yc_> по координатам вершин А <xa_, ya_>, В
 // <xb_, yb_> и длине катета BC <bc_>
 /// void __fastcall TriangleStraightCalc3V(int xa_, int ya_, int xb_, int yb_, int bc_, int
 /// &xc_, int &yc_)
 //{
 
 int   xa_, ya_, xb_, yb_, bc_;  //
 int   xc_, yc_;
 float pi=3.14159265;
 
 if(ya_==yb_)
 xc_=xb_, yc_=yb_ + bc_;
 else {
 double K=(xa_ - xb_)/(ya_ - yb_);
 double K1=K * xb_ + yb_;
 double P=2 * (K * K + 1);
 double N=2 * (yb_ * K - xb_ - K * K1);
 double M=xb_ * xb_ - 2 * yb_ * K1 + yb_ * yb_ + K1 * K1 - bc_ * bc_;
 int    sig_n=(bc_ > 0) - (bc_ < 0);  // Функция sign
 
 // xc_=(-N + sign(bc_)*sqrt(N*N - 2*P*M))/pi;
 xc_=(-N + sig_n * sqrt(N * N - 2 * P * M))/pi;
 yc_=K1 - K * xc_;
 }
 // }
 
 bc_=-145;
 int sig_n=(bc_ > 0) - (bc_ < 0);  // Функция sign
 DR("   bc_="<<bc_<<"   sig_n="<<sig_n<<endl);
 
 // 27.10.2017 19:48 constconst
 // http://www.mathforum.ru/forum/read/1/39503/92760/
 // http://mathhelpplanet.com/viewtopic.php?f=28&t=22911
 
 // sign(bc_) //   http://zealcomputing.ru/besedy/016/
 
 // if(a<0) a=-a; // ~
 // sign // https://helloacm.com/how-to-implement-the-sgn-function-in-c/
 //------------------------------------------------------------------------------------------------------
 */
