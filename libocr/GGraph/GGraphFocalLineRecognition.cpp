//@___________GGraphFocalLineRecognition.cpp
// Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru
// ****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
// ****************************************************************************
//
// C- This software is subject to, and may be distributed under, the
// C- GNU General Public License, either Version 2 of the license,
// C- or (at your option) any later version. The license should have
// C- accompanied the software or you may obtain a copy of the license
// C- from the Free Software Foundation at http://www.fsf.org.

#include "GGraph.h"

namespace ocr
{
/** @bref Функция распознования фокальных линий (графемы) букв
@main
Функция вычисляет координаты точек, из которых состоят фокальные линии букв и формирует
структуры хранения данных фокальных линий и и конгломератов фокальных линий - OCRStar.
Функция заполняет массив фокальных линий, которые содержат
промежуточные точки фокальных линий в массиве focalLine.
В процессе выделения линий информация о порядке соединения линий,
расположении точек и их типе заносится в структуры OCRStar в starArray
Для каждой фокальной линии также создается структура хранения черных пикселов которые
образуют данную фокальную линию <a href="GGraphAttributeLinePixels.cpp.html"></a> Описание
этого алгоритма в функции @fn GGraph::attributeLinePixels</a>
@comm
Функция вызывается после применения функцией определения фокальной линии(графемы) букв и
функции выделения фокальных точек. сответственно GGraphFocalLine.cpp  и
GGraphfocalPointXTL.cpp . Адреса начальных и конечных фокальных точек функция получает в
виде структур OCRPoint расположеннх в массиве focalPoint, Количество адресов равно sizeAdr.
@comm1
Не забыть очистиь от черного 2х pix бордюр
вызовом функции img->eraseBorder(2, 2);
*/

int GGraph::focalLineRecognition() {
    /// Комментарии к функции ///
    
    
    //
    // Также заполняется массив
    
    //  * Идея *
    // По сути дела производит упорядочение адресов точек вдоль фокальной линии.
    // Функция получает координаты стартовой особой точки и запускает движение маски вдоль фокальной линии от
    // начальной до конечной фокальной точки. Промежуточные координаты точек фокальной линии записываются в массив.
    // За тем следующая стартовая точка и т.д.
    
    //  * Описание алгоритма движения маски по точкам фокальной линии.*
    // Помещаем центр маски 3*3 на стартовую особую точку. Маской, с помощью таблици rg_tab2,
    // проверяем сначало ближайшие точки, они м.б. только слева или справа, снизу или сверху и их 4.
    // И они плотнее соприкасаются с центральной точкой, чем диагональные. Если среди этих 4 точек черной нет,
    // то проверяем диагональные ближайшие точки. Таким способом находим две черные точки фокальной линии,
    // среди них одна точка от предидущей итерации и ее не рассматриваем. Остается только одна точка.
    // Это центральная точка следующей итерации.
    // Записываем в массив (Б.Д.) адрес соответствующей этой точке, в абсолютной системе координат.
    // Запоминаем также ее координату в переменную (например w+1), чтобы исключить ее из рассмотрения на следующей
    // итерации (начальные условия переменных это координаты стартовой особой точки). Переставляем на нее центр маски.
    // Маска оказалась в новом положении соответствующему началу следующей итерации и т.д...
    // За одну итерацию находим не более одной точки.
    // Если встречаем конечную фокальную точку или другую особую точку, то считаем что линия закончилась.
    // Пример из которого видно, зачем сначало рассматриваются ближайшие точки только слева или справа, снизу или сверху,
    // а затем диагональные ближайшие точки.
    //  1  0  0
    //  1  1  0
    //  0  1  1
    // Аналогично работает алгоритм выбора стартовах точек линии (их max 4), только используется таблица rg_tab3 и
    // с помощью нее проверяются все возможные стартовые точки.
    // Принцип и конкретная реализация работы матрицей (маской) обсчета (3*3-1) по таблице описана в функции GGraphFocalPoint.cpp
    
    //  * Особенности применения *
    // Перед запуском функции необходимо предварительно очистить от черного 2х pix бордюр с помощью вызова
    // функции img->eraseBorder(2, 2);
    
    int GrafT=0;   // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)
    if (GrafT) { cout<<endl<<"Функция распознавания фокальных линий букв   focalLineRecognition() "<<endl; }
    
    focalLine.resize(0);
    pointArray.resize(0);
    pCount=0;
    
    // Вызов функция построения таблиц (массивов) распознавания фокальных линий.
    // Функция заполняет глобальные массивы table_1[256], table_2[256] и table_3[256].
    buildOCRLineTable();
    
    //инициализация массива id_data размеров w*h в котором записаны id номера фокальных точек по их координатам
    initID();
    
    // Вызов функция построения таблиц (массивов) для вычисления коэффициента корреляции уголов векторов.
    //buildOCRAlphaTable();  // использается функциями сравнения (корреляции) двух кривых Безье CorrelationBezierA,B.
    // Функция заполняет глобальные массивы tabAlpha_1[361].
    
    int w,h;
    w=ncolumns;  // ширина массива  IMAGE WIDTH
    h=nrows;     // высота массива  IMAGE HEIGHT
    int w_h=w*h; // длина массива  IMAGE
    unsigned int sizeBuf=w_h + 32;  // размер массива bytes_data_1.
    if ( w>32766 ) w=32766;         // 32767
    if (GrafT) { cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
    // w*h=10 млн. пикселей time=0.033  // w*h=14 млн. пикселей time=0.057
    
    /// вспомогательные переменные
    int nl;         // Переменная цикла по количеству фокальных линий выходящих из особой точки.
    int np;         // Переменная цикла по количеству особых точек по всему графическому тексту.
    int dl_nl;    // Координата точек начала фокальных линий (переменная таблицы rg_tab3), “nl” номер стартовой точки.
                  // @@@@ short dl_nl; //@@@ в некоторых компиляторах смещение указателя должно быть только integer
    int index;      // Переменная цикла по количеству точек фокальной линий.
                    // int w_1=w+1; // смещение с угла в центр матрицы (
                    //short g9=0, g2=0, g3=0, g8=0, g4=0, g7=0, g6=0, g5=0; // переменные для вывода графики
                    //short dm9=-w-1, dm2=-w, dm3=1-w, dm8=-1, dm4=1, dm7=w-1, dm6=w, dm5=w+1; // переменные координат смещения маски //
                    //          -w-1,     -w,     1-w,     -1,     1,     w-1,     w,     w+1  // величины смещения маски //
    
    // вспомогательный регистры (переменные таблиц)
    unsigned char rg0;  // байтовый регистр для хранения отдельных 8 бит маски.
    //int rg_tab1=1;
    int rg_tab2=1;
    long long rg_tab3=1;
    
    // обьявление локальных переменной для сохранения объекта "линия".
    OCRPoint p_line;  // для промежуточных точек вдоль фокальной линии. point of the line
    OCRPoint p_start; // для особых точек как начало фокальной линии.
    int endID;    //ID номер конечной фокальной точки линии
    
    
    /// Массивы исходной битовой картинки фокальнах линий ///
    // указатели типа uchar
    unsigned char *p0=bytes_data, *p1;  // входной массив строго: 0-черный 255-белый (11111111), ( с 0-черный 1-белый не работает)
    unsigned char *bytes_data_1;        // массив занятости адресов промежуточных точек фокальной линии (0,1).
    
    // выделение памяти под массивы.
    // Таблица (массив) занятости адресов промежуточных точек фокальной линии.
    bytes_data_1 = (unsigned char*)calloc(sizeBuf+64, sizeof(unsigned char)); // с заполнением нулями
    
    // Массивы для хранения таблиц глобальные и объявлены в GBitmap.h
    
    uint sizeAdr=(int)focalPoint.size(); // количество особых точек по всему графическому тексту. SumSpecialPoints
    uint SumLengthLine; // суммарная длина всех фокальных линий (суммарное количество всех промежуточных точек)
                        //uint LengthLine;    // длина фокальной линии (количество промежуточных точек вдоль фокальной линии)
    uint nLine;         // количество фокальных линий по всему графическому тексту.
    
    // максимальное количество фокальных линий выходящих из особой точки фиксированно и равно 4.
    int nLinePoint=4;
    
    int startSlice=0; //номер стартового слайса для цикла распознавания отдельно стоящих кругов
    
    // Координаты смещения маски по входящим или выходящим точкам пересечения фокальные линии с маской.
    // Реализуется один из двух вариантов смещения (на величину dl1 или dl2) и записывается в dl0.
    int dl0,dl1,dl2; // [-32768, 32768]
                     // текущие координаты положения маски в абсолютной линейно строчной системе координат (отсчитываются от начала скана).
    int sl,sl1,sl_;
    // координаты предыдущего положения маски в абсолютной линейно строчной системе координат (отсчитываются от начала скана).
    int sl_old;
    // текущие координаты положения маски в абсолютной декартовой системе координат (отсчитываются от начала скана).
    int x0,y0; // по факту координаты "x" и "y" особой точки.
    
    
    // инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный.
    //for ( int i=0; i < w_h_64; i++ ) { bytes_data0_64[i]=~bytes_data0_64[i]; } // по 8 байт одновременно // time=0.005 w*h=10 млн. пикселей.
    
    // подготовка массива для поиска еще не оцифрованных линий, копирование в bytes_data_1
    // исходной битовой картинки фокальнах линий (0-белый 255-черный).
    memcpy(bytes_data_1, bytes_data, w_h);  // адрес буфера назначения, адрес источника, количество байт для
                                            /// Цикл перебора особых точек по всему графическому тексту. ///
    nLine=0;  SumLengthLine=0;
    

    initStarArray();  //инициализация массива звездочек
    int needProcess=1;
    int mode=0;
    int pointIndex=0;
    
    // распознавание линий проводится в три этапа. Сначала распознаем линии
    // выходящие из T и X точек
    while (needProcess) {
        for(np=pointIndex; np < sizeAdr; np++) {   //количество точек sizeAdr меняется за время выполнения цикла
            // координаты начальной особой (фокальной) точки в Декартовой системе координат.
            OCRPoint &point=focalPoint[np];
            OCRStar &startStar=starArray[np];
            
            if(point.type==Z_POINT){
                startStar.lineCount=0;
                startStar.starCount=0;
                //стираем точку из массива занятости
                bytes_data_1[point.y * w + point.x]=127;
                
            }

            if(mode==0 && (point.type !=T_POINT && point.type !=X_POINT))continue;
            else if (mode>0){
                if(point.type !=L_POINT)continue;
                //проверяем точку в массиве занятости
                if( bytes_data_1[point.y * w + point.x]==127)continue;
            }
            //cout<<endl<<"np:"<<np<<" point x:"<<point.x<<" y:"<<point.y<<" t:"<<(int)point.type<<endl;



            x0=point.x;  // [-32768, 32768]
            y0=point.y;

            // координаты особой фокальной точки в линейно строчной системе координат для
            // центральной точки маски d1.
            sl=y0 * w + x0;

            // координаты особой фокальной точки в линейно строчной системе координат для
            // байтового регистра rg0.
            p0=bytes_data + sl - w - 1;  // координаты смещены в левый верхний угол маски на
                                           // 1 pix относительно ее центральной точки d1
            
            // сборка байтового регистра rg0 из отдельных 8 бит матрицы с помощью единичных масок (единица д.б.- строго 255 (11111111)).
            // координаты отсчитываются с левого верхнего угла матрицы.
            rg0=(*(p0)&1) + (*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w+2)&16) + (*(p0+w+w)&32) + (*(p0+w+w+1)&64) + (*(p0+w+w+2)&128);
            
            // получение количества фокальных линий выходящих из особых точек
            //(соответственно // 3,4,1).
            nLinePoint=point.type;

            // ответ таблицы table_3 (long) с координатами начала фокальных линий.
            rg_tab3=table_3[rg0];
            /// cout<<"распакованный table_3="<<table_3<<endl;

            /// Сохранение адресов первой точки фокальной линии (особой точки) в структуру
            p_start.x=x0;  // адрес первой точки фокальной линии в декартовых координатах "x"
            p_start.y=y0;  // адрес первой точки фокальной линии в декартовых координатах "y"


            // Заполнение массива занятости только особыми точками линий.
            bytes_data_1[sl]=127;

            /// Цикл перебора фокальных линий выходящих из особой точки. ///
            p1=p0;
            sl1=sl;  // сохраняем значения p0 и sl т.к. в следующим цикле они необратимо
                       // модифицируются.

            for(nl=0; nl < nLinePoint; nl++) {
                if(startStar.star[nl] !=0xFFFFFFFF) continue;  //линия уже просчитана

                // точка перед стартовой точкой линии. Соответствует координатам особой точки.
                sl_old=sl1;  // по смыслу sl_old=sl, но в этом цикле sl модифицируется

                // Распаковка координат из table_3 (long) в "nl" знаковых short с координатами
                // начала фокальных линий.
                dl_nl=*((short *)&rg_tab3 + nl);  // “nl” номер стартовой точки.

               // cout<<"dl0:"<<*((short*)&rg_tab3+0)<<" dl1:"<<*((short*)&rg_tab3+1)<<" dl2:"
               // <<*((short*)&rg_tab3+2)<<" dl3:"<<*((short*)&rg_tab3+3)<<endl;

                // Следующая точка линии после особой точки, т.е. стартовая точка линии. //
                p0=p1 + dl_nl;
                // координаты стартовой точки для байтового регистра rg0 (маски)
                sl=sl1 + dl_nl;
                // координаты стартовой точки для центральной точки маски d1.
                
                //cout<<"p_start.x:"<<sl%w<<" p_start.y:"<<sl/w<<endl;
                //cout<<"start line nl:"<<nl<<endl;

                /// Сохранение адресов второй точки фокальной линии (стартовой точки) в
                /// структуру ///
                p_line.x=sl % w;  // адрес второй точки фокальной линии, в декартовых
                                  // координатах "x"(short).
                p_line.y=sl/w;    // адрес второй точки фокальной линии, в декартовых
                                  // координатах "y"(short).

                OCRLine lineP;
                lineP.lenA=0;
                lineP.pointIndex=pCount;
                pointArray.resize(pCount + ncolumns * 2 + 256);
                OCRPoint *linePdata=(OCRPoint *)&pointArray[pCount];

                linePdata[0]=p_start;  // сохраняем первую точку линии (особую точку).
                linePdata[1]=p_line;  // сохраняем вторую точку линии (стартовую точку).
                // Длина фокальной линии состоящая из всех pix.
                // Начальное значение содержит стартовую и вторую точку.
                lineP.lenA=2;
                lineP.start.data=startStar.index;  // сохраняем индекс первой звездочки в стартовой точке


                int flag=1;  // флаг проверки необходимости создания новой линии
                if(bytes_data_1[sl]==127) flag=0;   //линия уже просчитана или нулевой длины
                
                /// Цикл перебора точек фокальных линий и вычисление их координат ///
                //  Цикл обеспечивает движение маски вдоль фокальной линии и принятие решения с
                //  помощью таблицы о направлении движения.
                rg_tab2=1;
                // остановка цикла по условию особой точки rg_tab2==0
                for(index=0; rg_tab2 !=0; index++) {
                    // Сборка байтового регистра rg0 из отдельных 8 бит матрицы с помощью
                    // единичной маски. Координаты отсчитываются с левого верхнего угла
                    // матрицы. Байты из памяти читаются почти подряд.
                    // d9=rg0 & 1;     d2=rg0>>1 & 1; d3=rg0>>2 & 1; d8=rg0>>3 & 1; d4=rg0>>4 & 1;   d7=rg0>>5 & 1;  d6=rg0>>6 & 1;      d5=rg0>>7 & 1;
                    rg0=(*(p0)&1) + (*(p0+1)&2) +  (*(p0+2)&4) +  (*(p0+w)&8) +  (*(p0+w+2)&16) + (*(p0+w+w)&32) + (*(p0+w+w+1)&64) + (*(p0+w+w+2)&128);

                    // После распаковки в основном цикле получаем тот же регистр rg0 с той-же
                    // последовательностью битов.

                    // Ответ таблицы int table_2 с двумя вариантами смещения маски на dl1 или
                    // dl2.
                    rg_tab2=table_2[rg0];

                    // Если текущая точка - это обычная точка фокальной линии (не является
                    // особой точкой фокальной линии).
                    if(rg_tab2 !=0 && flag) {  // условие особой точки rg_tab2==0.

                        // Распаковка координат из table_2 (int) в два знаковых short с двумя
                        // вариантами смещения маски на dl1 или dl2.
                        dl1=*(short *)&rg_tab2;
                        dl2=*((short *)&rg_tab2 + 1);
                        // После распаковки  координат получаем два short dl1 и dl2 (16р).

                        // Вывод графики и пояснения

                        // d9   d2   d3           0    1   0           1    0   1         -w-1   -w   1-w         1   2   4

                        // d8   d1   d4           1        1           0        0          -1           1         8       16

                        // d7   d6   d5           0    1   0           1    0   1          w-1    w   w+1         32  64 128

                        // Распакованная координата входящей и выходящей точки по шаблону.
                        // Заполнение таблиц (массива) занятости адресов промежуточных точек фокальной линии.
                        bytes_data_1[sl]=127;

                        // заполняем всю линию 127 от начальной стартовой до конечной стартовой точки включительно

                        // Запоминаем адрес sl до изменения, т.к. адрес sl+dl1 или sl+dl2 будет
                        // относится уже к следующей итерации. Запоминаем текущее положение
                        // маски, до модификации sl с помощью dl1 или dl2
                        sl_=sl;

                        // координаты маски в следующей итерации в абсолютной линейной системе координат.
                        if ( sl+dl1==sl_old ) { sl+=dl2; p0+=dl2; dl0=dl2; }  // это следующая стартовая точка.
                        if ( sl+dl2==sl_old ) { sl+=dl1; p0+=dl1; dl0=dl1; }  // или эта

                        
                        // запоминаем текущее положение маски, которое для следующей итерации
                        // будет стартовым, не мешая установки начальных условий sl_old=y0*w+x0;
                        sl_old=sl_;

                        /// Координаты точек линии от следующий после стартовой до конечной
                        /// особой точки, т.е. все сдвинуто вперед на pix. ///

                        /// Сохранение координат промежуточных точек в структуру (стартовая и
                        /// первая точка сохранены раньше) ///
                        p_line.x=sl % w;  // координата текущей точки фокальной линии, в
                                          // декартовых координатах по "x"(short).
                        p_line.y=sl/w;    // координата текущей точки фокальной линии, в
                                          // декартовых координатах по "y"(short).
                        // оч. быстро, добавляет меньше чем time=0.001
                        
                        // сохраняем характеристики промежуточных точек в структуру lineP.
                        // для массивов адресов от следующий после стартовой точки до конца.
                        linePdata[lineP.lenA]=p_line;
                        lineP.lenA++;  // Длина фокальной линии в pix.
                        //if(lineP.lenA>1024)break;
                    } else {           // if (rg_tab2!=0)
                        if(!flag && rg_tab2) break;
                        //если вторая точка линии не фокальная и уже просчитана, прерываем цикл набора линии
                        //не создаем новую линию (flag==0)
                        
                        //если вторая точка линии это фокальная точка (rg_tab2==0)
                        //создаем новую линию нулевой длины и записываем ее данные в OCRStar
                        flag=1;
                        break;
                    }
                }  // index

                //--------------------------------------------------------------------------------------
                // если линию не нужно заносить в базу, продолжаем цикл распознования линий из
                // этой точки
                if(!flag) continue;

                // Запись в структуру OCRLine

                // узнаем id номер конечной фокальной точки
                x0=sl % w;  // координата текущей точки фокальной линии, в декартовых
                              // координатах по "x"(short).
                y0=sl/w;  // координата текущей точки фокальной линии, в декартовых
                              // координатах по "y"(short).
                bytes_data_1[sl]=127;
                lineP.start=linePdata[0];
                endID=id_data[y0 * w + x0] - 1;  //y 795  x 1177
                // в поисковом массиве id_data id номер больше на единицу
                // cout<<"/#/___ x0:"<<x0<<" y0"<<y0<<" endID:"<<endID<<endl;
                if(endID > -1){
                    lineP.end=focalPoint[endID];
                }else{
                    lineP.end = lineP.start; //линия круга или точки
                }
                lineP.index=(int)focalLine.size();
                // Сохранение типа стартовой особой точки в объект линия.
                lineP.start.type=point.type;

                // Сохранение типа конечной особой точки в объект линия.
                // расстояние до конечной точки без учета экстремумов.
                lineP.length=
                    sqrt((lineP.start.x - lineP.end.x) * (lineP.start.x - lineP.end.x) +
                         (lineP.start.y - lineP.end.y) * (lineP.start.y - lineP.end.y));
                lineP.lenE0=lineP.lenE1=lineP.length;
                lineP.extremCount=0;
                lineP.type=BASE_LINE;
                lineP.end.data=endID;
                lineP.index=(int)focalLine.size();
                lineP.startID=startStar.index;
                lineP.endID=endID;
                pCount +=lineP.lenA;  // длина линии
                if(mode>1){  //для фокальных линий отдельно стоящего круга
                    endID=lineP.startID+1;
                    lineP.endID=endID;
                    lineP.end=lineP.start;
                    lineP.length=0;
                    //заполняем временный разрыв фокальной линии круга
                    linePdata[lineP.lenA]=lineP.start;
                    lineP.lenA++;
                    pCount++;
                }
                focalLine.push_back(lineP);
                if(focalLine.size()>100000)break;

                // если в конечной точке линии сходится несколько линий, то
                // определяем в какой порядковый номер в массиве линий конечной
                // звездочки должна быть записана эта линия.
                int id=0;
                if(lineP.end.type !=L_POINT) {
                    // запрашиваем table_3 и получаем  значение порядка смещений для набора
                    // данных линий (порядок линий звездочки).
                    long long rg_tab=table_3[rg0];
                    short    *sl_table=(short *)&rg_tab;
                    short     dl_test=sl_old - sl;
                    
                    if(dl_test==sl_table[1])      id=1;
                    else if(dl_test==sl_table[2]) id=2;
                    else if(dl_test==sl_table[3]) id=3;
                }

                // записываем данные в звездочки конца и начала линии.
                setEndStar(startStar, lineP, endID, nl, id, np);
            }  // for (nl=0;

        }  // for (np=0;
        mode++;
        
        if(mode>1){
            //после распознавания фокальных линий Х, Т и L точек
            //выполняем распознавание отдельно стоящих кругов и пиксельных точек
            //для каждого черного слайса текста проверяем все ли фокальные линии в нем распознаны
            needProcess=0;
            // цикл обеспечивает обработку (эррозию) только черных пикселей в тексте (точки d1),
            // перепрыгивая через белые области.
            //uchar *pw=bytes_data_1 + w + 1;  // w_1=(w+1); смещение с угла в центр матрицы (маски)
            uchar *pw=bytes_data_1;
            for(int g=startSlice; g < sizeBufSR; g +=2) {  //  w_h_=w*h-(w+w+4);  // time=0.18/2  только цикл
                                                  //  ( n_Lay=7, w*h=4 млн. пикселей )
                                                  // цикл обеспечивает удаление точки контура d1 с помощью таблицы.
                for(int x=BufS[g]; x < BufS[g + 1]; x++) {
                    if(*(pw + x) == 255) {
                        setStarInCircle(x);
                        //создаем разрыв в фокальной линии круга
                        *(bytes_data + x + 1)=0;
                        *(bytes_data_1 + x + 1)=0;
                        *(bytes_data + x + w)=0;
                        *(bytes_data_1 + x + w)=0;
                        *(bytes_data + x + w + 1)=0;
                        *(bytes_data_1 + x + w + 1)=0;

                        //в массиве занятости отмечаем новую точку как не занятую
                        *(bytes_data_1 + x)=0;
                        
                        //возвращаемся к циклу распознавания фокальных линий
                        //и распознаем фокальную линию круга
                        needProcess=1;
                        sizeAdr+=2;
                        pointIndex=(int)focalPoint.size()-2;
                        startSlice=g;
                        break;
                    }
                }
                if(needProcess) break;
            }
        }
        
    }  // while (needProcess);
    

    // приведение массива к общепринятому стандарту, 0-черный 255-белый ( внутренний формат
    // программы 0-белый 255-черный ). по 1 байту,  time=0.03  w_h=w*h=10 млн. пикселей.
    /// for ( i=0; i < w_h; i++ ) { if (bytes_data[i]>0) bytes_data[i]=0;  else
    /// bytes_data[i]=255; }
    // по 8 байт одновременно, time=0.005  w*h=10 млн. пикселей.
    //for(i=0; i < w_h_64; i++) {bytes_data0_64[i]=~bytes_data0_64[i];}

    // освобождение массивов
    if(bytes_data_1 !=NULL) free(bytes_data_1);

    pointArray.resize(pCount);  // освобождаем память занятую не инициализированными точками.

    if(GrafT) DG("\nколичество фокальных линий: "<<focalLine.size());

    //printSVG("/_Image2OCR/_2Draw_text1.svg");
    //cout<<" starArray:"<<starArray.size()<<endl;
    
    // Возвращаем количество фокальных линий по всему графическому тексту.
    return (int)focalLine.size();

}  //_____________________________________________________________
    
    
void GGraph::initStarArray() {
    /** Заполняем массив starArray инициализированными структурами OCRStar (звездочками)
     копируем из фокальной точки тип точки и ее координаты.
     количество звездочек соответствует количеству фокальных точек
     для правильного выделения линий нулевой длины, соединяющей смежные фокальные точки
     в массиве bytes_data_1 отмечаем все фокальные точки как распознанные
     */
    
    // количество особых точек по всему графическому тексту.
    uint sizeAdr=(int)focalPoint.size();
    starArray.resize(sizeAdr);
    
    for(uint np=0; np < sizeAdr; np++) {
        OCRPoint &point=focalPoint[np];
        OCRStar & star=starArray[np];
        star.index=np;
        star.cPoint=point;
        star.type=point.type;
        star.starCount=point.type;
        star.lineCount=point.type;
        if(star.type==Z_POINT) {
            star.starCount=0;
            star.lineCount=0;
        }
        star.level=0;
        star.minLen=255;
        memset((char *)star.star, 255, 48);
        //заполнение каждой ячейки массива star.star значением  0xFFFFFFFF
    }
    
}  //____________________________________________________________

/** @bref запись данных в OCRStar на конце фокальной линии */
void GGraph::setEndStar( OCRStar &startStar,
                         OCRLine &lineP,
                         int endID,
                         int nl,
                         int id,
                         int np) {
    /** после формирования линии необходимо записать в структуры OCRStar(звездочки)
     расположенных по координатам фокальных точек концов линии информацию о том что эти
     звездочки соединены линией с соответствующим id номером */
    
    OCRStar &endStar=starArray[endID];
    //взаимно записываем id номера соединенных звездочек
    //и записываем в звездочки копии векторов звездочки
    startStar.star[nl]=endID;
    startStar.line[nl]=lineP.index;
    startStar.dir[nl]=1;  //маркируем линию как исходящую из звездочки
    if(startStar.minLen > lineP.lenA) startStar.minLen=lineP.lenA;
    // cout<<"end.id:"<<endID<<" end.type:"<<(int)endStar.type<<" end.x:"<<lineP.end.x<<"
    // end.y:"
    //    <<lineP.end.y<<" l:"<<(int)lineP.lenA<<endl;
    endStar.star[id]=np;
    endStar.line[id]=lineP.index;
    if(endStar.minLen > lineP.lenA) endStar.minLen=lineP.lenA;
    endStar.dir[id]=0;  //маркируем линию как входящую в звездочку
    
}//____________________________________________________________

/** @bref запись данных в OCRStar фокальной линии круга*/
void GGraph::setStarInCircle(int x){
    
    OCRPoint newPoint;
    newPoint.y=x/ncolumns;
    newPoint.x=x%ncolumns;
    newPoint.type=L_POINT;
    focalPoint.push_back(newPoint);
    focalPoint.push_back(newPoint);
    //формируем новую OCRStar
    OCRStar newStar;
    newStar.index=(uint)starArray.size();
    newStar.cPoint=newPoint;
    newStar.type=L_POINT;
    newStar.starCount=1;
    newStar.lineCount=1;
    newStar.level=0;
    newStar.minLen=255;
    memset((char *)newStar.star, 255, 16);
    newStar.line[0]=(int)focalLine.size();
    newStar.star[0]=0xFFFFFFFF;
    starArray.push_back(newStar);
    newStar.index=(uint)starArray.size();
    starArray.push_back(newStar);
    //две OCRStar мы добавляем для того чтобы сохранить логику записи линий в OCRStar
    //линия выходит из одной OCRStar и приходит в другую.
    //заполнение каждой ячейки массива star.star значением  0xFFFFFFFF
    
    
}//___________________________________________________________________

void GGraph::initID() {
    if(initID_flag) return;
    int pointCount=(int)focalPoint.size();
    
    id_data=(ushort *)malloc(ncolumns * nrows * 2);
    bites_data_32=0;
    
    memset(id_data, 0, ncolumns * nrows * 2);
    for(int n=0; n < pointCount; n++) {
        OCRPoint p=focalPoint[n];
        id_data[p.y * ncolumns + p.x]=n + 1;
        //cout<<n<<" x:"<<p.x<<" y:"<<p.y<<" sl:"<<p.y * ncolumns + p.x<<endl;
    }
    initID_flag=1;   //y 795  x 1177
}
//------------------------------------------------------------------------------------------------------


}  // namespace ocr
