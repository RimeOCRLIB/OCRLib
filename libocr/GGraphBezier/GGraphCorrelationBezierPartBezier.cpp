//  Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .

#include "GGraphBezier.h"
#include <math.h> 


namespace ocr{

    
    // *****************************************************************************
    
                    /// Correlation Bezier1 /// основная рабочая версия.
    
    // Функция для сравнения (корреляции) одной кривой Безье с частью другой кривой Безье.
    float GGraphBezier::CorrelationBezierPart(OCRFocalLineBezier &line1, OCRFocalLineBezier &line2, OCRFocalLineBezier &line3){

        // Функция осуществляет сравнение короткой линии N1 с частью длинной линии N2.
        // На вход получает ID номера сравниваемых линий.
        // Возвращает полный коэффициент корреляции кривых Безье N1 и N3, где кривая N3 вычисляется как часть N2.        
        // Короткая линия приладывается к началу длинной образуя линию N3.
        // Линия N3 сейчас сохраняется в линии N2 (OCRFocalLineBezier &line3 не используется).

        // Каждая кривая Безье произошла от сглаженной фокальной линии, поэтому можно считать координаты
        // (по таблице) не по кривым Безье, а по соответствующим им сглаженным фокальным линиям.
        // Каждой сглаженной фокальной линии можно сопоставить кривую Безье. Сопоставление кривых Безье
        // со сглаженным фокальным линиям осуществляется по четырем точкам фокальных линий:
        // начальной точки, точки 1/3 длины, точки 2/3 длины и конечной точки.
        // По сути выполняется апроксимация сглаженных фокальных линий еще более гладкими
        // кривыми Безье. Это особенно важно в начале и в конце кривых, где сглаживание не эффективно.
        // Кривые Безье удобно использовать для сравнения и визуализации.
        // Две кривые Безье считаем равными, если совпадают начальные и конечные точки, а также их управляющие вектора.
        // Визуализация кривых легко выполняется с помощью управляющих векторов.

        
        
        int GrafT=1;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if(GrafT){
            cout<<endl<<"----------------------------------------------------------------------------"<<endl;
            cout<<endl<<"Функция для сравнения одной кривой с частью другой кривой Безье.   CorrelationBezierPart() "<<endl;
        }
        
        // Проверка самой короткой линии из двух сравниваемых линий.
        // Длина сглаженной фокальной линии N1 и N2.
        float lenM1=line1.lenM;        float lenM2=line2.lenM;
        // Линия N2 д.б. всегда более длинная чем N1.
        if (lenM2 < lenM1) { cout<<endl<<"return CorrelationBezier lenM1>lenM2"<<endl<<endl; return 0;}
        if(GrafT)cout<<"lenM1="<<lenM1<<"   lenM2="<<lenM2<<endl;

        
        // Кривая Безье N1.
        float line1_alphaP1=line1.alphaP1;  // угол наклона первого контрольного вектора кривой Безье N1.
        // Кривая Безье N2.
        float line2_alphaP1=line2.alphaP1;  // угол наклона первого контрольного вектора кривой Безье N2.
        /**/
        
        // При коэффициенте корреляции больше порога, принимаем решение, что короткая линии N1 является частью длинной линии N2.
        float dlt_max=75;   // Максимальный порог коэффициента корреляции уголов (от-100 до 100).
        // При коэффициенте корреляции меньше порога, выходим из функции.
        float dlt_min=25;   //  50  Минимальный порог коэффициента корреляции уголов (от-100 до 100).
        float nr111=1.11111111; // 100.0/90.0
        
        // Угол между прямыми (контрольными векторами) – это меньший угол.       
        // Знаковый коэффициент корреляции двух линий по углам,
        // разности углов: 0° 90° 180° 270° 360°, соответствует коэффициент корреляции: 100%  0  100%  0  100%.
        // Особенности вычисления коэффициента корреляции подробно разобраны и нарисованы в функции buildOCRAlphaTable().
        
        // проверить принадлежат ли P1 к общему началу линий ? Реверс //////////////////////////////////
        // Используется без знаковый коэффициент корреляции двух линий по углам, как не чуствительный к реверсу.
        // Коэффициент корреляции углов между контрольными векторами P1 кривых Безье N1 и N2.
        float deltaAlpha=fabs(line1_alphaP1-line2_alphaP1); // абсолютное значение разности углов контрольных векторов.
        if (deltaAlpha>180) deltaAlpha=360-deltaAlpha;  // абсолютное значение разности углов двух контрольных векторов не м.б. больше 180°.
        if (deltaAlpha>90) deltaAlpha=180-deltaAlpha;   // абсолютное значение разности углов контрольных векторов не м.б. больше 90° grade.
        ///if (deltaAlpha>90) {deltaAlpha=180-deltaAlpha; CorAlphaL=-100+nr111*deltaAlpha;}  else CorAlphaL=100-nr111*deltaAlpha;
        float CorAlphaP1=100-nr111*deltaAlpha;  // Коэффициент корреляции двух векторов по углам (0-100%).
        if(GrafT){
            cout<<"line1_alphaP1="<<line1_alphaP1<<"     line2_alphaP1="<<line2_alphaP1<<endl;
            cout<<"deltaAlpha="<<deltaAlpha<<"     Разность углов между векторами P1 кривых Безье N1 и N2"<<endl;
            cout<<"Коэффициент корреляции углов между контрольными векторами P1 кривых Безье N1 и N2.   CorAlphaP1="<<CorAlphaP1<<"%"<<endl;
        }
        // Выходим из функции, если коэффициент корреляции уголов между контрольными векторами P1 маленький.
        if (CorAlphaP1 < dlt_min) { cout<<"1 return CorrelationBezier CorAlphaP1<"<<dlt_min<<"%"<<endl<<endl;     return 0;}

        
        // Характеристики исходной короткой линии N1 и сопоставленой ей кривой Безье N2 уже известы //
        // (подсчитаны в GGraphBezierFocalLineRecBezier.cpp) //
        
        // фокальная линия N1
        //
        // 0                  t_13               t_23                 t
        // I-------------------I------------------I-------------------I
        // 0                  1/3                2/3               1*lineM1
        //
        //
        // фокальная линия N2
        //
        // 0                   t_13                t_23    окончание фокальной линия N3
        // I--------------------I-------------------I-------------------I-----------------------I
        // 0                   1/3                 2/3              1*lineM1                1*lineM2
        //

        
        // Вычисление параметров управляющих векторов кривой Безье N3, где кривая N3 вычисляется
        // как часть фокальной линии N2. Кривая N3 сохраняется на место кривой N2 (line2).
        focalLineBezierP(line2, 0, lenM1); // 0,0 по полной длине.
        // int strL - расстояние от начала фокальной до начала части фокальной линии.
        // int endL - расстояние от начала фокальной до конца части фокальной линии.

        /// Вычисление суммарного коэффициента корреляции соответствующих трех пар векторов кривых Безье. ///
        
        // Функция для сравнения (корреляции) двух кривых Безье по всем векторам.
        ///float CorAlphaSUM=CorrelationBezierA(line1, line3, 0);
        float CorAlphaSUM=CorrelationBezierA(line1, line2, 1); ////////////// надо 0
        // 0 коэффициент корреляции не зависит от масштаба (зависит от поворота кривых Безье).
        // 1 коэффициент корреляции не зависит от масштаба и от поворота кривых Безье.
        if(GrafT)cout<<"коэффициент корреляции углов кривых Безье N1 и N3.   CorAlphaSUM=CorrelationBezierA()="<<CorAlphaSUM<<"%"<<endl;
        
        
        // При коэффициенте корреляции меньше порога, принимаем решение, что короткая линии N1 НЕ является частью длинной линии N2.
        if (CorAlphaSUM < dlt_max) {
            CorAlphaSUM=0;
            if(GrafT)cout<<"короткая линии N1 НЕ является частью длинной линии N2.   CorAlphaSUM="<<CorAlphaSUM<<"%"<<endl<<endl;
            } else {
            if(GrafT)cout<<"короткая линии N1 является частью длинной линии N2     CorAlphaSUM="<<CorAlphaSUM<<"%"<<endl<<endl;
            }
        
        // Возвращаем суммарный коэффициент корреляции двух кривых Безье.
        return CorAlphaSUM;
        // CorAlphaSUM=0    короткая линии N1 НЕ является частью длинной линии N2.
        // CorAlphaSUM>0    короткая линии N1 является частью длинной линии N2 с коэффициентом корреляции CorAlphaSUM.

        
        // Базовое правило вычитания углов. //
        // Если одна прямая имеет отрицательный угловой коэффициент, а вторая положительный,
        // то угол между этими прямыми будет равен сумме абсолютных величин этих углов.
        // В случае же, когда угловые коэффициенты оба отрицательны или оба положительны,
        // то угол находится путем вычитания из большего угла меньшего.
        // В рассматриваемом примере получим, что угол между прямыми равен |34| + |-31| = 34 + 31 = 65 градусов.
        // http://www.kakprosto.ru/kak-126210-kak-opredelit-ugol-mezhdu-dvumya-pryamymi
        
        // gPort.mm  570стр
        // таблица в гр порту:
        // 1. id number
        // 1. len
        // 1. alpha°
        // 1. lenP1
        // 1. alphaP1°
        // 1. lenP2
        // 1. alphaP2°
        // 1. lenA
        // 1. lenM
        // 1. lenBf
        // 1. lenBff
      /**/
        
        
        /*
         // получение указателей на таблицу фокальных линий N1 и N2.
         // Таблица позволяет найти координаты x,y по расстоянию вдоль фокальной линии.
         OCRRointFloat *mTab=(OCRRointFloat*)&line2.mTab[0];    // получаем указатель mTab.
         if(GrafT)cout<<"     line2.mTab.size()="<<line2.mTab.size()<<endl<<endl;
        float x0, y0, x1, y1, x2, y2, x3, y3; // Декартовы координаты исходных точек фокальной линии N3 (mTab).
        
        //int lenA_=line2.lenA-1;     // количество пикселов линии-1.
        float t_13=lenM1*0.33333;   // расстояние вдоль длины фокальной линии N1 при t=L*1/3.
        int t13=(int)t_13;          // целая часть расстояния вдоль длины фокальной линии при t=L*1/3.
        float t_23=lenM1*0.66667;   // расстояние вдоль длины фокальной линии N1 при t=L*2/3.
        int t23=(int)t_23;          // целая часть расстояния вдоль длины фокальной линии при t=L*2/3.
        float t_1=lenM1;            // расстояние вдоль длины фокальной линии N1 при t=L*1.
        int t1=(int)t_1;            // целая часть расстояния вдоль длины фокальной линии N1 при t=L*1.
        if(GrafT)cout<<"t_13="<<t_13<<"     t_23="<<t_23<<"     lenM1="<<lenM1<<endl;
        
        
        // Вычисление характеристик проекции N3 короткой линии N1 на длинную линию N2 //
        
        // Получаем координаты начальных точек фокальной линии N2.
        x0=line2.start.x;    y0=line2.start.y;    // координаты начала фокальной линии при t2=0. ////////////////////////////////
        
        // Вычисленные координат трех исходных точек: 1/3 длины, 2/3 длины и конечной точки,
        // без линейной интерполяции, что быстрее, но чуть менее точно.
        OCRRointFloat & mTab_t13=mTab[t13];
        OCRRointFloat & mTab_t23=mTab[t23];
        OCRRointFloat & mTab_t1=mTab[t1];
        x1=mTab_t13.x;         y1=mTab_t13.y;
        x2=mTab_t23.x;         y2=mTab_t23.y;
        x3=mTab_t1.x;          y3=mTab_t1.y;
        if(GrafT)cout<<"x1="<<x1<<"  y1="<<y1<<"  x2="<<x2<<"  y2="<<y2<<"  x3="<<x3<<"  y3="<<y3<<endl;
        */
        
        
    }//____________________________________________________________________________
    
    
    
    // *****************************************************************************
 
    
    
    
    
  /*
    
    // *****************************************************************************
    
            // рабрчая резервная копия предидущей версии на досчете
                        /// Correlation Bezier1 ///
    
    // Функция для сравнения (корреляции) одной кривой Безье с частью другой кривой Безье.
    float GGraphBezier::CorrelationBezier1(OCRFocalLineBezier &line1, OCRFocalLineBezier &line2, OCRFocalLineBezier &line3){
        
        // Функция осуществляет сравнение короткой линии N1 с частью длинной линии N2.
        // На вход получает ID номера сравниваемых линий.
        // Возвращает полный коэффициент корреляции кривых Безье N1 и N3, где кривая N3 вычисляется как часть N2.
        // Короткая линия приладывается к началу длинной образуя линию N3.
        
        // Каждая кривая Безье произошла от сглаженной фокальной линии, поэтому можно сравнивать не кривые Безье,
        // а соответствующие им сглаженные фокальные линии. Каждой сглаженной фокальной линии можно сопоставить кривую Безье.
        // Сопоставление кривых Безье со сглаженным фокальным линиям осуществляется по четырем точкам фокальных линий:
        // начальной точки, точки 1/3 длины, точки 2/3 длины и конечной точки.
        // По сути выполняется апроксимация сглаженных фокальных линий еще более гладкими
        // кривыми Безье. Это особенно важно в начале и в конце кривых, где сглаживание не эффективно.
        // Кривые Безье удобно использовать для сравнения и визуализации.
        // Две кривые Безье считаем равными, если совпадают начальные и конечные точки, а также их управляющие точки.
        // Визуализация кривых легко выполняется с помощью управляющих точек.
        
        
        
        int GrafT=1;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if(GrafT){
            cout<<endl<<"----------------------------------------------------------------------------"<<endl;
            cout<<endl<<"Функция для сравнения одной кривой с частью другой кривой Безье.   CorrelationBezier1() "<<endl;
        }
        
        // Проверка самой короткой линии из двух сравниваемых линий.
        // Длина сглаженной фокальной линии N1 и N2.
        float lenM1=line1.lenM;        float lenM2=line2.lenM;
        // Линия N2 д.б. всегда более длинная чем N1.
        if (lenM2 < lenM1) { cout<<endl<<"return CorrelationBezier lenM1>lenM2"<<endl<<endl; return 0;}
        if(GrafT)cout<<"lenM1="<<lenM1<<"   lenM2="<<lenM2<<endl;
        
        
        // Кривая Безье N1.
        //float line1_len=line1.len;          // длина опорной линии, проведенной от начальной 0 до конечной 3 точки кривой Безье N1.
        //float line1_alpha=line1.alpha;      // угол между опорной линией кривой Безье N1 и горизонталью.
        //float line1_lenP1=line1.lenP1;      // длина первого контрольного вектора кривой Безье N1.
        float line1_alphaP1=line1.alphaP1;  // угол наклона первого контрольного вектора кривой Безье N1.
        //float line1_lenP2=line1.lenP2;      // длина второго контрольного вектора кривой Безье N1.
        //float line1_alphaP2=line1.alphaP2;  // угол наклона второго контрольного вектора кривой Безье N1.
        
        // Кривая Безье N2.
        ///float line2_len=line2.len;          // длина опорной линии, проведенной от начальной 0 до конечной 3 точки кривой Безье N2.
        ///float line2_alpha=line2.alpha;      // угол между опорной линией кривой Безье N2 и горизонталью.
        ///float line2_lenP1=line2.lenP1;      // длина первого контрольного вектора кривой Безье N2.
        float line2_alphaP1=line2.alphaP1;  // угол наклона первого контрольного вектора кривой Безье N2.
        ///float line2_lenP2=line2.lenP2;      // длина второго контрольного вектора кривой Безье N2.
        ///float line2_alphaP2=line2.alphaP2;  // угол наклона второго контрольного вектора кривой Безье N2.
    
        
        
        // При коэффициенте корреляции больше порога, принимаем решение, что короткая линии N1 является частью длинной линии N2.
        float dlt_max=75;   // Максимальный порог коэффициента корреляции уголов (от-100 до 100).
        // При коэффициенте корреляции меньше порога, выходим из функции.
        float dlt_min=25;   //  50  Минимальный порог коэффициента корреляции уголов (от-100 до 100).
        
        // Угол между прямыми – это меньший угол, и лежит в диапазоне от 0° до +90° (конци линии симметричны), при этом
        // коэффициент корреляции изменяется от 100% до 0.
        // Угол между контрольными векторами кривых Безье – это меньший угол, и лежит в диапазоне от 0° до +180°.
        // У векторов есть начало, есть конец. Углам: 0° +90° +180°, соответствует коэффициент корреляции: 100%  0 -100%.
        
        
        // Коэффициент корреляции углов между контрольными векторами P1 кривых Безье N1 и N2.
        float deltaAlpha=fabs(line1_alphaP1-line2_alphaP1); // абсолютное значение разности углов контрольных векторов.
        if (deltaAlpha>180) deltaAlpha=360-deltaAlpha; // абсолютное значение разности углов двух контрольных векторов не м.б. больше 180°.
        if (deltaAlpha>90) deltaAlpha=180-deltaAlpha;// абсолютное значение разности углов контрольных векторов не м.б. больше 90° grade.
        float CorAlphaP1=100-100*deltaAlpha/90;  // Коэффициент корреляции двух векторов по углам (0-100%).
        if(GrafT){
            cout<<"line1_alphaP1="<<line1_alphaP1<<"     line2_alphaP1="<<line2_alphaP1<<endl;
            cout<<"deltaAlpha="<<deltaAlpha<<"     Разность углов между векторами P1 кривых Безье N1 и N2"<<endl;
            cout<<"Коэффициент корреляции углов между контрольными векторами P1 кривых Безье N1 и N2.   CorAlphaP1="<<CorAlphaP1<<"%"<<endl;
        }
        // Выходим из функции, если коэффициент корреляции уголов между контрольными векторами P1 маленький.
        if (CorAlphaP1 < dlt_min) { cout<<"1 return CorrelationBezier CorAlphaP1<"<<dlt_min<<"%"<<endl<<endl;     return 0;}
        
        
        // получение указателей на массивы сглаженных координат точек фокальных линий N1 и N2.
        OCRRointFloat *mData2=(OCRRointFloat*)&line2.mData[0];
        // получение указателей на массивы интегральных сумм длины сглаженной фокальных линий N1 и N2.
        float *sLine2=(float*)&line2.sLine[0];
        // Все массивы float.
        
        
        // Характеристики исходной короткой линии N1 и сопоставленой ей кривой Безье N2 уже известы //
        // (подсчитаны в GGraphBezierFocalLineRecBezier.cpp) //
        
        // фокальная линия N1
        //
        //                   t_1_3              t_2_3
        // I---------+---------I--------+---------I---------+---------I
        // 0        1/6       1/3      1/2       2/3       5/6     1*lineM1
        //
        //
        // фокальная линия N2
        //
        //                    t_1_3               t_2_3    окончание фокальной линия N3
        // I----------+---------I-------+-----------I----------+--------I-----------------------I
        // 0         1/6       1/3     1/2         2/3        5/6    1*lineM1                1*lineM2
        //           +----------#        +----------#         +---------#       <--- области перебора индекса index,
        //                                                                      # - точки совпадения.
        
        
        float x0, y0, x1, y1, x2, y2, x3, y3; // Декартовы координаты исходных точек фокальной линии N3 (mData2).
        int lenA_=line2.lenA-1;     // количество пикселов линии-1.
        float t_1=lenM1;            // расстояние вдоль длины фокальной линии N1 при t=L*1.
        float t_1_3=lenM1/3;        // расстояние вдоль длины фокальной линии N1 при t=L*1/3.
        float t_2_3=lenM1*2/3;      // расстояние вдоль длины фокальной линии N1 при t=L*2/3.
        ///if(GrafT)cout<<"t_1_3="<<t_1_3<<"     t_2_3="<<t_2_3<<"     t_1="<<t_1<<endl;
        
        
        // Вычисление характеристик проекции N3 короткой линии N1 на длинную линию N2 //
        
        // Получаем координаты начальных точек фокальной линии N2.
        x0=line2.start.x;    y0=line2.start.y;    // координаты начала фокальной линии при t2=0.
        
        // Короткую линию накладываем на длинную линию и вычисляем перебором
        // координаты трех исходных точек: 1/3 длины, 2/3 длины и конечной точки.
        int index=(int)lenM1/6;                   // стартуем по линии N2 с 1/6 длины фокальной линии N1.cout<<"index="<<index<<endl;
        while( sLine2[index]<=t_1_3 ) index++;    // проверка совпадения точки фокальной линии N2 с точкой t_1_3=L*1/3;
        x1=mData2[index].x;    y1=mData2[index].y;// координаты фокальной линии N2 при совпадении с этой точкой.
        ///if (GrafT)cout<<"index(1/3)="<<index;
        
        index+=index>>1; // >>1 деление на 2 и +  // продолжаем движение по линии N2 примерно с половины длины фокальной линии N1.
        while( sLine2[index]<=t_2_3 && index<lenA_) index++;    // проверка совпадения точки фокальной линии с точкой t_2_3=L*2/3;
        ///while( sLine2[index]<=t_2_3 && index<lenA_) {index++; cout<<" "<<index<<"  sLine2[index]="<<sLine2[index]<<endl;}
        x2=mData2[index].x;    y2=mData2[index].y;// координаты фокальной линии при совпадении с этой точкой.
        ///if (GrafT)cout<<"   index(2/3)="<<index;
        
        index+=index>>2; // >>2 деление на 4 и +  // продолжаем движение по линии N2 примерно с половины длины фокальной линии N1.
        while( sLine2[index]<=t_1 && index<lenA_) index++; // проверка совпадения точки фокальной линии с точкой t_2_3=L*1;
        ///while( sLine2[index]<=t_1 && index<lenA_) {index++; cout<<" "<<index<<"  sLine2[index]="<<sLine2[index]<<endl;}
        x3=mData2[index].x;    y3=mData2[index].y;// координаты фокальной линии при совпадении с этой точкой.
        ///if (GrafT)cout<<"   index(1)="<<index<<endl;
        
        
        // Получили все необходимые характеристики проекции N3 (три вычисленные точки плюс одна начальная).
        // Вычисляем координаты управляющих точек кривой Безье N3 по четырем точкам полученной проекции N3:
        float Px0=x0;
        float Py0=y0;
        float Px1=(-5*x0 + 18*x1 - 9*x2 + 2*x3)/6;  // координата “x” первой управляющей точки.
        float Py1=(-5*y0 + 18*y1 - 9*y2 + 2*y3)/6;  // координата “y” первой управляющей точки.
        float Px2=( 2*x0 - 9*x1 + 18*x2 - 5*x3)/6;  // координата “x” второй управляющей точки.
        float Py2=( 2*y0 - 9*y1 + 18*y2 - 5*y3)/6;  // координата “y” второй управляющей точки.
        float Px3=x3;   // Начальные и конечные управляющие точки кривой Безье совпадают
        float Py3=y3;   // с начальными и конечными точками фокальной линии.
        // Источники:
        // http://alex-black.ru/article.php?content=109
        // http://fullref.ru/job_a517a7c403e9395d49dc5ea305453db0.html
        
        // Для вывода в графический порт ВРЕМЕННО сохраняем координаты управляющих точек кривой Безье N3 (ПОКА на место кривой Безье N2)
        // Сохраняем координаты управляющих точек кривой Безье N3 в line2.
        line2.p1.x=Px1;     line2.p1.y=Py1;     line2.p2.x=Px2;     line2.p2.y=Py2;
        // Сохраняем координаты начальных и конечных точек кривой Безье N3.
        line2.start.x=Px0;  line2.start.y=Py0;  line2.end.x=Px3;    line2.end.y=Py3;
        
        
        // Сохраняем координаты управляющих точек кривой Безье N3 в line3.
        line3.p1.x=Px1;     line3.p1.y=Py1;     line3.p2.x=Px2;     line3.p2.y=Py2;
        // Сохраняем координаты начальных и конечных точек кривой Безье N3.
        line3.start.x=Px0;  line3.start.y=Py0;  line3.end.x=Px3;    line3.end.y=Py3;
        
        
        /// Вычисляем углы и длины векторов кривой Безье N3. ///
        
        // Кривая Безье N3.
        float line3_len;    // длина опорного вектора L кривой Безье N3 (линии от начальной 0 до конечной 3 точки кривой).
        float line3_alpha;  // угол между опорным вектором и горизонталью.
        float line3_lenP1;  // длина контрольного вектора P1 (линии от начальной 0 до первой управляющей точки кривой).
        float line3_alphaP1;// угол между контрольным вектором P1 и опорным вектором L.
        float line3_lenP2;  // длина контрольного вектора P2 (линии от конечной 3 до второй управляющей точки кривой).
        float line3_alphaP2;// угол между контрольным вектором P2 и опорным вектором L.
        
        // Вычисление угла между опорным вектором и горизонталью и его длины.
        LineAngleLength(Px3 - Px0, Py3 - Py0, line3_alpha, line3_len); // , alpha, length
        line3.len=line3_len;        // Сохраняем рассстояние от начальной 0 до конечной 3 точки кривой Безье в pix.
        line3.alpha=line3_alpha;    // - alpha, угол наклона линии в градусах (0 до 360° grade).
        if(GrafT)cout<<"line3_alpha="<<line3_alpha<<"     line3_len="<<line3_len<<endl;
        
        // Вычисление угла между первым контрольным вектором и горизонталью и его длины.
        LineAngleLength(Px1 - Px0, Py1 - Py0, line3_alphaP1, line3_lenP1);
        line3.lenP1=line3_lenP1;        // Сохраняем длину первого контрольного вектора в pix.
        line3.alphaP1=line3_alphaP1;    // Сохраняем угол наклона первого контрольного вектора (0 до 360° grade).
        if(GrafT)cout<<"line3_alphaP1="<<line3_alphaP1<<"     line3_lenP1="<<line3_lenP1<<endl;
        
        // Вычисление угла между вторым контрольным вектором и горизонталью и его длины
        LineAngleLength(Px2 - Px3, Py2 - Py3, line3_alphaP2, line3_lenP2);
        line3.lenP2=line3_lenP2;        // Сохраняем длину второго контрольного вектора в pix.
        line3.alphaP2=line3_alphaP2;    // Сохраняем угол наклона второго контрольного вектора (0 до 360° grade).
        if(GrafT)cout<<"line3_alphaP2="<<line3_alphaP2<<"     line3_lenP2="<<line3_lenP2<<endl;
        
        
        
        /// Вычисление суммарного коэффициента корреляции соответствующих трех пар векторов кривых Безье. ///
        
        // Функция для сравнения (корреляции) двух кривых Безье.
        // 0 коэффициент корреляции не зависит от масштаба (зависит от поворота кривых Безье).
        // 1 коэффициент корреляции не зависит от масштаба и от поворота кривых Безье.
        float CorAlphaSUM=CorrelationBezierA(line1, line3, 0);
        if(GrafT)cout<<"коэффициент корреляции углов кривых Безье N1 и N3.   CorAlphaSUM=CorrelationBezier2()="<<CorAlphaSUM<<"%"<<endl;
        
        // При коэффициенте корреляции меньше порога, принимаем решение, что короткая линии N1 НЕ является частью длинной линии N2.
        if (CorAlphaSUM < dlt_max) {
            CorAlphaSUM=0;
            if(GrafT)cout<<"короткая линии N1 НЕ является частью длинной линии N2.   CorAlphaSUM="<<CorAlphaSUM<<"%"<<endl<<endl;
        } else {
            if(GrafT)cout<<"короткая линии N1 является частью длинной линии N2     CorAlphaSUM="<<CorAlphaSUM<<"%"<<endl<<endl;
        }
        
        // Возвращаем суммарный коэффициент корреляции двух кривых Безье.
        return CorAlphaSUM;
        // CorAlphaSUM=0    короткая линии N1 НЕ является частью длинной линии N2.
        // CorAlphaSUM>0    короткая линии N1 является частью длинной линии N2 с коэффициентом корреляции CorAlphaSUM.
        
        
        // Базовое правило вычитания углов. //
        // Если одна прямая имеет отрицательный угловой коэффициент, а вторая положительный,
        // то угол между этими прямыми будет равен сумме абсолютных величин этих углов.
        // В случае же, когда угловые коэффициенты оба отрицательны или оба положительны,
        // то угол находится путем вычитания из большего угла меньшего.
        // В рассматриваемом примере получим, что угол между прямыми равен |34| + |-31| = 34 + 31 = 65 градусов.
        // http://www.kakprosto.ru/kak-126210-kak-opredelit-ugol-mezhdu-dvumya-pryamymi
        
        // gPort.mm  570стр
        // таблица в гр порту:
        // 1. id number
        // 1. len
        // 1. alpha°
        // 1. lenP1
        // 1. alphaP1°
        // 1. lenP2
        // 1. alphaP2°
        // 1. lenA
        // 1. lenM
        // 1. lenBf
        // 1. lenBff
       
        
    }//____________________________________________________________________________
    
    
    
    // *****************************************************************************
*/
    
  
    
};//____________________________________________________________________________






