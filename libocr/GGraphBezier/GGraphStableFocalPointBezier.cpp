//  Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .

#include "GGraphBezier.h"

 
namespace ocr{
    
    //*****************************************************************************
    
    
    /// Базовая версия ///    
    
    // Функция выделения стабильных фокальных точек. Функция выделяет так же фокальные точки на фокальных линиях (графемах) букв. 
    // Возвращает номер самой стабильной особой (фокальной) точки в массиве векторов focalPoint. Номера точек начинаются с нуля.
    // Работает только с черно-белой картинкой.     
    
    int  GGraphBezier::StablePoint(vector<OCRPointFloat>&focalPoint) {
        
        //  * Идея *
        // Для выделения стабильных фокальных точек используются функции:
        // - полиграфического растискивания dotGain (стандартная функция)     
        // - выделения фокальных линий букв focalLine
        // - выделения фокальных точек на фокальных линиях букв focalPoint.
        // Алгоритм состоит в следующим:
        // Вычисляются фокальные точки обычным образом с помощью функций focalLine и focalPoint.
        // Исходный графический текст с помощью функции dotGain подвергается многократной эррозии в цикле по одному pix.
        // Многократная эррозия (снятие слоев) это сильная фильтрация графического текста.
        // Если пиксел в массиве bytes_data соответствующей особой точке уже белый (т.е. уже разрушился) и особая точка 
        // еще не меняла статус (равный 0), то присваемваем ей статус соответствующий количеству проведенных эррозий. 
        // Затем нахождится особая точка с наибольшим ей статусом. Это и есть самой стабильной точка. 
        // Функция возвращает номер самой стабильной особой (фокальной) точки в массиве переменной длинны focalPoint. Номера точек начинаются с нуля.
        // Адреса фокальных точек в декартовых координат "x", "y" (short) расположенны в массиве переменной длинны focalPoint. 
        // Количество адресов равно sizeAdr=focalPoint->size();.
        
        //  * Особенности *
        // Реально прелназначена для обработки небольших картинок в базе данных.
        
        //  * Особенности применения *
        // За счет внутренней буферизации функция возвращает исходный массив bytes_data с неизменном виде .
        // НА ВХОДЕ В ФУНКЦИЮ NCOLUMNS ДОЛЖЕН БЫТЬ КРАТНЕН 32, что необходима для работы функции 
        // "Имитация полиграфического растискивания" dotGain ( нормализацию можно выполнить с помощью функции crop32 ). 
        
        
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if (GrafT) { cout<<"Функция выделения стабильных фокальных точек на фокальных линиях букв  StablePoint() "<<endl; }
        
        
        TIME_START 
        
        int w,h;            
        w=ncolumns;  // ширина массива  IMAGE WIDTH
        h=nrows;     // высота массива  IMAGE HEIGHT
        int w_h=w*h; // длина массива  IMAGE
        
        if (GrafT) { cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
        // w*h=10 млн.  time=1.16  
        
        /// управляющие переменные ///         
        int n_Lay;      // количество удаленных слоев (слой это периметр символа) n_Lay=7;
        
        /// вспомогательные переменные
        int n=0;        // переменная главного цикла попиксельной эррозии исходного графического текста.
        int m=0;        // переменная перебора фокальных точек.
        unsigned int sizeAdr; // количество особых точек по всему графическому тексту
        int s;
        
        /// Массивы ///
        // указатели типа uchar
        //unsigned char *p0=bytes_data; // , *pw   // входной массив, 0-черный 255-белый ( с 0-черный 1-белый не работает).
        unsigned char *bytes_data_1;  // , *p1  // массив попиксельной эррозии исходного графического текста.
        // такой же как массив bytes_data (в нем находится копия исходного графического текста, подвергаемая эррозии). 
        
        // размер массива bytes_data_1.
        unsigned int sizeBuf=w_h + 32 ;
        
        // выделение памяти под массивы. 
        bytes_data_1 = (unsigned char*)malloc(sizeBuf); // p1
        ///bytes_data_1 = (unsigned char*)calloc(sizeBuf,sizeof(unsigned char)); 
        
        
        // копирование bytes_data в bytes_data_1. Сохранение основного массива bytes_data. // time=0.003  w_h=w*h=10 млн. пикселей 
        memcpy(bytes_data_1, bytes_data, w_h);    // адрес буфера назначения, адрес источника, количество байт для копирования.        
        // в массиве bytes_data_1 находится исходный графический текст. 
        
        // создание массива для хранения и визуализации одного слоя графического текста после эррозии.
        unsigned char *bytes_data_2=0;
        if (GrafT) {                
            bytes_data_2 = (unsigned char*)malloc(sizeBuf); // p2            
        } // if
        
        
        // Измерение среднего значения толщины штриха line_w в буквах по всему графическому тексту (изм. в десятых долях pix). // time=0.022    
        int line_wd1=lineWidth();     if (GrafT) { cout<<"Определение толщины штриха lineWidth()   line_wd1="<<line_wd1<<endl; }
        int n_RemovLayers=line_wd1/10+1; // деление на 10 т.к. толщины штриха измеряется в десятых долях pix
        n_Lay=n_RemovLayers;           // количество удаленных слоев (слой это периметр символа) n_Lay=7;
        if (GrafT) { cout<<"количество удаленных слоев (слой это периметр символа)   n_Lay="<<n_Lay<<endl; }
        
         
        
        /// Начальное вычисление фокальных точек обычным образом с помощью функций focalLine и focalPoint ///
        
        // запуск функции определения фокальных линий букв (графем)
        int min_RemovLayers=focalLine(n_RemovLayers);  // n_RemovLayers - количество удаленных слоев (слой это периметр символа).
        if (GrafT) { cout<<"Функция определения фокальных линий букв (графем)   focalLine() min_RemovLayers="<<min_RemovLayers<<endl; }
        
        // Возвращаемое функцией focalLine фактическое количество удаленных слоев.
        n_Lay=min_RemovLayers; // Вполне м.б. min_RemovLayers < n_RemovLayers
        if (GrafT) { cout<<"n_RemovLayers="<<n_RemovLayers<<"   min_RemovLayers="<<min_RemovLayers<<"   n_Lay="<<n_Lay<<endl; }
        
        // запуск функции выделения фокальных точек на фокальных линиях (графемах) букв.
        sizeAdr=focalPointXTL(focalPoint);
        if (GrafT) { cout<<"Функция выделения фокальных точек на фокальных линиях букв   focalPoint(focalPoint)   sizeAdr="<<sizeAdr<<endl; }
        /**/
        
        if(!focalPoint.size())return 0;

        // копирование bytes_data_1 в bytes_data. Восстановление основного массива bytes_data.
        memcpy(bytes_data, bytes_data_1, w_h); // адрес буфера назначения, адрес источника, количество байт для копирования.
        // на эррозию в один пиксел подается массив bytes_data.
        
        // получение указателя pt_p на реальные данные  // пример pt_p[3].x=8;
        OCRPointFloat *pt_p=(OCRPointFloat*)&focalPoint[0];
        // (OCRPointFloat*) приведение типа
        // focalPoint  массив  OCRPointFloat-ов
        // dataPtr() возвращает указатель pt_p на реальные данные перепрыгивая через служебные данные (указатель на первый элемент массива )        

            
        // Цикл попиксельной эррозии исходного графического текста. // 
        int MaxStability=0;   int NoMaxStability=0;
        for ( n=1; n < n_Lay+1; n++ ) { // n=1 !! Величина статуса начинается с единици.                 
            // Эррозия на один pix. Время выполнения функции time=0.091*8=0.73 // time=0.034
            // Это основное времени выполнения всей функции
            dotGain(-1, -1, -1, -1, 0);     // необходим либо ncolumns кратности 32 или (g, g, 0, 0, dot_gain)
            // Цикл проверки всех особых точек. Фиксация исчезновения каждой особой точки после очередной эррозии. 
            for ( m=0; m < sizeAdr; m++ ) {   
                s=pt_p[m].y*w + pt_p[m].x; // s - линейная координата,   x,y - Декартовы координаты
                // если точка в массиве bytes_data соответствующая особой точке уже белая (т.е. разрушилась) и особая точка 
                // еще не меняла статус (=0), то присваемваем ей статус соответствующий номеру шага эррозии. 
                if ( bytes_data[s] == 255 && pt_p[m].stability == 0 ) {    // 0 - черное, 255 - белое
                    pt_p[m].stability=n;
                    // Нахождение стабильной особой точки с самым большим статусом "n" и номером "m".
                    // Конци линий L_POINT не учавствуют в конкурсе на самую стабильную точку.
                    // Номера точек в массиве начинаются с нуля. Величина статуса с единици.
                    // if (n > MaxStability) { MaxStability=n; NoMaxStability=m;}
                    if (n > MaxStability && pt_p[m].type!=L_POINT) { MaxStability=n; NoMaxStability=m;}
                } // if   
            } // m            
            // визуализация одного слоя после эррозии (самый наглядный слой n==4 при n_Lay=6). Точки выводятся серым.
            if (GrafT) { if (n==n_Lay-2) { memcpy(bytes_data_2, bytes_data, w_h); }  }
        } // n
        
        if (GrafT) { 
            cout<<"Полиграфическое растискивание dotGain()  -1, -1, -1, -1, 0   выполняется  "<<n-1<<"  раз"<<endl;
        }        
        
        /**/
        
        /// sizeAdr=focalPoint->size();
        // визуализация особых точек (фокальных точек).
        if (GrafT) {
            for ( m=0; m < sizeAdr; m++ ) {
                // визуализация серым особых точек.
                bytes_data_2[(int)(pt_p[m].y*w + pt_p[m].x)]=128;  // 128 - серое
                // визуализация статуса особых точек и их координат "x" и "y".
                cout<<"stability="<<(short)pt_p[m].stability;
                cout<<" type="<<(short)pt_p[m].type;
                cout<<"  x="<<pt_p[m].x;
                cout<<"  y="<<pt_p[m].y<<endl;                
            } // for ( m=0; 
        }
        /**/
        
         /*
         // нахождение номера самой стабильной особой (фокальной) точки в массиве векторов focalPoint. Номера точек начинаются с нуля.
         // лучше применить сортировку адресов в массиве векторов focalPoint по переменной stability.
         int MaxStability=0;   int NoMaxStability=0;
         for ( m=0; m < sizeAdr; m++ ) { if (pt_p[m].Stability > MaxStability) { MaxStability=pt_p[m].stability; NoMaxStability=m;} }
         */
        
        // графическая визуализация серым самой стабильной особой точки или точек.
        if (GrafT) {
            for ( m=0; m < sizeAdr; m++ ) {
                // визуализация стабильных особых точек четырьмя окружающими точками.
                if ( pt_p[m].stability == MaxStability ) {    // 0 - черное, 255 - белое
                    bytes_data_2[(int)(pt_p[m].y*w + pt_p[m].x+3)]=128;
                    bytes_data_2[(int)(pt_p[m].y*w + pt_p[m].x-3)]=128;
                    bytes_data_2[(int)((pt_p[m].y+3)*w + pt_p[m].x)]=128;
                    bytes_data_2[(int)((pt_p[m].y-3)*w + pt_p[m].x)]=128;
                } // if
            } // for ( m=0; 
        }
        // визуализация параметров самой стабильной особой (фокальной) точки.
        if (GrafT) { 
            cout<<"Статус самой стабильной особой точки    MaxStability="<<MaxStability<<endl;
            cout<<"Номер самой стабильной особой точки    NoMaxStability="<<NoMaxStability<<endl;
            cout<<"Координаты самой стабильной особой точки    x="<<pt_p[NoMaxStability].x<<"  y="<<pt_p[NoMaxStability].y<<endl;
        }
        
        // Визуализация одного слоя графического текста после эррозии.
        if (GrafT) { 
            // копирование bytes_data_2 в bytes_data  // time=0.003  w_h=w*h=10 млн. пикселей 
            memcpy(bytes_data, bytes_data_2, w_h);    // адрес буфера назначения, адрес источника, количество байт для копирования.
        }
        // Восстановление основного массива bytes_data.
        else{           
            // копирование bytes_data_1 в bytes_data. 
            memcpy(bytes_data, bytes_data_1, w_h); // адрес буфера назначения, адрес источника, количество байт для копирования.
        }
        /**/
        
        if (GrafT) { TIME_PRINT_   cout<<"TIME_PRINT_   стабильных фокальных точек   StablePoint"<<endl;  }
        
        // освобождение массивов     
        if ( bytes_data_1 !=NULL ) free(bytes_data_1);
        if (GrafT) { if ( bytes_data_2 !=NULL ) free(bytes_data_2); } 
        
        // Ставим самую стабильную фокальную точку на первое место.
        OCRPointFloat pt=pt_p[0];
        pt_p[0]=pt_p[NoMaxStability];
        pt_p[NoMaxStability]=pt;
        
        // Возвращаем номер самой стабильной особой (фокальной) точки в массиве векторов focalPoint. Номера точек начинаются с нуля.
        return NoMaxStability;
        
        
        
    }//____________________________________________________________________________     
    
    
    /// Более точная версия ///    
    
    // Функция выделения стабильных фокальных точек на фокальных линиях (графемах) букв. Фактически выполняет сортировку 
    // адресов в массиве векторов focalPoint. Сортировка осуществляется по степени стабильности фокальных точек.
    // Работает только с черно-белой картинкой.     
    
    int  GGraphBezier::StablePointT(vector<OCRPointFloat>&focalPoint) {
        
        /*
         // Адреса стабильных фокальных точек в сортированном виде (по степени стабильности) расположенны в массиве векторов focalPoint. 
         // Нулевой элемент массива векторов это адрес самой стабильной фокальной точеки. Последний элемент массива векторов это адрес  
         // самой не стабильной фокальной точеки точка. Адреса (int) - это расстояние от начала координат до стабильной фокальной точки. 
         // Количество адресов равно sizeAdr. Функция возвращает количество особых точек (адресов) sizeAdr по всему графическому тексту.
         // За счет внутренней буферизации, функция возвращает исходный массив bytes_data с неизменном виде
         // Реально упрощено
         */
        
        //  * Идея *
        // Для выделения стабильных фокальных точек используются функции:
        // - полиграфического растискивания dotGain (стандартная функция)     
        // - выделения фокальных линий букв focalLine
        // - выделения фокальных точек на фокальных линиях букв focalPoint.
        // Алгоритм состоит в следующим:
        // Вычисляются фокальные точки обычным образом с помощью функций focalLine и focalPoint.
        // Исходный графический текст с помощью функции dotGain подвергается эррозии в цикле на один pix. 
        /*    
         // Координаты, исчезувших из-за эррозии, фокальных точек заносят в конец массива векторов focalPoint.
         // - Графический текст с помощью функции dotGain еще раз подвергается эррозии на один pix.
         // - С помощью функций focalLineSt и focalPointSt вычисляются новые фокальные точки.
         // - Сравниваются координаты предыдущих фокальных точек и новых фокальных точек.
         // - Координаты исчезувших фокальных точек заносят на свободное место в конец массива векторов focalPoint.
         // И так продолжается до тех пор пока из-за эррозии нельзя будет находить новые фокальные точки.
        */    
        // Самая последняя и самая устойчивая точка оказывается в конце массива.
        
        //  * Особенности *
        
        //  * Особенности применения *
        
        
        
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if (GrafT) { cout<<"Функция выделения стабильных фокальных точек на фокальных линиях букв   StablePoint() "<<endl; }
        
    
        
TIME_START 
        
        int x;    
        int w,h;            
        w=ncolumns;  // ширина массива  IMAGE WIDTH
        h=nrows;     // высота массива  IMAGE HEIGHT
        int w_h=w*h; // длина массива  IMAGE
        
        if (GrafT) { cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
        // w*h=10 млн.  time=0.0  
        
        /// управляющие переменные ///         
        int n_Lay;      // количество удаленных слоев (слой это периметр символа) n_Lay=7;
        int dot_gain=0; // -2 // Количество однопиксельных слоёв вокруг символа: добавленных от 1 до 31, убавленных от -1 до -31, без изменений 0.
        
        /// вспомогательные переменные
        int n=0;        // переменная главного цикла попиксельной эррозии исходного графического текста.
        int m=0;        // переменная перебора фокальных точек.
        unsigned short rg0=0;     // байтовый регистр для хранения отдельных 8 бит маски
        unsigned short rg0_old;   // байтовый регистр для
        unsigned int sizeAdr; // количество особых точек по всему графическому тексту
        int s;
        
        /// Массивы ///
        // указатели типа uchar
        unsigned char *p0=bytes_data; //, *pw   // входной массив, 0-черный 255-белый ( с 0-черный 1-белый не работает).
        unsigned char *bytes_data_1;  // , *p1  // массив попиксельной эррозии исходного графического текста.
        // такой же как массив bytes_data (в нем находится копия исходного графического текста, подвергаемая эррозии). 
        
        // размер массива bytes_data_1.
        unsigned int sizeBuf=w_h + 32 ;
        
        // выделение памяти под массивы. 
        bytes_data_1 = (unsigned char*)malloc(sizeBuf); // p1
        ///bytes_data_1 = (unsigned char*)calloc(sizeBuf,sizeof(unsigned char)); 
        
        
        // копирование bytes_data в bytes_data_1. Сохранение основного массива bytes_data. // time=0.003  w_h=w*h=10 млн. пикселей 
        memcpy(bytes_data_1, bytes_data, w_h);    // адрес буфера назначения, адрес источника, количество байт для копирования.        
        // в массиве bytes_data_1 находится исходный графический текст. 
        
        // создание массива и его заполнение для хранения и визуализвции серой подложки букв из исходного изображения.
        // содержимое массива bytes_data_2 не меняется при работе функции.
        unsigned char *bytes_data_2=0;
        if (GrafT) {                
            bytes_data_2 = (unsigned char*)malloc(sizeBuf); // p2            
            for ( x=0; x < w_h; x++ ) { bytes_data_2[x]=(255+bytes_data[x])/2; }
            // в массиве bytes_data_2 находится серый исходный графический текст.
        } // if
        
        
        // Измерение среднего значения толщины штриха line_w в буквах по всему графическому тексту (изм. в десятых долях pix). // time=0.022    
        int line_wd1=lineWidth();     if (GrafT) { cout<<"Определение толщины штриха lineWidth()   line_wd1="<<line_wd1<<endl; }
        n_Lay=line_wd1/10; //   деление на 10 т.к. толщины штриха измеряется в десятых долях pix
        int n_RemovLayers=n_Lay;       // количество удаленных слоев (слой это периметр символа) n_Lay=7;
        cout<<"количество удаленных слоев (слой это периметр символа)   n_Lay="<<n_Lay<<endl; 
        
        
        
        /// Начальное вычисление фокальных точек обычным образом с помощью функций focalLine и focalPoint ///
        
        // запуск функции определения фокальных линий букв (графем)
        focalLine(n_RemovLayers-n);  // n_RemovLayers - количество удаленных слоев (слой это периметр символа).
        if (GrafT) { cout<<"Функция определения фокальных линий букв (графем)   focalLine() n_RemovLayers="<<n_RemovLayers<<endl; } 
        
        // запуск функции выделения фокальных точек на фокальных линиях (графемах) букв.
        sizeAdr=graphFocalPoint(focalPoint);
        if (GrafT) { cout<<"Функция выделения фокальных точек на фокальных линиях букв   focalPoint(focalPoint)   sizeAdr="<<sizeAdr<<endl; }
        /**/  
        
        
        // копирование bytes_data_1 в bytes_data. Восстановление основного массива bytes_data.
        memcpy(bytes_data, bytes_data_1, w_h); // адрес буфера назначения, адрес источника, количество байт для копирования.
        // на эррозию в один пиксел подается массив bytes_data.
        
        // получение указателя pt_p на реальные данные  // пример pt_p[3].x=8;
        OCRPointFloat *pt_p=(OCRPointFloat*)&focalPoint[0];
        // (OCRPointFloat*) приведение типа
        // focalPoint  массив  OCRPointFloat-ов
        // dataPtr() возвращает указатель pt_p на реальные данные перепрыгивая через служебные данные (указатель на первый элемент массива )        
         /*
         class OCRPointFloat {
         public:
         OCRPointFloat();  short x;  short y;  short status; short stability;
         };
         */
        
        
        // Цикл попиксельной эррозии исходного графического текста. 
        for ( n=0; n < n_Lay; n++ ) { // n_Lay       
            
            // Эррозия на один pix. Время выполнения функции time=0.034                         
            dotGain(-1, -1, -1, -1, 0);     // необходим либо ncolumns кратности 32 или (g, g, 0, 0, dot_gain)
            if (GrafT) { cout<<"Полиграфическое растискивание dotGain()  dot_gain="<<dot_gain<<endl; }
            
            // цикл проверки всех особых точек.
            for ( m=0; m < sizeAdr; m++ ) {                 
                s=pt_p[m].y*w + pt_p[m].x; // s - линейная координата,   x,y - Декартовы координаты
                // если точка в массиве bytes_data соответствующая особой точке уже белая (т.е. разрушилась) и особая точка 
                // еще не меняла статус (=0), то присваемваем ей статус соответствующий номеру шага эррозии. 
                if ( bytes_data[s] == 255 && pt_p[m].stability == 0 ) {    // 0 - черное, 255 - белое
                    ///p0=bytes_data + s;
                    p0=bytes_data + s - (w+1);
                    rg0=(*(p0)&1) + (*(p0+1)&1) + (*(p0+2)&1) + (*(p0+w)&1) + (*(p0+w+2)&1) + (*(p0+w+w)&1) + (*(p0+w+w+1)&1) + (*(p0+w+w+2)&1);
                    rg0_old=8-rg0;
                    
                    pt_p[m].stability=(n+1)*10 + rg0_old;
                } // if   
                //p0=bytes_data + s - (w+1);
                //rg0=(*(p0)&1) + (*(p0+1)&1) + (*(p0+2)&1) + (*(p0+w)&1) + (*(p0+w+2)&1) + (*(p0+w+w)&1) + (*(p0+w+w+1)&1) + (*(p0+w+w+2)&1);
                //rg0_old=8-rg0;
            } // for ( m=0;
            
            // визуализация одного слоя после эррозии. Точки выводятся серым
            if (GrafT) {        
                if (n==3) { 
                    memcpy(bytes_data_2, bytes_data, w_h);
                    ///            for ( m=0; m < sizeAdr; m++ ) { bytes_data_2[ pt_p[m].y*w + pt_p[m].x ]=128; } // 0 - черное, 255 - белое
                } // if (n==n_Lay)
            } // if (GrafT) 
            
        } // n
        if (GrafT) { cout<<endl; cout<<"Окончание цикла по количеству удаленных слоев   n="<<n<<endl; }        
        
        /**/
        
        sizeAdr=(uint)focalPoint.size();
        if (GrafT) {
            for ( m=0; m < sizeAdr; m++ ) {
                // визуализация серым особых точек (фокальных точек).
                bytes_data_2[ (int)(pt_p[m].y*w + pt_p[m].x)]=128;  // 128 - серое
                // визуализация статуса особых точек (фокальных точек) и их координат "x" и "y".
                cout<<"stability="<<(short)pt_p[m].stability;
                cout<<"  x="<<pt_p[m].x;
                cout<<"  y="<<pt_p[m].y<<endl;                
            } // for ( m=0; 
        }
        
        // нахождение номера самой стабильной особой (фокальной) точки в массиве векторов focalPoint. Номера точек начинаются с нуля.
        // лучше применить сортировку адресов в массиве векторов focalPoint по переменной stability.
        int MaxStability=0;
        int NoMaxStability=0;
        for ( m=0; m < sizeAdr; m++ ) { if (pt_p[m].stability > MaxStability) { MaxStability=pt_p[m].stability; NoMaxStability=m;} }
        if (GrafT) { 
            cout<<"Статус самой стабильной особой (фокальной) точки    MaxStability="<<MaxStability<<endl;
            cout<<"Номер самой стабильной особой (фокальной) точки    NoMaxStability="<<NoMaxStability<<endl;
            cout<<"Координаты самой стабильной особой (фокальной) точки    x="<<pt_p[NoMaxStability].x<<"  y="<<pt_p[NoMaxStability].y<<endl;
        }
        
        if (GrafT) { 
            /// bytes_data=bytes_data_2; // визуализируется массив bytes_data_2 
            // копирование bytes_data_2 в bytes_data  // time=0.003  w_h=w*h=10 млн. пикселей 
            memcpy(bytes_data, bytes_data_2, w_h);    // адрес буфера назначения, адрес источника, количество байт для копирования.
            // в массиве bytes_data находится исходный графический текст.
            // визуализация серым исходного графического текста
            ///            for ( x=0; x < w_h; x++ ) { bytes_data[x]=(255+bytes_data[x])/2; }
            /*
             // визуализация черным особых точек (фокальных точек)
             int s=focalPoint[0][0]->y*w + focalPoint[0][0]->x;
             bytes_data[s]=0;  bytes_data[s+1]=0;  bytes_data[s+w]=0;  bytes_data[s+1+w]=0;
             for ( m=1; m < sizeAdr; m++ ) { bytes_data[focalPoint[0][m]->y*w + focalPoint[0][m]->x]=0; } // читаем из массива векторов
             */
        }
        /**/
        
        TIME_PRINT_   cout<<"TIME_PRINT_   стабильных фокальных точек   StablePoint"<<endl;

        // освобождение массивов     
        if ( bytes_data_1 !=NULL ) free(bytes_data_1);
        if (GrafT) { if ( bytes_data_2 !=NULL ) free(bytes_data_2); }    
        
        // Возвращаем номер самой стабильной особой (фокальной) точки в массиве векторов focalPoint. Номера точек начинаются с нуля.
        return NoMaxStability;
        
        // за счет внутренней буферизации функция возвращает исходный массив bytes_data с неизменном виде    
        
        
        // Нормализация массива bytes_data по размеру ncolumns кратным 32  // w=16224 × h=2464  time=0.17 (пересчитано т.к. 16224/32=507 )
        ///img_pecha->crop32();    if (GrafT) { cout<<"Нормализация ncolumns/32*32 массива bytes_data   crop32()"<<endl; }          
        // возвращает новый массив bytes_data с новым размером по горизонтали ncolumns кратным 32 и новым data_size=ncolumns*nrows;
        
        
    }//____________________________________________________________________________  
    
    
    
    
    // Адреса стабильных фокальных точек в сортированном виде (по степени стабильности) расположенны в массиве векторов focalPoint. 
    // Нулевой элемент массива векторов это адрес самой стабильной фокальной точеки. Адреса (int) - это расстояние от начала координат
    // до стабильной фокальной точки. Количество адресов равно sizeAdr.
    
    // сборка байтового регистра rg0 из отдельных 8 бит матрицы с помощью единичных масок
    ///rg0=(*(p0)&1) + (*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w+2)&16) + (*(p0+w+w)&32) + (*(p0+w+w+1)&64) + (*(p0+w+w+2)&128);
    ///rg0=*p0 + *(p0+1) + *(p0+2) + *(p0+w) + *(p0+w+2) + *(p0+w+w) + *(p0+w+w+1) + *(p0+w+w+2);                    
    //rg0=~rg0;   
    
    // формирование центральной  области  "On"  без переходной области
    // формирование перефирийной области  "Off" без переходной области
    /*
     for (int y=0; y < h; y++ ) {
     s=~BufOff[y];
     Sb=On[y];
     ///Off[y]=Off[y] & s;
     if (maskType==1) {On[y]=Sb=Sb & s; }
     // подсчет площади центральной маски "On"
     // Регистровые суммы маски mask32 по  X    //0xFFFFFFFF
     Sb-=(Sb >> 1) & 0x55555555;                // 2-битовые ячейки
     Sb=(Sb & 0x33333333) + ((Sb >> 2) & 0x33333333); // 4-битовые
     Sb=(Sb + (Sb >> 4)) & 0x0F0F0F0F;                // 8-битоовые
     Sb+=Sb >> 8;                               // 16-битовые
     Sb+=Sb >> 16;                              // 32-битовая ячейка
     NMask+=Sb & 0x3F;  // 31 Обнуляем старшие разряды, содержащие "мусор"
     }
     //DM(END<<" x0st "<<x0st<<" x0st "<<x1st<<" x1st "<<y0st<<" y0st "<<y1st<<" y1st "<<END);
     */
    
    /*
     Регистровые суммы. На примере 8-битного числа:
     
     v = (v & 0x55) + ((v >> 1) & 0x55);
     v = (v & 0x33) + ((v >> 2) & 0x33);
     return (v & 0x0f) + ((v >> 4) & 0x0f);    //0x0000003F;     
     */
    
    /*
     // цикл попиксельной эррозии исходного графического текста. 
     // В цикле происходит вычисление всех особых точек после каждой попиксельной эррозии исходного графического текста.
     for ( n=0; n < n_Lay; n++ ) { // n_Lay       
     
     // запуск функции определения фокальных линий букв (графем)
     focalLine(n_RemovLayers-n);  // n_RemovLayers - количество удаленных слоев (слой это периметр символа).
     if (GrafT) { cout<<"Функция определения фокальных линий букв (графем)   focalLine() n_RemovLayers="<<n_RemovLayers<<endl; } 
     
     vector<OCRPointFloat>*focalPoint=vector<OCRPointFloat>::create(); // вектор
     // запуск функции выделения фокальных точек на фокальных линиях (графемах) букв.
     sizeAdr=focalPoint(focalPoint);
     if (GrafT) { cout<<"Функция выделения фокальных точек на фокальных линиях букв   focalPoint(focalPoint)   sizeAdr="<<sizeAdr<<endl; }
     
     
     // сортировка адресов в массиве векторов focalPoint.
     if (GrafT) {        
     if (n==3) { // n_Lay-1 // n=8
     memcpy(bytes_data_2, bytes_data_1, w_h);
     for ( m=0; m < sizeAdr; m++ ) { bytes_data_2[focalPoint[0][m]->y*w + focalPoint[0][m]->x]=128; } // 0
     } // if (n==n_Lay)
     }
     
     
     // на эррозию в один пиксел подается массив bytes_data_1   
     ////       bytes_data=bytes_data_1;
     memcpy(bytes_data, bytes_data_1, w_h);
     
     
     
     // Эррозия на один pix. Время выполнения функции time=0.034                         
     dotGain(-1, -1, -1, -1, 0);     // необходим либо ncolumns кратности 32 или (g, g, 0, 0, dot_gain)
     if (GrafT) { cout<<"Полиграфическое растискивание dotGain()  dot_gain="<<dot_gain<<endl; }
     
     // восстановление указателя bytes_data
     ////       bytes_data=p0;
     
     // копирование bytes_data_1 в bytes_data  // time=0.003  w_h=w*h=10 млн. пикселей 
     ////       memcpy(bytes_data, bytes_data_1, w_h);    // адрес буфера назначения, адрес источника, количество байт для копирования.        
     // в массиве bytes_data находится исходный графический текст, подвергнутый эррозии в один пиксел (в общем n_Lay раз).
     memcpy(bytes_data_1, bytes_data, w_h);
     
     } // n
     */
    
    
    // Адреса стабильных фокальных точек в сортированном виде (по степени стабильности) расположенны в массиве векторов focalPoint. 
    // Нулевой элемент массива векторов это адрес самой стабильной фокальной точеки. Последний элемент массива векторов это адрес  
    // самой не стабильной фокальной точеки точка. Адреса (int) - это расстояние от начала координат до стабильной фокальной точки. 
    // Количество адресов равно sizeAdr. Функция возвращает количество особых точек (адресов) sizeAdr по всему графическому тексту.
    // За счет внутренней буферизации, функция возвращает исходный массив bytes_data с неизменном виде
    // Реально упрощено
    
    //  * Идея *
    // Для выделения стабильных фокальных точек используются функции:
    // - полиграфического растискивания dotGain (стандартная функция)     
    // - выделения фокальных линий букв focalLine
    // - выделения фокальных линий букв, около известных фокальных точек focalLineSt
    // - выделения фокальных точек на фокальных линиях букв focalPoint.
    // - выделения фокальных точек на фокальных линиях букв, около известных фокальных точек focalPointSt.
    // Для увеличения быстродействия функции focalLineSt и focalPointSt работают в небольшой области около известных фокальных точек,  
    // а не по всей площади текста. В остальном они аналогичны функциям focalLine и focalPoint.
    // Алгоритм состоит в следующим:
    // Вычисляются фокальные точки обычным образом с помощью функций focalLine и focalPoint.
    // Исходный графический текст с помощью функции dotGain подвергается эррозии на один pix. 
    // С помощью функций focalLineSt и focalPointSt вычисляются новые фокальные точки (только в окрестностях исходных фокальные точки).
    // Сравниваются координаты исходных фокальных точек и новых фокальных точек. 
    // Координаты, исчезувших из-за эррозии, фокальных точек заносят в конец массива векторов focalPoint.
    // - Графический текст с помощью функции dotGain еще раз подвергается эррозии на один pix.
    // - С помощью функций focalLineSt и focalPointSt вычисляются новые фокальные точки.
    // - Сравниваются координаты предыдущих фокальных точек и новых фокальных точек.
    // - Координаты исчезувших фокальных точек заносят на свободное место в конец массива векторов focalPoint.
    // И так продолжается до тех пор пока из-за эррозии нельзя будет находить новые фокальные точки.
    // Самая последняя и самая устойчивая точка оказывается в конце массива.    
    
    // реально надо вынести из фунуций: 
    // - вычисление таблиц 
    // - приведение массивов к общепринятому стандарту
    // - пометить слайсы стартовыми особыми точками
    
    //  * Особенности *
    
    
    //  * Особенности применения *
    
    // В цикле происходит вычисление всех особых точек после каждой попиксельной эррозии исходного графического текста.
    
    
}
