//  Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .

#include "GGraphBezier.h"
#include <math.h> 

#ifdef ASM_OS64_SSE42_POPCNT
   #include <immintrin.h> // заголовочный файл immintrin.h с описанием соответствующих intrinsic-функций.
#endif

namespace ocr{

    
    //*****************************************************************************
    
                /// Correlation BezierT /// основная рабочая версия, не зависит от масштаба .
    
    // Функция для сравнения (корреляции) двух кривых Безье. Используется таблица для ранней отсечки.
    float GGraphBezier::CorrelationBezierT(OCRFocalLineBezier &line1, OCRFocalLineBezier &line2){

        // Функция осуществляет сравнение кривых Безье. По трем векторам считает коэффициент корреляции.
        // На вход в итоге получает ID номера сравниваемых линий N1 и N2.
        // Возвращает полный коэффициент корреляции кривых Безье N1 и N2.
        // Функция в общем случае не зависит от наклона и масштаба сравниваемых кривых Безье.
        
        // pCor=0 коэффициент корреляции не зависит от масштаба (зависит от поворота кривых Безье).
        // pCor=1 коэффициент корреляции не зависит от масштаба и от поворота кривых Безье.
        
        /// Теория ///
        // Кривая Безье описывается тремя векторами: двумя управляющими векторами P1 и P2 и вектором P1P2
        // проведенным между концами контрольных векторов. Коэффициент корреляции двух векторов "a" и "b"
        // (степень похожести) определяется их скалярным произведением.
        // Для полярных координат удобная форма:
        // - скалярным произведением двух векторов "ab" называется число, равное произведению модулей (длинны)
        // этих векторов "a*b" на косинус угла между ними "cos(alpha).  ab=a*b*cos(alpha), 0≤alpha≤П.
        // Для декартовых координат удобная форма:
        // - скалярное произведение векторов "a" и "b" равно сумме произведений соответствующих
        // координат ab=ax*bx+ay*by.
        // Суммарный коэффициент корреляции кривых Безье (N1, N2) равен сумме коэффициентов корреляции трех
        // векторов (P1, P1P2, P2) с весами пропорциональными длине векторов.
        // У cos плоская вершина, поэтому вместо него применена нормировка коэффициента корреляции углом
        // в 90° градусов, у которой острая вершина. Если ипользовать cos, то лучше вычислить его по таблице.
        // Если не вычислять разность углов между векторами и опорной линией, то функция станет зависимой
        // от поворота кривых Безье, но останется не зависимой от масштаба. Не забыть заблокировать лимиты "dlt_min".

      
        int GrafT=1;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if(GrafT){
            cout<<endl<<"-----------------------------------------------------------------------------------"<<endl;
            cout<<endl<<"Функция для сравнения (корреляции) двух кривых Безье N1 и N2.   CorrelationBezierT() "<<endl;
        }

        cout<<" alpha1="<<line1.alpha<<" alpha2="<<line2.alpha<<endl;

        
        // Кривая Безье N1. // все данные 01 сек
        //float line1_len=line1.len;            // длина опорной линии, проведенной от начальной 0 до конечной 3 точки.
        //float line1_alpha=line1.alpha;          // угол между опорной линией кривой Безье N1 и горизонталью.
        float line1_lenP1=line1.lenP1;          // длина первого контрольного вектора кривой Безье N1.
        float line1_alphaP1=line1.alphaP1;      // угол наклона первого контрольного вектора кривой Безье N1.
        float line1_lenP2=line1.lenP2;          // длина второго контрольного вектора кривой Безье N1.
        float line1_alphaP2=line1.alphaP2;      // угол наклона второго контрольного вектора кривой Безье N1.
        float line1_lenP1P2=line1.lenP1P2;      // длина вектора проведенного между концами контрольных векторов pix.
        float line1_alphaP1P2=line1.alphaP1P2;  // угол наклона вектора проведенного между концами контрольных векторов.

        // Кривая Безье N2.
        //float line2_len=line2.len;            // длина опорной линии, проведенной от начальной 0 до конечной 3 точки
        //float line2_alpha=line2.alpha;          // угол между опорной линией кривой Безье N2 и горизонталью.
        float line2_lenP1=line2.lenP1;          // длина первого контрольного вектора кривой Безье N2.
        float line2_alphaP1=line2.alphaP1;      // угол наклона первого контрольного вектора кривой Безье N2.
        float line2_lenP2=line2.lenP2;          // длина второго контрольного вектора кривой Безье N2.
        float line2_alphaP2=line2.alphaP2;      // угол наклона второго контрольного вектора кривой Безье N2.
        float line2_lenP1P2=line2.lenP1P2;      // длина вектора проведенного между концами контрольных векторов в pix.
        float line2_alphaP1P2=line2.alphaP1P2;  // угол наклона вектора проведенного между концами контрольных векторов.
        /**/
        
        // целочисленные значения углов для применения таблицы.
        int line1_alpInt=line1.alpInt;
        int line2_alpInt=line2.alpInt;
        
        float deltaAlpha;   // Абсолютное значение разности углов между двух линий.
        int dltAlpha;
        float CorAlphaL;    // Коэффициент корреляции углов между опорными линиями кривых Безье N1 и N2.
        float CorAlphaP1;   // Коэффициент корреляции углов между контрольными векторами P1 кривых Безье N1 и N2.
        float CorAlphaP2;   // Коэффициент корреляции углов между контрольными векторами P2 кривых Безье N1 и N2.
        float CorAlphaP1P2; // Коэффициент корреляции углов между контрольными векторами P1P2 кривых Безье N1 и N2.
        // Опорная линиям условно проведена между начальными 0 и конечными точками 3 кривой Безье.
        /**/
        
        
        // веса коэффициентов корреляции углов.
        float wg_P1=0, wgP1P2=0, wg_P2=0; //wgL=0
        // При коэффициенте корреляции меньше порога, выходим из функции.
        float dlt_min=25;   //  50%  Минимальный порог коэффициента корреляции уголов (от-100% до 100%).
        // dlt_min=25%; соответствует разность уголов dltAlpha=67°;
        // dlt_min=50%; соответствует разность уголов dltAlpha=45°;
        // dlt_min=33%; максимальное значение выше которого начинается влияние на конечный коэффициент корреляции.
        
        float nr111=1.11111111; // 100.0/90.0
        // CorAlphaL=100-100*deltaAlpha/90;
        
        // Базовое правило применения углов. //
        // Если одна прямая имеет отрицательный угловой коэффициент, а вторая положительный,
        // то угол между этими прямыми будет равен сумме абсолютных величин этих углов.
        // В случае же, когда угловые коэффициенты оба отрицательны или оба положительны,
        // то угол находится путем вычитания из большего угла меньшего (abs).
        // http://www.kakprosto.ru/kak-126210-kak-opredelit-ugol-mezhdu-dvumya-pryamymi
        
        // Для вычисления коэффициента корреляции используется наименьший угол между прямыми (контрольными векторами кривых Безье),
        // Особенности вычисления коэффициента корреляции подробно разобраны и нарисованы в функции buildOCRAlphaTable().

        /*
        int L_1=14;        int L_2=215;
        if(line1.index==L_1 && line2.index==L_2){ GrafT=1; } // 3617 1697   ///////////////////////////////////////////////////////////
        if(GrafT) {
            cout<<"line1.index"<< line1.index<<"  line2.index="<<line2.index<<endl<<endl;
            line1.status=1;     line2.status=1;
        }
        */
        
        
        /// Коэффициент корреляции углов между опорными линиями кривых Безье N1 и N2. ///
        
        // Используется целочисленные значения углов и таблиц для ранней отсечки. Выигрыш 0,035сек (при 1,595сек),
        // такой же выигрыш дает "Нормализация по start end".
        // Используется без знаковый коэффициент корреляции двух линий по углам, как не чуствительный к реверсу.
        dltAlpha=abs(line1_alpInt-line2_alpInt); // Абсолютное значение разности углов двух опорных линий.
        CorAlphaL=tabAlpha_1[dltAlpha]; // Таблица для вычисления коэффициента корреляции уголов векторов.
        if(GrafT) {
            cout<<"(L) Разность (1) углов"<<"   line1.alpInt="<< line1.alpInt<<"  line2.alpInt="<<line2.alpInt<<"   dltAlpha="<<dltAlpha<<endl;
            cout<<"(L) Коэффициент корреляции углов между опорными линиями кривых Безье   CorAlphaL="<<CorAlphaL<<"%"<<endl<<endl;
        }
        // Выходим из функции, если коэффициент корреляции уголов между опорными линиями маленький. dlt_min
        if (CorAlphaL<dlt_min) {if(GrafT) {cout<<"(L) 1 Коэффициент корреляции < "<<dlt_min<<"   return"<<endl<<endl;}   return 0;}
        // 18,0 млн  из  25,0 млн
        /**/
        

        
        
        /// Отработка реверсивных кривых Безье. В Декартовых координатах. ///
        
        /// Например, при делении на углы возникают реверсивные кривые. Реверсивные пары: 2975, 2976.
        // При совмещении по центрам (в Декартовых координатах), у реверсивных кривых ближайшие друг к другу конци линий L1 L2,
        // оказываются названными по разному.
        // В Полярных координатах это приводит к тому что у таких кривых:
        // - вектора P1 и P2 меняются местами.
        // - к углам alpha и alphaP1P2 добавяется по 180 градусов.
        // Подсчет коэффициента корреляции при этом дает не верный результат
        
        float L1x0=line1.p0_c.x;            float L1y0=line1.p0_c.y;    // приведенные координаты точки p0 линии L1    start_с
        /// float L1x0=line1.start_с.x;     float L1y0=line1.start_с.y; // приведенные координаты точки p0 линии L1    start_с
        /// float L1x3=-L1x0;               float L1y3=-L1y0;           // приведенные координаты точки p3 линии L1      end_с
        // Получаем координаты начальных и конечных точек опорной линии L2 по отношению к ее середине.
        float L2x0=line2.p0_c.x;            float L2y0=line2.p0_c.y;    // приведенные координаты точки p0 линии L2    start_с
        /// float L2x0=line2.start_с.x;     float L2y0=line2.start_с.y; // приведенные координаты точки p0 линии L2    start_с
        /// float L2x3=-L2x0;               float L2y3=-L2y0;           // приведенные координаты точки p3 линии L2      end_с
        //if(GrafT)cout<<"line1.p0_c.x="<<line1.p0_c.x<<"   line2.p0_c.x="<<line2.p0_c.x<<endl;
        //if(GrafT)cout<<"line1.start_с.x="<<line1.start_с.x<<"   line1.start_с.y="<<line1.start_с.y<<endl;

        
        // Определение ближайших к друг другу концов линий L1 L2, совмещенных по центру. В Декартовых координатах. //
        // Для этого сравнениваем квадраты расстояний между точкой p0 кривой N1 и точками p0 или p3 кривой Безье N2.
        // Если расписать квадраты расстояний по теореме Пифагора, раскрыть скобки и привести подобные, получится простая формула:
        // L1x0*L2x0 >-L1y0*L2y0. Это условие полностью эквивалентно прямому сравнению квадратов расстояний между этими точками и
        // вычисляется быстрее. Теория и вывод формулы в конце функции.
        // Если ближайшие концы линий помечены не одинакого, например  start_с и end_с  (start_с и end_с), то необходимо
        // формально поменять местами (между собой) содержимое контрольных векторов P1 и P2 кривой Безье.
        // Для этого меняем местами значения их углов и длин. Углы векторов L и P1P2 соответственно отличаются на 180°.
        // Это ситуация "реверсивной кривой".
        
        int L2;
        // Проверка названий ближайших концов линий по квадратам расстояний (к названиям привязаны конкретные углы и длины).
        if (L1x0*L2x0 <-L1y0*L2y0){ // <  основная проверка     // register1=12853788
        //if (L1x0*L2x0 >-L1y0*L2y0){ // >  зеркальная проверка
            ///cout<<"index1="<<line1.index<<" index2="<<line2.index;
            ///cout<<"   line1_alpInt="<<line1_alpInt <<" line2_alpInt="<<line2_alpInt<<"   РЕВЕРС"<<endl;
            // Меняем местами (между собой) содержимое контрольных векторов P1 и P2.
            L2=line2_alphaP1;    line2_alphaP1=line2_alphaP2;    line2_alphaP2=L2;
            L2=line2_lenP1;      line2_lenP1=line2_lenP2;        line2_lenP2=L2;
            // Переносим начало координат для отсчета углов с одного конца линии на другой.
            if (line2_alphaP1P2<=180) { line2_alphaP1P2=line2_alphaP1P2 + 180; }    else line2_alphaP1P2=line2_alphaP1P2 - 180;
            // почему -180? +180-360=-180;
            if(GrafT){
                cout<<"line2_alphaP1="<<line2_alphaP1<<"   line2_alphaP2="<<line2_alphaP2<<endl;
                cout<<endl<<"<РЕВЕРС>"<<endl<<endl;
            }
           /// register1++;
        } // if (L1x0*L2x0 <-L1y0*L2y0)
        /**/


        /// Коэффициент корреляции уголов между векторами P1P2 кривых Безье N1 и N2. ///

        // Вычисление разности углов между контрольными векторами P1P2 кривых Безье N1 и N2.
        deltaAlpha=fabs(line1_alphaP1P2-line2_alphaP1P2);
        //if(GrafT)cout<<"(P1P2) Разность (2) углов"<<"   line1_alphaP1P2="<< line1_alphaP1P2<<"  line2_alphaP1P2="<<line2_alphaP1P2<<"   deltaAlpha="<<deltaAlpha<<endl;
        
        // Вычисление коэффициента корреляции углов между контрольными векторами P1P2 кривых Безье N1 и N2.
        // Находим наименьший угол (<90°) между контрольными векторами кривых Безье N1 и N2.
        if (deltaAlpha>180) deltaAlpha=360-deltaAlpha;
        if (deltaAlpha>90) {deltaAlpha=180-deltaAlpha; CorAlphaP1P2=-100+nr111*deltaAlpha;} else CorAlphaP1P2=100-nr111*deltaAlpha;
        /**/
        if(GrafT) {
            cout<<"(P1P2) deltaAlpha="<<deltaAlpha<<"     Разность (2) углов между векторами P1P2 кривых Безье N1 и N2"<<endl;
            cout<<"(P1P2) Коэффициент корреляции углов между контрольными векторами P1P2   CorAlphaP1P2="<<CorAlphaP1P2<<"%"<<endl<<endl;
        }
        // Выходим из функции, если коэффициент корреляции уголов между контрольными векторами P1P2 маленький.
        if (CorAlphaP1P2<dlt_min) { if(GrafT) cout<<"(P1P2) 3 Коэффициент корреляции < "<<dlt_min<<"    return"<<endl<<endl; return 0;}
        // 13,6 млн


        
        /// Коэффициент корреляции уголов между контрольными векторами P1 кривых Безье N1 и N2. ///

        // Вычисление разности углов между контрольными векторами P1 кривых Безье N1 и N2.
        deltaAlpha=fabs(line1_alphaP1-line2_alphaP1);
        //if(GrafT)cout<<"(P1) Разность (2) углов"<<"   line1_alphaP1="<< line1_alphaP1<<"  line2_alphaP1="<<line2_alphaP1<<"   deltaAlpha="<<deltaAlpha<<endl;
        
        // Вычисление коэффициента корреляции углов между контрольными векторами P1 кривых Безье N1 и N2.
        // Находим наименьший угол (<90°) между контрольными векторами кривых Безье N1 и N2.
        if (deltaAlpha>180) deltaAlpha=360-deltaAlpha;
        if (deltaAlpha>90) {deltaAlpha=180-deltaAlpha; CorAlphaP1=-100+nr111*deltaAlpha;}  else CorAlphaP1=100-nr111*deltaAlpha;
        // Разности углов от 90° до 0° соответствует коэффициент корреляции от 0 до 100%. // CorAlphaP1=100-100*deltaAlpha/90;
        /**/
        if(GrafT) {
            cout<<"(P1) deltaAlpha="<<deltaAlpha<<"     Разность (2) углов между векторами P1 кривых Безье N1 и N2"<<endl;
            cout<<"(P1) Коэффициент корреляции углов между контрольными векторами P1   CorAlphaP1="<<CorAlphaP1<<"%"<<endl<<endl;
        }
        // Выходим из функции, если коэффициент корреляции уголов между контрольными векторами P1 маленький.
        if (CorAlphaP1<dlt_min) { if(GrafT) cout<<"(P1) 2 Коэффициент корреляции < "<<dlt_min<<"    return"<<endl<<endl; return 0;}
        // 10,0 млн
        

        
        /// Коэффициент корреляции уголов между контрольными векторами P2 кривых Безье N1 и N2. ///

        // Вычисление разности углов между контрольными векторами P2 кривых Безье N1 и N2.
        deltaAlpha=fabs(line1_alphaP2-line2_alphaP2);
        //if(GrafT)cout<<"(P2) Разность (2) углов"<<"   line1_alphaP2="<< line1_alphaP2<<"  line2_alphaP2="<<line2_alphaP2<<"   deltaAlpha="<<deltaAlpha<<endl;
        
        // Вычисление коэффициента корреляции углов между контрольными векторами P2 кривых Безье N1 и N2.
        // Находим наименьший угол (<90°) между контрольными векторами кривых Безье N1 и N2.
        if (deltaAlpha>180) deltaAlpha=360-deltaAlpha;
        if (deltaAlpha>90) {deltaAlpha=180-deltaAlpha; CorAlphaP2=-100+nr111*deltaAlpha;} else CorAlphaP2=100-nr111*deltaAlpha;
        /**/
        if(GrafT) {
            cout<<"(P2) deltaAlpha="<<deltaAlpha<<"     Разность (2) углов между векторами P2 кривых Безье N1 и N2"<<endl;
            cout<<"(P2) Коэффициент корреляции углов между контрольными векторами P2   CorAlphaP2="<<CorAlphaP2<<"%"<<endl<<endl;
        }
        // Выходим из функции, если коэффициент корреляции уголов между контрольными векторами P2 маленький.
        if (CorAlphaP2<dlt_min) { if(GrafT) cout<<"(P2) 3 Коэффициент корреляции < "<<dlt_min<<"    return"<<endl<<endl; return 0;}
        // 8,0 млн
        
       
        
        
        /// Суммарный коэффициент корреляции соответствующих трех пар векторов кривых Безье, без весов. ///
        
        /*
        // 1. Суммарный коэффициент корреляции углов трех векторов. Суммы разности углов берутся с фиксированными весами 1/3.
        //  Не зависит от наклона и масштаба.
        float CorAlphaSUM=(CorAlphaP1 + CorAlphaP1P2 + CorAlphaP2)/3.0;  // Нормирующий коэффициент =3.
        if(GrafT)cout<<"Коэффициент корреляции кривых Безье (суммы разности углов с весами 1/3).   CorAlphaSUM="
        <<CorAlphaSUM<<"%"<<endl<<endl;
        // не подходит для отсечки
        */
        
        // 2. Суммарный коэффициент корреляции углов трех векторов P1, P2, P1P2 с пропорциональными весами.
        // в место опорной линией испльзуется вектор lenP1P2. Не зависит от наклона и масштаба.
        wg_P1=line1_lenP1*line2_lenP1;   wgP1P2=line1_lenP1P2*line2_lenP1P2;   wg_P2=line1_lenP2*line2_lenP2;
        // Нормирующий коэффициент.
        float norm=(wg_P1 + wgP1P2 + wg_P2);
        // Суммы коэффициентов корреляции углов берутся с весами пропорциональными произведению длин соответствующих векторов.
        float CorAlphaSUM=(wg_P1*CorAlphaP1 + wgP1P2*CorAlphaP1P2 + wg_P2*CorAlphaP2)/norm;
        if(GrafT)cout<<"Суммарный коэффициент корреляции кривых Безье (суммы корреляции разности углов с весами проп. длине векторов).    CorAlphaSUM="
            <<CorAlphaSUM<<"%"<<endl<<endl;
        /**/

        
        /*
        if(CorAlphaSUM>85) {   // 0,87 млн  time=1.56 сек
            register1++;
        }
        // 25 000 000 - 18 000 000 = 7 000 000
        */
        
        
        if(GrafT)cout<<"-----------------------------------------------------------------------------------"<<endl;
        
        // Возвращаем суммарный коэффициент корреляции двух кривых Безье.
        return CorAlphaSUM;
        
        //---------------------------------------------------------------------------------------------------------------------------
        
        /*
        ////////////
         float dx, dy;
         // Совмещение двух кривых Безье по середине их опорных линий L.
         // Прямое вычисление квадратов расстояний между точкой p0 кривой N1 и точками p0 или p3 кривой Безье N2.
         dx=L1x0 - L2x0;     dy=L1y0 - L2y0;
         // квадрат расстояния между точкой p0 кривой N1 и точкой p0 кривой Безье N2.
         float L1p0_L2p0=dx*dx + dy*dy;      // float L1p0_L2p0=sqrt(dx*dx + dy*dy);
         //  dx=L1x0 - L2x3;     dy=L1y0 - L2y3;
         dx=L1x0 + L2x0;     dy=L1y0 + L2y0;
         // квадрат расстояния между точкой p0 кривой N1 и точкой p3 кривой Безье N2.
         float L1p0_L2p3=dx*dx + dy*dy;      // float L1p0_L2p3=sqrt(dx*dx + dy*dy);
         ///if (L1p0_L2p0 > L1p0_L2p3){ //}  // register1=12853788   // if (L1x0*L2x0 <-L1y0*L2y0){ // register1=12853788
        ////////////
        */
        
        ////////////
        // вывод формулы //
        // исходная формула равенства квадрата расстояния между точкой p0 кривой N1 и точками p0 или p3 кривой Безье N2.
        //   (L1x0 - L2x0)*(L1x0 - L2x0) + (L1y0 - L2y0)*(L1y0 - L2y0) =
        // = (L1x0 + L2x0)*(L1x0 + L2x0) + (L1y0 + L2y0)*(L1y0 + L2y0)
        
        // (L1x0 - L2x0)*(L1x0 - L2x0)=L1x0*L1x0 - 2*L1x0*L2x0 + L2x0*L2x0
        // (L1y0 - L2y0)*(L1y0 - L2y0)=L1y0*L1y0 - 2*L1y0*L2y0 + L2y0*L2y0
        // (L1x0 + L2x0)*(L1x0 + L2x0)=L1x0*L1x0 + 2*L1x0*L2x0 + L2x0*L2x0
        // (L1y0 + L2y0)*(L1y0 + L2y0)=L1y0*L1y0 + 2*L1y0*L2y0 + L2y0*L2y0
        
        // - 2*L1x0*L2x0 - 2*L1y0*L2y0 = 2*L1x0*L2x0 + 2*L1y0*L2y0
        //               - 4*L1y0*L2y0 = 4*L1x0*L2x0
        //                   L1x0*L2x0 = -L1y0*L2y0
        // Конечная формула L1x0*L2x0 = -L1y0*L2y0 равенства квадрата расстояния между точкой p0 кривой N1 и
        // точками p0 или p3 кривой Безье N2. Соответственно ее можно использовать для сравнения >< величины
        // расстояний между этими точками.
        // Это же условие является условием перпендикулярности двух прямых.
        // Одновременно L1x0*L2x0 + L1y0*L2y0=0; левая часть это скалярное произведение векторов L1 и L2 в координатах.
        // L1p0_L2p0 > L1p0_L2p3  и  L1x0*L2x0 >-L1y0*L2y0  эти условия полностью эквивалентны,
        // а второе условие вычислять быстрее.
        ////////////

    }//____________________________________________________________________________

    
    
    //*****************************************************************************
    
    /// Correlation BezierA ///
    
    // Функция для сравнения (корреляции) двух кривых Безье. Может не зависить масштаба и поворота кривых Безье.
    float GGraphBezier::CorrelationBezierA(OCRFocalLineBezier &line1, OCRFocalLineBezier &line2, int pCor){
        
        
        // Функция осуществляет сравнение кривых Безье. По трем векторам считает коэффициент корреляции.
        // На вход в итоге получает ID номера сравниваемых линий N1 и N2.
        // Возвращает полный коэффициент корреляции кривых Безье N1 и N2.
        // Функция в общем случае не зависит от наклона и  сравниваемых кривых Безье.
        
        // pCor=0 коэффициент корреляции не зависит от масштаба (зависит от поворота кривых Безье).
        // pCor=1 коэффициент корреляции не зависит от масштаба и от поворота кривых Безье.
        
        /// Теория ///
        // Кривая Безье описывается тремя векторами: двумя управляющими векторами P1 и P2 и вектором P1P2
        // проведенным между концами контрольных векторов. Коэффициент корреляции двух векторов "a" и "b"
        // (степень похожести) определяется их скалярным произведением.
        // Для полярных координат удобная форма:
        // - скалярным произведением двух векторов "ab" называется число, равное произведению модулей (длинны)
        // этих векторов "a*b" на косинус угла между ними "cos(alpha).  ab=a*b*cos(alpha), 0≤alpha≤П.
        // Для декартовых координат удобная форма:
        // - скалярное произведение векторов "a" и "b" равно сумме произведений соответствующих
        // координат ab=ax*bx+ay*by.
        // Суммарный коэффициент корреляции кривых Безье (N1, N2) равен сумме коэффициентов корреляции трех
        // векторов (P1, P1P2, P2) с весами пропорциональными длине векторов.
        // У cos плоская вершина, поэтому вместо него применена нормировка коэффициента корреляции углом
        // в 90° градусов, у которой острая вершина. Если ипользовать cos, то лучше вычислить его по таблице.
        // Если не вычислять разность углов между векторами и опорной линией, то функция станет зависимой
        // от поворота кривых Безье, но останется не зависимой от масштаба. Не забыть заблокировать лимиты "dlt_min".
        
        
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if(GrafT){
            cout<<endl<<"-----------------------------------------------------------------------------------"<<endl;
            cout<<endl<<"Функция для сравнения (корреляции) двух кривых Безье N1 и N2.   CorrelationBezierT() "<<endl;
        }
        
        
        // Кривая Безье N1. // все данные 01 сек
        //float line1_len=line1.len;            // длина опорной линии, проведенной от начальной 0 до конечной 3 точки.
        float line1_alpha=line1.alpha;          // угол между опорной линией кривой Безье N1 и горизонталью.
        float line1_lenP1=line1.lenP1;          // длина первого контрольного вектора кривой Безье N1.
        float line1_alphaP1=line1.alphaP1;      // угол наклона первого контрольного вектора кривой Безье N1.
        float line1_lenP2=line1.lenP2;          // длина второго контрольного вектора кривой Безье N1.
        float line1_alphaP2=line1.alphaP2;      // угол наклона второго контрольного вектора кривой Безье N1.
        float line1_lenP1P2=line1.lenP1P2;      // длина вектора проведенного между концами контрольных векторов pix.
        float line1_alphaP1P2=line1.alphaP1P2;  // угол наклона вектора проведенного между концами контрольных векторов.
        
        // Кривая Безье N2.
        //float line2_len=line2.len;            // длина опорной линии, проведенной от начальной 0 до конечной 3 точки
        float line2_alpha=line2.alpha;          // угол между опорной линией кривой Безье N2 и горизонталью.
        float line2_lenP1=line2.lenP1;          // длина первого контрольного вектора кривой Безье N2.
        float line2_alphaP1=line2.alphaP1;      // угол наклона первого контрольного вектора кривой Безье N2.
        float line2_lenP2=line2.lenP2;          // длина второго контрольного вектора кривой Безье N2.
        float line2_alphaP2=line2.alphaP2;      // угол наклона второго контрольного вектора кривой Безье N2.
        float line2_lenP1P2=line2.lenP1P2;      // длина вектора проведенного между концами контрольных векторов в pix.
        float line2_alphaP1P2=line2.alphaP1P2;  // угол наклона вектора проведенного между концами контрольных векторов.
        /**/
        
        // целочисленные значения углов для применения таблицы.
        int line1_alpInt=line1.alpInt;
        int line2_alpInt=line2.alpInt;
        
        float deltaAlpha;   // Абсолютное значение разности углов между двух линий.
        int dltAlpha;
        float CorAlphaL;    // Коэффициент корреляции углов между опорными линиями кривых Безье N1 и N2.
        float CorAlphaP1;   // Коэффициент корреляции углов между контрольными векторами P1 кривых Безье N1 и N2.
        float CorAlphaP2;   // Коэффициент корреляции углов между контрольными векторами P2 кривых Безье N1 и N2.
        float CorAlphaP1P2; // Коэффициент корреляции углов между контрольными векторами P1P2 кривых Безье N1 и N2.
        // Опорная линиям условно проведена между начальными 0 и конечными точками 3 кривой Безье.
        /**/
        
        
        // веса коэффициентов корреляции углов.
        float wg_P1=0, wgP1P2=0, wg_P2=0; //wgL=0
        // При коэффициенте корреляции меньше порога, выходим из функции.
        float dlt_min=25;   //  50%  Минимальный порог коэффициента корреляции уголов (от-100% до 100%).
        // dlt_min=25%; соответствует разность уголов dltAlpha=67°;
        // dlt_min=50%; соответствует разность уголов dltAlpha=45°;
        // dlt_min=33%; максимальное значение выше которого начинается влияние на конечный коэффициент корреляции.
        
        float nr111=1.11111111; // 100.0/90.0
        // CorAlphaL=100-100*deltaAlpha/90;
        
        // Базовое правило применения углов. //
        // Если одна прямая имеет отрицательный угловой коэффициент, а вторая положительный,
        // то угол между этими прямыми будет равен сумме абсолютных величин этих углов.
        // В случае же, когда угловые коэффициенты оба отрицательны или оба положительны,
        // то угол находится путем вычитания из большего угла меньшего (abs).
        // http://www.kakprosto.ru/kak-126210-kak-opredelit-ugol-mezhdu-dvumya-pryamymi
        
        // Для вычисления коэффициента корреляции используется наименьший угол между прямыми (контрольными векторами кривых Безье),
        // Особенности вычисления коэффициента корреляции подробно разобраны и нарисованы в функции buildOCRAlphaTable().
        
         /*
         int L_1=14;        int L_2=215;
         if(line1.index==L_1 && line2.index==L_2){ GrafT=1; } // 3617 1697   ///////////////////////////////////////////////////////////
         if(GrafT) {
         cout<<"line1.index"<< line1.index<<"  line2.index="<<line2.index<<endl<<endl;
         line1.status=1;     line2.status=1;
         }
         */
        
        
        /// Коэффициент корреляции углов между опорными линиями кривых Безье N1 и N2. ///
        
        // Используется целочисленные значения углов и таблиц для ранней отсечки. Выигрыш 0,035сек (при 1,595сек),
        // такой же выигрыш дает "Нормализация по start end".
        // Используется без знаковый коэффициент корреляции двух линий по углам, как не чуствительный к реверсу.
        dltAlpha=abs(line1_alpInt-line2_alpInt); // Абсолютное значение разности углов двух опорных линий.
        CorAlphaL=tabAlpha_1[dltAlpha]; // Таблица для вычисления коэффициента корреляции уголов векторов.
        if(GrafT) {
            cout<<"(L) Разность (1) углов"<<"   line1.alpInt="<< line1.alpInt<<"  line2.alpInt="<<line2.alpInt<<"   dltAlpha="<<dltAlpha<<endl;
            cout<<"(L) Коэффициент корреляции углов между опорными линиями кривых Безье   CorAlphaL="<<CorAlphaL<<"%"<<endl<<endl;
        }
        // Выходим из функции, если коэффициент корреляции уголов между опорными линиями маленький. dlt_min
        if (CorAlphaL<dlt_min) {if(GrafT) {cout<<"(L) 1 Коэффициент корреляции < "<<dlt_min<<"   return"<<endl<<endl;}   return 0;}
        // 18,0 млн  из  25,0 млн
        /**/
        
        
        
        /// Отработка реверсивных кривых Безье. В Декартовых координатах. ///
        
        /// Например, при делении на углы возникают реверсивные кривые. Реверсивные пары: 2975, 2976.
        // В Декартовых координатах, у реверсивных кривых ближайшие друг к другу конци линий L1 L2,
        // оказываются названными по разному. Линии L1 L2 при этом совмещены по центрам.
        // В Полярных координатах это приводит к тому что у таких кривых:
        // - вектора P1 и P2 меняются местами.
        // - к углам alpha и alphaP1P2 добавяется по 180 градусов.
        // Подсчет коэффициента корреляции при этом дает не верный результат
        
        // Переход из глобальных координат в локальные координаты, совмещение двух кривых Безье по середине их опорных линий. //
        // Получаем координаты начальных и конечных точек опорной линии L1 по отношению к ее середине.

        float L1x0=line1.p0_c.x;            float L1y0=line1.p0_c.y;    // приведенные координаты точки p0 линии L1    start_с
        /// float L1x0=line1.start_с.x;     float L1y0=line1.start_с.y; // приведенные координаты точки p0 линии L1    start_с
        /// float L1x3=-L1x0;               float L1y3=-L1y0;           // приведенные координаты точки p3 линии L1      end_с
        // Получаем координаты начальных и конечных точек опорной линии L2 по отношению к ее середине.
        float L2x0=line2.p0_c.x;            float L2y0=line2.p0_c.y;    // приведенные координаты точки p0 линии L2    start_с
        /// float L2x0=line2.start_с.x;     float L2y0=line2.start_с.y; // приведенные координаты точки p0 линии L2    start_с
        /// float L2x3=-L2x0;               float L2y3=-L2y0;           // приведенные координаты точки p3 линии L2      end_с
        //if(GrafT)cout<<"line1.p0_c.x="<<line1.p0_c.x<<"   line2.p0_c.x="<<line2.p0_c.x<<endl;
        //if(GrafT)cout<<"line1.start_с.x="<<line1.start_с.x<<"   line1.start_с.y="<<line1.start_с.y<<endl;
        
        
        // Определение ближайших к друг другу концов линий L1 L2, совмещенных по центру. В Декартовых координатах. //
        // Для этого сравнениваем квадраты расстояний между точкой p0 кривой N1 и точками p0 или p3 кривой Безье N2.
        // Если расписать квадраты расстояний по теореме Пифагора, раскрыть скобки и привести подобные, получится простая формула:
        // L1x0*L2x0 >-L1y0*L2y0. Это условие полностью эквивалентно прямому сравнению квадратов расстояний между этими точками и
        // вычисляется быстрее. Теория и вывод формулы в конце функции.
        // Если ближайшие концы линий помечены не одинакого, например  start_с и end_с  (start_с и end_с), то необходимо
        // формально поменять местами (между собой) содержимое контрольных векторов P1 и P2 кривой Безье.
        // Для этого меняем местами значения их углов и длин. Углы векторов L и P1P2 соответственно отличаются на 180°.
        // Это ситуация "реверсивной кривой".
        
        int L2;
        // Проверка названий ближайших концов линий по квадратам расстояний (к названиям привязаны конкретные углы и длины).
        if (L1x0*L2x0 <-L1y0*L2y0){ // <       // register1=12853788
            ///cout<<"index1="<<line1.index<<" index2="<<line2.index;
            ///cout<<"   line1_alpInt="<<line1_alpInt <<" line2_alpInt="<<line2_alpInt<<"   РЕВЕРС"<<endl;
            // Меняем местами (между собой) содержимое контрольных векторов P1 и P2.
            L2=line2_alphaP1;    line2_alphaP1=line2_alphaP2;    line2_alphaP2=L2;
            L2=line2_lenP1;      line2_lenP1=line2_lenP2;        line2_lenP2=L2;
            // Переносим начало координат для отсчета углов с одного конца линии на другой.
            if (line2_alphaP1P2<=180) { line2_alphaP1P2=line2_alphaP1P2 + 180; }    else line2_alphaP1P2=line2_alphaP1P2 - 180;
            // почему -180? +180-360=-180;
            if(GrafT){
                cout<<"line2_alphaP1="<<line2_alphaP1<<"   line2_alphaP2="<<line2_alphaP2<<endl;
                cout<<endl<<"<РЕВЕРС>"<<endl<<endl;
            }
///            register1++;
        } // if (L1x0*L2x0 <-L1y0*L2y0)
        /**/
        
        
        
        /// Коэффициент корреляции уголов между векторами P1P2 кривых Безье N1 и N2. ///
        
        if(pCor){
            // Приведенние углов векторов к опорной линии.
            // Разность углов между вектором P1P2 и опорной линией кривой Безье N1.
            float deltaAlphaL1P1P2=fabs(line1_alphaP1P2-line1_alpha);
            // Разность углов между вектором P1P2 и опорной линией кривой Безье N2.
            float deltaAlphaL2P1P2=fabs(line2_alphaP1P2-line2_alpha);
            // Вычисление разности приведенных углов между контрольными векторами P1P2 кривых Безье N1 и N2.
            deltaAlpha=fabs(deltaAlphaL1P1P2-deltaAlphaL2P1P2);
            
            ///dltAlpha=(int)fabs(deltaAlphaL1P1P2-deltaAlphaL2P1P2);
            ///CorAlphaP1P2=tabAlpha_1[dltAlpha];
        }else{
            // Вычисление разности углов между контрольными векторами P1P2 кривых Безье N1 и N2.
            deltaAlpha=fabs(line1_alphaP1P2-line2_alphaP1P2);
            
            ///dltAlpha=(int)fabs(line1_alphaP1P2-line2_alphaP1P2);
            ///CorAlphaP1P2=tabAlpha_1[dltAlpha];
        }
        //if(GrafT)cout<<"(P1P2) Разность (2) углов"<<"   line1_alphaP1P2="<< line1_alphaP1P2<<"  line2_alphaP1P2="<<line2_alphaP1P2<<"   deltaAlpha="<<deltaAlpha<<endl;
        // Вычисление коэффициента корреляции углов между контрольными векторами P1P2 кривых Безье N1 и N2.
        // Находим наименьший угол (<90°) между контрольными векторами кривых Безье N1 и N2.
        if (deltaAlpha>180) deltaAlpha=360-deltaAlpha;
        if (deltaAlpha>90) {deltaAlpha=180-deltaAlpha; CorAlphaP1P2=-100+nr111*deltaAlpha;} else CorAlphaP1P2=100-nr111*deltaAlpha;
        /**/
        if(GrafT) {
            cout<<"(P1P2) deltaAlpha="<<deltaAlpha<<"     Разность (2) углов между векторами P1P2 кривых Безье N1 и N2"<<endl;
            cout<<"(P1P2) Коэффициент корреляции углов между контрольными векторами P1P2   CorAlphaP1P2="<<CorAlphaP1P2<<"%"<<endl<<endl;
        }
        // Выходим из функции, если коэффициент корреляции уголов между контрольными векторами P1P2 маленький.
        if (CorAlphaP1P2<dlt_min) { if(GrafT) cout<<"(P1P2) 3 Коэффициент корреляции < "<<dlt_min<<"    return"<<endl<<endl; return 0;}
        // 13,6 млн
        
        
        
        /// Коэффициент корреляции уголов между контрольными векторами P1 кривых Безье N1 и N2. ///
        
        if(pCor){
            // Приведенние углов векторов к опорной линии.
            // Разность углов между вектором P1 и опорной линией кривой Безье N1.
            float deltaAlphaL1P1=fabs(line1_alphaP1-line1_alpha);
            // Разность углов между вектором P1 и опорной линией кривой Безье N2.
            float deltaAlphaL2P1=fabs(line2_alphaP1-line2_alpha);
            // Вычисление разности приведенных углов между контрольными векторами P1 кривых Безье N1 и N2.
            deltaAlpha=fabs(deltaAlphaL1P1-deltaAlphaL2P1); // абсолютное значение разности углов двух контрольных векторов.
            
            ///dltAlpha=(int)fabs(deltaAlphaL1P1-deltaAlphaL2P1);
            ///CorAlphaP1=tabAlpha_1[dltAlpha];
        }else{
            // Вычисление разности углов между контрольными векторами P1 кривых Безье N1 и N2.
            deltaAlpha=fabs(line1_alphaP1-line2_alphaP1);
            
            ///dltAlpha=(int)fabs(line1_alphaP1-line2_alphaP1);
            ///CorAlphaP1=tabAlpha_1[dltAlpha];
        }
        //if(GrafT)cout<<"(P1) Разность (2) углов"<<"   line1_alphaP1="<< line1_alphaP1<<"  line2_alphaP1="<<line2_alphaP1<<"   deltaAlpha="<<deltaAlpha<<endl;
        // Вычисление коэффициента корреляции углов между контрольными векторами P1 кривых Безье N1 и N2.
        // Находим наименьший угол (<90°) между контрольными векторами кривых Безье N1 и N2.
        if (deltaAlpha>180) deltaAlpha=360-deltaAlpha;
        if (deltaAlpha>90) {deltaAlpha=180-deltaAlpha; CorAlphaP1=-100+nr111*deltaAlpha;}  else CorAlphaP1=100-nr111*deltaAlpha;
        // Разности углов от 90° до 0° соответствует коэффициент корреляции от 0 до 100%. // CorAlphaP1=100-100*deltaAlpha/90;
        /**/
        if(GrafT) {
            cout<<"(P1) deltaAlpha="<<deltaAlpha<<"     Разность (2) углов между векторами P1 кривых Безье N1 и N2"<<endl;
            cout<<"(P1) Коэффициент корреляции углов между контрольными векторами P1   CorAlphaP1="<<CorAlphaP1<<"%"<<endl<<endl;
        }
        // Выходим из функции, если коэффициент корреляции уголов между контрольными векторами P1 маленький.
        if (CorAlphaP1<dlt_min) { if(GrafT) cout<<"(P1) 2 Коэффициент корреляции < "<<dlt_min<<"    return"<<endl<<endl; return 0;}
        // 10,0 млн
        
        
        
        /// Коэффициент корреляции уголов между контрольными векторами P2 кривых Безье N1 и N2. ///
        
        if(pCor){
            // Приведенние углов векторов к опорной линии.
            // Разность углов между вектором P2 и опорной линией кривой Безье N1.
            float deltaAlphaL1P2=fabs(line1_alphaP2-line1_alpha);
            // Разность углов между вектором P2 и опорной линией кривой Безье N2.
            float deltaAlphaL2P2=fabs(line2_alphaP2-line2_alpha);
            // Вычисление разности углов между контрольными векторами P2 кривых Безье N1 и N2.
            deltaAlpha=fabs(deltaAlphaL1P2-deltaAlphaL2P2);
            
            ///dltAlpha=(int)fabs(deltaAlphaL1P2-deltaAlphaL2P2);
            ///CorAlphaP2=tabAlpha_1[dltAlpha];
        }else{
            // Вычисление разности углов между контрольными векторами P2 кривых Безье N1 и N2.
            deltaAlpha=fabs(line1_alphaP2-line2_alphaP2);
            
            ///dltAlpha=(int)fabs(line1_alphaP2-line2_alphaP2);
            ///CorAlphaP2=tabAlpha_1[dltAlpha];
        }
        //if(GrafT)cout<<"(P2) Разность (2) углов"<<"   line1_alphaP2="<< line1_alphaP2<<"  line2_alphaP2="<<line2_alphaP2<<"   deltaAlpha="<<deltaAlpha<<endl;
        // Вычисление коэффициента корреляции углов между контрольными векторами P2 кривых Безье N1 и N2.
        // Находим наименьший угол (<90°) между контрольными векторами кривых Безье N1 и N2.
        if (deltaAlpha>180) deltaAlpha=360-deltaAlpha;
        if (deltaAlpha>90) {deltaAlpha=180-deltaAlpha; CorAlphaP2=-100+nr111*deltaAlpha;} else CorAlphaP2=100-nr111*deltaAlpha;
        /**/
        if(GrafT) {
            cout<<"(P2) deltaAlpha="<<deltaAlpha<<"     Разность (2) углов между векторами P2 кривых Безье N1 и N2"<<endl;
            cout<<"(P2) Коэффициент корреляции углов между контрольными векторами P2   CorAlphaP2="<<CorAlphaP2<<"%"<<endl<<endl;
        }
        // Выходим из функции, если коэффициент корреляции уголов между контрольными векторами P2 маленький.
        if (CorAlphaP2<dlt_min) { if(GrafT) cout<<"(P2) 3 Коэффициент корреляции < "<<dlt_min<<"    return"<<endl<<endl; return 0;}
        // 8,0 млн
        
        
        
        
        /// Суммарный коэффициент корреляции соответствующих трех пар векторов кривых Безье, без весов. ///
        
        /*
        // 1. Суммарный коэффициент корреляции углов трех векторов. Суммы разности углов берутся с фиксированными весами 1/3.
        //  Не зависит от наклона и масштаба.
        float CorAlphaSUM=(CorAlphaP1 + CorAlphaP1P2 + CorAlphaP2)/3.0;  // Нормирующий коэффициент =3.
        if(GrafT)cout<<"Коэффициент корреляции кривых Безье (суммы разности углов с весами 1/3).   CorAlphaSUM="
        <<CorAlphaSUM<<"%"<<endl<<endl;
        // не подходит для отсечки
        */
        
        // 2. Суммарный коэффициент корреляции углов трех векторов P1, P2, P1P2 с пропорциональными весами.
        // в место опорной линией испльзуется вектор lenP1P2. Не зависит от наклона и масштаба.
        wg_P1=line1_lenP1*line2_lenP1;   wgP1P2=line1_lenP1P2*line2_lenP1P2;   wg_P2=line1_lenP2*line2_lenP2;
        // Нормирующий коэффициент.
        float norm=(wg_P1 + wgP1P2 + wg_P2);
        // Суммы коэффициентов корреляции углов берутся с весами пропорциональными произведению длин соответствующих векторов.
        float CorAlphaSUM=(wg_P1*CorAlphaP1 + wgP1P2*CorAlphaP1P2 + wg_P2*CorAlphaP2)/norm;
        if(GrafT)cout<<"Суммарный коэффициент корреляции кривых Безье (суммы корреляции разности углов с весами проп. длине векторов).    CorAlphaSUM="
            <<CorAlphaSUM<<"%"<<endl<<endl;
        /**/

        
        /*
        if(CorAlphaSUM>85) {   // 0,87 млн  time=1.56 сек
            register1++;
        }
        // 25 000 000 - 18 000 000 = 7 000 000
        */
        
        
        if(GrafT)cout<<"-----------------------------------------------------------------------------------"<<endl;
        
        // Возвращаем суммарный коэффициент корреляции двух кривых Безье.
        return CorAlphaSUM;
        
        
        //---------------------------------------------------------------------------------------------------------------------------
        
        
        /// Отработка реверсивных кривых Безье. В Полярных координатах.
        /// не полностью совпадает с результатом полученным в Декартовых координатах.
        //int flag=0;
        ///     if (line1_alpInt < 180 || line2_alpInt < 180) {flag=1; register1++;} //cout<<"index1="<<line1.index<<" index2="<<line2.index<<"   РЕВЕРС АЛЬФА"<<endl;
        //if(flag) cout<<"+++АЛЬФА"<<endl;
        
        /*
         ////////////
         float dx, dy;
         // Совмещение двух кривых Безье по середине их опорных линий L.
         // Прямое вычисление квадратов расстояний между точкой p0 кривой N1 и точками p0 или p3 кривой Безье N2.
         dx=L1x0 - L2x0;     dy=L1y0 - L2y0;
         // квадрат расстояния между точкой p0 кривой N1 и точкой p0 кривой Безье N2.
         float L1p0_L2p0=dx*dx + dy*dy;      // float L1p0_L2p0=sqrt(dx*dx + dy*dy);
         //  dx=L1x0 - L2x3;     dy=L1y0 - L2y3;
         dx=L1x0 + L2x0;     dy=L1y0 + L2y0;
         // квадрат расстояния между точкой p0 кривой N1 и точкой p3 кривой Безье N2.
         float L1p0_L2p3=dx*dx + dy*dy;      // float L1p0_L2p3=sqrt(dx*dx + dy*dy);
         ///if (L1p0_L2p0 > L1p0_L2p3){ //}  // register1=12853788   // if (L1x0*L2x0 <-L1y0*L2y0){ // register1=12853788
         ////////////
         */
        
        ////////////
        // вывод формулы //
        // исходная формула равенства квадрата расстояния между точкой p0 кривой N1 и точками p0 или p3 кривой Безье N2.
        //   (L1x0 - L2x0)*(L1x0 - L2x0) + (L1y0 - L2y0)*(L1y0 - L2y0) =
        // = (L1x0 + L2x0)*(L1x0 + L2x0) + (L1y0 + L2y0)*(L1y0 + L2y0)
        
        // (L1x0 - L2x0)*(L1x0 - L2x0)=L1x0*L1x0 - 2*L1x0*L2x0 + L2x0*L2x0
        // (L1y0 - L2y0)*(L1y0 - L2y0)=L1y0*L1y0 - 2*L1y0*L2y0 + L2y0*L2y0
        // (L1x0 + L2x0)*(L1x0 + L2x0)=L1x0*L1x0 + 2*L1x0*L2x0 + L2x0*L2x0
        // (L1y0 + L2y0)*(L1y0 + L2y0)=L1y0*L1y0 + 2*L1y0*L2y0 + L2y0*L2y0
        
        // - 2*L1x0*L2x0 - 2*L1y0*L2y0 = 2*L1x0*L2x0 + 2*L1y0*L2y0
        //               - 4*L1y0*L2y0 = 4*L1x0*L2x0
        //                   L1x0*L2x0 = -L1y0*L2y0
        // Конечная формула L1x0*L2x0 = -L1y0*L2y0 равенства квадрата расстояния между точкой p0 кривой N1 и
        // точками p0 или p3 кривой Безье N2. Соответственно ее можно использовать для сравнения >< величины
        // расстояний между этими точками.
        // Это же условие является условием перпендикулярности двух прямых.
        // Одновременно L1x0*L2x0 + L1y0*L2y0=0; левая часть это скалярное произведение векторов L1 и L2 в координатах.
        // L1p0_L2p0 > L1p0_L2p3  и  L1x0*L2x0 >-L1y0*L2y0  эти условия полностью эквивалентны,
        // а второе условие вычислять быстрее.
        ////////////
        
    }//____________________________________________________________________________

        
    
    //*****************************************************************************
    
                    /// Correlation BezierB ///
    
    // Функция для сравнения (корреляции) двух кривых Безье. С параметрами выбора векторов.
    float GGraphBezier::CorrelationBezierB(OCRFocalLineBezier &line1, OCRFocalLineBezier &line2, int mirror, int ln, int p1, int p1p2, int p2){

        
        // Функция осуществляет сравнение кривых Безье. По трем векторам считает коэффициент корреляции.
        // На вход в итоге получает ID номера сравниваемых линий N1 и N2.
        // Возвращает полный коэффициент корреляции кривых Безье N1 и N2.
        // Функция в общем случае не зависит от наклона и масштаба сравниваемых кривых Безье.
        
        /// Теория ///
        // Кривая Безье описывается тремя векторами: двумя управляющими векторами P1 и P2 и вектором P1P2
        // проведенным между концами контрольных векторов. Коэффициент корреляции двух векторов "a" и "b"
        // (степень похожести) определяется их скалярным произведением.
        // Для полярных координат удобная форма:
        // - скалярным произведением двух векторов "ab" называется число, равное произведению модулей (длинны)
        // этих векторов "a*b" на косинус угла между ними "cos(alpha).  ab=a*b*cos(alpha), 0≤alpha≤П.
        // Для декартовых координат удобная форма:
        // - скалярное произведение векторов "a" и "b" равно сумме произведений соответствующих
        // координат ab=ax*bx+ay*by.
        // Суммарный коэффициент корреляции кривых Безье (N1, N2) равен сумме коэффициентов корреляции трех
        // векторов (P1, P1P2, P2) с весами пропорциональными длине векторов.
        // У cos плоская вершина, поэтому вместо него применена нормировка коэффициента корреляции углом
        // в 90° градусов, у которой острая вершина. Если ипользовать cos, то лучше вычислить его по таблице.
        // Если не вычислять разность углов между векторами и опорной линией, то функция станет зависимой
        // от поворота кривых Безье, но останется не зависимой от масштаба. Не забыть заблокировать лимиты "dlt_min".


        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if(GrafT){
            cout<<endl<<"-----------------------------------------------------------------------------------"<<endl;
            cout<<endl<<"Функция для сравнения (корреляции) двух кривых Безье N1 и N2.   CorrelationBezierB() "<<endl;
        }
        
        
        // Кривая Безье N1.
        //float line1_len=line1.len;          // длина опорной линии, проведенной от начальной 0 до конечной 3 точки.
        float line1_alpha=line1.alpha;      // угол между опорной линией кривой Безье N1 и горизонталью.
        float line1_lenP1=line1.lenP1;      // длина первого контрольного вектора кривой Безье N1.
        float line1_alphaP1=line1.alphaP1;  // угол наклона первого контрольного вектора кривой Безье N1.
        float line1_lenP2=line1.lenP2;      // длина второго контрольного вектора кривой Безье N1.
        float line1_alphaP2=line1.alphaP2;  // угол наклона второго контрольного вектора кривой Безье N1.
        float line1_lenP1P2=line1.lenP1P2;      // длина вектора проведенного между концами контрольных векторов pix.
        float line1_alphaP1P2=line1.alphaP1P2;  // угол наклона вектора проведенного между концами контрольных векторов.
        
        // Кривая Безье N2.
        //float line2_len=line2.len;          // длина опорной линии, проведенной от начальной 0 до конечной 3 точки.
        float line2_alpha=line2.alpha;      // угол между опорной линией кривой Безье N2 и горизонталью.
        float line2_lenP1=line2.lenP1;      // длина первого контрольного вектора кривой Безье N2.
        float line2_alphaP1=line2.alphaP1;  // угол наклона первого контрольного вектора кривой Безье N2.
        float line2_lenP2=line2.lenP2;      // длина второго контрольного вектора кривой Безье N2.
        float line2_alphaP2=line2.alphaP2;  // угол наклона второго контрольного вектора кривой Безье N2.
        float line2_lenP1P2=line2.lenP1P2;      // длина вектора проведенного между концами контрольных векторов в pix.
        float line2_alphaP1P2=line2.alphaP1P2;  // угол наклона вектора проведенного между концами контрольных векторов.
        /**/

        
        // Если необходимо сравнить две кривые у которых вектора расположены в противоположном порядке (зеркальные вектора),
        // то у нее формально меняем местами контрольные вектора P1 и P2 кривой Безье (их углы и длины).
        // Опорные вектора L и P1P2 оставляем как есть, поскольку они симметричны относительно начальных и конечных точек кривой Безье.
        
        
        
        /// Отработка реверсивных кривых Безье. В Декартовых координатах. ///
        
        /// Например, при делении на углы возникают реверсивные кривые. Реверсивные пары: 2975, 2976.
        // В Декартовых координатах, у реверсивных кривых ближайшие друг к другу конци линий L1 L2,
        // оказываются названными по разному. Линии L1 L2 при этом совмещены по центрам.
        // В Полярных координатах это приводит к тому что у таких кривых:
        // - вектора P1 и P2 меняются местами.
        // - к углам alpha и alphaP1P2 добавяется по 180 градусов.
        // Подсчет коэффициента корреляции при этом дает не верный результат
        
        // Переход из глобальных координат в локальные координаты, совмещение двух кривых Безье по середине их опорных линий. //
        // Получаем координаты начальных и конечных точек опорной линии L1 по отношению к ее середине.
        
        float L1x0=line1.p0_c.x;            float L1y0=line1.p0_c.y;    // приведенные координаты точки p0 линии L1    start_с
        /// float L1x0=line1.start_с.x;     float L1y0=line1.start_с.y; // приведенные координаты точки p0 линии L1    start_с
        /// float L1x3=-L1x0;               float L1y3=-L1y0;           // приведенные координаты точки p3 линии L1      end_с
        // Получаем координаты начальных и конечных точек опорной линии L2 по отношению к ее середине.
        float L2x0=line2.p0_c.x;            float L2y0=line2.p0_c.y;    // приведенные координаты точки p0 линии L2    start_с
        /// float L2x0=line2.start_с.x;     float L2y0=line2.start_с.y; // приведенные координаты точки p0 линии L2    start_с
        /// float L2x3=-L2x0;               float L2y3=-L2y0;           // приведенные координаты точки p3 линии L2      end_с
        //if(GrafT)cout<<"line1.p0_c.x="<<line1.p0_c.x<<"   line2.p0_c.x="<<line2.p0_c.x<<endl;
        //if(GrafT)cout<<"line1.start_с.x="<<line1.start_с.x<<"   line1.start_с.y="<<line1.start_с.y<<endl;
        
        
        // Определение ближайших к друг другу концов линий L1 L2, совмещенных по центру. В Декартовых координатах. //
        // Для этого сравнениваем квадраты расстояний между точкой p0 кривой N1 и точками p0 или p3 кривой Безье N2.
        // Если расписать квадраты расстояний по теореме Пифагора, раскрыть скобки и привести подобные, получится простая формула:
        // L1x0*L2x0 >-L1y0*L2y0. Это условие полностью эквивалентно прямому сравнению квадратов расстояний между этими точками и
        // вычисляется быстрее. Теория и вывод формулы в конце функции.
        // Если ближайшие концы линий помечены не одинакого, например  start_с и end_с  (start_с и end_с), то необходимо
        // формально поменять местами (между собой) содержимое контрольных векторов P1 и P2 кривой Безье.
        // Для этого меняем местами значения их углов и длин. Углы векторов L и P1P2 соответственно отличаются на 180°.
        // Это ситуация "реверсивной кривой".
        
        int L2;
        // Проверка названий ближайших концов линий по квадратам расстояний (к названиям привязаны конкретные углы и длины).
        if (L1x0*L2x0 <-L1y0*L2y0){ // <       // register1=12853788
            ///cout<<"index1="<<line1.index<<" index2="<<line2.index;
            ///cout<<"   line1_alpInt="<<line1_alpInt <<" line2_alpInt="<<line2_alpInt<<"   РЕВЕРС"<<endl;
            // Меняем местами (между собой) содержимое контрольных векторов P1 и P2.
            L2=line2_alphaP1;    line2_alphaP1=line2_alphaP2;    line2_alphaP2=L2;
            L2=line2_lenP1;      line2_lenP1=line2_lenP2;        line2_lenP2=L2;
            // Переносим начало координат для отсчета углов с одного конца линии на другой.
            if (line2_alphaP1P2<=180) { line2_alphaP1P2=line2_alphaP1P2 + 180; }    else line2_alphaP1P2=line2_alphaP1P2 - 180;
            // почему -180? +180-360=-180;
            // Отработать креверс между опорными линиями кривых Безье N1 и N2.
            if(GrafT){
                cout<<"line2_alphaP1="<<line2_alphaP1<<"   line2_alphaP2="<<line2_alphaP2<<endl;
                cout<<endl<<"<РЕВЕРС>"<<endl<<endl;
            }
            ///            register1++;
        } // if (L1x0*L2x0 <-L1y0*L2y0)
        /**/
        
        
        if (mirror) {
            // Меняем местами (между собой) содержимое контрольных векторов P1 и P2.
            L2=line2_alphaP1;    line2_alphaP1=line2_alphaP2;    line2_alphaP2=L2;
            if (line2_alphaP2<=180) { line2_alphaP2=-line2_alphaP2 + 180; }    else line2_alphaP2=-line2_alphaP2 + 360;
            if (line2_alphaP1<=180) { line2_alphaP1=-line2_alphaP1 + 180; }    else line2_alphaP1=-line2_alphaP1 + 360;
            ///if (line2_alphaP1<=180) { line2_alphaP1=line2_alphaP1 + 180; }    else line2_alphaP1=line2_alphaP1 - 180;
            ///if (line2_alphaP2<=180) { line2_alphaP2=line2_alphaP2 + 180; }    else line2_alphaP2=line2_alphaP2 - 180;
            //if (line2_alphaP1<=180) { line2_alphaP1=-line2_alphaP1 + 180; }    else line2_alphaP1=-line2_alphaP1 - 180;
            //if (line2_alphaP2<=180) { line2_alphaP2=-line2_alphaP2 + 180; }    else line2_alphaP2=-line2_alphaP2 - 180;
            L2=line2_lenP1;      line2_lenP1=line2_lenP2;        line2_lenP2=L2;
            

            // Переносим начало координат для отсчета углов с одного конца линии на другой.
            ///if (line2_alphaP1P2<=180) { line2_alphaP1P2=line2_alphaP1P2 + 180; }    else line2_alphaP1P2=line2_alphaP1P2 - 180;//////////
 //           if (line2_alphaP1P2<=180) { line2_alphaP1P2=-line2_alphaP1P2 + 180; }    else line2_alphaP1P2=-line2_alphaP1P2 + 360;
            /////////if (line2_alphaP1P2<=180) { line2_alphaP1P2=line2_alphaP1P2 + 180; }    else line2_alphaP1P2=line2_alphaP1P2 - 180;
            ///////if (line2_alphaP1P2<=180) { line2_alphaP1P2=-line2_alphaP1P2 + 180; }    else line2_alphaP1P2=-line2_alphaP1P2 - 180;
            // почему -180? +180-360=-180;
            // Отработать реверс между опорными линиями кривых Безье N1 и N2.
        }
        
        
        float deltaAlpha;       // Абсолютное значение разности углов между двух линий.
        float CorAlphaL=0;      // Коэффициент корреляции углов между опорными линиями кривых Безье N1 и N2.
        float CorAlphaP1=0;     // Коэффициент корреляции углов между контрольными векторами P1 кривых Безье N1 и N2.
        float CorAlphaP2=0;     // Коэффициент корреляции углов между контрольными векторами P2 кривых Безье N1 и N2.
        float CorAlphaP1P2=0;   // Коэффициент корреляции углов между контрольными векторами P1P2 кривых Безье N1 и N2.
        // Опорная линиям условно проведена между начальными 0 и конечными точками 3 кривой Безье.
        /**/
        
        
        // веса коэффициентов корреляции углов.
        float wgL=0, wg_P1=0, wgP1P2=0, wg_P2=0;
        // произведения весов коэффициентов корреляции углов на сам коэффициент корреляции.
        ///float  wgL_CorAlphaL, wg_P1_CorAlphaP1, wgP1P2_CorAlphaP1P2, wg_P2_CorAlphaP2;
        // Коэффициент корреляции масштабанезависим.
        
        // При коэффициенте корреляции меньше порога, выходим из функции.
        float dlt_min=25;   //  50  Минимальный порог коэффициента корреляции уголов (от-100 до 100).
        // dlt_min=25%; соответствует разность уголов dltAlpha=67°;
        // dlt_min=50%; соответствует разность уголов dltAlpha=45°;
        // dlt_min=33%; максимальное значение выше которого начинается влияние на конечный коэффициент корреляции.
        
        
        int pCor=0;
        if (pCor==0) line1_alpha=line2_alpha=0;
        // pCor=0 коэффициент корреляции не зависит от масштаба (зависит от поворота кривых Безье).
        // pCor=1 коэффициент корреляции не зависит от масштаба и от поворота кривых Безье.
        
        float nr111=1.11111111; // 100.0/90.0
        // CorAlphaL=100-100*deltaAlpha/90;
        
        
        // Базовое правило применения углов. //
        // Если одна прямая имеет отрицательный угловой коэффициент, а вторая положительный,
        // то угол между этими прямыми будет равен сумме абсолютных величин этих углов.
        // В случае же, когда угловые коэффициенты оба отрицательны или оба положительны,
        // то угол находится путем вычитания из большего угла меньшего (abs).
        // http://www.kakprosto.ru/kak-126210-kak-opredelit-ugol-mezhdu-dvumya-pryamymi
        
        // Для вычисления коэффициента корреляции используется наименьший угол между прямыми (контрольными векторами кривых Безье),
        // Особенности вычисления коэффициента корреляции подробно разобраны и нарисованы в функции buildOCRAlphaTable().
        
    /*
    /// Коэффициент корреляции уголов между опорными линиями кривых Безье N1 и N2. ///
    if(ln){
        // Абсолютное значение разности углов двух опорных линий.
        deltaAlpha=fabs(line1_alpha-line2_alpha);
        
        // Находим наименьший угол (<90°) между опорными линиями кривых Безье N1 и N2.
        if (deltaAlpha>180) deltaAlpha=360-deltaAlpha;
        if (deltaAlpha>90) deltaAlpha=180-deltaAlpha;
        // Коэффициент корреляции двух линий по углам. // CorAlphaL=100-100*deltaAlpha/90;
        CorAlphaL=100-nr111*deltaAlpha; // разности углов от 90° до 0° соответствует коэффициент корреляции от 0 до 100%.
        if(GrafT)cout<<"(L) Разность (1) углов"<<"  line1_alpha="<<    line1_alpha<<"  line2_alpha="<<line2_alpha<<"   deltaAlpha="<<deltaAlpha<<endl;
        if(GrafT)cout<<"(L) Коэффициент корреляции углов между опорными линиями кривых Безье   CorAlphaL="<<CorAlphaL<<"%"<<endl<<endl;
        
        // Выходим из функции, если коэффициент корреляции уголов между опорными линиями маленький.
        if (CorAlphaL<dlt_min) {if(GrafT) cout<<"(L) 1 Коэффициент корреляции < "<<dlt_min<<"   return"<<endl<<endl;   return 0;}
        
        // Bес опорной линии в суммарном коэффициенте корреляции.
        wgL=0.25*line1_len*line2_len; // влияние длины опорной линией на общий коэффициент корреляции углов уменьшено в два раза.
    }
    */

        
    /// Коэффициент корреляции уголов между контрольными векторами P1 кривых Безье N1 и N2. ///
    if(p1){
        // Приведенние углов векторов к опорной линии.
        // Разность углов между вектором P1 и опорной линией кривой Безье N1.
        float deltaAlphaL1P1=fabs(line1_alphaP1-line1_alpha);
        // Разность углов между вектором P1 и опорной линией кривой Безье N2.
        float deltaAlphaL2P1=fabs(line2_alphaP1-line2_alpha);
///        if (mirror) {deltaAlphaL2P1=180-deltaAlphaL2P1;    if (deltaAlphaL2P1<0) deltaAlphaL2P1+=360;}
        
        // Вычисление коэффициента корреляции углов между контрольными векторами P1 кривых Безье N1 и N2.
        // Вычисление разности углов между контрольными векторами P1 кривых Безье N1 и N2.
        deltaAlpha=fabs(deltaAlphaL1P1-deltaAlphaL2P1); // абсолютное значение разности углов двух контрольных векторов.
        // Находим наименьший угол (<90°) между контрольными векторами кривых Безье N1 и N2.
        if (deltaAlpha>180) deltaAlpha=360-deltaAlpha;
        if (deltaAlpha>90) {deltaAlpha=180-deltaAlpha; CorAlphaP1=-100+nr111*deltaAlpha;}  else CorAlphaP1=100-nr111*deltaAlpha;
        // Разности углов от 90° до 0° соответствует коэффициент корреляции от 0 до 100%. // CorAlphaP1=100-100*deltaAlpha/90;
        if(GrafT) {
            cout<<"(P1) deltaAlpha="<<deltaAlpha<<"     Разность (2) углов между векторами P1 кривых Безье N1 и N2"<<endl;
            cout<<"(P1) Коэффициент корреляции углов между контрольными векторами P1   CorAlphaP1="<<CorAlphaP1<<"%"<<endl<<endl;
        }
        // Выходим из функции, если коэффициент корреляции уголов между контрольными векторами P1 маленький.
        if (CorAlphaP1<dlt_min) { if(GrafT) cout<<"(P1) 2 Коэффициент корреляции < "<<dlt_min<<"    return"<<endl<<endl; return 0;}
        
        // Bес вектора P1 в суммарном коэффициенте корреляции.
        wg_P1=line1_lenP1*line2_lenP1;
    }
       
        
    /// Коэффициент корреляции уголов между векторами P1P2 кривых Безье N1 и N2. ///
    if(p1p2){
        // Приведенние углов векторов к опорной линии.
        // Разность углов между вектором P1P2 и опорной линией кривой Безье N1.
        float deltaAlphaL1P1P2=fabs(line1_alphaP1P2-line1_alpha);
        // Разность углов между вектором P1P2 и опорной линией кривой Безье N2.
        float deltaAlphaL2P1P2=fabs(line2_alphaP1P2-line2_alpha);
        
        // Вычисление коэффициента корреляции углов между контрольными векторами P1P2 кривых Безье N1 и N2.
        // Вычисление разности углов между контрольными векторами P1P2 кривых Безье N1 и N2.
        deltaAlpha=fabs(deltaAlphaL1P1P2-deltaAlphaL2P1P2);
        // Находим наименьший угол (<90°) между контрольными векторами кривых Безье N1 и N2.
        if (deltaAlpha>180) deltaAlpha=360-deltaAlpha;
        if (deltaAlpha>90) {deltaAlpha=180-deltaAlpha; CorAlphaP1P2=-100+nr111*deltaAlpha;} else CorAlphaP1P2=100-nr111*deltaAlpha;
        if(GrafT) {
            cout<<"(P1P2) deltaAlpha="<<deltaAlpha<<"     Разность (2) углов между векторами P1P2 кривых Безье N1 и N2"<<endl;
            cout<<"(P1P2) Коэффициент корреляции углов между контрольными векторами P1P2   CorAlphaP1P2="<<CorAlphaP1P2<<"%"<<endl<<endl;
        }
        // Выходим из функции, если коэффициент корреляции уголов между контрольными векторами P1P2 маленький.
        if (CorAlphaP1P2<dlt_min) { if(GrafT) cout<<"(P1P2) 3 Коэффициент корреляции < "<<dlt_min<<"    return"<<endl<<endl; return 0;}
        
        // Bес вектора P1P2 в суммарном коэффициенте корреляции.
        wgP1P2=line1_lenP1P2*line2_lenP1P2;
    }
        
        
    /// Коэффициент корреляции уголов между контрольными векторами P2 кривых Безье N1 и N2. ///
    if(p2){
        // Приведенние углов векторов к опорной линии.
        // Разность углов между вектором P2 и опорной линией кривой Безье N1.
        float deltaAlphaL1P2=fabs(line1_alphaP2-line1_alpha);
        // Разность углов между вектором P2 и опорной линией кривой Безье N2.
        float deltaAlphaL2P2=fabs(line2_alphaP2-line2_alpha);
///        if (mirror) {deltaAlphaL2P2=180-deltaAlphaL2P2;    if (deltaAlphaL2P2<0) deltaAlphaL2P2+=360;}
        
        // Вычисление коэффициента корреляции углов между контрольными векторами P2 кривых Безье N1 и N2.
        // Вычисление разности углов между контрольными векторами P2 кривых Безье N1 и N2.
        deltaAlpha=fabs(deltaAlphaL1P2-deltaAlphaL2P2);
        // Находим наименьший угол (<90°) между контрольными векторами кривых Безье N1 и N2.
        if (deltaAlpha>180) deltaAlpha=360-deltaAlpha;
        if (deltaAlpha>90) {deltaAlpha=180-deltaAlpha; CorAlphaP2=-100+nr111*deltaAlpha;} else CorAlphaP2=100-nr111*deltaAlpha;
        if(GrafT) {
            cout<<"(P2) deltaAlpha="<<deltaAlpha<<"     Разность (2) углов между векторами P2 кривых Безье N1 и N2"<<endl;
            cout<<"(P2) Коэффициент корреляции углов между контрольными векторами P2   CorAlphaP2="<<CorAlphaP2<<"%"<<endl<<endl;
        }
        // Выходим из функции, если коэффициент корреляции уголов между контрольными векторами P2 маленький.
        if (CorAlphaP2<dlt_min) { if(GrafT) cout<<"(P2) 3 Коэффициент корреляции < "<<dlt_min<<"    return"<<endl<<endl; return 0;}
        
        // Bес вектора P2 в суммарном коэффициенте корреляции.
        wg_P2=line1_lenP2*line2_lenP2;
    }
        

        
        /// Суммарный коэффициент корреляции углов (в общем случае) 4х векторов L, P1, P1P2, P2 с пропорциональными весами.///
        
        // Нормирующий коэффициент.
        float norm=(wgL + wg_P1 + wgP1P2 + wg_P2);
        // Суммы коэффициентов корреляции углов берутся с весами пропорциональными произведению длин соответствующих векторов.
        float CorAlphaSUM=(wgL*CorAlphaL + wg_P1*CorAlphaP1 + wgP1P2*CorAlphaP1P2 + wg_P2*CorAlphaP2)/norm;
        if(GrafT)cout<<"Суммарный коэффициент корреляции кривых Безье (суммы корреляции разности углов с весами проп. длине векторов).    CorAlphaSUM="<<CorAlphaSUM<<"%"<<endl<<endl;
        /**/

        
        if(GrafT)cout<<"-----------------------------------------------------------------------------------"<<endl;
        
        // Возвращаем суммарный коэффициент корреляции двух кривых Безье.
        return CorAlphaSUM;
        

        /**/
        /// Проверка совпадения первых управляющих точек кривых Безье N1 и N2. ///
        // Фактически это проверка совпадения двух ломаных линий. Можно обобщить до двух ломаных кривых Безье.
        // Соединяя пары ломаных линий вперекрышку, можно сравнивать многоугольники.
        // М.б. масштабонезависимая, если проверять отношение длин линий.
        
        
    }//____________________________________________________________________________
    
    
    //*****************************************************************************

    
    // Рабочий код, но не понадобился. //
    
    //-------------------------------------------------------------------------------------------------------------------------
    
    
    /// Отработка реверсивных кривых Безье. В Полярных координатах.
    /// не полностью совпадает с результатом полученным в Декартовых координатах.
    //int flag=0;
    ///     if (line1_alpInt < 180 || line2_alpInt < 180) {flag=1; register1++;} //cout<<"index1="<<line1.index<<" index2="<<line2.index<<"   РЕВЕРС АЛЬФА"<<endl;
    //if(flag) cout<<"+++АЛЬФА"<<endl;
    
    //------------------------------------------------------
    
    /*
    /// Отработка реверсивных кривых Безье. В Декартовых координатах. ///
    
    /// Например, при делении на углы возникают реверсивные кривые. Реверсивные пары: 2975, 2976.
    // В Декартовых координатах, у реверсивных кривых ближайшие друг к другу конци линий L1 L2,
    // оказываются названными по разному. Линии L1 L2 при этом совмещены по центрам.
    // В Полярных координатах это приводит к тому что у таких кривых:
    // - вектора P1 и P2 меняются местами.
    // - к углам alpha и alphaP1P2 добавяется по 180 градусов.
    // Подсчет коэффициента корреляции при этом дает не верный результат
    
    // Переход из глобальных координат в локальные координаты, совмещение двух кривых Безье по середине их опорных линий. //
    // Получаем координаты начальных и конечных точек опорной линии L1 по отношению к ее середине.
    float L1x0=line1.start_с.x;   float L1y0=line1.start_с.y;   // приведенные координаты точки p0 линии L1    start_с
    ///// float L1x3=-L1x0;       float L1y3=-L1y0;             // приведенные координаты точки p3 линии L1      end_с
    // Получаем координаты начальных и конечных точек опорной линии L2 по отношению к ее середине.
    float L2x0=line2.start_с.x;   float L2y0=line2.start_с.y;   // приведенные координаты точки p0 линии L2    start_с
    ///// float L2x3=-L2x0;       float L2y3=-L2y0;             // приведенные координаты точки p3 линии L2      end_с
    //if(GrafT)cout<<"line1.start_с.x="<<line1.start_с.x<<"   line1.start_с.y="<<line1.start_с.y<<endl;
    
    // Определение ближайших к друг другу концов линий L1 L2, совмещенных по центру. В Декартовых координатах. //
    // Для этого сравнениваем квадраты расстояний между точкой p0 кривой N1 и точками p0 или p3 кривой Безье N2.
    // Если расписать квадраты расстояний по теореме Пифагора, раскрыть скобки и привести подобные, получится простая формула:
    // L1x0*L2x0 >-L1y0*L2y0. Это условие полностью эквивалентно прямому сравнению квадратов расстояний между этими точками и
    // вычисляется быстрее. Теория и вывод формулы в конце функции.
    // Если ближайшие концы линий помечены не одинакого, например  start_с и end_с  (start_с и end_с), то необходимо
    // формально поменять местами (между собой) содержимое контрольных векторов P1 и P2 кривой Безье.
    // Для этого меняем местами значения их углов и длин. Углы векторов L и P1P2 соответственно отличаются на 180°.
    // Это ситуация "реверсивной кривой".
    
    int L2;
    // Проверка названий ближайших концов линий по квадратам расстояний (к названиям привязаны конкретные углы и длины).
    if (L1x0*L2x0 <-L1y0*L2y0){ // <       // register1=12853788
        ///cout<<"index1="<<line1.index<<" index2="<<line2.index;
        ///cout<<"   line1_alpInt="<<line1_alpInt <<" line2_alpInt="<<line2_alpInt<<"   РЕВЕРС"<<endl;
        // Меняем местами (между собой) содержимое контрольных векторов P1 и P2.
        L2=line2_alphaP1;    line2_alphaP1=line2_alphaP2;    line2_alphaP2=L2;
        L2=line2_lenP1;      line2_lenP1=line2_lenP2;        line2_lenP2=L2;
        // Переносим начало координат с одного конца линии на другой.
        if (line2_alphaP1P2<=180) { line2_alphaP1P2=line2_alphaP1P2 + 180; }    else line2_alphaP1P2=line2_alphaP1P2 - 180;
        // почему -180? +180-360=-180;
        if(GrafT){
            cout<<"line2_alphaP1="<<line2_alphaP1<<"   line2_alphaP2="<<line2_alphaP2<<endl;
            cout<<endl<<"<РЕВЕРС>"<<endl<<endl;
        }
      register1++;
    } // if (L1x0*L2x0 <-L1y0*L2y0)
    */
                
    //------------------------------------------
                
    /*
     ////////////
     float dx, dy;
     // Совмещение двух кривых Безье по середине их опорных линий L.
     // Прямое вычисление квадратов расстояний между точкой p0 кривой N1 и точками p0 или p3 кривой Безье N2.
     dx=L1x0 - L2x0;     dy=L1y0 - L2y0;
     // квадрат расстояния между точкой p0 кривой N1 и точкой p0 кривой Безье N2.
     float L1p0_L2p0=dx*dx + dy*dy;      // float L1p0_L2p0=sqrt(dx*dx + dy*dy);
     //  dx=L1x0 - L2x3;     dy=L1y0 - L2y3;
     dx=L1x0 + L2x0;     dy=L1y0 + L2y0;
     // квадрат расстояния между точкой p0 кривой N1 и точкой p3 кривой Безье N2.
     float L1p0_L2p3=dx*dx + dy*dy;      // float L1p0_L2p3=sqrt(dx*dx + dy*dy);
     ///if (L1p0_L2p0 > L1p0_L2p3){ //}  // register1=12853788   // if (L1x0*L2x0 <-L1y0*L2y0){ // register1=12853788
     ////////////
     */
    
    ////////////
    // вывод формулы //
    // исходная формула равенства квадрата расстояния между точкой p0 кривой N1 и точками p0 или p3 кривой Безье N2.
    //   (L1x0 - L2x0)*(L1x0 - L2x0) + (L1y0 - L2y0)*(L1y0 - L2y0) =
    // = (L1x0 + L2x0)*(L1x0 + L2x0) + (L1y0 + L2y0)*(L1y0 + L2y0)
    
    // (L1x0 - L2x0)*(L1x0 - L2x0)=L1x0*L1x0 - 2*L1x0*L2x0 + L2x0*L2x0
    // (L1y0 - L2y0)*(L1y0 - L2y0)=L1y0*L1y0 - 2*L1y0*L2y0 + L2y0*L2y0
    // (L1x0 + L2x0)*(L1x0 + L2x0)=L1x0*L1x0 + 2*L1x0*L2x0 + L2x0*L2x0
    // (L1y0 + L2y0)*(L1y0 + L2y0)=L1y0*L1y0 + 2*L1y0*L2y0 + L2y0*L2y0
    
    // - 2*L1x0*L2x0 - 2*L1y0*L2y0 = 2*L1x0*L2x0 + 2*L1y0*L2y0
    //               - 4*L1y0*L2y0 = 4*L1x0*L2x0
    //                   L1x0*L2x0 = -L1y0*L2y0
    // Конечная формула L1x0*L2x0 = -L1y0*L2y0 равенства квадрата расстояния между точкой p0 кривой N1 и
    // точками p0 или p3 кривой Безье N2. Соответственно ее можно использовать для сравнения >< величины
    // расстояний между этими точками.
    // Это же условие является условием перпендикулярности двух прямых.
    // Одновременно L1x0*L2x0 + L1y0*L2y0=0; левая часть это скалярное произведение векторов L1 и L2 в координатах.
    // L1p0_L2p0 > L1p0_L2p3  и  L1x0*L2x0 >-L1y0*L2y0  эти условия полностью эквивалентны,
    // а второе условие вычислять быстрее.
    ////////////
    
    //-------------------------------------------------------------------------------------------------------------------------
    
    /*
     /// Вычисление разности уголов между контрольным вектором P1 (P2,P1P2) и опорной линией кривой Безье N1 (N2). ///
     /// Углы приведенные к опорной линии.
     //if(GrafT)cout<<"(P) Разность (1) углов"<<"  line1_alphaP1="<<line1_alphaP1<<"   line2_alphaP1="<<line2_alphaP1<<"   line1_alpha="<<line1_alpha<<endl<<endl;
     
     // Разность углов между вектором P1 и опорной линией кривой Безье N1. Углы приведенные к опорной линии.
     float deltaAlphaL1P1=fabs(line1_alphaP1-line1_alpha);
     // Разность углов между вектором P2 и опорной линией кривой Безье N1.
     float deltaAlphaL1P2=fabs(line1_alphaP2-line1_alpha);
     // Разность углов между вектором P1P2 и опорной линией кривой Безье N1.
     float deltaAlphaL1P1P2=fabs(line1_alphaP1P2-line1_alpha);
     
     // Разность углов между вектором P1 и опорной линией кривой Безье N2.
     float deltaAlphaL2P1=fabs(line2_alphaP1-line2_alpha);
     // Разность углов между вектором P2 и опорной линией кривой Безье N2.
     float deltaAlphaL2P2=fabs(line2_alphaP2-line2_alpha);
     // Разность углов между вектором P1P2 и опорной линией кривой Безье N2.
     float deltaAlphaL2P1P2=fabs(line2_alphaP1P2-line2_alpha);
     
     
     /// Вычисление коэффициента корреляции углов между контрольными векторами P1 (P2,P1P2) кривых Безье N1 и N2. ///
     
     // Вычисление разности углов между контрольными векторами P1 кривых Безье N1 и N2.
     deltaAlpha=fabs(deltaAlphaL1P1-deltaAlphaL2P1); // абсолютное значение разности углов двух контрольных векторов.
     // Находим наименьший угол (<90°) между контрольными векторами кривых Безье N1 и N2.
     if (deltaAlpha>180) deltaAlpha=360-deltaAlpha;
     if (deltaAlpha>90) {deltaAlpha=180-deltaAlpha; CorAlphaP1=-100+nr111*deltaAlpha;}  else CorAlphaP1=100-nr111*deltaAlpha;
     // Разности углов от 90° до 0° соответствует коэффициент корреляции от 0 до 100%. // CorAlphaP1=100-100*deltaAlpha/90;
     if(GrafT) {
     cout<<"(P1) deltaAlpha="<<deltaAlpha<<"     Разность (2) углов между векторами P1 кривых Безье N1 и N2"<<endl;
     cout<<"(P1) Коэффициент корреляции углов между контрольными векторами P1   CorAlphaP1="<<CorAlphaP1<<"%"<<endl<<endl;
     }
     // Выходим из функции, если коэффициент корреляции уголов между контрольными векторами P1 маленький.
     if (CorAlphaP1<dlt_min) { if(GrafT) cout<<"(P1) 2 Коэффициент корреляции < "<<dlt_min<<"    return"<<endl<<endl; return 0;}
     
     
     // Вычисление разности углов между контрольными векторами P2 кривых Безье N1 и N2.
     deltaAlpha=fabs(deltaAlphaL1P2-deltaAlphaL2P2);
     // Находим наименьший угол (<90°) между контрольными векторами кривых Безье N1 и N2.
     if (deltaAlpha>180) deltaAlpha=360-deltaAlpha;
     if (deltaAlpha>90) {deltaAlpha=180-deltaAlpha; CorAlphaP2=-100+nr111*deltaAlpha;} else CorAlphaP2=100-nr111*deltaAlpha;
     if(GrafT) {
     cout<<"(P2) deltaAlpha="<<deltaAlpha<<"     Разность (2) углов между векторами P2 кривых Безье N1 и N2"<<endl;
     cout<<"(P2) Коэффициент корреляции углов между контрольными векторами P2   CorAlphaP2="<<CorAlphaP2<<"%"<<endl<<endl;
     }
     // Выходим из функции, если коэффициент корреляции уголов между контрольными векторами P2 маленький.
     if (CorAlphaP2<dlt_min) { if(GrafT) cout<<"(P2) 3 Коэффициент корреляции < "<<dlt_min<<"    return"<<endl<<endl; return 0;}
     
     
     // Вычисление разности углов между контрольными векторами P1P2 кривых Безье N1 и N2.
     deltaAlpha=fabs(deltaAlphaL1P1P2-deltaAlphaL2P1P2);
     // Находим наименьший угол (<90°) между контрольными векторами кривых Безье N1 и N2.
     if (deltaAlpha>180) deltaAlpha=360-deltaAlpha;
     if (deltaAlpha>90) {deltaAlpha=180-deltaAlpha; CorAlphaP1P2=-100+nr111*deltaAlpha;} else CorAlphaP1P2=100-nr111*deltaAlpha;
     if(GrafT) {
     cout<<"(P1P2) deltaAlpha="<<deltaAlpha<<"     Разность (2) углов между векторами P1P2 кривых Безье N1 и N2"<<endl;
     cout<<"(P1P2) Коэффициент корреляции углов между контрольными векторами P1P2   CorAlphaP1P2="<<CorAlphaP1P2<<"%"<<endl<<endl;
     }
     // Выходим из функции, если коэффициент корреляции уголов между контрольными векторами P1P2 маленький.
     if (CorAlphaP1P2<dlt_min) { if(GrafT) cout<<"(P1P2) 3 Коэффициент корреляции < "<<dlt_min<<"    return"<<endl<<endl; return 0;}
     */
    
    //-------------------------------------------------------------------------------------------------------------------------
    
    
    /*
     // 2.1 Суммарный коэффициент корреляции углов трех векторов P1, P2, L с пропорциональными весами. Не зависимый от масштаба.
     // влияние длины опорной линией на общий коэффициент корреляции углов лучше уменьшить в два раза. // wgL*0.25;
     float wg_P1=line1_lenP1*line2_lenP1;   float wgL=0.25*line1_len*line2_len;   float wg_P2=line1_lenP2*line2_lenP2;
     // Нормирующий коэффициент.
     float norm=(wg_P1 + wgL + wg_P2);
     // Суммы коэффициентов корреляции углов берутся с весами пропорциональными произведению длин соответствующих векторов.
     float CorAlphaSUM_2=(wg_P1*CorAlphaP1 + wgL*CorAlphaL + wg_P2*CorAlphaP2)/norm;
     if(GrafT)cout<<"Коэффициент корреляции кривых Безье (суммы разности углов с весами проп. длине вектора).    CorAlphaSUM_2="
     <<CorAlphaSUM_2<<"%"<<endl<<endl;
     */
    
    /*
     // 3. Суммарный коэффициент корреляции углов двух векторов. Не зависимый от наклона.
     // проверить углы на -| кривых
     float k=(line1_lenP1*line2_lenP1 + line1_lenP2*line2_lenP2); // Нормирующий коэффициент
     float CorAlphaSUM_3=(line1_lenP1*line2_lenP1*CorAlphaP1 + line1_lenP2*line2_lenP2*CorAlphaP2)/k;
     if(GrafT)cout<<"Суммарный коэффициент корреляции углов (не зависимо от наклона).   CorAlphaSUM_3="
     <<CorAlphaSUM_3<<"%"<<endl<<endl;
     */
    
    /*
     /// Проверка совпадения относительных длин линий сравниваемых кривых Безье N1 и N2. ///
     
     // Коэффициент корреляции кривых Безье N1 и N2 по относительной длине опорныых линий (0-100%).
     float CorLenL=100*(1-2*fabs(line1_len-line2_len)/(line1_len+line2_len));
     // Коэффициент корреляции кривых Безье N1 и N2 по относительной длине контрольных векторов P1
     float CorLenP1=100*(1-2*fabs(line1_lenP1-line2_lenP1)/(line1_lenP1+line2_lenP1));
     // Коэффициент корреляции кривых Безье N1 и N2 по относительной длине контрольных векторов P2
     float CorLenP2=100*(1-2*fabs(line1_lenP2-line2_lenP2)/(line1_lenP2+line2_lenP2));
     if(GrafT)cout<<"-CorLenL="<<CorLenL<<"     CorLenP1="<<CorLenP1<<"     CorLenP2="<<CorLenP2<<endl;
     
     //  Суммарный коэффициент корреляции кривых Безье N1 и N2 по относительным длинам линий.
     float CorLenSUM=(CorLenP1 + CorLenL + CorLenP2)/3;
     if(GrafT)cout<<"---Суммарный коэффициент корреляции по относительным длинам линий кривых Безье N1 и N2.   CorLenSUM="<<CorLenSUM<<"%"<<endl;
     
     //  Полный коэффициент корреляции кривых Безье N1 и N2
     float CorBezierSUM=(CorAlphaSUM_2 + CorLenSUM)/2;
     //CorBezierSUM=sqrt(CorAlphaSUM*CorLenSUM);
     if(GrafT)cout<<"***Полный коэффициент корреляции кривых Безье N1 и N2    CorBezierSUM="<<CorBezierSUM<<"%***"<<endl<<endl;
     
     // Возвращаем суммарный коэффициент корреляции двух кривых Безье.
     return CorBezierSUM;
     */
    
    
    /**/
    
    /// Проверка совпадения первых управляющих точек кривых Безье N1 и N2. ///
    // Фактически это проверка совпадения двух ломаных линий. Можно обобщить до двух ломаных кривых Безье.
    // Соединяя пары ломаных линий вперекрышку, можно сравнивать многоугольники.
    // М.б. масштабонезависимая, если проверять отношение длин линий.
    
    //-------------------------------------------------------------------------------
    
    
};//____________________________________________________________________________





