//  Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .

#include "GGraphBezier.h"
#include <math.h> 


namespace ocr{
    
    //*****************************************************************************
    
    // FocalLineRecBezier //
    // Продолжение функциЙ FocalLineRecLeveling И FocalLineRecognition.

    
    //*****************************************************************************
    
                            /// BezierP (cubic) /// основная рабочая версия.
    
    // Функция с возможностью вычисления параметров кривой Безье по части фокальной линии.
    
    void GGraphBezier::focalLineBezierP(OCRFocalLineBezier &line, int strL, int endL){

        // int strL - расстояние от начальной точки фокальной линии start до начальной точки кривой Безье Px0.
        // int endL - расстояние от начальной точки фокальной линии start до конечной точки кривой Безье Px3.
        // Новая длина сглаженной фокальной линии   line.lenM=LengthLineM=endL-strL;
        
        // Функция по ID номеру линии вычисляет параметры (длина и угол) управляющих векторов кривой Безье,
        // без учета краёв фокальной линии, что эквивалентно переходу из декартовых координат в полярные.
        // Также вычисляются координаты управляющих точек и константы параметрического уравнения общего вида (A, B, C, D).
        // Две управляющие точки это те точки, которые таскаем мышкой при визуальном построении кривой (управляющие вектора).
        // Параметрическое уравнение общего вида: x(t)=Ax*t*t*t + Bx*t*t + Cx*t + Dx, аналогично для “y”,
        // где параметр t менятся в диапазоне от 0 до 1, от начала к концу кривой.
        // По сути выполняется апроксимация сглаженных фокальных линий еще более гладкими кривыми Безье.
        // Которые потенциально можно стыковать друг с другом.
        
        // Функция используя координаты начальных и конечных точек исходной кривой вычисляет координаты
        // узлов (главных точек) при t=L*1/3, t=L*2/3 по таблице mTab. По координатам главных точек вычисляются
        // параметры (длина и угол) управляющих векторов кривой Безье.
        
        int GrafT=1;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if(line.index==-1){ // 3617 1697
            GrafT=1; // 1
            cout<<endl<<"----------------------------------------------------------------------------"<<endl;
            cout<<endl<<"Функция для вычисления параметров (6) кривой Безье   focalLineBezierP() "<<endl;
            cout<<"index="<<line.index<<endl;
        }else GrafT=0;


        // Вычисление опорных точек. //
        // Для любых четырех точек на плоскости существует кривая Безье, проходящая через них при t = 0, 1/3, 2/3 и 1.
        // Источник: http://fullref.ru/job_a517a7c403e9395d49dc5ea305453db0.html


        // получение указателя на массив (таблицу), координат точек, сглаженных и нормализованных по расстоянию вдоль фокальной линии.
        OCRPointFloat *mTab=(OCRPointFloat*)&line.mTab[0];
        float LengthLineM=line.mTab.size()-1;       // Реальная длина сглаженной фокальной линии. (int)
        if(GrafT)cout<<"    полная длина фокальной линии    LengthLineM="<<LengthLineM<<endl;
        
        float x0, y0, x1, y1, x2, y2, x3, y3;   // Декартовы координаты четырех главных точек сглаженной фокальной линии.
        float x_0, y_0, x_1, y_1;   // Декартовы координаты узлов при t=L*1/3, t=L*2/3 сглаженной фокальной линии.
        float k;                    // коэффициент линейной интерполяции.
        //float k13=1.0/3.0, k23=2.0/3.0;
        
        // Выбор вычисления параметров кривой Безье по полной длине фокальной линии или по ее части.
        if(strL==0 && endL==0) { // 0,0 по полной длине.
            // Получаем координаты начальных и конечных точек полной длине фокальной линии.
            ///x0=line.start.x;    y0=line.start.y;    // координаты начала фокальной линии при t2=0.
            ///x3=line.end.x;      y3=line.end.y;      // координаты конца фокальной линии при t2=L, где L=LengthLineM.
            x0=line.p0.x;       y0=line.p0.y;   // координаты начала фокальной линии при t2=0.
            x3=line.p3.x;       y3=line.p3.y;   // координаты конца фокальной линии при t2=L, где L=LengthLineM.
            strL=0;
            if(GrafT)cout<<"    1   start.x="<<x0<<"   start.y="<<y0<<"     end.x="<<x3<<" end.y="<<y3<<endl;
        } else {
            ///strL=2, endL=(int)(LengthLineM*0.5); // ТЕСТ в остальных случаех легко вешаются т.к. изменили координаы start и end.
            if(strL>LengthLineM) strL=LengthLineM;    if(endL>LengthLineM) endL=LengthLineM; // ограничение.
            // Получаем координаты начальных и конечных точек (узлов) части длины фокальной линии при t=strL и t=endL.
            OCRPointFloat & mTab_strL=mTab[strL];
            OCRPointFloat & mTab_endL=mTab[endL];
            x0=mTab_strL.x;        y0=mTab_strL.y;
            x3=mTab_endL.x;        y3=mTab_endL.y;
            LengthLineM=endL-strL;  // Реальная длина части фокальной линии в пределах strL и endL.
            if(GrafT)cout<<"    2   strL="<<x0<<"   strL="<<y0<<"     endL="<<x3<<" endL="<<y3<<endl;
            line.lenP=LengthLineM;  // Сохранение длины укороченной кривой Безье (как части длины сглаженной фокальной линии).
        } // else
        if(GrafT)cout<<"    полная1 или частичная2 длина фокальной линии    LengthLineM="<<LengthLineM<<endl;
        
        float t_13=LengthLineM*0.33333+strL; // расстояние вдоль длины фокальной линии до узла t=L*1/3 с учетом strL.
        int t13=(int)t_13;                   // целая часть расстояния вдоль длины фокальной линии до узла t=L*1/3.
        float t_23=LengthLineM*0.66667+strL; // расстояние вдоль длины фокальной линии до узла t=L*2/3 с учетом strL.
        int t23=(int)t_23;                   // целая часть расстояния вдоль длины фокальной линии до узла t=L*2/3.
        if(GrafT)cout<<"t_13="<<t_13<<"     t_23="<<t_23<<"     LengthLineM="<<LengthLineM<<endl;

        
        //------------
        
        // Вычисленные координат узлов t=L*1/3 и t=L*2/3 c линейной интерполяцией. //
        
        // Вычисленные координат узла t=L*1/3 сглаженной фокальной линии:
        OCRPointFloat & mTab_t13=mTab[t13];
        OCRPointFloat & mTab_t131=mTab[t13+1];
        x_0=mTab_t13.x;         y_0=mTab_t13.y;
        x_1=mTab_t131.x;        y_1=mTab_t131.y;
        // линейная интерполяция между точками "x_0, y_0" и "x_1, y_1" главной точки t=L*1/3.
        k=t_13-t13; // т.к. всегда (L1-L0)=1;    /// float k=(lineL-L0)/(L1-L0);
        x1=x_0 + k*(x_1-x_0);       y1=y_0 + k*(y_1-y_0);
        //if(GrafT)cout<<"  x_0="<<x_0<<"  y_0="<<y_0<<endl;
        if(GrafT)cout<<"x1="<<x1<<"  y1="<<y1<<endl;
        
        // Вычисленные координат узла t=L*2/3 сглаженной фокальной линии:
        OCRPointFloat & mTab_t23=mTab[t23];
        OCRPointFloat & mTab_t231=mTab[t23+1];
        x_0=mTab_t23.x;         y_0=mTab_t23.y;
        x_1=mTab_t231.x;        y_1=mTab_t231.y;
        // линейная интерполяция между точками "x_0, y_0" и "x_1, y_1" узла t=L*2/3.
        k=t_23-t23;
        x2=x_0 + k*(x_1-x_0);       y2=y_0 + k*(y_1-y_0);
        if(GrafT)cout<<"x2="<<x2<<"  y2="<<y2<<endl;
        
        //------------
        /**/
        
        /*
        // Вычисленные координат узлов t=L*1/3 и t=L*2/3 без линейной интерполяции. //
         
        // После нормализации точек вдоль фокальной линии, для получения координат по длине линии,
        // можно использовать только таблицу mTab, что быстрее, но чуть менее точно.
        OCRPointFloat & mTab_t13=mTab[t13];
        OCRPointFloat & mTab_t23=mTab[t23];
        x1=mTab_t13.x;         y1=mTab_t13.y;
        x2=mTab_t23.x;         y2=mTab_t23.y;
        if(GrafT)cout<<"x1="<<x1<<"  y1="<<y1<<"  x2="<<x2<<"  y2="<<y2<<endl;
        */
        
        //------------
        
        /*
        // Тест, конструирование реверсивной кривой Безье из обычной, перестановкой координат.
        // Использыется для тестирования операции "РЕВЕРС" в функции GGraphBezierCorrelationBezierFull.cpp
        // Заменены только начальные и конечные точки, не пересчитаны все остальные промежуточные точки фокальной линии.
        if(line.index==215){ // 1689
            // меняем местами координаты
            float X0=x0;    float X1=x1;    float X2=x2;    float X3=x3;
            float Y0=y0;    float Y1=y1;    float Y2=y2;    float Y3=y3;
            x0=X3;   y0=Y3;     // координаты узла t=0 (начала) фокальной линии.
            x1=X2;   y1=Y2;     // координаты узла t=L/3 (середины) фокальной линии.
            x2=X1;   y2=Y1;     // координаты узла t=L*2/3 (середины) фокальной линии.
            x3=X0;   y3=Y0;     // координаты узла t=L (конца) фокальной линии, где L=LengthLineM.
            // вычисление координат начальных и конечных точек фокальной линии по отношению к ее середине.
            line.start_с.x=(x0-x3)/2.0;    line.start_с.y=(y0-y3)/2.0; // Замена координат полученных в focalLineNorm.
            line.end_с.x=(x3-x0)/2.0;      line.end_с.y=(y3-y0)/2.0;
        }
        */


        // Запись в массив координат двух исходных точек на сглаженной фокальной линии
        // при параметре t_1/3=L/3 и t_2/3=L*2/3, для вывода в графический порт. Тест.
        line.test.resize(2);    // resize на 2 пары.
        OCRPointFloat *test=(OCRPointFloat*)&line.test[0]; // получение указателя.
        test[0].x=x1;   test[0].y=y1;   // запись в массив координат узла L1=L/3.
        test[1].x=x2;   test[1].y=y2;   // запись в массив координат узла L2=L*2/3.
        /**/

        
        // Функция на входе получает координаты четырех исходных точек, узлов (t=0, 1/3, 2/3, 1), всего 8 цифр.
        // Возвращает декартовы координаты вершин управляющего многоугольника Безье или что тоже, в полярных координатах
        // длинны и углы, управляющих точек (векторов) кривой Безье, всего 8 цифр.
                    // Фактически переход в полярные координаты //
        
        // Вычисляем координаты управляющих точек кривой Безье (точек апроксимирующех линию)
        // по координатам исходных точек, расположенных на сглаженной фокальной линии mData:
        float Px0=x0;
        float Py0=y0;
        float Px1=(-5.0*x0 + 18.0*x1 - 9.0*x2 + 2.0*x3)/6.0;  // координата “x” первой управляющей точки.
        float Py1=(-5.0*y0 + 18.0*y1 - 9.0*y2 + 2.0*y3)/6.0;  // координата “y” первой управляющей точки.
        float Px2=( 2.0*x0 - 9.0*x1 + 18.0*x2 - 5.0*x3)/6.0;  // координата “x” второй управляющей точки.
        float Py2=( 2.0*y0 - 9.0*y1 + 18.0*y2 - 5.0*y3)/6.0;  // координата “y” второй управляющей точки.
        float Px3=x3;   // Начальные и конечные управляющие точки кривой Безье совпадают
        float Py3=y3;   // с начальными и конечными точками (узлами) фокальной линии.
        // Источники:
        // Роджерс Д., Адамс Дж. Математические основы машинной графики. М.: Мир, 2001. 604 с.
        // http://sernam.ru/book_mm3d.php?id=92 // это Адамс
        // http://alex-black.ru/article.php?content=109
        // http://fullref.ru/job_a517a7c403e9395d49dc5ea305453db0.html
        
        /*
        // Нормализация по start end //  register1=355, но сокращает вдвое срабатывание "РЕВЕРС".
        // Приведение координат start и end возникших при делении ломанной фокальной линии на составляющие линии,
        // к единому линейно-строчному формату. Потенциально опасная операция т.к. легко забыть, что заменены
        // только начальные и конечные точки и не пересчитаны все остальные промежуточные точки фокальной линии.
        float P_x1=Px1;    float P_y1=Py1;    float P_x2=Px2;    float P_y2=Py2;
        if(y3<y0)  { Px0=x3;  Py0=y3;  Px1=P_x2;  Py1=P_y2;  Px2=P_x1;  Py2=P_y1;  Px3=x0;  Py3=y0; }
        if(y3==y0) { if(x3<x0) { Px0=x3;  Py0=y3;  Px1=P_x2;  Py1=P_y2;  Px2=P_x1;  Py2=P_y1;  Px3=x0;  Py3=y0; } }
        // вычисление координат начальных и конечных точек фокальной линии по отношению к ее середине.
        line.start_с.x=(Px0-Px3)/2.0;    line.start_с.y=(Py0-Py3)/2.0;  // Замена координат полученных в focalLineNorm,
        line.end_с.x=(Px3-Px0)/2.0;      line.end_с.y=(Py3-Py0)/2.0;    // поскольку x0 и x3 поменялись местами (знак)
        */
        
        // Сохраняем координаты управляющих точек кривой Безье.
        ///line.start.x=Px0;   line.start.y=Py0;   // координаты “x,y” начала фокальной линии.
        line.p0.x=Px0;      line.p0.y=Py0;      // координаты “x,y” начала фокальной линии.
        line.p1.x=Px1;      line.p1.y=Py1;      // координаты “x,y” первой управляющей точки.
        line.p2.x=Px2;      line.p2.y=Py2;      // координаты “x,y” второй управляющей точки.
        line.p3.x=Px3;      line.p3.y=Py3;      // координаты “x,y” конца фокальной линии.
        ///line.end.x=Px3;     line.end.y=Py3;     // координаты “x,y” конца фокальной линии.
        // координаты начальных и конечных точек кривой Безье по отношению к ее середине.
        line.p0_c.x=(Px0-Px3)/2.0;        line.p0_c.y=(Py0-Py3)/2.0;
        line.p3_c.x=(Px3-Px0)/2.0;        line.p3_c.y=(Py3-Py0)/2.0;

        // p0 (p3) в дальнейшем может не совпадать с start (end).
        // В реверсивных кривых p0 (p3) не совпадает с start (end), а совпадает end (start).
        /**/

        
        /*
        // Обратные формулы (проверено).
        // По координатам управляющих точек кривой Безье вычисляем исходные точки (для L1=L/3 и L2=L*2/3):
        float x_2=(6*Px1 + 12*Px2 + x0 + 8*x3)/27;     float y_2=(6*Py1 + 12*Py2 + y0 + 8*y3)/27;
        if(GrafT)cout<<"x_2=(6*Px1 + 12*Px2 + x0 + 8*x3)/27="<<x_2<<"     y_2="<<y_2<<endl;
        float x_1=(12*Px1 + 6*Px2 + 8*x0 + x3)/27;     float y_1=(12*Py1 + 6*Py2 + 8*y0 + y3)/27;
        if(GrafT)cout<<"x_1=(12*Px1 + 6*Px2 + 8*x0 + x3)/27="<<x_1<<"     y_1="<<y_1<<endl;
        */
        
        if(GrafT) {
            cout<<"     LengthLineM="<<LengthLineM<<endl;
            cout<<"start_x="<<x0<<"    start_y="<<y0<<"    end_x="<<x3<<"    end_y="<<y3<<endl;
            cout<<"x1==1/3="<<x1<<"   y1==1/3="<<y1<<"   x2==2/3="<<x2<<"   y2==2/3="<<y2<<endl;
            cout<<"Px1="<<Px1<<"     Py1="<<Py1<<"     Px2="<<Px2<<"     Py2="<<Py2<<endl;
        }
        
        if(GrafT)cout<<"-------------"<<"Углы и длины линий Безье"<<endl;

        
        // длина опорного вектора L кривой Безье соответствует линии проведенной от начальной 0 до конечной 3 точки кривой.
        // длина контрольного вектора P1 соответствует линии проведенной от начальной 0 до первой управляющей точки кривой.
        // длина контрольного вектора P2 соответствует линии проведенной от конечной 3 до второй управляющей точки кривой.
        float Length;           // длина вектора.
        float Alpha;            // угол между вектором и горизонталью.
        float delta_x, delta_y; // переменные разностей координат.
   
        
        // Вычисление угла между опорным вектором и горизонталью и его длины.
        delta_x=Px3 - Px0;      delta_y=Py3 - Py0;
        // Вызов функции вычисления длинны линии и угола между линией и горизонталью.
        LineAngleLength(delta_x, delta_y, Alpha, Length); // , alpha, length
        if(GrafT)cout<<"AlphaPoint0="<<Alpha<<"     LengthPoint0="<<Length<<endl;
        line.len=Length;          // Сохраняем рассстояние от начальной 0 до конечной 3 точки кривой Безье в pix.
        line.alpha=Alpha;         // - alpha, угол наклона линии в градусах (0 до 360° grade).
        line.alpInt=(int)Alpha;   // - alpInt, целочисленное значение угола наклона линии в градусах (0 до 360° grade).
        
        // Вычисление угла, между первым контрольным вектором и горизонталью и его длины.
        delta_x=Px1 - Px0;      delta_y=Py1 - Py0;
        LineAngleLength(delta_x, delta_y, Alpha, Length); // , alpha, length
        if(GrafT)cout<<"AlphaPoint1="<<Alpha<<"     LengthPoint1="<<Length<<endl;
        line.lenP1=Length;        // Сохраняем длину первого контрольного вектора в pix.
        line.alphaP1=Alpha;       // Сохраняем угол наклона первого контрольного вектора (0 до 360° grade).
        ///line.alpIntP1=(int)Alpha;
        
        // Вычисление угла, между вторым контрольным вектором и горизонталью и его длины.
        delta_x=Px2 - Px3;      delta_y=Py2 - Py3;
        ///if(GrafT)cout<<"delta_x="<<delta_x<<"     delta_y="<<delta_y<<endl;
        LineAngleLength(delta_x, delta_y, Alpha, Length); // , alpha, length
        if(GrafT)cout<<"AlphaPoint2="<<Alpha<<"     LengthPoint2="<<Length<<endl;
        line.lenP2=Length;        // Сохраняем длину второго контрольного вектора в pix.
        line.alphaP2=Alpha;       // Сохраняем угол наклона второго контрольного вектора (0 до 360° grade).
        ///line.alpIntP2=(int)Alpha;
        
        // Вычисление длины линии от первой управляющей точки до второй управляющей точки кривой Безье.
        delta_x=Px1 - Px2;        delta_y=Py1 - Py2;
        LineAngleLength(delta_x, delta_y, Alpha, Length);
        line.lenP1P2=Length;    // Сохраняем вектор от 1 управляющей точки до 2 управляющей точки в pix.
        line.alphaP1P2=Alpha;   // Сохраняем угол наклона вектора от первой управляющей точки до второй управляющей точки.
        ///line.alpIntP1P2=(int)Alpha;
        /**/


        /*
        // Вычисление констант параметрического уравнения общего вида. //
        // работает, но сейчас не используется.
        
        // функция используя координаты четырех точек кривой вычисляет константы параметрического уравнения.
        // Полином третьего порядка с константами; A, B, C, D, по зтим константам однозначно и просто связан с координатами
        // точек фокальной линии: начала, двух управляющих и конца (Px0, Py0), (Px1, Py1), (Px2, Py2) и (Px3, Py3).
        // x(t) = Ax*t*t*t + Bx*t*t + Cx*t + Dx;  // 0<=t<=1  // аналогично для “y”.
         
        // пропорциональные коэффициенты Ax, Bx, Cx, Dx и Ay, By, Cy, Dy зто все линия с разной скоростью движения по t
        
        // Вычисляем константы параметрического уравнения общего вида для "x":
        //x(t) = Ax*t*t*t + Bx*t*t + Cx*t + Dx;  // 0<=t<=1
        float Ax=  -Px0 + 3*Px1 - 3*Px2 + Px3;
        float Bx= 3*Px0 - 6*Px1 + 3*Px2;
        float Cx=-3*Px0 + 3*Px1;
        float Dx=   Px0;
        if(GrafT)cout<<"Ax="<<Ax<<"     Bx="<<Bx<<"     Cx="<<Cx<<"     Dx="<<Dx<<endl;
        
        // Вычисляем константы параметрического уравнения общего вида для "y":
        float Ay=  -Py0 + 3*Py1 - 3*Py2 + Py3;
        float By= 3*Py0 - 6*Py1 + 3*Py2;
        float Cy=-3*Py0 + 3*Py1;    /////// Cx=3*Px0 + 3*Px1;  C = -3p0 + 3p1 ///////
        float Dy=   Py0;
        if(GrafT)cout<<"Ay="<<Ay<<"     By="<<By<<"     Cy="<<Cy<<"     Dy="<<Dy<<endl;
         // Источник: у http://www.sunspire.ru/articles/part27/
        */
        
        /*
        // Тест, конструирование реверсивной кривой Безье из обычной, перестановкой координат.
        // Использыется для тестирования операции "РЕВЕРС" в функции GGraphBezierCorrelationBezierFull.cpp
        // Заменены только начальные и конечные точки, не пересчитаны все остальные промежуточные точки фокальной линии.
        if(line.index==215){ // 1689
            // меняем местами координаты
            float X0=x0;    float X1=x1;    float X2=x2;    float X3=x3;
            float Y0=y0;    float Y1=y1;    float Y2=y2;    float Y3=y3;
            x0=X3;   y0=Y3;     // координаты начала фокальной линии при t=0.
            x1=X2;   y1=Y2;     // координаты середины фокальной линии при t=L/3.
            x2=X1;   y2=Y1;     // координаты середины фокальной линии при t=L*2/3.
            x3=X0;   y3=Y0;     // координаты конца фокальной линии при t=L, где L=LengthLineM.
            // вычисление координат начальных и конечных точек фокальной линии по отношению к ее середине.
            line.start_с.x=(x0-x3)/2.0;    line.start_с.y=(y0-y3)/2.0; // Замена координат полученных в focalLineNorm.
            line.end_с.x=(x3-x0)/2.0;      line.end_с.y=(y3-y0)/2.0;
        }
        */
        
        /*
        // Нормализация по start end //
        // Приведение координат start и end возникших при делении ломанной фокальной линии на составляющие линии,
        // к единому линейно-строчному формату. Потенциально опасная операция т.к. заменены только начальные и
        // конечные точки, не пересчитаны все остальные промежуточные точки фокальной линии.
        float P_x1=Px1;    float P_y1=Py1;    float P_x2=Px2;    float P_y2=Py2;
        if(y3<y0)  { Px0=x3;  Py0=y3;  Px1=P_x2;  Py1=P_y2;  Px2=P_x1;  Py2=P_y1;  Px3=x0;  Py3=y0; }
        if(y3==y0) { if(x3<x0) { Px0=x3;  Py0=y3;  Px1=P_x2;  Py1=P_y2;  Px2=P_x1;  Py2=P_y1;  Px3=x0;  Py3=y0; } }
        // вычисление координат начальных и конечных точек фокальной линии по отношению к ее середине.
        line.start_с.x=(Px0-Px3)/2.0;    line.start_с.y=(Py0-Py3)/2.0;  // Замена координат полученных в focalLineNorm,
        line.end_с.x=(Px3-Px0)/2.0;      line.end_с.y=(Py3-Py0)/2.0;    // поскольку x0 и x3 поменялись местами (знак)
        */
        
        /*
        // Тест, конструирование зеркальной криой Безье из обычной с номером 1689.
        if(line.index==1689){
            // меняем местами
            float X0=x0;    float X1=x1;    float X2=x2;    float X3=x3;
            float Y0=y0;    float Y1=y1;    float Y2=y2;    float Y3=y3;
            //x0=X3;   y0=Y3;     // координаты начала фокальной линии при t=0.
            x1=X1-0.5;   y1=Y1+2.5;     // координаты середины фокальной линии при t=L/3.
            x2=X2+1.5;   y2=Y2-1.5;     // координаты середины фокальной линии при t=L*2/3.
            //x3=X0;   y3=Y0;     // координаты конца фокальной линии при t=L, где L=LengthLineM.
        }
        */

        /**/
        
     
    }//____________________________________________________________________________
    
    
    
                /// BezierF (cubic) /// основная рабочая версия.

    // Функция для вычисления параметров кривой Безье только по полной длине фокальной линии.
    // Линейный досчет в конце функции.
    
    void GGraphBezier::focalLineBezierF(OCRFocalLineBezier &line){
        
        // Функция по ID номеру линии вычисляет параметры (длина и угол) управляющих векторов кривой Безье,
        // т.о. выполняет переход из декартовых координат в полярные. Также вычисляются координаты
        // управляющих точек и константы параметрического уравнения общего вида (A, B, C, D).
        // Две управляющие точки это те точки, которые таскаем мышкой при визуальном построении кривой (управляющие вектора).
        // Параметрическое уравнение общего вида: x(t)=Ax*t*t*t + Bx*t*t + Cx*t + Dx, аналогично для “y”,
        // где параметр t менятся в диапазоне от 0 до 1, от начала к концу кривой.
        // По сути выполняется апроксимация сглаженных фокальных линий еще более гладкими кривыми Безье.
        // Которые потенциально можно стыковать друг с другом.
        
        // Функция используя координаты начальных и конечных точек исходной кривой вычисляет координаты
        // узлов (главных точек) при t=L*1/3, t=L*2/3 и таблице mTab. По координатам главных точек вычисляются
        // параметры (длина и угол) управляющих векторов кривой Безье.
        
        int GrafT=1;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if(line.index==-1){ // 3617 1697
            GrafT=1; // 1
            cout<<endl<<"----------------------------------------------------------------------------"<<endl;
            cout<<endl<<"Функция для вычисления параметров (6) кривой Безье   focalLineBezierF() "<<endl;
            cout<<"index="<<line.index<<endl;
        }else GrafT=0;
        
        
        // Вычисление опорных точек. //
        // Для любых четырех точек на плоскости существует кривая Безье, проходящая через них при t = 0, 1/3, 2/3 и 1.
        // Источник: http://fullref.ru/job_a517a7c403e9395d49dc5ea305453db0.html
        
        
        // получение указателя на массив (таблицу), сглаженных и нормализованных по расстоянию вдоль фокальной линии, координат точек.
        OCRPointFloat *mTab=(OCRPointFloat*)&line.mTab[0];
        
        float x0, y0, x1, y1, x2, y2, x3, y3;   // Декартовы координаты четырех главных точек сглаженной фокальной линии.
        float x_0, y_0, x_1, y_1;   // Декартовы координаты узлов при t=L*1/3, t=L*2/3 сглаженной фокальной линии.
        float LengthLineM=0;        // Реальная длина сглаженной фокальной линии.
        float k;                    // коэффициент линейной интерполяции.
        
        
        // Получаем координаты начальных и конечных точек полной фокальной линии.
        ///x0=line.start.x;    y0=line.start.y;    // координаты начала фокальной линии при t2=0.
        ///x3=line.end.x;      y3=line.end.y;      // координаты конца фокальной линии при t2=L, где L=LengthLineM.
        x0=line.p0.x;       y0=line.p0.y;   // координаты начала фокальной линии при t2=0.
        x3=line.p3.x;       y3=line.p3.y;   // координаты конца фокальной линии при t2=L, где L=LengthLineM.
        
        
        //float LengthLineM=line.lenM;          // Реальная длина сглаженной фокальной линии.
        LengthLineM=line.mTab.size()-1;         // Реальная длина сглаженной фокальной линии. (int)
        if(GrafT)cout<<"     LengthLineM="<<LengthLineM<<endl;

        float t_13=LengthLineM/3.0;     // расстояние вдоль длины фокальной линии до узла t=L*1/3. // (float)
        int t13=(int)t_13;              // целая часть расстояния вдоль длины фокальной линии до узла t=L*1/3.
        float t_23=LengthLineM*2.0/3.0; // расстояние вдоль длины фокальной линии до узла t=L*2/3. // float t_13*2.0;
        int t23=(int)t_23;              // целая часть расстояния вдоль длины фокальной линии до узла t=L*2/3.
        if(GrafT)cout<<"t_13="<<t_13<<"     t_23="<<t_23<<"     LengthLineM="<<LengthLineM<<endl;

        
        // Вычисленные координат узлов t=L*1/3 и t=L*2/3 c линейной интерполяцией. //
        
        // Вычисленные координат узла t=L*1/3 сглаженной фокальной линии:
        x_0=mTab[t13].x;     y_0=mTab[t13].y;
        x_1=mTab[t13+1].x;   y_1=mTab[t13+1].y;
        // линейная интерполяция между точками "x_0, y_0" и "x_1, y_1" главной точки t=L*1/3.
        k=t_13-t13; // т.к. всегда (L1-L0)=1;    /// float k=(lineL-L0)/(L1-L0);
        x1=x_0 + k*(x_1-x_0);       y1=y_0 + k*(y_1-y_0);
        //if(GrafT)cout<<"  x_0="<<x_0<<"  y_0="<<y_0<<endl;
        if(GrafT)cout<<"  x1="<<x1<<"  y1="<<y1<<endl;
        
        // Вычисленные координат узла t=L*2/3 сглаженной фокальной линии:
        x_0=mTab[t23].x;     y_0=mTab[t23].y;
        x_1=mTab[t23+1].x;   y_1=mTab[t23+1].y;
        // линейная интерполяция между точками "x_0, y_0" и "x_1, y_1" главной точки t=L*2/3.
        k=t_23-t23;
        x2=x_0 + k*(x_1-x_0);       y2=y_0 + k*(y_1-y_0);
        if(GrafT)cout<<"  x2="<<x2<<"  y2="<<y2<<endl;
        /**/
        
        
        // Вычисленные координат узлов t=L*1/3 и t=L*2/3 без линейной интерполяции. //
        
        // После нормализации точек вдоль фокальной линии, для получения координат по длине линии,
        // можно использовать только таблицу mTab.
        /*
        x1=mTab[t13].x;     y1=mTab[t13].y; // без линейной интерполяция между точками.
        x2=mTab[t23].x;     y2=mTab[t23].y;
        if(GrafT)cout<<"  x1="<<x1<<"  y1="<<y1<<"  x2="<<x2<<"  y2="<<y2<<endl;
        */
        
        
        // Запись в массив координат двух исходных точек сглаженной фокальной линии
        // при параметре t_1/3=L/3 и t_2/3=L*2/3, для вывода в графический порт. Тест.
        line.test.resize(2);    // resize на 2 пары.
        OCRPointFloat *test=(OCRPointFloat*)&line.test[0]; // получение указателя.
        test[0].x=x1;   test[0].y=y1;   // запись в массив координат узла L1=L/3.
        test[1].x=x2;   test[1].y=y2;   // запись в массив координат узла L2=L*2/3.
        /**/
        
        
        // Функция на входе получает координаты четырех исходных точек (t=0, 1/3, 2/3, 1), всего 8 цифр.
        // Возвращает декартовы координаты вершин управляющего многоугольника Безье или что тоже, в полярных координатах
        // длинны и углы, управляющих точек (векторов) кривой Безье, всего 8 цифр.
        
        // Вычисляем координаты управляющих точек кривой Безье (точек апроксимирующех линию)
        // по координатам исходных точек, расположенных на сглаженной фокальной линии mData:
        float Px0=x0;
        float Py0=y0;
        float Px1=(-5.0*x0 + 18.0*x1 - 9.0*x2 + 2.0*x3)/6.0;  // координата “x” первой управляющей точки.
        float Py1=(-5.0*y0 + 18.0*y1 - 9.0*y2 + 2.0*y3)/6.0;  // координата “y” первой управляющей точки.
        float Px2=( 2.0*x0 - 9.0*x1 + 18.0*x2 - 5.0*x3)/6.0;  // координата “x” второй управляющей точки.
        float Py2=( 2.0*y0 - 9.0*y1 + 18.0*y2 - 5.0*y3)/6.0;  // координата “y” второй управляющей точки.
        float Px3=x3;   // Начальные и конечные управляющие точки кривой Безье совпадают
        float Py3=y3;   // с начальными и конечными точками (узлами) фокальной линии.
        // Источники:
        // Роджерс Д., Адамс Дж. Математические основы машинной графики. М.: Мир, 2001. 604 с.
        // http://sernam.ru/book_mm3d.php?id=92 // это Адамс
        // http://alex-black.ru/article.php?content=109
        // http://fullref.ru/job_a517a7c403e9395d49dc5ea305453db0.html
        
        
        // Сохраняем координаты управляющих точек кривой Безье.
        line.p0.x=Px0;      line.p0.y=Py0;      // координаты “x,y” начала фокальной линии.
        line.p1.x=Px1;      line.p1.y=Py1;      // координаты “x,y” первой управляющей точки.
        line.p2.x=Px2;      line.p2.y=Py2;      // координаты “x,y” второй управляющей точки.
        line.p3.x=Px3;      line.p3.y=Py3;      // координаты “x,y” конца фокальной линии.
        // координаты начальных и конечных точек кривой Безье по отношению к ее середине.
        line.p0_c.x=(Px0-Px3)/2.0;        line.p0_c.y=(Py0-Py3)/2.0;
        line.p3_c.x=(Px3-Px0)/2.0;        line.p3_c.y=(Py3-Py0)/2.0;
        // p0 (p3) в дальнейшем может не совпадать с start (end).
        
        /*
         // Обратные формулы (проверено).
         // По координатам управляющих точек кривой Безье вычисляем исходные точки (для L1=L/3 и L2=L*2/3):
         float x_2=(6*Px1 + 12*Px2 + x0 + 8*x3)/27;     float y_2=(6*Py1 + 12*Py2 + y0 + 8*y3)/27;
         if(GrafT)cout<<"x_2=(6*Px1 + 12*Px2 + x0 + 8*x3)/27="<<x_2<<"     y_2="<<y_2<<endl;
         float x_1=(12*Px1 + 6*Px2 + 8*x0 + x3)/27;     float y_1=(12*Py1 + 6*Py2 + 8*y0 + y3)/27;
         if(GrafT)cout<<"x_1=(12*Px1 + 6*Px2 + 8*x0 + x3)/27="<<x_1<<"     y_1="<<y_1<<endl;
         */
        
        if(GrafT) {
            cout<<"     LengthLineM="<<LengthLineM<<endl;
            cout<<"start_x="<<x0<<"    start_y="<<y0<<"    end_x="<<x3<<"    end_y="<<y3<<endl;
            cout<<"x1==1/3="<<x1<<"   y1==1/3="<<y1<<"   x2==2/3="<<x2<<"   y2==2/3="<<y2<<endl;
            cout<<"Px1="<<Px1<<"     Py1="<<Py1<<"     Px2="<<Px2<<"     Py2="<<Py2<<endl;
        }
        
        if(GrafT)cout<<"-------------"<<endl<<"Углы и длины линий Безье"<<endl;
        
        
        // длина опорного вектора L кривой Безье соответствует линии проведенной от начальной 0 до конечной 3 точки кривой.
        // длина контрольного вектора P1 соответствует линии проведенной от начальной 0 до первой управляющей точки кривой.
        // длина контрольного вектора P2 соответствует линии проведенной от конечной 3 до второй управляющей точки кривой.
        float Length;           // длина вектора.
        float Alpha;            // угол между вектором и горизонталью.
        float delta_x, delta_y; // переменные разностей координат.
        
        
        // Вычисление угла между опорным вектором и горизонталью и его длины.
        // Начальные управляющие точки кривой Безье Px0 совпадают с начальными точками фокальной линии x0.
        delta_x=x3 - x0;        delta_y=y3 - y0;
        // Вызов функции вычисления длинны линии и угола между линией и горизонталью.
        LineAngleLength(delta_x, delta_y, Alpha, Length); // , alpha, length
        if(GrafT)cout<<"AlphaPoint0="<<Alpha<<"     LengthPoint0="<<Length<<endl;
        line.len=Length;          // Сохраняем рассстояние от начальной 0 до конечной 3 точки кривой Безье в pix.
        line.alpha=Alpha;         // - alpha, угол наклона линии в градусах (0 до 360° grade).
        line.alpInt=(int)Alpha;   // - alpInt, целочисленное значение угола наклона линии в градусах (0 до 360° grade).
        
        // Вычисление угла, между первым контрольным вектором и горизонталью и его длины.
        delta_x=Px1 - Px0;      delta_y=Py1 - Py0;
        LineAngleLength(delta_x, delta_y, Alpha, Length); // , alpha, length
        if(GrafT)cout<<"AlphaPoint1="<<Alpha<<"     LengthPoint1="<<Length<<endl;
        line.lenP1=Length;        // Сохраняем длину первого контрольного вектора в pix.
        line.alphaP1=Alpha;       // Сохраняем угол наклона первого контрольного вектора (0 до 360° grade).
        ///line.alpIntP1=(int)Alpha;
        
        // Вычисление угла, между вторым контрольным вектором и горизонталью и его длины.
        delta_x=Px2 - Px3;      delta_y=Py2 - Py3;
        ///if(GrafT)cout<<"delta_x="<<delta_x<<"     delta_y="<<delta_y<<endl;
        LineAngleLength(delta_x, delta_y, Alpha, Length); // , alpha, length
        if(GrafT)cout<<"AlphaPoint2="<<Alpha<<"     LengthPoint2="<<Length<<endl;
        line.lenP2=Length;        // Сохраняем длину второго контрольного вектора в pix.
        line.alphaP2=Alpha;       // Сохраняем угол наклона второго контрольного вектора (0 до 360° grade).
        ///line.alpIntP2=(int)Alpha;
        
        // Вычисление длины линии от первой управляющей точки до второй управляющей точки кривой Безье.
        delta_x=Px1 - Px2;        delta_y=Py1 - Py2;
        LineAngleLength(delta_x, delta_y, Alpha, Length);
        line.lenP1P2=Length;    // Сохраняем вектор от 1 управляющей точки до 2 управляющей точки в pix.
        line.alphaP1P2=Alpha;   // Сохраняем угол наклона вектора от первой управляющей точки до второй управляющей точки.
        ///line.alpIntP1P2=(int)Alpha;
        /**/
        //cout<<"line.alphaP1="<<line.alphaP1<<"     line.alphaP2="<<line.alphaP2<<endl;
        
        /*
         // Вычисление констант параметрического уравнения общего вида. //
         // работает, но сейчас не используется.
         
         // функция используя координаты четырех точек кривой вычисляет константы параметрического уравнения.
         // Полином третьего порядка с константами; A, B, C, D, по зтим константам однозначно и просто связан с координатами
         // точек фокальной линии: начала, двух управляющих и конца (Px0, Py0), (Px1, Py1), (Px2, Py2) и (Px3, Py3).
         // x(t) = Ax*t*t*t + Bx*t*t + Cx*t + Dx;  // 0<=t<=1  // аналогично для “y”.
         
         // пропорциональные коэффициенты Ax, Bx, Cx, Dx и Ay, By, Cy, Dy зто все линия с разной скоростью движения по t
         
         // Вычисляем константы параметрического уравнения общего вида для "x":
         //x(t) = Ax*t*t*t + Bx*t*t + Cx*t + Dx;  // 0<=t<=1
         float Ax=  -Px0 + 3*Px1 - 3*Px2 + Px3;
         float Bx= 3*Px0 - 6*Px1 + 3*Px2;
         float Cx=-3*Px0 + 3*Px1;
         float Dx=   Px0;
         if(GrafT)cout<<"Ax="<<Ax<<"     Bx="<<Bx<<"     Cx="<<Cx<<"     Dx="<<Dx<<endl;
         
         // Вычисляем константы параметрического уравнения общего вида для "y":
         float Ay=  -Py0 + 3*Py1 - 3*Py2 + Py3;
         float By= 3*Py0 - 6*Py1 + 3*Py2;
         float Cy=-3*Py0 + 3*Py1;    /////// Cx=3*Px0 + 3*Px1;  C = -3p0 + 3p1 ///////
         float Dy=   Py0;
         if(GrafT)cout<<"Ay="<<Ay<<"     By="<<By<<"     Cy="<<Cy<<"     Dy="<<Dy<<endl;
         // Источник: у http://www.sunspire.ru/articles/part27/
         */
        
        
        /*
        float x0, y0, x1, y1, x2, y2, x3, y3;   // Декартовы координаты исходных точек сглаженной фокальной линии mData.
        float LengthLineM=line.lenM;        // Реальная длина сглаженной фокальной линии.
        float t_1_3=LengthLineM/3.0;        // расстояние вдоль длины фокальной линии при t=L*1/3.
        float t_2_3=LengthLineM*2.0/3.0;    // расстояние вдоль длины фокальной линии при t=L*2/3.
        if(GrafT)cout<<"t_1_3="<<t_1_3<<"     t_2_3="<<t_2_3<<"     LengthLineM="<<LengthLineM<<endl;
        float x_old, y_old, l1, l_old, k;   // переменные линейной интерполяция между точками "index" и "index-1".
        
        uint index=1;
        // Вычисленные перебором координат двух исходных точек, расположенных на сглаженной фокальной линии mData:
        if(LengthLine>10) index=LengthLineM/6;  // стартуем с 1/6 длины сглаженной фокальной линии.
        while( sLine[index]<=t_1_3 ) index++;   // проверка совпадения точки фокальной линии с точкой t_1_3=L*1/3;
        x1=mData[index].x;  y1=mData[index].y;  // координаты фокальной линии при совпадении с этой точкой.
        // линейная интерполяция между точками "index" и "index-1".
        x_old=mData[index-1].x;     y_old=mData[index-1].y;
        l1=sLine[index];            l_old=sLine[index-1];
        k=(t_1_3-l_old)/(l1-l_old);
        x1=x_old+k*(x1-x_old);       y1=y_old+k*(y1-y_old);
        if (GrafT)cout<<"index="<<index<<endl;
        
        if(LengthLine>10) index+=index>>1;// >>1 деление на 2 // продолжаем движение примерно с половины длины фокальной линии.
        while( sLine[index]<=t_2_3 ) index++;   // проверка совпадения точки фокальной линии с точкой t_2_3=L*2/3;
        x2=mData[index].x;  y2=mData[index].y;  // координаты фокальной линии при совпадении с этой точкой.
        // линейная интерполяция между точками "index" и "index-1".
        x_old=mData[index-1].x;     y_old=mData[index-1].y;
        l1=sLine[index];            l_old=sLine[index-1];
        k=(t_2_3-l_old)/(l1-l_old);
        x2=x_old+k*(x2-x_old);       y2=y_old+k*(y2-y_old);
        if (GrafT)cout<<"index="<<index<<endl;
        ///////while( sLine2[index]<=t_1 && index<lenA_) index++;/////// проверить  && index<lenA_
        //if (GrafT)cout<<"sLine[index-1]="<<sLine[index-1]<<"  sLine[index]="<<sLine[index]<<"     t_2_3="<<t_2_3<<"     t_2_3="<<t_2_3<<endl;
        */
        
        
    }//____________________________________________________________________________


    
    //*****************************************************************************
    
    // Функция предназначена для растеризации и прямого вычисления длины кубической кривой Безье (медленная). Выполняется по start, end
    
    void GGraphBezier::BezierLength(OCRFocalLineBezier &line){
        
        // Функция предназначена для вычисления длины кубической кривой Безье.
        // Функция не быстрая, т.к. вычисляет (растеризует) используя прямое вычисление координат точек
        // кривой Безье по уравнению. Необходимо 24 умножения с плавающей точкой для каждой точки кривой
        
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        //if(line.index==1697){ // 1697 спираль // 1752 прямая // index=2349  LengthLineM=6  LengthLineB=7  LengthLineBp=7 ???
        //    GrafT=1;
        //}else GrafT=0;
        if(GrafT)cout<<endl<<"Функция для прямого вычисления длины кубической кривой Безье   BezierLength() "<<endl;
        
        // Нахождение в графическом порту линии по id номеру.
        //gPort.mm/drawRect
        //selectLine.resize(0);
        //selectLine.push_back(5076);
        
        // Кубическая кривая Безье описывается параметрическим уравненим общего вида: x(t)=Ax*t*t*t + Bx*t*t + Cx*t + Dx;
        // или, что удобнее для вычислений: x(t)=(1−t)^3*Px0 + 3*(1−t)^2*t*Px1 + 3*(1−t)*t^2*Px2 + t^3*Px3;
        // Аналогично для “y”, где t параметр, определяющий положение точки на кривой.
        // Параметр t менятся в диапазоне от 0 до 1, от начала к концу кривой.

        int index;
        float x0, y0, x1, y1;           // Декартовы координаты соседних точек кривой Безье.
        float dx, dy;                   // Переменные разностей координат кривой Безье. // d_xLine, d_yLine        
        float rg_x1, rg_y1;             // Переменные двухразрядного регистров  "х" и "у".
        
        int LengthLine=line.lenA;       // Длинна фокальной линии состоящая из pix.
        float LengthLineB=0;            // Реальная длина кривой Безье, апроксимирующея сглаженную фокальную линию.
        float t, tt, ttt, d, dd, ddd;   // Переменные параметрического уравнения общего вида.

      
        // Координаты  “x”, “y” управляющих точек кривой Безье.
        float Px0=line.start.x;     float Py0=line.start.y; // координаты начала фокальной линии при t2=0.
        float Px1=line.p1.x;        float Py1=line.p1.y;    // координаты первой управляющей точки.
        float Px2=line.p2.x;        float Py2=line.p2.y;    // координаты второй управляющей точки.
        float Px3=line.end.x;       float Py3=line.end.y;   // координаты конца фокальной линии при t2=t*L. Где L=LengthLineM

        
        // Шаг разбиения кривой Безье на отрезки прямых линий.
        // LengthLine количество точек, достаточное для гладкой аппроксимации кривой Безье отрезками прямых линий.
        // 1.0  максимальное значение параметра t.
        float delta_t=1.0/(float)LengthLine;
        //LengthLineM=28.1809  LengthLineB=27.5263  LengthLineBp=29.3267
        //LengthLineM=28.1809  LengthLineB=26.857  LengthLineBp=29.3267
        
        // массив интегральных сумм длины кривой Безье.
        ///line.bLine.resize(LengthLine);           // resize
        ///float *bLine=(float*)&line.bLine[0];     // получаем указатель
        // указатели на массивы адресов точек сглаженной фокальной линии.
        ///OCRPointFloat *mData=(OCRPointFloat*)&line.mData[0]; // Для тестового вывода растеризованной кривой Безье.
        
        
        // Реальная длина кривой Безье. //
        // Кривая Безье разбивается на "LengthLine" отрезков. Длины отрезков считаюся по Теореме Пифагора и суммируются.
        t=0;    /// bLine[0]=0;
        rg_x1=Px0;   rg_y1=Py0;   // Координаты стартовой точки для t=0;

        for ( index=0; index<LengthLine; index++ ) {
            
            t+=delta_t;
            tt=t*t;   ttt=tt*t;
            d=1-t;    dd=d*d;   ddd=dd*d;
            // Координаты точек кривой Безье при (t).
            x0=ddd*Px0 + 3*dd*t*Px1 + 3*d*tt*Px2 + ttt*Px3;
            y0=ddd*Py0 + 3*dd*t*Py1 + 3*d*tt*Py2 + ttt*Py3;
            // Координаты точек кривой Безье при (t-delta_t).
            x1=rg_x1;
            y1=rg_y1;
            // Вычисление расстояния между соседними точками кривой Безье.
            dx=x1-x0;  dy=y1-y0;
            // Реальная длина кривой Безье.
            LengthLineB+=sqrt(dx*dx + dy*dy);
            // Заполнение массива интегральных сумм длины кривой Безье.
            ///bLine[index]=LengthLineB;
            rg_x1=x0;   // сдвиг влево двухразрядного регистра "rg_x1, rg_x0"  по "х"
            rg_y1=y0;   // сдвиг влево двухразрядного регистра "rg_x1, rg_x0"  по "y"
            
            //if(GrafT)cout<<"index="<<index<<"  t="<<t<<"  LengthLineB="<<LengthLineB<<endl;
            // тестовый вывод растеризованной кривой Безье в массив сглаженной фокальной линии.
            ///mData[index].x=x0;  mData[index].y=y0;
            ////if(GrafT)cout<<"     index="<<index<<"     t="<<t<<"     2*LengthLineB="<<2*LengthLineB<<"     (int)2*LengthLineB="<<(int)(2*LengthLineB)<<endl;

        }
        
        line.lenB=LengthLineB;  // Сохраняем реальную длину кривой Безье.
        if(GrafT)cout<<"  LengthLineB="<<LengthLineB<<endl;

        // Основная источник информации по обсчету кривой Безье сайт:
        // http://rsdn.ru/article/multimedia/Bezier.xml#
        // Автор: Maxim Shemanarev.
        
       
    }//____________________________________________________________________________
    
    
    //*****************************************************************************
    
    // Функция для очень быстрого приближенного вычисления длины кубической кривой Безье. Выполняется по векторам.

    void GGraphBezier::BezierLengthApproximate(OCRFocalLineBezier &line){
        
        // Функция предназначена для вычисления длины кубической кривой Безье.
        // Функция очень быстрая, т.к. не растеризует всю кривую Безье. Для получения длины кубической
        // кривой Безье необходимо вычислить всего четыре расстояния между четырьмя управляющими точками.
        // Ошибка приближения до 1-1.5 pix и мало зависит от длинны линии.
        // Может оказатся удачной для вычисления масштаба текста по одной кривой Безье.
        
        // Длина кубической кривой, заданной четырьмя точками, приближается ломаными по формуле:
        // float D=(sqrt(P1*P1-P0*P0) + sqrt(P2*P2-P1*P1) + sqrt(P3*P3-P2*P2) + sqrt(P3*P3-P0*P0))/2;
        // Считается, что эта формула есть в книге:
        // Роджерс Д., Адамс Дж. Математические основы машинной графики. М.: Мир, 2001. 604 с.
        
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if(GrafT)cout<<endl<<"Функция для очень быстрого приближенного вычисления длины кубической кривой Безье   BezierLengthApproximate() "<<endl;


        // Длина кубической кривой, заданной четырьмя точками, приближается ломаными:
        float LengthLineBff=(line.lenP1 + line.lenP1P2 + line.lenP2 + line.len)/2.0;
        //if(GrafT)cout<<"  LengthLineBff="<<LengthLineBff<<endl;
        
        line.lenBff=LengthLineBff;  // Сохраняем приближенное значение длины кривой Безье.
        /**/
        
        if(GrafT)cout<<"LengthLineBff="<<LengthLineBff<<endl;
        
        //float LengthLineM=line.lenM;    // Реальная длина сглаженной фокальной линии.
        //float LengthLineB=line.lenB;    // Реальная длина кривой Безье, апроксимирующея сглаженную фокальную линию.
        //if(GrafT)cout<<"LengthLineM="<<LengthLineM<<"  LengthLineB="<<LengthLineB<<"  LengthLineBff="<<LengthLineBff<<endl;

        
        
    }//____________________________________________________________________________
    
    
    //*****************************************************************************
    
    // Функция вызова подпрограммы быстрой растеризации кривой Безье (recursiveBezier). Выполняется по start, end
    
    void GGraphBezier::BezierRasterisation(OCRFocalLineBezier &line, vector<OCRPointFloat>&lineBezierPoints){
        
        // На входе функция получает указатель focalLine[id], где находятся управляющие точки кривой Безье и
        // указатель куда focalLine[id].mData нужно положить растеризованные точки кривой Безье.
        
        int GrafT=1;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if(GrafT) {
            cout<<endl<<"----------------------------------------------------------------------------"<<endl;
            cout<<endl<<"Функция для вызова подпрограммы быстрой растеризации кривой Безье   BezierRasterisation() "<<endl;
            cout<<"line "<<line.index<<" l="<<line.mData.size()<<endl;
        }

        // Координаты четырех управляющих точек кривой Безье.
        double x1=line.p0.x;
        double y1=line.p0.y;
        double x2=line.p1.x;
        double y2=line.p1.y;
        double x3=line.p2.x;
        double y3=line.p2.y;
        double x4=line.p3.x;
        double y4=line.p3.y;
        
        OCRPointFloat p(x1,y1);
        lineBezierPoints.push_back(p);
        float LengthLineBf;
        recursiveBezier(lineBezierPoints, x1, y1, x2, y2, x3, y3, x4, y4, LengthLineBf);
        OCRPointFloat p1(x4,y4);
        lineBezierPoints.push_back(p1);
        
        line.lenBf=LengthLineBf;  // Сохраняем приближенное значение длины кривой Безье.
        if(GrafT)cout<<"    LengthLineBf="<<LengthLineBf<<endl;
        
    }//____________________________________________________________________________
    
    
    // Рекурсивная функция предназначена для быстрой растеризации и вычисления длины кубической кривой Безье.
    
    void GGraphBezier::recursiveBezier( vector<OCRPointFloat>&lineBezierPoints,
                                float x1, float y1,
                                float x2, float y2,
                                float x3, float y3,
                                float x4, float y4,
                                float &LengthLineBf ){
        
        // Функция быстрая, т.к. вычисляет (растеризует) используя рекурсивное вычисление координат
        // точек кривой Безье. Необходимо всего 6 сложений для каждой точки кривой.
        // Источник:
        // http://rsdn.ru/article/multimedia/Bezier.xml#
        // Автор: Maxim Shemanarev.
        // Разобраться, ниже код компактнее:
        // Первоисточник:   http://www.devmag.org.za/downloads/bezier_curves/BezierPath.cs
        // Перевод первоисточника:   http://3d-orange.com.ua/bezier-curves-for-your-games-tutorial/
        // Хорошее объяснение метода в тексте: "Интерполяция сплайнами", на просторах интернета выглядет как "08 Сплайны.pdf"
        // Или что тоже самое:
        // http://www.intuit.ru/studies/courses/993/163/lecture/4497
        
        //----------------------
        double x12   = (x1 + x2) / 2;
        double y12   = (y1 + y2) / 2;
        double x23   = (x2 + x3) / 2;
        double y23   = (y2 + y3) / 2;
        double x34   = (x3 + x4) / 2;
        double y34   = (y3 + y4) / 2;
        double x123  = (x12 + x23) / 2;
        double y123  = (y12 + y23) / 2;
        double x234  = (x23 + x34) / 2;
        double y234  = (y23 + y34) / 2;
        double x1234 = (x123 + x234) / 2;
        double y1234 = (y123 + y234) / 2;
        
        // m_distance_tolerance – это квадрат (?) допустимого максимального отклонения от идеальной кривой.
        // Для типичных экранных разрешений значение 0.5*0.5 = 0.25 дает вполне хороший результат.
        float m_distance_tolerance=0.001;
        //m_distance_tolerance*=m_distance_tolerance;   // не забыть вывести из под рек 0.03;
        
        
        static int n=0;
        static float LenBf=0;
        static float x1234_=x1;
        static float y1234_=y1;
        //float d_x, d_y;
        /**/
        
        // Попытка аппроксимировать всю кривую одним отрезком
        //------------------
        double dx=x4-x1;
        double dy=y4-y1;
        
        double d2=fabs(((x2 - x4)*dy - (y2 - y4)*dx));
        double d3=fabs(((x3 - x4)*dy - (y3 - y4)*dx));
        
        if((d2 + d3)*(d2 + d3) < m_distance_tolerance*(dx*dx + dy*dy))
        {
            OCRPointFloat p(x1234, y1234);
            lineBezierPoints.push_back(p);
            
            dx=x1234 - x1234_;    dy=y1234 - y1234_;
            LenBf+=sqrt(dx*dx + dy*dy);
            LengthLineBf=LenBf;
            x1234_=x1234;   y1234_=y1234;
            //cout<<"n="<<n<<"    LengthLineBf="<<LengthLineBf<<endl;
            /**/
            n++;
            return;
         }
        
        
        //if(n > 32) return;
        
        // Продолжить деление
        //----------------------
        recursiveBezier(lineBezierPoints, x1, y1, x12, y12, x123, y123, x1234, y1234, LengthLineBf);
        recursiveBezier(lineBezierPoints, x1234, y1234, x234, y234, x34, y34, x4, y4, LengthLineBf);
        

}//____________________________________________________________________________
    
    
    //*****************************************************************************
    
                                            /// Mass ///
    // Функция для распознования фокальных линиий с помощью центра масс: прямой, дуги, круга, и спирали.
    // Если эту функцию использовать, то имеет смысл заменить центр масс управляющими точками кривой Безье.
    
    void GGraphBezier::focalLineRecMass(OCRFocalLineBezier &line){
        
        // начало линии, точки деления фокальной линиии на три отрезка в pix и конец. Отсчитываются от начала линии.
        int point1, point2;
        int line1, line2; // длинны двух отрезков фокальной линиии.
        float Mass0_x, Mass0_y, Mass1_x, Mass1_y, Mass2_x, Mass2_y; // координаты центров масс трех отрезка фокальной линиии.
        float d_x, d_y, d_xLine, d_yLine;  // переменные разностей координат.
        float StartMass1, StartMass2, EndMass1, EndMass2; // расстояния от концов фокальной линии до первой и второй точек центров масс.
        ///float StartMass10, StEndMass12, EndMass02; // расстояния от первой и второй точек центров масс до точки центра масс всей фокальной линии.
        float deltaL0, deltaL1, deltaL2; // разности расстояний от концов фокальной линии до центров масс.
        float sumLine=0;    // суммарная длина всех расстояний от концов фокальной линии до центров масс.
        
        float cor_L=0;      // Коэффициент корреляции линии с прямой (0-100%).
        float cor_Arc, cor_Spi;
        float alpha;        // Величина угола наклона линии в градусах.
        float Pg0_LineArc, Pg1_LineSp;       // Порог между прямой линией и дугой.
        float cor_Shift, cor_Sim0, cor_Sim1, cor_Sim2;     // Коэффициент корреляции дуги.
        cor_Shift=cor_Sim0=cor_Sim1=cor_Sim2=100;
        
        
        int LengthLine=(int)line.data.size(); // длина фокальной линии.
        // получаем прямые массивы
        OCRPointFloat *data=(OCRPointFloat*)&line.data[0];
        OCRPointFloat *sData=(OCRPointFloat*)&line.sData[0];

        
        // Выходим из функции, если линия короткая.
        //cout<<"LengthLine"<<LengthLine<<endl;
        ///if (LengthLine<6) return;
        
        // координаты начала и конца фокальной линии.
        float start_x=line.start.x;      float start_y=line.start.y;
        float end_x=line.end.x;          float end_y=line.end.y;
        
        int GrafT=0 ;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if(line.index==1184){ // 1132 4506 3100 не точная линия, 3187 (11pix)  4017 (14pix) точная линия,   4248 дуга,  3996 2706 1849 гигу.
            GrafT=0;
        }else GrafT=0;
        if(GrafT)cout<<"start_x="<<start_x<<"     start_y="<<start_y<<"     end_x="<<end_x<<"     end_y="<<end_y<<endl;
        
        if(GrafT)cout<<"LengthLine"<<LengthLine<<endl;
        
// реальная раскладка по пикселям фокальной линии и массиву интегральных сумм.
if(GrafT)for(int i=0;i<LengthLine;i++)cout<<i<<" x="<<data[i].x<<"   инт.суммы по x="<<sData[i].x<<endl;
        
        /// распознавание прямой линии ///
        if(GrafT)cout<<endl<<"распознавание прямой линии"<<endl;
        // идея - рассстояние между центром массы линии и серединой прямой соединяющей концы линии.
        // и проверка на сколько далеко положение центра массы линии от середины прямой соединяющей концы линии.
        
        float LengthLineDirect;     // рассстояние между концами линии.
        float center_x, center_y;   // середина линии
        float delta_CM; // рассстояние между центром массы линии и серединой прямой соединяющей концы линии
        // LengthLine длина для массива, реальная число pix=LengthLine.
      
        
        // точные координаты центра масс фокальной линиии (обязательно float).
        Mass0_x=(float)(sData[LengthLine-1].x)/LengthLine;
        Mass0_y=(float)(sData[LengthLine-1].y)/LengthLine; // LengthLine-1 предотвращает вылет за конец массива
        if(GrafT)cout<<"Mass0_x="<<Mass0_x<<"    Mass0_y="<<Mass0_y<<"     line.centerM.x="<<line.centerM.x<<"     line.centerM.y="<<line.centerM.y<<endl;
        
        
        // Вычисление расстояния между началом и концом линии по Теореме Пифагора. //
        d_x=d_xLine=end_x - start_x;
        d_y=d_yLine=end_y - start_y;
        
        if(GrafT)cout<<"d_x="<<d_x<<"     d_y="<<d_y<<endl;
        LengthLineDirect=sqrt(d_x*d_x + d_y*d_y);
////////line.len=(int)LengthLineDirect; // рассстояние между концами линии.
        
        // вычисление середины линии
        center_x=(start_x + end_x)/2; ////////
        center_y=(start_y + end_y)/2; ////////
        
////////line.center.x=(int)center_x;
////////line.center.y=(int)center_y;
        
        if(GrafT)cout<<"center_x="<<center_x<<"     Mass0_x="<<Mass0_x<<endl;
        // рассстояние между центром массы линии и серединой прямой соединяющей концы линии.
        d_x=center_x - Mass0_x;
        d_y=center_y - Mass0_y;
        if(GrafT)cout<<"d_x="<<d_x<<"     d_y="<<d_y<<endl;
        delta_CM=sqrt(d_x*d_x + d_y*d_y);
        // рассстояние между центром массы линии и серединой прямой соединяющей концы линии.
        line.dM=delta_CM; ////////////////////////////////////
        // вычисление точки кривой Безье апроксимирующей линию.
        //////line.p1.x=(int)(center_x - d_x*2.5); // см focalLineRecBezier3
        //////line.p1.y=(int)(center_y - d_y*2.5);
        
        // Вычисление коэффициента корреляции. Чем ближе коэффициент корреляции к 100, тем больше кривая похожа на прямую.
        ///cor_L=100*(LengthLineDirect-delta_CM)/LengthLineDirect; ////////////////////////////////////////////////////////////
        if(GrafT)cout<<"LengthLineDirect="<<LengthLineDirect<<"     delta_CM="<<delta_CM<<endl;
        
        // Вычисление коэффициента смещения центра масс относительно середины линии.
        // Чем ближе коэффициент смещения к 100, тем ближе центр масс к середине линии.
        cor_Shift=100*(LengthLineDirect-delta_CM)/LengthLineDirect;
        
        // Величина угола наклона линии в градусах.
        alpha=-57.29747*atan(d_yLine/d_xLine);      // угол в градусах в I и IIII квадрантах (-90° до +90° гр). float может делить на "0".
        if (d_xLine<0) { if (d_yLine<0) alpha+=90; }   // доопределение углов во II квадранте. // верх оси "y" выбран ? отрицательным.
        if (d_xLine<0) { if (d_yLine>=0)alpha+=180;}   // доопределение углов в III квадранте. // dy>=0 не тестировали
        if (d_xLine>=0){ if (d_yLine>0) alpha+=360;}   // доопределение углов в IIII квадранте.
        ///alpha=-57.29747*atan2(d_yLine,d_xLine);  // угол в градусах в I,II и III,IIII квадрантах (-180° до +180° гр).
        
        // Возвращаем:
//        line.corL=(int)cor_L;  // - cor_L, коэффициент корреляции линии с прямой (0-100%).
/////////        line.alpha=(int)alpha; // - alpha, угол наклона линии в градусах (0 до 360° grade).
        
        if (GrafT) { cout<<"cor_Shift="<<cor_Shift<<"%"<<"     alpha="<<alpha<<"° grade"<<endl; }
        /**/
        
        //if (LengthLine<6) return;
        //---------------------------------------------------------------------------------
        
        
        /// распознавание дуги ///
        if(GrafT)cout<<endl<<"распознавание дуги"<<endl;
        // идея - вычисление рассстояние между центром массы линии и ее началом и концом линии.
        // и проверка на сколько положение центра массы линии симметрично относительно ее начала и конца.
        
        
        // рассстояние между концом фокальной линиии и центром массы.
        d_x=start_x - Mass0_x;
        d_y=start_y - Mass0_y;
        if(GrafT)cout<<"d_x="<<d_x<<"     d_y="<<d_y<<endl;
        StartMass1=sqrt(d_x*d_x + d_y*d_y);
        
        // рассстояние между началом фокальной линиии и центром массы.
        d_x=end_x - Mass0_x;
        d_y=end_y - Mass0_y;
        if(GrafT)cout<<"d_x="<<d_x<<"     d_y="<<d_y<<endl;
        EndMass1=sqrt(d_x*d_x + d_y*d_y);
         
        // модуль разности расстояний от начала и конца фокальной линии до точки центра масс.
        deltaL0=fabs(EndMass1-StartMass1);
        if (GrafT) { cout<<"+++deltaL0="<<deltaL0<<endl; }
        
        // суммарная длина расстояний от начала и конца фокальной линии до центра масс.
        sumLine=StartMass1 + EndMass1;
        
        // проверяем на сколько центры масс первого и второго отрезка линиии симметричны относительно начала и конца фокальной линиии.
        // Вычисление коэффициента корреляции дуги. Чем ближе коэффициент корреляции к 100, тем больше кривая похожа на дугу.
        ///cor_Arc0=100*(sumLine-deltaL0)/sumLine;   // if (cor_L>100) cor_L=100;
        if(GrafT)cout<<"LengthLine="<<LengthLine<<"     sumLine="<<sumLine<<"     deltaL0="<<deltaL0<<endl;
        
        // Вычисление коэффициента симетрии центра масс относительно краев линии.
        // Чем ближе коэффициент симетрии к 100, тем больше симетрична кривая.
        cor_Sim0=100*(sumLine-deltaL0)/sumLine;

        
        // Возвращаем:
        // line.cor_Arc=(int)cor_Arc;  // cor_Arc, коэффициент корреляции линии с дугой (0-100%).
        // line.centerM.x;  line.centerM.y; // координаты int центра масс фокальной линиии уже известны.
        // Mass0_x;  Mass0_y; // точные float координаты центра масс фокальной линиии подсчитаны здесь.
        
        if (GrafT) { cout<<"cor_Sim0="<<cor_Sim0<<"%"<<endl; }

        
        //---------------------------------------------------------------------------------
        
        
        /// распознавание спирали ///
        if(GrafT)cout<<endl<<"распознавание спирали"<<endl;
        if(GrafT)cout<<"start_x="<<start_x<<"     start_y="<<start_y<<"     end_x="<<end_x<<"     end_y="<<end_y<<endl;
   

        // определение четности и не четности длинны фокальной линиии.
        int LenLinOdd=LengthLine%2; // LenLinOdd=0; четный even, LenLinOdd=1; не четный odd.
        
        // координаты точки деления фокальной линиии на отрезки "A" и "B" для четной и не четной длинны фокальной линиии.
        int LenLin2=LengthLine/2;
        if (LenLinOdd==0) { // четная длина фокальной линиии.
            if(GrafT)cout<<"Четная длина фокальной линиии  LenLinOdd="<<LenLinOdd<<endl;
            // деление на отрезки "A" и "B" происходит "в стык".
            line1=line2=LenLin2;    // длинны отрезков "A" и "B" фокальной линиии. 7485
            point1=LenLin2-1;       // point1, point2 точки деления фокальной линиии на отрезки "A" и "B".
            point2=LenLin2;
        }
        else{ // НЕ четная длина фокальной линиии.
            if(GrafT)cout<<"НЕ четная длина фокальной линиии  LenLinOdd="<<LenLinOdd<<endl;
            // деление на отрезки "A" и "B" происходит "в перекрышку" на один pix.
            line1=line2=LenLin2+1;  // длинны отрезков "A" и "B" фокальной линиии. При стыковке в "в перекрышку" длинны отрезков становятся на 1 больше.
            point1=LenLin2;         // point1, point2 точки деления фокальной линиии на отрезки "A" и "B".
            point2=LenLin2;
        }
        if(GrafT)cout<<"LenLin2="<<LenLin2<<endl;
        //if(GrafT)cout<<"point1="<<point1<<"    point2="<<point2<<"    line1="<<line1<<"    line2="<<line2<<endl;
        
        
        //            Mass1           Mass2
        //              *               *
        //
        //      *-------A------**-------B--------*
        //      0             P1,P2         LengthLine-1
        //    start                             end
        
        // координаты центра масс отрезка "A" фокальной линиии [0-P1].
        Mass1_x=(float)(sData[point1].x)/line1; // line1=point1-0;
        Mass1_y=(float)(sData[point1].y)/line1;
        // координаты центра масс отрезка "B" фокальной линиии [P2-(LengthLine-1)].
        Mass2_x=(float)(sData[LengthLine-1].x - sData[point2-1].x)/line2;
        Mass2_y=(float)(sData[LengthLine-1].y - sData[point2-1].y)/line2;
        // LengthLine-1 предотвращает вылет за конец массива.
        // point2-1 сдвинули к началу на 1 для правильного подсчета массива интегральных сумм.
        if(GrafT)cout<<"Mass1_x="<<Mass1_x<<"    Mass1_y="<<Mass1_y<<"    Mass2_x="<<Mass2_x<<"    Mass2_y="<<Mass2_y<<endl;
        
        // рассстояние между началом  отрезка "A" и его центром массы.
        d_x=start_x - Mass1_x;      d_y=start_y - Mass1_y;
        StartMass1=sqrt(d_x*d_x + d_y*d_y);
        // рассстояние между концом отрезка "A" и его центром массы.
        d_x=data[point1].x - Mass1_x;     d_y=data[point1].y - Mass1_y;
        EndMass1=sqrt(d_x*d_x + d_y*d_y);
        //if(GrafT)cout<<"d_x="<<d_x<<"     d_y="<<d_y<<endl;
        
        // модуль разности расстояний от начала и конца отрезка "A" до его центра масс.
        deltaL1=fabs(EndMass1-StartMass1);
        // суммарная длина расстояний от начала и конца отрезка "A" до его центра масс.
        sumLine=StartMass1 + EndMass1;
        // Вычисление коэффициента корреляции дуги. Чем ближе коэффициент корреляции к 100, тем больше кривая похожа на дугу.
        ///float cor_Arc1=100*(sumLine-deltaL1)/sumLine;
        
        // Вычисление коэффициента симетрии центра масс относительно краев линии.
        // Чем ближе коэффициент симетрии к 100, тем больше симетрична кривая.
        cor_Sim1=100*(sumLine-deltaL1)/sumLine;
        
        // рассстояние между началом отрезка "B" и его центром массы.
        d_x=data[point2].x - Mass2_x;     d_y=data[point2].y - Mass2_y;  ////////// +1 для четной длинны фокальной линиии.
        StartMass2=sqrt(d_x*d_x + d_y*d_y);
        // рассстояние между концом отрезка "B" и его центром массы.
        d_x=end_x - Mass2_x;        d_y=end_y - Mass2_y;
        EndMass2=sqrt(d_x*d_x + d_y*d_y);
        //if(GrafT)cout<<"d_x="<<d_x<<"     d_y="<<d_y<<endl;

        // модуль разности расстояний от начала и конца отрезка "B" до его центра масс.
        deltaL2=fabs(EndMass2-StartMass2);
        // суммарная длина расстояний от начала и конца отрезка "B" до его центра масс.
        sumLine=StartMass2 + EndMass2;
        // Вычисление коэффициента корреляции дуги. Чем ближе коэффициент корреляции к 100, тем больше кривая похожа на дугу.
        ///float cor_Arc2=100*(sumLine-deltaL2)/sumLine;
        
        // Вычисление коэффициента симетрии центра масс относительно краев линии.
        // Чем ближе коэффициент симетрии к 100, тем больше симетрична кривая.
        cor_Sim2=100*(sumLine-deltaL2)/sumLine;
        
        if(GrafT)cout<<"cor_Sim1="<<cor_Sim1<<"%"<<"     cor_Sim2="<<cor_Sim2<<"%"<<endl;
        //if(GrafT)cout<<"StartMass1="<<StartMass1<<"    EndMass1="<<EndMass1<<"    StartMass2="<<StartMass2<<"    EndMass2="<<EndMass2<<endl;
        
        //------
        /*
        //StartMass10, StEndMass12, EndMass02;
        // рассстояние между центром массы отрезка "A" Mass1 центром массы отрезка.
        d_x=Mass1_x - Mass0_x;      d_y=Mass1_y - Mass0_y;
        StartMass10=sqrt(d_x*d_x + d_y*d_y);
        // рассстояние между центром массы отрезка "B" Mass2 и центром масс фокальной линиии Mass0.
        d_x=Mass2_x - Mass0_x;      d_y=Mass2_y - Mass0_y;
        EndMass02=sqrt(d_x*d_x + d_y*d_y);
        //if(GrafT)cout<<"d_x="<<d_x<<"     d_y="<<d_y<<endl;
        // рассстояние между центром массы отрезка "A" Mass1 и центром массы отрезка "B" Mass2.
        d_x=Mass2_x - Mass1_x;      d_y=Mass2_y - Mass1_y;
        StEndMass12=sqrt(d_x*d_x + d_y*d_y);
        if(GrafT) {cout<<"рассстояние между всеми 3 центрами масс"<<endl;
            cout<<"StartMass10="<<StartMass10<<"    EndMass02="<<EndMass02<<"    StEndMass12="<<StEndMass12<<endl;}
        
        // модуль разности расстояний между центрами масс отрезков и центром масс всей фокальной линиии Mass0.
        float deltaL102=fabs(StartMass10-EndMass02);
        // суммарная длина расстояний между центрами масс отрезков и центром масс всей фокальной линиии Mass0.
        float sumLine102=StartMass10 + EndMass02;
        // Вычисление коэффициента симетрии центров масс отрезков относительно центра масс всей фокальной линии.
        // Чем ближе коэффициент симетрии к 100, тем больше симетрична кривая.
        float cor_Sim102=100*(sumLine102-deltaL102)/sumLine102;
        if(GrafT)cout<<"index="<<line.index<<"      cor_Sim102="<<cor_Sim102<<"%"<<endl;
        */
        //------
        
        
        // гигу это максимальный коэффициент корреляции 2 дуг.
        
        
        // StartMass1=9.20936    EndMass1=8.48655    StartMass2=8.41731    EndMass2=8.57518
        //                      1>                  >                   ==
        
        float dlt1, dlt2, dlt3;
        ///dlt1=StartMass1-EndMass1;  dlt2=EndMass1-StartMass2;  dlt3=StartMass2-EndMass2;
        
        
        // 2706 dlt1=-0.823248    dlt2=-1.01354    dlt3=-0.254778
        // 3996 dlt1=-0.844032    dlt2=-1.61537    dlt3=-0.0391493
        // 1849 dlt1=0.327463     dlt2=-1.11138    dlt3=-0.178106
        // 2404 dlt1=-0.0518656    dlt2=1.10921    dlt3=0.120855 полное гигу
        
        dlt1=fabs(StartMass1-EndMass1);  dlt2=fabs(EndMass1-StartMass2);  dlt3=fabs(StartMass2-EndMass2);
        //if (dlt1<dlt2  && dlt3<dlt2  && dlt1>dlt3) {  }
        //if(GrafT)cout<<"===dlt1="<<dlt1<<"    dlt2="<<dlt2<<"    dlt3="<<dlt3<<endl;
        
        
        
        float maxC=0; int MaxCor=0;  cor_L=1;   cor_Arc=2;   cor_Spi=3;
        Pg0_LineArc=97;  // порог между прямой линией и дугой или спиралью.
        Pg1_LineSp=95;   // порог между дугой и спиралью.
        int Pg0_pix=7;   // порог, все что короче P0_pix=7 является линией.
        int Pg1_pix=Pg0_pix*3;   // порог, все что короче P1_pix=21 не может являться спиралью.
        if(GrafT)cout<<endl<<"Pg0_LineArc="<<Pg0_LineArc<<"     Pg1_LineSp="<<Pg1_LineSp<<endl;
        
        float cor_Spi_min;  float cor_Spi_max;
        cor_Spi_min=cor_Sim1;
        cor_Spi_max=cor_Sim2;
        if (cor_Sim1>cor_Sim2) { cor_Spi_max=cor_Sim1; cor_Spi_min=cor_Sim2; }
        
        
            if (cor_Shift>Pg0_LineArc || LengthLine<Pg0_pix) { // порог между линией и дугой. // все что короче P0_pix=7 является линией
                // распознование линии. // область линии. //
                maxC=cor_L=cor_Shift; MaxCor=LINE;  // cor_L коэффициент корреляции прямой линией с кривой.
            }else{
                    // распознование дуги. // область дуги. //
                    maxC=cor_Arc=cor_Sim0; MaxCor=ARC;

                    if (cor_Sim0<Pg1_LineSp && LengthLine>Pg1_pix ) {
                        // распознование спирали. //  область спирали. //
                        maxC=cor_Spi=cor_Spi_max; MaxCor=SPIRAL;
                    } //if
                
                    //if (fabs(cor_Sim2-cor_Sim1) > 0.1 && LengthLine>15 && deltaMax>0.2) { cor_Spi=cor_Spi_max; }
                    ///if ( cor_Spi_max<99.8 && cor_Spi_min<97.0 && fabs(cor_Sim2-cor_Sim1) > 0.1 && LengthLine>15 && dlt1<dlt2  && dlt3<dlt2 ) {
                    ////if ( cor_Spi_max<99.0 && cor_Spi_min<97.0 && LengthLine>15 ) {
                    //if (LengthLine>21 && cor_Sim102<99.9 && fabs(cor_Sim2-cor_Sim1) > 0.1) { maxC=cor_Spi=cor_Spi_max; MaxCor=SPIRAL; }
      
            
            } // else{
        
        //  if (LengthLine<P0_pix) { maxC=cor_L=cor_Shift; MaxCor=LINE; } // все что короче P0_pix=7 является линией
        //  if (cor_Shift>P_Line) (cor_M=cor_Shift + cor_Sim0 + cor_Sim0 + cor_Sim0)/4;
        

        if(GrafT)cout<<"cor_Shift="<<cor_Shift<<"%"<<"    cor_Sim0="<<cor_Sim0<<"%"<<"    cor_Sim1="<<cor_Sim1<<"%"<<"    cor_Sim2="<<cor_Sim2<<"%"<<endl;
        if(GrafT)cout<<"cor_L="<<cor_L<<"%"<<"    cor_Arc="<<cor_Arc<<"%"<<"    cor_Spi="<<cor_Spi<<"%"<<endl;
        if(GrafT)cout<<"максимальный коэффициент корреляции     maxC="<<maxC<<"   MaxCor="<<MaxCor<<endl;
        
        // Возвращаем:
   //     line.maxCor=MaxCor;        // - MaxCor, прямая-1, дуга-2, спираль-3, круг-4
   //     line.maxC=(int)maxC;       // - maxC, максимальный коэффициент корреляции линии (0-100%).
   //     line.corL=(int)cor_L;      // - cor_L, коэффициент корреляции линии с прямой (0-100%).
   //     line.corA=(int)cor_Arc;    // - cor_Arc, коэффициент корреляции линии с дугой (0-100%).
   //     line.corS=(int)cor_Spi;    // - cor_Spi, коэффициент корреляции линии со спиралью (0-100%).
        
        
        //line.maxCor=SPIRAL; // все что дллиннее LINE_SIZE рисуем кривыми Безье
        if(line.data.size()<LINE_SIZE) { line.corL=100; line.maxC=100; line.maxCor=LINE; } // GGraphBezier.h // <9 <12
        
      /*  */

    }//____________________________________________________________________________
    


    //*****************************************************************************
    
                                    /// КРУГ ///
    // Функция для подсчета характеристик фокальной линии: коэффициента корреляции линии с кругом и
    // диаметра круга.  
 
    void GGraphBezier::focalLineRecCircle2 (OCRFocalLineBezier &line) {
        
         //sl_1, sl_2, LengthLine45, LengthLine90, LengthLine, centerX, centerY
        
        
        // Подсчитывается реальная длина фокальной линии  LengthLine_, состоящая из pix. Вычисляется диаметр круга D=L/π,
        // который может быть на этом месте. В вызывающей функции вычислениется координаты центра окружности centerX, centerY,
        // как среднее арифметическое координат текущих точек линии. Остается проверить, является ли полноценным кругом
        // эта замкнутая кривая с известной длинной и центром. На сколько коэффициент корреляции близок к 100%.
        // Для этого, по таблице для каждой точки, при движении вдоль кривой, вычисляется относительный угол поворота каждого пикселя.
        // Непрерывно суммируем относительные углы (со знаком), одновременно вычисляя min и max значение этой суммы вдоль всей кривой.
        // Только при движении вдоль окружности сумма относительных уголов остается постоянной и min равен max.
        // М.б. придется сглаживать скользячкой шириной в LengthLine_/4.
        // При движении вдоль прозвольной кривой min всегда не равен max.
        // Коэффициент корреляции линии (кривой) с окружностью показывает на сколько % min отличается от max.
        // Этот подход работает и в случае прямой.
        // Угол при полном обходе для замкнутой кривой, всегда будет равен 360° градусов.
        // Другой вариант
        // Непрерывно суммируем относительные углы (БЕЗ знака), получаем полнай угол больше чем 360° градусов.
        // Это и есть критерий как вслучае с прямой.
        
        float centerX=line.centerM.x;
        float centerY=line.centerM.y;

        
        int GrafT=0 ;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        //диаметр круга  diameter of a circle     хорда  длины окружности
        
        int x1,y1,x2,y2;  // Декартовы координаты начала и конца линии.
        float dx,dy;
        // Просто линна фокальной линии, т.е. длина фокальной линии состоящая из всех pix (диагональных и ортогональных).
        float LengthLine=(float)line.data.size();
        // Длинна фокальной линии состоящая только из ортогональных pix, т.е. pix стыкующихся только под углом 90° градусов.
        //float LengthLine90=(float)line.LengthLine90;
        // Длинна фокальной линии состоящая только из диагональных pix, т.е. pix стыкующихся только под углом 45° градусов.
        //float LengthLine45=(float)line.LengthLine45;
        // Длинна фокальной линии по кратчайшему расстоянию от начала линии до конца линии.
        float LengthLineDirect;
        // Истинная длина фокальной линии круга диаметра равного diameter.
        ///
        
        int cor_D;   // Коэффициент корреляции линии с к кругом (0-100%).
        int diameter; // Диаметр круга в pix.

        if (GrafT) {
            cout<<endl<<"Функция для подсчета характеристик фокальной линии по отношению к кругу   focalLineRecCircle2 () "<<endl;
            cout<<"Длинна фокальной линии  LengthLine="<<LengthLine<<endl;
            //cout<<"Длинна фокальной линии состоящий из ортогональных pix LengthLine90="<<LengthLine90<<endl;
        }

        
        //cout<<"sl_1="<<sl_1<<"   sl_2="<<sl_2<<endl;
        //cout<<"x1=sl_1%w="<<sl_1%w<<"   y1=sl_1/w="<<sl_1/w<<"   x2=sl_2%w="<<sl_2%w<<"   y2=sl_2/w="<<sl_2/w<<endl;

        x1=line.start.x;  y1=line.start.y;
        x2=line.end.x;    y2=line.end.y;
        dx=(float)(x2-x1);
        dy=(float)(y2-y1);
        
        // Вычисление расстояния между началом и концом линии (точнее от середины конечных точек) по Теореме Пифагора.
        LengthLineDirect=sqrt(dx*dx+dy*dy);
        // Полная длина фокальной линии.
        LengthLineDirect++; // +1 т.к. считаем от середины конечных точек линии 0.5pix + 0.5pix=1pix
        
        // Реальная длина фокальной линии, состоящая из pix состыкованных под 90° или 0° с длинной в 1 pix, и pix состыкованных под 45°
        // с длинной в 1.41 pix (длина диагонали pix).
        // float LengthLineV=LengthLine90 + 1.41421356*LengthLine45; // 1.41421356=sqrt(2) диагональный размер pix 1*1
        float LengthLineV;
        LengthLineV=1.2*LengthLine; //////////
        
        if (GrafT) {
            cout<<"centerX="<<centerX<<"   centerY="<<centerY<<"   LengthLine="<<LengthLine<<endl; //centerN
            //cout<<"dx="<<dx<<"     dy="<<dy<<endl;
            cout<<"LengthLineV - LengthLineDirect="<<LengthLineV - LengthLineDirect<<endl;
            cout<<"Длинна одной фокальной линии  (LengthLine)="<<LengthLine<<"       LengthLineDirect="<<LengthLineDirect<<endl;
            
        }
        
        // Вычисление диаметра круга D=L/π.
        diameter=(int)LengthLineV/3.14159265;
        
        // Вычисление истинного диаметра круга L=π*D
        ////LengthLineDirect=(int)diameter*3.14159265;
        
        // Вычисление координаты возможного центра окружности center в основной функции (вычисление ценра масс)
        
        // Вычисление коэффициента корреляции.
        ///cor_D=(int)100*LengthLineDirect/LengthLine_;   // if (cor_D>100) cor_D=100;  // LengthLine_ всегда +=1;
        //if (LengthLineDirect>8 && LengthLineDirect>8)
        cor_D=100*(LengthLineV-LengthLineDirect)/LengthLineV;
        //else cor_D=0;
        
        // Возвращаем  возможные:
        line.corC=cor_D; // cor_D, коэффициент корреляции линии с окружностью (0-100%)
        if(line.corC>line.maxC){
            line.maxCor=CIRCLE;
            line.maxC=cor_D;
        }
        
        line.radius=diameter; // diameter, диаметр круга в pix.
        // - center, координаты центра окружности.
        
/////        if (GrafT) { cout<<"cor_D="<<cor_D<<"%"<<"     diameter="<<diameter<<"pix"<<"   x=center%w="<<center%w<<"   y=center/w="<<center/w<<endl; }
        
        // усреднение углов лучей выходящих из особой точки 
       
        
    }//____________________________________________________________________________
    /**/
    
 
//*****************************************************************************

// Функция вычисления длины линии и угла между линией и горизонталью.
    
void GGraphBezier::LineAngleLength(float delta_x, float delta_y, float &alpha, float &length ){
    
    // Функция получает расстояние в pix между началом и концом линии по координатам "x" и "y".
    // Отдает длинну в pix и угол в градусах (от 0° до 360°) между линией и горизонталью.
    
    // Вычисление длины линии по Теореме Пифагора.
    length=sqrt(delta_x*delta_x + delta_y*delta_y);
    
    /*
    // Величина угла между линией и горизонталью от -90° до +90° градусов.
    alpha=-57.29747*atan(delta_y/delta_x); // угол в градусах в I и IIII квадрантах (-90° до +90° гр).
    // float может делить на "0".
    
    // Доопределение углов до значения от 0° до 360° градусов.
    if (delta_x<0) { if (delta_y<0) alpha+=90; } // доопределение углов во II квадранте. // верх оси "y" выбран ? отрицательным.
    if (delta_x<0) { if (delta_y>=0)alpha+=180;} // доопределение углов в III квадранте. // dy>=0 не тестировали
    if (delta_x>=0){ if (delta_y>0) alpha+=360;} // доопределение углов в IIII квадранте.
    */
    
    // Величина угла между линией и горизонталью от -180° до +180° градусов.
    alpha=-57.29747*atan2f(delta_y,delta_x);    // угол в градусах в I,II и III,IIII квадрантах (-180° до +180° гр).
    // если убрать минус, то все работает, но на графике углы нельзя интерпретировать поскольку ось "y" направлена в низ.
    // доопределение углов до значения от 0° до 360° градусов. Углы только положительные.
    if (alpha<0) alpha+=360;
    //cout<<"alpha="<<alpha<<endl;
    /**/
    
    // ...Если угол θ положителен, поворот выполняется против часовой стрелки, а если отрицателен — по часовой стрелке.
    // Однако уравнение было выведено для обычной прямоугольной системы координат, так что на экране дисплея ось Y
    // оказывается инвертированной, а значит, положительный и отрицательный углы меняются местами. стр 398
    // Андрэ Ламота "Программирование игр для Windows. Советы профессионала"
    
    // Поскольку "ноль" координат в графическом порту находится в левом верхнем углу картинки, а в математике в нижнем углу,
    // то перед "y" приходится ставить минус. Отсюда минус перед atan2f и тогда угол откладывались в привычном направлении,
    // против часовой стрелки, а не по часовой стрелки как в случае без минуса.

    
    // float atan2f(float a, float b);      double atan2(double a, double b);
    // Аргументы и возвращаемое значение функции atan2f являются числами с плавающей точкой.
    // Тип float, точность не менее шести значащих десятичных цифр, разрядность - 32). -
    
    
}//____________________________________________________________________________



    
}; //____________________________________________________________________________




