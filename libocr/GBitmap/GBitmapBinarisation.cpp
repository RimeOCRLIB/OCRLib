//  Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .

#include "GBitmap.h"

#ifdef ASM_OS64_SSE42_POPCNT_ATT
#include <smmintrin.h>  // для_mm_popcnt_u64
#endif

namespace ocr{
  
  
  
  //*****************************************************************************
  
  
  // Разрабатываемая version  22 февраля 2019.
  
  //***********************Adaptive Threshold************************************
  
  // Многопороговая функция преобразования серого массива в битовый массив (адаптивный порог), самая
  // аккуратная, но медленнее базовой функции binarisation в 2-2,5 раза. Использует фиксированный border.
  // Самые аккуратные параметры для этой функции binarisationF(?, ?);
  // НА ВХОДЕ В ФУНКЦИЮ ncolumns ДОЛЖЕН БЫТЬ КРАТНЕН 32.
  // Запуск функции нормализации crop32(); должен происходить в самом начале блока функций графической предобработки.
  // Самые аккуратные параметры для хороших текстов у этой функции binarisationF(92, 84, 28);
  // Самые аккуратные параметры для текстов с утонченными штрихами binarisationF(98, 92, 14);
  
  float  GBitmap::binarisationM(int Tr1, int Tr2, int BASE) {
    
    //***********************Adaptive Threshold************************************
    
    // Функция binarisationM() и базовая функция binarisation() выполняют аналогичный задачи.
    // Отличия заключаются в том что в binarisationM() используются два разных порога
    //
    //
    //
    // усреднения с разными порогами. Результаты разных вариантов бинаризации в виде ч.б. картинок суммируются.
    
    //  * Идея одного варианта усреднения *
    // Tr1 - устанавливает порог как число процентов, от вычисленного адаптивного порога в виде значения
    // средней яркости по области BASE*BASE. Если значение яркости текущего пикселя на Tr1 процентов ниже,
    // чем среднея яркость, то он установлевает текущий пиксел в черное, в противном случае в белое.
    // Обычно Tr1=80-98, BASE=14.
    
    
    //  * Реализация *
    // Выполнена на более быстрых циклах.
    
    //  * Особенности применения *
    // Если Tr1 выбирать меньше - то получаются более тонкие линии (штрихи), если Tr1 больше - более толстые линии и
    // бледные штрихи лучше проработаны. Однако при максимальном увеличении Tr1 до 98-99 вместе с лучшей проработкой
    // бледных и тонких штрихов проявляется шумовой мусор от фона. Обычно Tr1=92-98, оптимально 98.
    // Для отсечения шумового мусора применяется порог Tr2.
    // Обычно Tr2 выбирают в диапазоне 76-92 (оптимально 92) по минимому фоновых шумов.
    // Убрано умножение BASE на 3,5 внутри функции (BASE=BASE*3,5).
    
    if(Tr1==0 || Tr2==0 || BASE==0) return 0;
    
    TIME_START // time=0.54 сек,  w=4064 h=2472,  _Image2OCR/__Page_09___.png
    
    // Если размер ncolumns не кратен 32 (остаток от деления на 32) > 0.
    if( ncolumns%32>0 ) {
      cout<<"НА ВХОДЕ В ФУНКЦИЮ binarisationM() ncolumns ДОЛЖЕН БЫТЬ КРАТНЕН 32, ncolumns="<<ncolumns<<endl;
    }
    
    // функция нормализации массива bytes_data по размеру ncolumns кратным 32
    ///crop32();
    // получает новый массив bytes_data с новым размером по горизонтали ncolumns кратным 32 и новым data_size=ncolumns*nrows;
    
    // Check arguments and init variables
    int w=ncolumns;     // ширина массива   IMAGE_WIDTH
    int h=nrows;        // высота массива   IMAGE_HEIGHT
    int w_h=w*h;        // размер массива   IMAGE_SIZE
    
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
    if (GrafT) {
      cout<<"Адаптивный порог binarisationM:"<<"  Tr1="<<Tr1<<"  Tr2="<<Tr2<<"  BASE="<<BASE<<endl;
      cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
    
    
    // ограничения на процент от порога  Tr1 и Tr2.
    if (Tr1 < 16) Tr1 = 16;   if (Tr1 > 99) Tr1 = 99;
    if (Tr2 < 16) Tr2 = 16;   if (Tr2 > 99) Tr2 = 99;
    
    // ограничения на размер скользящий области усреднения BASE*BASE в пикселях.
    if (BASE < 4) BASE = 4;   if (BASE > 128) BASE = 128;
    
    /////////////////////////////////////////////////////////////////////////////
    
    // входной массив серый, выходной ч.б., 0-черный 255-белый.
    ///uchar *p0=bytes_data;        // глобальный массив, исходник.
    //uchar *bytes_data_=bytes_data;  // сохраняем указатель на bytes_data.
    
    // Массивы функционально аналогичены bytes_data
    uchar *bytes_data_1 = (uchar*)malloc(w_h*sizeof(uchar*)); // копия исходника.
    uchar *bytes_data_2 = (uchar*)malloc(w_h*sizeof(uchar*)); ////////////////////
    ///bytes_data_1 = (uchar*)calloc(sizeBuf, sizeof(uchar)); // p1
    
    /// ТЕСТ
    // для Tr1=98 и BASE=14  по умолчанию значение Tr2=92 (как 92% от значения Tr).
    
    
    // Реализация алгоритма агресивной бинаризации с защитной маской (периферийной маской).//
    
    // Сохранение bytes_data, исходника.
    memcpy(bytes_data_1, bytes_data, w_h); // адрес буфера назначения, адрес источника, количество байт для копирования.
    
    //*
    // Параметр Tr1 управляет качеством начертания буквы (как в классической функции binarisation). Обычно 92-98. Оптимально 98.
    // Параметр Tr2 управляет качеством фона, позволяя минимизировать шумовые артефакты фона (точки). Обычно 76-92. Оптимально 92.
    // Параметр BASE это размер скользящий области усреднения яркости в pix. Оптимально 14.
    
    // значение Tr2 как % от значения Tr1 задаваемого вручную.
    Tr2=(Tr2*Tr1)/100; // для Tr=98 и BASE=14  по умолчанию значение Tr2=92 (как 92% от значения Tr1).
    // 92 эмпирический коэффициент. 78 текст с разворотом и ВЫРАЖЕННЫМ серым фоном
    if (GrafT) {cout<<"   Tr2="<<Tr2<<endl;}
    
    // Применение щадящий бинаризации для изготовления заготовки защитной маски.
    // можно получить сразу 2 (8) маски  и даже сохранить их с одном ч.б. массиве. //
    binarisationF(Tr2, BASE); // 92, 14
    
    // Вычисление средней толщины штриха по всей исходной картинке.
    // От толщины штриха удобно задавать величину полиграфического растискивания для получения защитной маски.
    float Df=LineWidthImg();
    int D=(int)Df;
    if (GrafT) {cout<<"   D="<<D<<endl;}
    
    // Из заготовки защитной маски с помощью полиграфического растискивания получаем толстые ч.б. буквы
    // - защитную маску. Маска имет размер картинки и функционально представляет собой черный фон с дырками
    // в виде растиснутых букв.
    dotGain(0,0,0,0, D+3); // где 3 эмпирический коэффициент. // 5+3 // с обоих сторон добавляется по (D+3)/2
    ///dotGain(gRateLefts, gRateRight, gRateHighs, gRateLower, 0);
    // Два способа задания полиграфического растискивания расписаны в самой функции:
    // - первый способ:  dotGain(0,0,0,0, 4); где цифры это величина растискивания в pix
    //  dot_gain добавляет однопиксельные слои вокруг символов (-dot_gain убавляет) и
    // блокирует использование gRateLefts, gRateRight, gRateHighs, gRateLower.
    // При этом способе добавлятся по 1 pix поочередно с каждой стороны штриха.
    // - второй способ:  dotGain(2, 2, 2, 2, 0);
    // dot_gain=0 блокирует свое собственное влияние и можно использовать индивидуальной установки
    // gRateLefts, gRateRight, gRateHighs, gRateLower.
    
    
    //*
    // Сохранение готовой защитной маски в bytes_data_2.
    memcpy(bytes_data_2, bytes_data, w_h); //
    
    // Восстановление исходной серой bytes_data из bytes_data_1.
    memcpy(bytes_data, bytes_data_1, w_h); //
    
    // Применение агресивной бинаризации к серому, которая потенциально может создавать мусор вокруг букв и по всему тексту.
    // Функция преобразования серого массива в битовый массив (адаптивный порог).
    binarisationF(Tr1, BASE); // 98, 14
    
    // Применение защитной маски bytes_data2_64 не влияющей на буквы и стирающей мусор вокруг букв и по всему тексту.
    int w_h_64=w_h/sizeof(ulong);  // sizeof(ulong)=8
    // приведение указателя uchar на bytes_data к ulong.
    ulong *bytes_data_64=(ulong*)bytes_data;
    ulong *bytes_data2_64=(ulong*)bytes_data_2;
    // Обрабатываем одновременно по 8 байт.
    for ( int x=0; x < w_h_64; x++ ) { bytes_data_64[x]=bytes_data_64[x] | bytes_data2_64[x]; }
    // Обработка последнего участка массива длинной от 0 до 8 байт.
    int wh_=w_h_64*sizeof(ulong);
    for (int x=wh_; x<w_h; x++){ bytes_data[x]=bytes_data[x] | bytes_data_2[x]; }
    //*/
    // закончена работа алгоритма и получено искомое ч.б. изображение букв в bytes_data.
    
    
    
    
    // При пакетной обработке похоже именно этот блок кода на ссылках вешает обработку
    
    /*
     // ТЕСТ убираем маску
     ////// memset(bytes_data, 0, w_h);   // начало (указатель), значение, количество символов в байтах (длина) *sizeof(uint)
     
     // Теперь в bytes_data находится маска, в bytes_data_1 исходник.
     
     // Меняем ссылку bytes_data на bytes_data_1 и затем агресивно бинаризуем исходник находящийся в bytes_data_1.
     bytes_data=bytes_data_1;
     
     // Применение агресивной бинаризации к серому, которая потенциально может создавать мусор вокруг букв и по всему тексту.
     // Функция преобразования серого массива в битовый массив (адаптивный порог).
     binarisationF(Tr1, BASE); // 98, 14
     
     bytes_data=bytes_data_; // восстанавливаем прежний указатель на bytes_data
     
     // теперь в bytes_data как и было находится маска, в bytes_data_1 агресиво бинаризованный исходник.
     
     // ТЕСТ убираем агресиво бинаризованный исходник
     //////memset(bytes_data_1, 0, w_h);
     
     // ПОХОЖЕ ЗАСАДА В УКАЗАТЕЛЯХ bytes_data_64 И bytes_data1_64
     // Применение защитной маски bytes_data64 не влияющей на буквы и стирающей мусор вокруг букв и по всему тексту.
     int w_h_64=w_h/sizeof(ulong);  // sizeof(ulong)=8
     // приведение указателя uchar на bytes_data к ulong.
     ulong *bytes_data_64=(ulong*)bytes_data;
     ulong *bytes_data1_64=(ulong*)bytes_data_1;
     // Обрабатываем одновременно по 8 байт.
     for ( int x=0; x < w_h_64; x++ ) { bytes_data_64[x]=bytes_data_64[x] | bytes_data1_64[x]; }
     // Обработка последнего участка массива длинной от 0 до 8 байт.
     int wh_=w_h_64*sizeof(ulong);
     for (int x=wh_; x<w_h; x++){ bytes_data[x]=bytes_data[x] | bytes_data_1[x]; }
     //*/
    // закончена работа алгоритма и получено искомое ч.б. изображение букв в bytes_data.
    
    
    
    // освобождение массивов.
    if ( bytes_data_1 !=NULL ) free(bytes_data_1);
    if ( bytes_data_2 !=NULL ) free(bytes_data_2); /////////////////////
    
    if(GrafT) { TIME_PRINT_ }
    
    // Возвращение средней толщины штриха по всей исходной картинке в пикселях и долях пикселя (float).
    return Df;
    
    //_____________________________________________________________________________
    
    
    /*
     //МОЖНО НЕ ВЫЧИСЛЯТЬ gRateLefts .....
     // Вычисление "D" необходимого количества слоев растискивания для получения защитной маски.
     int Dg=D + 3; // где 3 эмпирический коэффициент.
     int gRateLefts, gRateRight, gRateHighs, gRateLower;
     // Пересчет толщины штриха "D" в количество поочередно применяемых однопиксельных слоев с шагом в 1 pix.
     gRateLefts=Dg/2 + Dg%2;         gRateHighs=gRateLefts;
     gRateRight=Dg/2;                gRateLower=gRateRight;
     cout<<"Dg="<<Dg<<endl;
     cout<<"gRateLefts="<<gRateLefts<<"   gRateRight="<<gRateRight<<"   gRateHighs="<<gRateHighs<<"   gRateLower="<<gRateLower<<endl;
     //*/
    
    /*
     // Вычисление среднего значения фона по всей исходной картинке с вычитанием дырок защитной маски.
     uint n=0;    uint fond=0;
     for (int x=0; x<w_h; x++){
     ///uchar b_data=bytes_data[x];
     // Просто подсчитывается суммарное количество серого //(>0) вне дырок защитной маски.
     //if (bytes_data[x]==255) {fond+=bytes_data_1[x], n++;} // >0
     fond+=bytes_data[x];
     ///cout<<(ushort)b_data<<endl;
     } // x
     // Средний фон
     fond=(255-fond/w_h);
     cout<<"fond="<<fond<<endl;
     
     //*/
    
    
    /////////////////////////////////////////////////////////////////////////////
    
    /*
     memcpy(bytes_data_1, bytes_data, w_h); // адрес буфера назначения, адрес источника, количество байт для копирования.
     
     int w_h_64=w_h/sizeof(ulong);  // sizeof(ulong)=8
     ulong *bytes_data_64=(ulong*)bytes_data;    // приведение указателя uchar на bytes_data к ulong.
     // bytes_data2_64[x] | 0x8080808080808080 +  0x4040404040404040
     ulong *bytes_data2_64=(ulong*)bytes_data_2;
     
     // Обрабатываем одновременно по 8 байт.
     for ( int x=0; x < w_h_64; x++ ) { bytes_data2_64[x]=bytes_data2_64[x] & (bytes_data_64[x] | 0x8080808080808080); }
     //for ( int x=0; x < w_h_64; x++ ) { bytes_data2_64[x]=(bytes_data2_64[x] | 0x8080808080808080) & (bytes_data_64[x] | 0x8080808080808080); }
     // Обработка последнего участка массива длинной от 0 до 8 байт.
     int wh_=w_h_64*sizeof(ulong);
     ///for (int x=wh_; x<w_h; x++){ bytes_data[x]+=(bytes_data[x] & 0x80); }
     
     memcpy(bytes_data, bytes_data_2, w_h);
     //*/
    
  }//_____________________________________________________________________________
  
  
  
  // ГОТОВАЯ НОВАЯ ОТЛАДОЧНАЯ fast version   29 марта 2019
  // это тестовая функция для отработки переполнений
  
  //***********************Adaptive Threshold************************************
  
  // Функция преобразования серого массива в битовый массив (адаптивный порог).
  // Выполнена на основе функции binarisationF(), но может обрабатывать графические
  // картинки в несколько раз большего размера чем исходная функция binarisation.
  // Самые аккуратные параметры для хороших текстов у этой функции binarisationF(92, 28);
  // Самые аккуратные параметры для текстов с утонченными штрихами binarisationF(98, 14);
  
  // Авторы = "DerekBradley and GerhardRoth".
  // www.derekbradley.ca / AdaptiveThresholding / index.html.
  
  void  GBitmap::binarisationL(int Tr, int BASE) {
    
    //***********************Adaptive Threshold************************************
    
    // Функция binarisationL() и базовая функция binarisation() выполняют аналогичный задачи.
    // Отличия закдючаются в том что в binarisationF() для вычисления средней яркости в скользящей области в
    // циклах применяеются не неравенства ограничивающие выход за пределы массивов, а бордюр фиксированного размера.
    
    //  * Идея *
    // Tr - устанавливает порог как число процентов, от вычисленного адаптивного порога в виде
    // значения средней яркости по области S*S. Если значение яркости текущего пикселя на Tr процентов ниже,
    // чем среднея яркость, то он установлевает текущий пиксел в черное, в противном случае в белое.
    // Обычно Tr=80-95, BASE=s=2-16.
    // Если Tr выбирать меньше - то получаются более тонкие линии (штрихи), Tr больше - более толстые линии.
    
    //  * Реализация *
    // Выполнена на более быстрых циклах.
    
    //  * Особенности применения *
    // Убрано умножение BASE на 3,5 внутри функции (BASE=BASE*3,5).
    // В этой версии расширин максимальный размер обрабатываемой картинки за счет суммирования в массиве интегральных сумм
    // белого с кодировкой "0", а не "255" как раньше. Белого в обрабатываемой картинке на порядок больше чем черного.
    // Переполнение uint sum, как суммы серого по всей площади, наступает при больших размерах графической картинки.
    // Теперь практический максимум обрабатываемого размера 24960*4620 и более.
    // Раньше было:
    // scale1=1.0; // 0.4 порог 0.45 без инверсии  w=9984,  h=1848  scale1=0.4    // 1.0 порог 1.0 с инверсией  w=24960  h=4620  scale1=1
    // Чисто теоретический максимум обрабатываемого размера был 3645*674.------------
    // 1 апреля 2019.
    
    if(Tr==0 || BASE==0)return;
    
    //int flag=1; // если есть бордюр, то flag=1; и функция выполняется быстро без отработки краевых эффенктов.
    //uint border=32;
    //if (border<32) {cout<<"Ошибка в функции binarisationF, необходим border>=32,  border="<<border<<endl; flag=0; return;}
    
    // Check arguments and init variables
    ///int w=ncolumns;     // ширина массива   IMAGE_WIDTH
    ///int h=nrows;        // высота массива   IMAGE_HEIGHT
    
    int w=columns();       // ширина массива   IMAGE_WIDTH.
    int h=rows();          // высота массива   IMAGE_HEIGHT.
    
    int w_h=w*h;        // размер массива   IMAGE_SIZE
    
    
    
    TIME_START // time=0.165 сек,  w=4064 h=2472,  _Image2OCR/__Page_09___.png
    
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
    if (GrafT) {
      cout<<"Адаптивный порог binarisationL    BASE="<<BASE<<endl;
      cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
    
    
    // ограничения на процент от порога  Tr.
    if (Tr < 16) Tr = 16;   if (Tr > 99) Tr = 99;
    
    // ограничения на размер буквы BASE в пикселях, где
    // BASE ориентировачно средний размер буквы или строки по всей странице, в Tenjur=46.
    if (BASE < 4) BASE = 4;   if (BASE > 128) BASE = 128;
    
    
    // ОБНУЛЕНИЕ border
    ///////variationBorder(0, s2-5);
    
    ///////invert();  // для нового алгоритма с инверсией.
    
    
    /////////////////////////////////////////////////////////////////////////////
    
    // create the integral image. //
    // интегральная яркость, integrated brightness. //
    
    
    // входной серый и выходной ч.б. массивы, 0-черный 255-белый
    ///uchar *p0=bytes_data; //глобальный массив
    
    // массив интегральных сумм
    uint *integralImg = (uint*)malloc(w_h*sizeof(uint*));
    
    // выход в случае отсутствия свободной памяти запрашиваемого размера.
    if (integralImg==NULL) {DC("integralImg"); return;}
    
    //memset(integralImg, 0, w_h*sizeof(uint*));
    //memset(bytes_data, 255, w_h);
    
    // Подсчет интегральных сумм яркостей для работы скользящего суммирующего квадрата площадью S*S. //
    
    uchar *p0 = bytes_data;
    uchar *d0;
    uint  *p1 = integralImg;
    uint  *d1;
    
    uint sum=0; // сумма серого (сумма яркостей) папавшая в площадь квадрата.
    ulong max=0; // ТЕСТ на переполнение uint
    
    ///TIME_START
    
    //*
    // Обработка нулевой строки y=0; (первой по счету).
    for (int x=0; x<w; x++)
    {
      // подсчет интегральных сумм яркостей для работы скользящего суммирующего квадрата S*S.
      sum+=255-*(p0 + x);    // sum+=255-bytes_data[x];  // sum+= *p0;   p0++;
      *(p1 + x) = (sum);    // ~sum // integralImg[x]=sum;  // *p1 = sum;   p1++;
      ///long p=p1-integralImg;   if (p<4 || p>(w_h-4)) cout<<"w*h="<<w*h<<",  p="<<p<<",  *(p1 + x)="<<*(p1 + x)<<endl;
    } //x
    
    // Обработка всех остальных строк y=1; и т.д.
    for (int y=1; y<h; y++)
    {
      // обнуляем сумму в этом столбце // reset this column sum.
      sum=0;
      // вспомогательные переменные для увеличения быстродействия.
      p0+=w;  // p0 = bytes_data + y*w;
      d0=p0;  // сохраняем для выполнения цикла по "x"
      p1+=w;  // p1 = integralImg + y*w;
      d1=p1;  // сохраняем для выполнения цикла по "x"
      
      for (int x=0; x<w; x++)
      {
        // подсчет интегральных сумм яркостей для работы скользящего суммирующего квадрата S*S.
        sum+=255-*d0;           // sum+=255-*(p0 + x);           // sum+=255-bytes_data[y*w + x];
        *d1 = *(d1-w) + sum;
        //ulong t = *d1 = *(d1-w) + (sum); // (~sum) // *(p1+x) = *(p1+x-w) + sum; // integralImg[y*w + x]=integralImg[y*w + x - w] + sum;
        //    if (t>max)max=t;    // ТЕСТ на переполнение uint
        d0++;                // p0 = bytes_data + y*w + x;
        d1++;                // p1 = integralImg + y*w + x;
        //long p=d0-bytes_data;    if (p<4 || p>(w_h-4)) cout<<"w*h="<<w*h<<",  p="<<p<<endl;
        
        //    long p=d1-integralImg;   if (p<4 || p>(w_h-4)) cout<<"w*h="<<w*h<<",  p="<<p<<",  t="<<t<<endl;
        //cout<<"  y="<<y<<"  x="<<x<<"  *(p0 + x)="<<(short)*(p0 + x)<<"  sum="<<sum<<"  *(p1 + x)="<<*(p1 + x)<<endl;
      } //x
    } //y
    //*/
    cout<<"max="<<max<<"    max="<<max/1000000<<" млн. пикселей"<<endl; //
    cout<<"4294967295-max="<<4294967295-max<<endl; // ТЕСТ на переполнение uint
    cout<<"integralImg[w_h-1]="<<integralImg[w_h-1-w]<<endl;
    cout<<"bytes_data[w_h-1]="<<(int)bytes_data[w_h-1]<<endl;
    TIME_PRINT_
    
    ///     for (int x=0; x<w_h; x++) { bytes_data[x]=(uchar)integralImg[x]; }
    //*/
    
    /////////////////////////////////////////////////////////////////////////////////
    
    
    //*
    
    // Адаптивный порог. //
    // perform thresholding. //
    
    // Оставлено для теста
    ///int S=BASE*35/10;  // S в 3,5 больше размера буквы или строки //////////
    ///int s2=S/2; // половина стороны суммирующего квадрата //////////
    int s2=BASE/2; // половина стороны суммирующего квадрата
    if (GrafT) {cout<<"  Tr="<<Tr<<"  BASE="<<BASE<<"  s2+s2="<<s2+s2<<endl;}
    
    // Приведение Tr к 128 вместо 100, позволяет использовать сдвиг >>7 (/128) вместо деления в цикле perform thresholding.
    Tr=(Tr<<7)/100 + 1; // Tr=(Tr*128)/100 + 1; // "1" осталась от старого алгоритма, предотвращала деление на ноль.
    
    // вспомогательные переменные, для увеличения быстродействия.
    uint count = (s2+s2)*(s2+s2); // площадь суммирующего квадрата count=S*S (не заходит за border).
    uint count255=count*255;
    uint count128=count*128;
    
    int s2_w=s2*w;  // s2 это половина стороны суммирующего квадрата по по оси "x", s2_w соответственно по оси "y".
    // border "b" ограничивает область сканирования текста суммирующим квадратом, предотвращая выход за граници массива, b>=s2.
    int b=s2+1;     // border по оси "x", с запасом в 1 pix ( +1 ). //////////////////////////////////////////////////////////
    int b_w=b*w;    // border по оси "y", с запасом в 1 pix.
    
    // *p1-*p4 и *d1-*d4 указатели на координаты углов суммирующего квадрата.
    uint *p2, *p3, *p4;
    uint *d2, *d3, *d4;
    uint *p;
    
    
    // Учет border в начале цикла.
    p0 = bytes_data + b + b_w; // указатель на обрабатываемый серый пиксель.
    p = integralImg + b + b_w; // указатель на центр суммирующего квадрата (S*S region), от него отсчитывается +-s2.
    // b это начальное смещение цикла по "x" т.е. border, при этом цикл начинается с "0".
    // b_w это начальное смещение цикла по "y" т.е. border, при этом цикл начинается с "0".
    
    
    // Учет border в конце цикла.
    int w2b=w-b-b;   // размер страници в pix по "y" минус border.
    int h2b=h-b-b;   // размер страници в pix по "x" минус border.
    
    // Задание координат углов суммирующего квадрата (border уже учетен).
    
    // указатель на левый верхний угол суммирующего квадрата.
    p1 = p - s2 - s2_w;
    // -s2 это смещение по "x" в "-" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix
    
    // указатель на правый верхний угол суммирующего квадрата.
    p2 = p + s2 - s2_w;
    //  s2 это смещение по "x" в "+" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix.
    
    // указатель на левый нижний угол суммирующего квадрата.
    p3 = p - s2 + s2_w;
    // -s2 это смещение по "x" в "-" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix.
    
    // указатель на правый нижний угол суммирующего квадрата.
    p4 = p + s2 + s2_w;
    //  s2 это смещение по "x" в "+" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix.
    
    //int x=0;
    for (int y=0; y<h2b; y++){ // h2b=h-b-b;
      
      d0=p0;  d1=p1;  d2=p2;  d3=p3;  d4=p4; // сохраняем указатели *p0-*p4 для выполнения цикла по "x"
      
      for (int x=0; x<w2b; x++){ // w2b1=w-b-b;
        
        // сумма серого папавшая в площадь квадрата S*S.
        // I(x,y)=s(x2,y2)-s(x1,y2)-s(x2,y1)+s(x1,x1)
        // sum = integralImg[y*w + x - s2*w - s2] - integralImg[y*w + x - s2*w + s2]
        // - integralImg[y*w + x + s2*w - s2] +  integralImg[y*w + x + s2*w + s2];
        sum =count255 - (*d1 - *d2 - *d3 + *d4);
        
        //////*d1=0;  *d2=0;  *d3=0;  *d4=0; // TECT на визуализацию области покрытия скользящим квадратом. Нужно переназначить указатели.
        //////*d0=0; // TECT на визуализацию области попиксельной обработки. На входе ставим memset(bytes_data, 255, w_h);
        //////*d0=1*sum/count; // *p0=sum; // TECT на визуализацию среднего по области попиксельной обработки.
        
        /// Бинаризация ///
        // Если яркость (0-255) пиксела больше средней по площади яркости скользящего квадрата S*S, то считаем пиксель ЧЕРНЫМ белым.
        /// if (bytes_data[index]*count128 > sum*Tr)  {bytes_data[index]=255;} else { bytes_data[index]=0; } где index=y*w + x; (без учета border)
        // Разные функции бинаризации. Все алгоритмы в итоге бинаризуют одинакого.
        if ( *d0*count128 > sum*Tr )  { *d0=255; }  else { *d0=0; }     // binarisationF
        /// if ( *d0*count > ((sum*Tr)>>7) )  { *d0=255; }  else { *d0=0; } // binarisation
        // наверно более грубые градации уровней.
        //if ( *d0 > sum/count - (128-Tr))  { *d0=255; }  else { *d0=0; } // 255 белый /128    // *128 //////////////////////////////
        
        
        //long p=d0-bytes_data;    if (p<4+b+4*b_w || p>w_h-(4+b+b_w)) cout<<"w*h="<<w*h<<",  p="<<p<<endl; // TECT
        //long p=d1-integralImg;    if (p<4|| p>w_h-(4+b+4*b_w)) cout<<"w*h="<<w*h<<",  p="<<p<<endl;       // TECT
        
        //if ( *d0*count128 > (~sum)*Tr )  { *d0=0; }      // TECT черный шаблон на исходный серый текст
        
        d0++;  d1++;   d2++;   d3++;   d4++; // d0 = bytes_data + y*w + x; // d1 = integralImg + y*w + x;
        
      } // x
      
      p0+=w;  p1+=w;  p2+=w;  p3+=w;  p4+=w; // p0 = bytes_data + y*w; // p1 = integralImg + y*w;
      
    }  // y
    //*/
    
    cout<<"  200*Tr/128="<<200*Tr/128<<endl;
    
    /*
     // "Preview" в MAC OS справо по вертиками врет до нескольких pix.
     // TECT, вывод псевдографикой всей картинки или одной строки по середине высоты.
     cout<<endl;
     for (int y=0; y<h; y++){
     for (int x=0; x<w; x++){
     cout<<(int)bytes_data[w*y + x]/255;   // вся картинка
     //cout<<(int)bytes_data[w*(h/2) + x]/255; // одна строка
     } // x
     cout<<endl;
     }  // y
     //*/
    
    ///invert();
    
    // освобождение массива integralImg.
    if ( integralImg !=NULL ) free(integralImg);
    
    if(GrafT) { TIME_PRINT_ }
    
    //TECT
    /*
     int n=0; // binarisationF(96, 14) n=1859248 // binarisation(96, 3) n=1859248 // _Image2OCR/__Page_09___.png
     for (int x=0; x<w*h; x++){ if ( bytes_data[x]==0 ) n++;} // x
     cout<<"n="<<n<<endl;
     //*/
    
  }//_____________________________________________________________________________
  
  
  
  // ГОТОВАЯ НОВАЯ fast version  2 февраля 2019
  
  //***********************Adaptive Threshold************************************
  
  // Функция преобразования серого массива в битовый массив (адаптивный порог).
  // Выполнена на основе функции binarisation(), но в 1,5-2 раза быстрее базовой и
  // самая тщательная. Убрано умножение BASE на 3,5 внутри функции (BASE=BASE*3,5).
  // Самые аккуратные параметры для хороших текстов у этой функции binarisationF(92, 28);
  // Самые аккуратные параметры для текстов с утонченными штрихами binarisationF(98, 14);
  
  // Авторы = "DerekBradley and GerhardRoth".
  // www.derekbradley.ca / AdaptiveThresholding / index.html.
  
  void  GBitmap::binarisationF(int Tr, int BASE) {
    //***********************Adaptive Threshold************************************
    
    // Функция binarisationF() и базовая функция binarisation() выполняют аналогичный задачи.
    // Отличия закдючаются в том что в binarisationF() для вычисления средней яркости в скользящей области в
    // циклах применяеются не неравенства ограничивающие выход за пределы массивов, а бордюр фиксированного размера.
    
    //  * Идея *
    // Tr - устанавливает порог как число процентов, от вычисленного адаптивного порога в виде
    // значения средней яркости по области S*S. Если значение яркости текущего пикселя на Tr процентов ниже,
    // чем среднея яркость, то он установлевает текущий пиксел в черное, в противном случае в белое.
    // Обычно Tr=80-95, BASE=s=2-16.
    // Если Tr выбирать меньше - то получаются более тонкие линии (штрихи), Tr больше - более толстые линии.
    
    //  * Реализация *
    // Выполнена на более быстрых циклах.
    
    //  * Особенности применения *
    // Убрано умножение BASE на 3,5 внутри функции (BASE=BASE*3,5).
    // В этой версии расширин максимальный размер обрабатываемой картинки за счет суммирования в массиве интегральных сумм
    // белого с кодировкой "0", а не "255" как раньше. Белого в обрабатываемой картинке на порядок больше чем черного.
    // Переполнение uint sum, как суммы серого по всей площади, наступает при больших размерах графической картинки.
    // Теперь практический максимум обрабатываемого размера 24960*4620 и более.
    // 1 апреля 2019.
    
    if(Tr==0 || BASE==0)return;
    
    // Check arguments and init variables
    int w=ncolumns;     // ширина массива   IMAGE_WIDTH
    int h=nrows;        // высота массива   IMAGE_HEIGHT
    int w_h=w*h;        // размер массива   IMAGE_SIZE
    
    
    TIME_START // time=0.165 сек,  w=4064 h=2472,  _Image2OCR/__Page_09___.png
    
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
    if (GrafT) {
      cout<<"Адаптивный порог binarisationF    BASE="<<BASE<<endl;
      cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
    
    
    // ограничения на процент от порога  Tr.
    if (Tr < 16) Tr = 16;   if (Tr > 99) Tr = 99;
    
    // ограничения на размер буквы BASE в пикселях, где
    // BASE ориентировачно средний размер буквы или строки по всей странице, в Tenjur=46.
    if (BASE < 4) BASE = 4;   if (BASE > 128) BASE = 128;
    
    
    // ОБНУЛЕНИЕ border
    ///////variationBorder(0, s2-5);
    
    
    /////////////////////////////////////////////////////////////////////////////
    
    // create the integral image. //
    // интегральная яркость, integrated brightness. //
    
    
    // входной серый и выходной ч.б. массивы, 0-черный 255-белый
    ///uchar *p0=bytes_data; //глобальный массив
    
    // массив интегральных сумм
    uint *integralImg = (uint*)malloc(w_h*sizeof(uint*));
    
    // выход в случае отсутствия свободной памяти запрашиваемого размера.
    if (integralImg==NULL) {DC("integralImg"); return;}
    
    
    // Подсчет интегральных сумм яркостей для работы скользящего суммирующего квадрата площадью S*S. //
    
    uchar *p0 = bytes_data;
    uchar *d0;
    uint  *p1 = integralImg;
    uint  *d1;
    uint sum=0; // сумма серого (сумма яркостей) папавшая в площадь квадрата.
    
    //*
    // Обработка нулевой строки y=0; (первой по счету).
    for (int x=0; x<w; x++)
    {
      // подсчет интегральных сумм яркостей для работы скользящего суммирующего квадрата S*S.
      sum+=255-*(p0 + x);    // sum+=255-bytes_data[x];  // sum+= *p0;   p0++;
      *(p1 + x) = sum;    // integralImg[x]=sum;  // *p1 = sum;   p1++;
    } //x
    
    // Обработка всех остальных строк y=1; и т.д.
    for (int y=1; y<h; y++)
    {
      // обнуляем сумму в этом столбце // reset this column sum.
      sum=0;
      // вспомогательные переменные для увеличения быстродействия.
      p0+=w;  // p0 = bytes_data + y*w;
      d0=p0;  // сохраняем для выполнения цикла по "x"
      p1+=w;  // p1 = integralImg + y*w;
      d1=p1;  // сохраняем для выполнения цикла по "x"
      
      for (int x=0; x<w; x++)
      {
        // подсчет интегральных сумм яркостей для работы скользящего суммирующего квадрата S*S.
        sum+=255-*d0;        // sum+=255-*(p0 + x);        // sum+=255-bytes_data[y*w + x];
        *d1 = *(d1-w) + sum; // *(p1+x) = *(p1+x-w) + sum; // integralImg[y*w + x]=integralImg[y*w + x - w] + sum;
        d0++;                // p0 = bytes_data + y*w + x;
        d1++;                // p1 = integralImg + y*w + x;
        //long p=d0-bytes_data;    if (p<4 || p>(w_h-4)) cout<<"w*h="<<w*h<<",  p="<<p<<endl;
        //long p=d1-integralImg;   if (p<4 || p>(w_h-4)) cout<<"w*h="<<w*h<<",  p="<<p<<endl;
        //cout<<"  y="<<y<<"  x="<<x<<"  *(p0 + x)="<<(short)*(p0 + x)<<"  sum="<<sum<<"  *(p1 + x)="<<*(p1 + x)<<endl;
      } //x
    } //y
    //*/
    
    ///     for (int x=0; x<w_h; x++) { bytes_data[x]=(uchar)integralImg[x]; }
    
    
    /////////////////////////////////////////////////////////////////////////////////
    
    
    //*
    
    // Адаптивный порог. //
    // perform thresholding. //
    
    int s2=BASE/2; // половина стороны суммирующего квадрата
    if (GrafT) {cout<<"  Tr="<<Tr<<"  BASE="<<BASE<<"  s2+s2="<<s2+s2<<endl;}
    
    // Приведение Tr к 128 вместо 100, позволяет использовать сдвиг >>7 (/128) вместо деления в цикле perform thresholding.
    Tr=(Tr<<7)/100 + 1; // Tr=(Tr*128)/100 + 1; // "1" осталась от старого алгоритма, предотвращала деление на ноль.
    
    // вспомогательные переменные, для увеличения быстродействия.
    uint count = (s2+s2)*(s2+s2); // площадь суммирующего квадрата count=S*S (не заходит за border).
    uint count255=count*255;
    uint count128=count*128;
    
    int s2_w=s2*w;  // s2 это половина стороны суммирующего квадратапо по оси "x", s2_w соответственно по оси "y".
    // border "b" ограничивает область сканирования текста суммирующим квадратом, предотвращая выход за граници массива, b>=s2.
    int b=s2+1;     // border по оси "x", с запасом в 1 pix ( +1 ). //////////////////////////////////////////////////////////
    int b_w=b*w;    // border по оси "y", с запасом в 1 pix.
    
    // *p1-*p4 и *d1-*d4 указатели на координаты углов суммирующего квадрата.
    uint *p2, *p3, *p4;
    uint *d2, *d3, *d4;
    uint *p;
    
    
    // Учет border в начале цикла.
    p0 = bytes_data + b + b_w; // указатель на обрабатываемый серый пиксель.
    p = integralImg + b + b_w; // указатель на центр суммирующего квадрата (S*S region), от него отсчитывается +-s2.
    // b это начальное смещение цикла по "x" т.е. border, при этом цикл начинается с "0".
    // b_w это начальное смещение цикла по "y" т.е. border, при этом цикл начинается с "0".
    
    // Учет border в конце цикла.
    int w2b=w-b-b;   // размер страници в pix по "y" минус border.
    int h2b=h-b-b;   // размер страници в pix по "x" минус border.
    
    // Задание координат углов суммирующего квадрата (border уже учетен).
    
    // указатель на левый верхний угол суммирующего квадрата.
    p1 = p - s2 - s2_w;
    // -s2 это смещение по "x" в "-" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix
    
    // указатель на правый верхний угол суммирующего квадрата.
    p2 = p + s2 - s2_w;
    //  s2 это смещение по "x" в "+" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix.
    
    // указатель на левый нижний угол суммирующего квадрата.
    p3 = p - s2 + s2_w;
    // -s2 это смещение по "x" в "-" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix.
    
    // указатель на правый нижний угол суммирующего квадрата.
    p4 = p + s2 + s2_w;
    //  s2 это смещение по "x" в "+" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix.
    
    
    for (int y=0; y<h2b; y++){ // h2b1=h-b-b;
      
      d0=p0;  d1=p1;  d2=p2;  d3=p3;  d4=p4; // сохраняем указатели *p0-*p4 для выполнения цикла по "x"
      
      for (int x=0; x<w2b; x++){ // w2b1=w-b-b;
        
        // сумма серого папавшая в площадь квадрата S*S.
        // I(x,y)=s(x2,y2)-s(x1,y2)-s(x2,y1)+s(x1,x1)
        // sum = integralImg[y*w + x - s2*w - s2] - integralImg[y*w + x - s2*w + s2]
        // - integralImg[y*w + x + s2*w - s2] +  integralImg[y*w + x + s2*w + s2];
        sum =count255 - (*d1 - *d2 - *d3 + *d4);
        
        //////*d1=0;  *d2=0;  *d3=0;  *d4=0; // TECT на визуализацию области покрытия скользящим квадратом. Нужно переназначить указатели.
        //////*d0=0; // TECT на визуализацию области попиксельной обработки. На входе ставим memset(bytes_data, 255, w_h);
        //////*d0=1*sum/count; // *p0=sum; // TECT на визуализацию среднего по области попиксельной обработки.
        
        /// Бинаризация ///
        // Если яркость (0-255) пиксела больше средней по площади яркости скользящего квадрата S*S, то считаем пиксель ЧЕРНЫМ белым.
        /// if (bytes_data[index]*count128 > sum*Tr)  {bytes_data[index]=255;} else { bytes_data[index]=0; } где index=y*w + x; (без учета border)
        // Разные функции бинаризации. Все алгоритмы в итоге бинаризуют одинакого.
        if ( *d0*count128 > sum*Tr )  { *d0=255; }  else { *d0=0; }         // binarisationF
        /// if ( *d0*count > ((sum*Tr)>>7) )  { *d0=255; }  else { *d0=9; } // binarisation
        
        d0++;  d1++;   d2++;   d3++;   d4++; // d0 = bytes_data + y*w + x; // d1 = integralImg + y*w + x;
        
      } // x
      
      p0+=w;  p1+=w;  p2+=w;  p3+=w;  p4+=w; // p0 = bytes_data + y*w; // p1 = integralImg + y*w;
      
    }  // y
    //*/
    
    
    // освобождение массива integralImg.
    if ( integralImg !=NULL ) free(integralImg);
    
    if(GrafT) { TIME_PRINT_ }
    
    //TECT
    /*
     int n=0; // binarisationF(96, 14) n=1859248 // binarisation(96, 3) n=1859248 // _Image2OCR/__Page_09___.png
     for (int x=0; x<w*h; x++){ if ( bytes_data[x]==0 ) n++;} // x
     cout<<"n="<<n<<endl;
     //*/
    
    // Оставлено для теста
    ///int S=BASE*35/10;  // S в 3,5 больше размера буквы или строки //////////
    ///int s2=S/2; // половина стороны суммирующего квадрата //////////
  }//_____________________________________________________________________________
  
  
  
  
  // НОВАЯ Гауссиан version бинаризации. // декабрь 2018
  
  //***********************Adaptive BinarisationG************************************
  // Функция преобразования серого массива в битовый массив (адаптивный порог).
  // Выполнена на основе функции binarisation(), тонкие перетяжки бинаризует хуже всех
  // и в 2-2,5 раза медленние базовой. Нет особых достоинств.
  // Самые подходящие параметры для этой функции binarisationF(98, 6)
  
  void  GBitmap::binarisationG(int Tr, int BASE) {
    //***********************Adaptive BinarisationG************************************
    
    
    // Функция binarisationG() и базовая функция binarisation() выполняют аналогичный задачи.
    // Отличия закдючаются в том что в binarisationG() для вычисления средней яркости в скользящей области
    // применяется не квадрат со сторанами "s*s", а Гауссиан c радиусом "s".
    // Применение Гауссиана эквивалентно четырем независимым проходам квадратом с усреднением яркости.
    // Функция с усреднением по Гауссиану позволяет использовать не большую область усреднения (BASE=2-6,Tr>92),
    // что позволяет более тщательно разбирать и бинаризовать слипающиеся узоры с низким разрешением.
    
    //  * Идея *
    // Tr - устанавливает порог как число процентов, от вычисленного адаптивного порога в виде значения
    // средней яркости по Гауссиану c радиусом "s". Если значение яркости текущего пикселя на Tr процентов ниже,
    // чем среднея яркость, то он установлевает текущий пиксел в черное, в противном случае в белое.
    // Обычно Tr=80-95, BASE=s=2-16.
    // Если Tr выбирать меньше - то получаются более тонкие линии (штрихи), Tr больше - более толстые линии.
    // Величину  радиуса Гауссиана "s" можно однозначно связать со средней высотой буквы или строки по всей странице.
    // binarisationG() приблизительно в 2-2,5 раза медленние базовой функция binarisation().
    // Быстродействие binarisationG() практически полностью определяется быстродействием
    // примененного внутри этой функции Гауссианом gaussianF().
    
    /// Горизонтальное размытие (blur) одномерным Гауссианом двухмерного массива данных (изображения). ///
    // прямоугольная весовая функция.
    // y(n)= y(n-1)+xn-x(n-2k-1)
    // треугольная весовая функция (применена в данном случае).
    // y(n)= -y(n-2)+2y(n-1)+x(n-2k-2)-2x(n-k-1)+xn
    
    if(Tr==0 || BASE==0)return;
    
    int w=ncolumns;     // ширина массива   IMAGE_WIDTH
    int h=nrows;        // высота массива   IMAGE_HEIGHT
    int w_h=w*h;        // размер массива   IMAGE_SIZE
    
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }.
    
    if (GrafT) {
      cout<<"Функция адаптивной бинаризации binarisationG()    BASE="<<BASE<<endl;
      cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h<<" пикселей"<<endl; }
    
    TIME_START // time=0.53 сек,  w=4064 h=2472,  _Image2OCR/__Page_09___.png
    
    invert(); ////////////////////////////////
    
    uchar *p0; // указатель на массив bytes_data
    uchar *bytes_data_1, *p1;
    uint sizeBuf=w_h+64; // размер массива с запасом
    // Массив для копии bytes_data.
    bytes_data_1=(uchar*)malloc(sizeBuf); // *p1
    //int b_data, b_data_1; // переменные соответствующих массивов.
    
    // копирование bytes_data в bytes_data_1
    memcpy(bytes_data_1, bytes_data, w_h);  // адрес буфера назначения, адрес источника, количество байт для копирования.
    
    // ограничения на процент от порога  Tr.
    if (Tr < 16) Tr = 16;   if (Tr > 99) Tr = 99;
    
    // Ограничения на размер скользящий области усреднения яркости страници.
    // Фактически повторяют ограничения на "радиус" Гауссиана в пикселях в функции gaussianF().
    if (BASE < 2) BASE = 2;   if (BASE > 64) BASE = 64;
    
    
    // вычисления средней яркости в скользящей области с помощью Гауссиана в массиве bytes_data.
    gaussianF(BASE); // свертка Гауссова фильтра и исходного изображения.
    
    
    // позволяет использовать сдвиг <<14 вместо деления в цикле бинаризация.
    ///Tr=(Tr<<14)/100 + 4;   // <<7   *128
    ///////      Tr=(Tr<<14)/100;        // <<14   *16384
    Tr=(100-Tr); // для нового алгоритма
    
    /// Бинаризация, perform thresholding. ///
    p0=bytes_data;   p1=bytes_data_1;
    for (int x=0; x<w_h; x++) {
      
      ///if ( bytes_data_1[x] > (Tr*bytes_data[x])>>7 )  { bytes_data_1[x]=255; }  else { bytes_data_1[x]=0; }
      //// if ( (*p1<<14) > *p0*Tr )  { *p0=255; }  else { *p0=0; } // основной старый алгоритм // <<14   *16384 // без разници
      //if ( *p1 > (Tr*(*p0))>>14 )  { *p0=255; }  else { *p0=0; } // >>14   /16384 // грубовато на малых BASE
      // белый 255       // черный 0
      if ( *p1 > *p0 + Tr )  { *p0=0; }  else { *p0=255; } // основной новый алгоритм с инверсией // + вх инверсия и Tr=(100-Tr)*count;
      // оба алгоритма в итоге бинаризуют одинакого
      
      p0++; p1++;
      
    } //x
    //cout<<endl;
    
    // освобождение массива bytes_data_1
    if ( bytes_data_1 !=NULL ) free(bytes_data_1);
    
    if(GrafT) { TIME_PRINT_ }
    
    
  }//__________________________________________________________
  
  
  
  
  // ГОТОВАЯ НОВАЯ fast version с большими вопросами. Примерно 2015г. Частично модифицированно 4 февраля 2019.
  
  //***********************Adaptive Threshold************************************
  // Функция преобразования серого массива в битовый массив (адаптивный порог)
  // Самые подходящие параметры для этой функции binarisationF(98, 3)
  
  // Авторы = "DerekBradley and GerhardRoth".
  // www.derekbradley.ca / AdaptiveThresholding / index.html.
  
  void  GBitmap::binarisation(int Tr, int BASE) {
    //***********************Adaptive Threshold************************************
    
    // BASE средний размер буквы или строки по всей странице. Напрямер Tenjur BASE=46pix.
    // скользящия область S*S вычисления значения средней яркости  в 3,5
    // больше размера буквы или строки S=BASE*3.5
    
    // Tr - устанавливает порог как число процентов, от вычисленного
    // адаптивного порога в виде значения средней яркости по области S*S.
    // Если значение яркости текущего пикселя на Tr процентов ниже, чем в среднея
    // яркость по области S*S то он установлевается в черное,
    // в противном случае он установлевается в белое. Обычно Tr=80.
    // Tr меньше - более тонкие линии (штрихи), Tr больше - более толстые линии.
    
    // Для этой функции binarisation() максимальный размер обрабатываемого файла оставлен прежним:
    // - практический максимум обрабатываемого размера страници 9984*1848 pix.
    // - теоретический максимум обрабатываемого размера страници 3645*674 pix.
    
    if(Tr==0 || BASE==0)return;
    
    // Check arguments and init variables
    short w=ncolumns;   // ширина массива   IMAGE_WIDTH
    short h=nrows;      // высота массива   IMAGE_HEIGHT
    
    unsigned int* integralImg;
    //unsigned int *d1;
    unsigned char* input=bytes_data;
    unsigned char *d0, *p0;
    
    unsigned int sum=0;
    unsigned int count=0;
    int x, y, x1, y1, x2, y2;
    // вспомогательные переменные для увеличения быстродействия.
    unsigned int *p1, *p2;
    
    //cout_<<END<<"АdaptiveThreshold(), New version V0"<<endl;
    /// cout<<"Адаптивный порог binarisation()   Tr="<<Tr<<"  BASE="<<BASE<<endl;
    
    
    // ОБНУЛЕНИЕ border
    //variationBorder(255, 8);
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }.
    
    TIME_START  // time=0.225/0.235 сек,  w=4064 h=2472,  _Image2OCR/__Page_09___.png   //  time=0.297  w=2698 h= 4000
    
    
    integralImg = (unsigned int*)malloc(w*h*sizeof(unsigned int*));
    
    // выход в случае отсутствия свободной памяти запрашиваемого размера.
    if (integralImg==NULL) {DC("integralImg"); return;}
    
    // обнуление массива new_data.
    //memset(integralImg,0,w*h*sizeof(unsigned int*));
    
    
    // create the integral image.
    // интегральная яркость integrated brightness. 4 февраля 2019. Быстрее в 1,5 раза
    
    //*
    // Обработка нулевой строки (первой по счету).
    sum=0;
    p0 = bytes_data;
    p1 = integralImg;
    for (x=0; x<w; x++)
    {
      // подсчет сумм яркостей для обработки скользящего суммирующего квадрата S*S.
      sum+= *(p0 + x);    // sum+=bytes_data[x];
      *(p1 + x) = sum;    // integralImg[x]=sum;
    } //x
    
    // Обработка всех остальных строк.
    for (y=1; y<h; y++)
    {
      // reset this column sum
      sum=0;
      // вспомогательные переменные для увеличения быстродействия.
      p0+=w;  // p0 = bytes_data + y*w;
      p1+=w;  // p1 = integralImg + y*w;
      
      for (x=0; x<w; x++)
      {
        // подсчет сумм яркостей для обработки скользящего суммирующего квадрата S*S.
        sum+= *(p0 + x);                // sum+= bytes_data[index];     // index=y*w + x;
        *(p1+x) = *(p1+x-w) + sum;      // integralImg[index]=integralImg[index-w] + sum;
        
      } //x
    } //y
    //*/
    
    
    /*
     // интегральная яркость integrated brightness. Все что ниже примерно 2015г.
     
     for (y=0; y<h; y++)
     {
     // reset this column sum.
     sum = 0;
     // вспомогательные переменные для увеличения быстродействия.
     p0 = input + y*w;
     p1 = integralImg + y*w;
     
     for (x=0; x<w; x++)
     {
     d1 = p1 + x;             // d0 = (input + y*w + x);
     
     // подсчет сумм яркостей для обработки скользящего суммирующего квадрата S*S.
     sum += *(p0 + x);        // sum += input[index];
     
     if ( y==0 )              // d0=(input + index);
     *d1 = sum;           // integralImg[index] = sum;
     else
     *d1 = *(d1-w) + sum; // integralImg[index]=integralImg[index-1] + sum;
     
     } //x
     } //y
     //*/
    
    //TIME_PRINT_
    
    
    // ограничения на процент от порога  Tr.
    if (Tr < 16) Tr = 16;   if (Tr > 99) Tr = 99;
    //Tr = 98;
    // позволяет использовать сдвиг <<7 вместо деления в цикле perform thresholding.
    Tr=(Tr<<7)/100 + 1 ; //     // 80*128/100;   (80<<7)/100;
    
    // ограничения на размер буквы BASE в пикселях, где
    // BASE средний размер буквы или строки по всей странице, в Tenjur=46
    if (BASE < 4) BASE = 4;   if (BASE > 160) BASE = 160;
    int S=BASE*35/10;  // S в 3,5 больше размера буквы или строки  S=46 *3,5=160
    //S=6;
    int s2=S/2;
    
    // вспомогательные переменные, для увеличения быстродействия.
    int h_1=h-1;
    int w_1=w-1;
    int y2_y1;
    
    
    
    // perform thresholding.
    
    for (y=0; y<h; y++){
      
      // set the SxS region
      y1 = y - s2;  y2 = y + s2;
      
      // check the border
      if (y1 < 0)   y1 = 0;
      if (y2 > h_1) y2 = h_1;         //   if (y2 >=h) y2 = h-1;
      
      // вспомогательные переменные, для увеличения быстродействия.
      p0 = input + y*w;
      p1 = integralImg + y1*w;
      p2 = integralImg + y2*w;
      y2_y1 = y2 - y1;
      
      for (x=0; x<w; x++){
        
        // set the SxS region
        x1 = x - s2;  x2 = x + s2;
        
        // check the border
        if (x1 < 0)   x1 = 0;
        if (x2 > w_1) x2 = w_1;     //   if (x2 >=w) x2 = w-1;
        
        // площадь суммирующего квадрата S*S с учетом border.
        count = y2_y1*(x2-x1);      // count = countX*(y2-y1);
        
        // сумма серого папавшая в площадь квадрата S*S.
        // I(x,y)=s(x2,y2)-s(x1,y2)-s(x2,y1)+s(x1,x1)
        // sum = integralImg[y2*w + x2] - integralImg[y1*w + x2]
        //	    -integralImg[y2*w + x1] + integralImg[y1*w + x1];
        sum = *(p2 + x2) - *(p1 + x2) - *(p2 + x1) + *(p1 + x1);
        
        d0 = p0 + x;
        /// Бинаризация ///
        // если яркость (0-255) пиксела больше средней по площади
        // яркости скользящего квадрата S*S, то считаем пиксель белым.
        // if (input[index]*count > (sum*Tr)>>7)  {input[index]=255;}
        if ( *d0*count > ((sum*Tr)>>7) )  { *d0=255; }  // 255 белый
        else { *d0=0; }   //else { input[index]=0; }    //  /128
        
      } // x
      
    }  // y
    /**/
    
    // освобождение массива integralImg
    if ( integralImg !=NULL ) free(integralImg);
    
    if(GrafT) { TIME_PRINT_ }
    
    /*
     //TECT
     int n=0; // n=1859248 // (96, 3) // _Image2OCR/__Page_09___.png
     for (x=0; x<w*h; x++){ if ( bytes_data[x]==0 ) n++;} // x
     cout<<"n="<<n<<endl;
     */
  }//_____________________________________________________________________________
  
  
  // Функция быстрого преобразования серого массива в битовый массив по фиксированному порогу 128. 17 марта 2019.
  // Бинаризуем по 8 байт одновременно.
  void  GBitmap::binarisation64() {
    
    // 64р версия с досчетом последних байт.
    // Фиксированный порог задается сдвигом  >>7 (делением на 128) и не м.б. изменен.
    // Подходит для быстрой бинаризации массива после сжатия jpg, можно легко переписать на JavaScript.
    
    // Алгоритм быстрой бинаризации входного массива битмап по фиксированному порогу 128. //
    // Если записанное в байте число больше 128, то в старшем разряде обязательно находится единица.
    // Если записанное в байте число меньше 128, то в старшем разряде обязательно находится ноль.
    // Остается только выделить старший разряд маской 0x80=128 и получить уровни "0" или "128".
    // Результат делим на 128 и умножаем на 255 для получения стандартных уровней "0" или "255"
    // бинаризованного битмапа.
    // Все операции можно делать одновременно во всех 8х байтах 64х разрядного слова.
    
    
    int w_h=data_size;                          // размер массива   IMAGE_SIZE
    int w_h_64=w_h/sizeof(ulong);               // sizeof(ulong)=8
    ulong *bytes_data_64=(ulong*)bytes_data;    // приведение uchar bytes_data к типу ulong
    
    //*
    // Бинаризуем по 8 байт одновременно. Последний участок массива длинной от 0 до 8 байт не бинаризуется.
    for ( int x=0; x < w_h_64; x++ ) {
      bytes_data_64[x]=(bytes_data_64[x] & 0x8080808080808080)/128*255; // >>7 деление на 128
    } // x
    // Бинаризация последнего участка всего массива длинной от 0 до 8 байт. Можно и не делать.
    int wh_=w_h_64*sizeof(ulong);
    for (int x=wh_; x<w_h; x++){ bytes_data[x]=(bytes_data[x] & 0x80)/128*255; }
    //*/
    
    // Получили выходной бинаризованный битмап с уровнями:   0-черный    255-белый
    
    
    /*
     // отладка
     // Бинаризуем по 8 байт одновременно. Последний участок массива длинной от 0 до 8 байт не бинаризуется.
     for ( int x=0; x < w_h_64; x++ ) {
     bytes_data_64[x]=(bytes_data_64[x] & 0x8080808080808080)/128*255; // >>7 деление на 128
     //bytes_data_64[x]=((bytes_data_64[x]/128) & 0x101010101010101)*255; // >>7 деление на 128
     ///bytes_data_64[x]=(bytes_data_64[x] & 0x4040404040404040)/64*255; // >>7 деление на 128//
     } // x
     // Бинаризация последнего участка всего массива длинной от 0 до 8 байт. Можно и не делать.
     int wh_=w_h_64*sizeof(ulong);
     for (int x=wh_; x<w_h; x++){ bytes_data[x]=(bytes_data[x] & 0x80)/128*255; }
     //for (int x=wh_; x<w_h; x++){ bytes_data[x]=((bytes_data[x]>>7) & 1)*255; }
     //*/
    
    //for (int x=w_h/2; x<w_h/2+100; x++){ cout<<"  b="<<(int)bytes_data[x]<<endl; }
    //for (int x=0; x<w_h; x++){ if(bytes_data[x]>112) bytes_data[x]=255;  else bytes_data[x]=0; }
    
  }//_____________________________________________________________________________
  
  
  
  // НЕ ГОТОВАЯ НОВАЯ НЕ fast version в работе //  декабрь 2018
  // нет хорошей идеи
  
  //***********************Adaptive Brightness************************************
  // функция коррекции освещённости предназначена для выравнивания неравномерностей освещённости
  // страници (адаптивный яркость). Выполнена на иснове функции binarisation().
  
  void  GBitmap::brightnessCor(int Wr, int BASE) {
    //***********************Adaptive Brightness************************************
    
    // Retinex Algorithm
    // BASE=S скользящия область S*S для вычисления значения средней яркости ().
    // Wr "коэффициент модуляции освещённости" - глубина изменения освещённости по всей исходной странице.
    
    // Размываеи исходное изображения с помощью скользящия область S*S.
    // Каждый пиксел исходного изображения умножаем на Wr, делим на величину размытого пикселя и получаем пиксел выходного изображения.
    // Отрабатываем ситуацию деления на ноль. Если текущий размытый пиксель равен нулю, то исходный пиксель оставляем без изменений.
    // Этот алгоритм можно применить несколько раз с разными областями усредения S*S, на практике обычно n=3.
    // Величину скользящий область S*S можно связать со средним размером буквы или строки по всей странице. Напрямер  .
    
    
    if(Wr==0 || BASE==0)return;
    
    int w=ncolumns;     // ширина массива   IMAGE_WIDTH
    int h=nrows;        // высота массива   IMAGE_HEIGHT
    int w_h=w*h;        // размер массива   IMAGE_SIZE
    int x;
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
    if (GrafT) {
      cout<<"Функция коррекции освещённости brightnessCor()    BASE="<<BASE<<endl;
      cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h<<" пикселей"<<endl; }
    
    TIME_START
    
    //uchar *p0; // указатель на массив bytes_data
    uchar *bytes_data_1; // *p1
    uint sizeBuf=w_h+64; // размер массива с запасом
    // Массив для копии bytes_data.
    bytes_data_1=(uchar*)malloc(sizeBuf); // *p1
    int b_data, b_data_1; // переменные соответствующих массивов.
    
    
    // ограничения на процент от порога  Wr.
    if (Wr < 16) Wr = 16;   if (Wr > 99) Wr = 99;
    
    // Ограничения на размер скользящий области усреднения яркости страници.
    // Фактически повторяют ограничения на "радиус" Гауссиана в пикселях в функции gaussianF().
    if (BASE < 2) BASE = 2;   if (BASE > 64) BASE = 64;
    
    // Инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный.
    invert();
    
    /*
     // Инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный.
     // Для реальной картинки полученной при открытии файла необходимо инверсия.
     ///for ( x=0; x < w_h; x++ ){ bytes_data[x]=~bytes_data[x]; }
     int w_h_64=w_h/sizeof(ulong);  // sizeof(ulong)=8
     ulong *bytes_data_64=(ulong*)bytes_data;    // приведение к ulong
     // Инвертируем одновременно по 8 байт. Последний участок массива длинной от 0 до 8 бит не инвертируется.
     // Последний участок массива длинной s+s в дальнейшем все равно будет обнулятся.
     for ( x=0; x < w_h_64; x++ ) { bytes_data_64[x]=~bytes_data_64[x]; }
     //*/
    
    
    // копирование bytes_data в bytes_data_1
    memcpy(bytes_data_1, bytes_data, w_h);  // адрес буфера назначения, адрес источника, количество байт для копирования.
    
    
    int d=3;
    /*
     // Применить функцию detectContour
     // позволяет получать контурное изображение по x прямо по исходному изображению, без бинаризации.
     for (x=0; x<w_h-d; x++) {
     b_data=(abs(bytes_data[x] - bytes_data[x+d]))*2;
     if ( b_data > 255 )  { b_data=255; }
     bytes_data[x]=b_data;
     
     //if ( x > (w_h/2+50-8*w) && x < (w_h/2+64-8*w) ) {
     //    //cout<<"sum/count="<<sum/count<<endl;
     //    cout<<"bytes_data[x]="<<b_data;  cout<<"     bytes_data_1[x]="<<(ushort)((uchar)(bytes_data_1[x]))<<endl;
     //    bytes_data_1[x]=0;
     //}
     
     } //x
     //*/
    
    //Wr=96;
    BASE=48; //  Tr=89  s=8  ////////////
    
    //TIME_PRINT_
    
    // вычисления средней яркости в скользящей области с помощью Гауссиана в массиве bytes_data.
    gaussianF(BASE); // свертка Гауссова фильтра и исходного изображения bytes_data.
    
    int mean=0;
    int max=0;
    int dlt=0; int n=0; int mean_dlt=0;
    int min=1<<30;
    int min_dlt=1<<30;
    for (x=w*64; x<w_h-w*64; x++) { //x<w_h-d;
      
      b_data=bytes_data[x];
      b_data_1=bytes_data_1[x];
      dlt=b_data_1-b_data;
      
      
      if ( b_data>max ) max=b_data;
      if ( b_data<min ) min=b_data;
      //if ( b_data_1>max ) max=b_data_1;
      //if ( b_data_1<min ) min=b_data_1;
      if ( dlt<min_dlt ) min_dlt=dlt;
      
      mean+=b_data;
      if ( dlt<0 ) { mean_dlt+=dlt; n++; }
      
      //if ( x > (w_h/2+50-8*w-64) && x < (w_h/2+64-8*w+64) ) {
      if ( x > (w_h/2+50-8*w) && x < (w_h/2+64-8*w) ) {
        //cout<<"sum/count="<<sum/count<<endl;
        cout<<"x%w="<<x%w<<"  bytes_data[x]="<<b_data;  cout<<"     bytes_data_1[x]="<<b_data_1<<endl;
        //               bytes_data_1[x]=0;
      }
    } //x
    
    
    mean_dlt/=n;
    mean/=w_h;
    
    cout<<endl;
    cout<<"   min="<<min<<"   mean_dlt="<<mean_dlt<<"   min_dlt="<<min_dlt<<"   max="<<max<<"   mean="<<mean<<endl;
    cout<<"   dlt="<<dlt<<endl;
    
    // деление, светлое делает темнее.
    //int mid_Brig=127; // является параметром смещения.
    //int gain=3; // 51 - это коэффициент масштабирования (усиления)
    for (x=0; x<w_h-1; x++) {
      
      b_data_1=bytes_data_1[x];
      // b_data=2*abs(bytes_data[x] - mid_Brig);
      b_data=1*bytes_data[x]/1;
      if ( b_data < 1 )  { b_data=1; }
      //if ( b_data < amp )  { b_data=amp; }
      ///b_data=(((1024*gain*b_data_1)/(1+b_data))/1024 + 96)*1.5;
      ///////b_data=(((256*gain*b_data_1)/(b_data))/256)*1.0;     // / // -min и *max в место ограничений по 255 и 0
      ///////b_data=(int)sqrt((float)(1*gain*b_data_1)*(b_data));        // * // -min и *max в место ограничений по 255 и 0   /(128*32)
      b_data=(int)15*sqrtf((b_data_1-b_data + 64)*1.6);        // - //  + mean // -b_data + mean/8 // (b_data_1-b_data )*2.2);
      
      if ( b_data > 255 )  { b_data=255; }
      if ( b_data < 0 )  { b_data=0; }
      //////bytes_data[x]=~b_data;//////
      bytes_data[x]=b_data;
      
    } //x
    //min=n1; nMax=n2;
    //if(min>nMax) {min=n2; nMax=n1;}
    
    for (x=0; x<w_h-d; x++) {
      if ( x > (w_h/2+50-8*w) && x < (w_h/2+64-8*w) ) {
        //if ( x > (w_h/2+50-8*w-64) && x < (w_h/2+64-8*w+64) ) {
        b_data=bytes_data[x];
        b_data_1=bytes_data_1[x];
        //cout<<"sum/count="<<sum/count<<endl;
        cout<<"x%w="<<x%w<<"  bytes_data[x]="<<b_data;  cout<<"     bytes_data_1[x]="<<b_data_1<<endl;
        bytes_data[x]=255; ////////
      }
      
      bytes_data[x]=~bytes_data[x];
    } //x
    cout<<endl;
    
    /**/
    
    // освобождение массива bytes_data_1
    if ( bytes_data_1 !=NULL ) free(bytes_data_1);
    
    
    if(GrafT) { TIME_PRINT_ }
    
    ///-------------
    
    /*
     // abs
     int xx=-255;
     int s = xx >> 31; int dl= (xx ^ s) - s;
     cout<<"dl="<<dl<<endl;
     */
    
    /*
     x=32;
     int max=0;
     if ( x>max ) max=x;
     
     int min=1<<30;
     if ( x<min ) min=x;
     
     //cout<<"   x="<<x<<"   min="<<min<<"   max="<<max<<endl;
     */
    
  }//_____________________________________________________________________________
  
  
  
  
} // namespace ocr
