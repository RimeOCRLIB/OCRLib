//  Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .


//13 11 2010
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

//*****************************angle recognition********************************

// Функция определения угла наклона текста с помощью дискретного быстрого
// преобразования Радона (аналог GBitsetRotation.h).
// Заменены массивы на malloc. 7 марта 2019

// ИСТОЧНИКИ
// Программная реализация алгоритма Deskew
// http://www.djvu-soft.narod.ru/bookscanlib/008.htm
// и его прототип  http://pagetools.sourceforge.net/

#include "GBitmap.h"
namespace ocr{
  
  
  
  //_____________________________________________________________________________
  
  // Функция определения угла наклона текста с помощью быстрого преобразования Радона.
  // Выполняет адаптивную бинаризацию binarisationF и затем запускает функцию detectPageAngle.
  
  float GBitmap::detectPageAngleB(int maxAngle, int Tr, int BASE) {
    
    // Особенности применения преобразования Радона. //
    
    // Перед применением нельзя использовать функцию создание бордюра, например variationBorder.
    // При наличии фона по краям текста может получится контрастная рамка, которая ухудшает
    // точность определения угла наклона текста или даже может сделать его не возможным.
    // Преобразование Радона очень чувствительно к прямым линиям.
    
    // Чем больше максимально возможный определяемый угол maxAngle, тем ниже точность определения
    // угла поворота текста и ниже быстродействие.
    // maxAngle=7gr  g=8  t=0.125sec;     maxAngle=14gr  g=4  t=0.29sec;      maxAngle=26gr  g=2  t=0.8sec.
    // На 7 градусах на технически качественных текстах уже заменна не точность определения угла.
    
    // Применение функции optimizationW(g) для уменьшения горизонтального размера исходной картинки в "g" раз
    // не привело к улучшению быстродействия ядра функции Радона. Пока ремачим.
    
    
    if(abs(maxAngle)<1) return 0;
    
    ///maxAngle=-maxAngle; // ТЕСТ
    
    // Если максимально возможный определяемый угол наклона текста "maxAngle" положительный, то
    // функция выполняется с сохранением исходной картинки. Если параметр отрицательный, то функция
    // выполняется без сохранения исходной картинки. И знак параметра "maxAngle" меняется на положительный.
    int copyArray=1;
    if(maxAngle<0) { copyArray=0; maxAngle=-maxAngle; }
    //copyArray=0 сохраняем исходную серую картинку, =1 сохраняем бинаризованную картинку.
    
    // Ограничение максимально возможного определяемого угла в градусах.
    if(maxAngle<2) maxAngle=2;      // g=28;
    if(maxAngle>45) maxAngle=45;    // g=1;
    
    int GrafT=0;    // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
    if (GrafT) { cout<<"Функции определения угла наклона текста с расширеным динамическим диапазоном яркостей  maxAngle="<<maxAngle<<endl;
      cout<<"ncolumns="<<ncolumns<<",  nrows="<<nrows<<"    columns()="<<columns()<<"    rows()="<<rows()<<endl;}
    
    TIME_START
    
    int g=8; // вычисляемый параметр "g" это сумма пикселей по горизонтальной уменьшающая массив bytes_data_1 в "g" раз.
    // далее "g" модифицируется.
    float alpha; // угол наклона текста.
    float maxAngleF=(float)maxAngle;
    
    /*/
     // Определение по параметру "g" максимально возможного определяемого угла наклона текста "maxAngleF".
     maxAngleF = 57.29747*atan(1.0/g);
     maxAngleF = ((float)((int)(maxAngleF*10.0)))/10.0; // ограничение количества знаков после запятой, 10 это 1 знак.
     cout<<"g="<<g<<",  maxAngleF="<<maxAngleF<<endl;
     //*/
    // Определение по максимально возможному определяемый углу наклона текста "maxAngle" параметра "g".
    ///maxAngleF=2.0; // ТЕСТ
    g=(int)(1.0/tan(maxAngleF/57.29747));
    if (GrafT) cout<<"maxAngleF="<<maxAngleF<<",  g="<<g<<endl;
    
    
    // Автоопределение наличие серого или черно-белого в битмапе. // time=0.006
    int graduation=DetectGradations();
    // graduation=1; в битмапе встречается серое и надо применить адаптивный порог, graduation=0; битмап уже бинаризован.
    ////graduation=1; // ТЕСТ
    if (GrafT) {
      if (graduation==1) cout<<"Автоопределение числа градаций. Битмап уже серый graduation="<<graduation<<endl;
      else cout<<"Автоопределение числа градаций. Черно-белый битмап graduation="<<graduation<<endl;
    }
    
    
    //*
    // Выполнение адаптивной бинаризации с сохранением исходной картинки.
    if (copyArray>0) {
      
      // входной массив серый, выходной ч.б., 0-черный 255-белый.
      ///uchar bytes_data;         // глобальный массив, исходник.
      
      // Массив для копии bytes_data.
      int w_h=columns()*rows();
      uchar *bytes_data_1=(uchar*)malloc(w_h);
      
      // Сохранение исходной картинки bytes_data перед ее бинаризацией.
      memcpy(bytes_data_1, bytes_data, w_h);
      // адрес буфера назначения, адрес источника, количество байт для копирования.
      
      // Если битмап серый необходимо применить адаптивный порог.
      if (graduation==1) {
        // Вызов функции адаптивной бинаризации для расширения динамического диапазона яркостей функции detectPageAngle.
        // Эта бинаризация используется только для определения угла наклона текста.
        binarisationF(Tr-3, BASE); // Tr-2 дает чуть менее качественную бинаризацию с мелких деталях, за то меньше фонового шума.
        if (GrafT) cout<<"Адаптивная функция бинаризации binarisationF для функции detectPageAngle. Tr="<<Tr<<", BASE="<<BASE<<endl;
      }
      
      // Функция выполняет уменьшение горизонтального размера исходной картинки в "g" раз.
      ///optimizationW(g); //////////     //return 0;
      
      // Функция определения угла наклона текста с помощью быстрого преобразования Радона.
      alpha=detectPageAngle(g); //// g=1;
      
      // Восстановление bytes_data. Возвращение исходной, не бинаризованной картинки в bytes_data.
      //memcpy(bytes_data, bytes_data_1, w_h);
      
      // освобождение массива bytes_data
      if ( bytes_data !=NULL ) free(bytes_data);
      
      // Меняем ссылку bytes_data на bytes_data_1. Возвращение исходной, не бинаризованной картинки в bytes_data.
      bytes_data=bytes_data_1;
      
      // освобождение массива bytes_data_1
      //if ( bytes_data_1 !=NULL ) free(bytes_data_1);
      
      // Освобождение исходного массива bytes_data
      ///free(bytes_data);
      // Получение ссылки на место в памяти (на массив) где находится bytes_data_1 с выходным уменьшиным изображением.
      ///bytes_data=bytes_data_1;
      // Замена исходных параметров на новые.
      data_size=ncolumns * nrows;
      bytes_per_row=ncolumns;        // количество байтов в строке
      
    }
    //*
    // Выполнение адаптивной бинаризации без сохранения исходной картинки.
    else {
      // Если битмап серый необходимо применить адаптивный порог.
      if (graduation==1) {
        // Вызов функции адаптивной бинаризации для расширения динамического диапазона яркостей функции detectPageAngle.
        // Эта бинаризация используется только для определения угла наклона текста.
        binarisationF(Tr-3, BASE); // Tr-2 дает чуть менее качественную бинаризацию с мелких деталях, за то меньше фонового шума.
        if (GrafT) {cout<<"Адаптивная функция бинаризации binarisationF для функции detectPageAngle.  Tr="<<Tr<<", BASE="<<BASE<<endl;
          cout<<"исходная картинка в этой функции НЕ сохранена, бинаризованная картинка используется для выделения строк. g="<<g<<endl;}
      }
      // Функция выполняет уменьшение горизонтального размера исходной картинки в "g" раз.
      ///optimizationW(g); //////////
      // если битмап бинаризован, просто вычисляем угол наклона текста с помощью быстрого преобразования Радона.
      alpha=detectPageAngle(g); //// g=1
    }
    //*/
    
    ///alpha=alpha/g; //////////
    
    if(GrafT) { TIME_PRINT_ }
    
    // возвращение полученного угла наклона текста.
    return alpha;
    
  }//_____________________________________________________________________________
  
  
  
  // Функция отимизация исходного массива bytes_data для определения угла наклона текста.
  // Выполняет уменьшение горизонтального размера исходной картинки в "g" раз. 4 апреля 2019 г.
  
  void GBitmap::optimizationW( int g ) {
    
    // Выполняется после применения функции binarisationF(Tr-3, BASE)
    // Уменьшение горизонтального размера исходной картинки выполняется с
    // усреднением "g" пикселей и последующей простой пороговой бинаризацией.
    
    // Применение функции optimizationW(g) для уменьшения горизонтального размера исходной картинки в "g" раз
    // не приводит к улучшению быстродействия ядра функции Радона. Поскольку основной цикл определяющий
    // быстродействие преобразование Радона обладает размерностью "w2" обратнопропорциональной "g"
    // Ремачим. Правда в цикле увеличение шага: step*=2;
    
    if(g==0) return;
    
    int h=nrows;        // высота массива   IMAGE_HEIGHT.
    int w=ncolumns;     // ширина массива   IMAGE_WIDTH.
    int w_h=w*h;        // размер массива   IMAGE_SIZE.
    int w_g=w/g;        // размер массива уменьшенный в "g" раз по горизонтали.
    
    
    
    int GrafT=0;    // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
    if (GrafT) { cout<<"Функции уменьшения размера исходной картинки для измерения угола наклона текста,  g="<<g<<endl;
      cout<<"  w="<<w<<" h="<<h<<" w_h="<<w_h<<" g="<<g<<endl;}
    
    //g=8;
    
    // Массив для уменьшенной копии bytes_data.
    uchar *bytes_data_1=(uchar*)malloc(w*h/g);
    
    // указатели на массивы.
    uchar *p0=bytes_data; //глобальный массив.
    uchar *d0;
    uchar *p1=bytes_data_1;
    uchar *d1;
    
    uint  Ps128=255*g-128;
    int n, sum;
    int d=0;
    ///int max=0;      // ТЕСТ
    ///int min=1<<30;  // ТЕСТ
    
    
    //*
    
    for(int y=0; y < h; y++) {
      
      d1=p1;  // сохраняем для выполнения цикла по "x"
      d=0;
      for(int x=0; x < w_g; x++) { // w_g=w/g;
        
        //for(n=0; n< g; n++) { sum+=*(n + d + p0); int v=n + d + y*w;   if (v>max)max=v; if (v<min)min=v; }  y < min_B  && (p0-bytes_data)<w_h;
        
        sum=0;
        d0=p0;  // сохраняем для выполнения цикла по "n"
        
        d0+=d;         for(n=0; n<g; n++) { sum+=*(d0 + n); }    // sum+=*(n + d + p0);
        
        // После суммирования "g" пикселей с инверсией, получились бинаризованные и сжатые по горизонтали серые буквы на черном фоне.
        ///if(sum<Ps128) *(bytes_data_1 + y*w/g + x)=0;  else *(bytes_data_1 + y*w/g + x)=255;  // if(sum<Ps128) p1[h*x + y]=255;  else p1[h*x + y]=0;
        if(sum<Ps128) *d1=0;  else *d1=255;  // if(sum<Ps128) p1[h*x + y]=255;  else p1[h*x + y]=0;
        
        d+=g;   // прыжок по оси "x" через "g"   // d=x*g;
        d1++;   // указатель на выходной массив  // bytes_data_1[y*w + x]
        //ulong v=(d1-bytes_data_1);  if (v>max)max=v; if (v<min)min=v;  // ТЕСТ
        
      } // x
      p0+=w;      // p0 = bytes_data + y*w;
      p1+=w_g;    // p1 = bytes_data_1 + y*w_g;
    } // y
    
    // Получили уменьшеный по горизонтали в "g" раз массив bytes_data_1, где каждый pix это сумма по горизонтали "g" pix исходного массива bytes_data.
    
    ///cout<<"  min="<<min<<" max="<<max<<" w_h/g="<<w_h/g<<" w_h="<<w_h<<endl; // ТЕСТ
    
    //*
    // Освобождение исходного массива bytes_data
    free(bytes_data);
    // Получение ссылки на место в памяти (на массив) где находится bytes_data_1 с выходным уменьшиным изображением.
    bytes_data=bytes_data_1;
    // Замена исходных параметров на новые.
    ncolumns=w_g;
    nrows=h;
    data_size=h*w/g;
    bytes_per_row=w_g;        // количество байтов в строке
    //*/
    //cout<<"  +nrows="<<nrows<<"  ncolumns="<<ncolumns<<endl;
    
  }//_____________________________________________________________________________
  
  
  // Функция определения угла наклона текста с помощью быстрого преобразования Радона.
  float GBitmap::detectPageAngle(int g) {
    
    // Особенности применения преобразования Радона. //
    
    // Перед применением нельзя использовать функцию создание бордюра, например variationBorder.
    // При наличии фона по краям текста может получится контрастная рамка, которая ухудшает
    // точность определения угла наклона текста или даже может сделать его не возможным.
    // Преобразование Радона очень чувствительно к прямым линиям.
    
    // Параметр "g" это сумма пикселей по горизонтальной уменьшающея массив bytes_data_1 в "g" раз.
    // Параметр g задает максимально возможный определяемый угол наклона текста,
    // Чем g меньше тем больше максимально возможный определяемый угол maxAlpha=arctg(1/g).
    // По умолчанию g=8, с увеличением максимального угола наклона текста,
    // пропорционально падает быстродействие t:
    // g=8 angle<7gr t=0.125sec;   g=4 angle<14gr t=0.29sec;   g=2 angle<26gr t=0.8sec.
    // g=24 angle<14gr t=0.125sec, но точность в два раза ниже чем g=4.
    // Геометрический смысл параметра g это сумма пикселей по горизонтальной прямоугольной
    // области размером:
    // 1 на 8 пикселей,  или 1 на 4,  или 1 на 2,  или 1 на 1,  или 2 на 4 (g=24).
    
    // Похоже надо выравнивать ширину массива по 32.
    // "FreeImage_GetPitch - возвращает ширину растрового изображения в байтах, округленную
    // до следующей 32-битной границы, также известной как шаг или шаг или сканирование".
    
    float alpha=0;
    
    if(g==0) return 0; // при g=0 функция вешается.
    
    // Ограничения на "g" в пикселях, g от 1 до 32.
    if ( g<1 ) g=1;   if ( g>28 ) g=28;
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    if (GrafT) { cout<<"Функция определения угла наклона текста  version V0    detectPageAngle(g)   g="<<g<<endl; }
    
    
    unsigned int h=nrows;      // высота массива   IMAGE_HEIGHT
    unsigned int w=ncolumns;   // ширина массива   IMAGE_WIDTH
    ///cout<<"  nrows="<<nrows<<"  ncolumns="<<ncolumns<<endl;
    
    
    unsigned int w_g=w/g;      // w_8=w/8;    >>3 деление на 8  // w_8=(w+7)/8;  //***
    unsigned int i;
    
    TIME_START  //  time=0.516  w=2698 h=4000
    
    // Вычисление w2 как ближайшей степени двойки w, причем w2 >= w,
    // например если w=1035 то w2=2048.
    unsigned int w2=1;
    while( w2<w_g ){ w2<<=1; }  // <<1 умножение на 2
    
    // Size of sharpness table
    // Размер массива для суммы квадратов конечных разностей.
    unsigned int ssize=2*w2-1;
    // Создание массива для суммы квадратов конечных разностей.
    /// unsigned int *sharpness=new unsigned int(ssize);
    uint *sharpness = (uint*)malloc(ssize*sizeof(uint*));
    //cout<<"sharpness="<<sizeof(sharpness)<<endl;
    //cout<<"ssize*sizeof(uint*)="<<ssize*sizeof(uint*)<<endl; // ПРЕВЫШЕНИЕ В 4 РАЗА
    
    // Вызовы функции быстрого преобразования Радона для определения угла alpha.
    toolsRadon( 1, sharpness, w2, g);
    toolsRadon(-1, sharpness, w2, g);
    
    
    // Вычисляем максимум суммы квадратов разностей vmax и индекс imax,
    // соответствующий этому максимому. Индекс определяет угл наклона текста.
    ///cout_<<endl;
    unsigned int s, imax=0, vmax=0;
    double sum=0.;  // unsigned int sum=0;
    for(i=0; i<ssize; i++) {
      s=sharpness[i];
      if( s>vmax ) { imax=i;  vmax=s; }
      
      sum+=s;
      /// cout_<<" "<<imax;  // cout_<<" "<<vmax/1000;
    } //i
    ///cout_<<END<<endl;
    
    // Освобождение массива sharpness.
    // delete sharpness;
    if ( sharpness !=NULL ) free(sharpness);
    
    // Определение нулевого угла наклона текста. // Heuristics !!!
    //if( vmax<=((int)(3*sum/h)) ) { cout_<<END<<"angle=0; no detect"<<endl; return 0; }
    if( vmax<=(unsigned int)(3*sum/h) ) { if(GrafT)cout<<"angle=0; no detect"<<endl; return 0; }
    
    // Определение произвольного угла наклона текста alpha, в диапазоне +-7 градусов.
    // int iskew = (int)imax - int(w2) + 1;
    int iskew = imax - w2 + 1;
    
    
    // Convert radians to degrees and change the sign:
    // Вычисляем арктангенс, преобразуем радианы в градусы и изменяем знак:
    float F=iskew;
    /// float alpha = -57.29747*atan(F/(8*w2));
    alpha = -57.29747*atan(F/(g*w2));                          // double  //***
    /**/
    
    if (GrafT) { cout<<"возвращает угол наклона текста    float alpha="<<alpha<<endl; }
    
    /*
     cout<<endl<<"w="<<w<<"  w2="<<w2<<"  h="<<h<<"  w*h="<<w*h<<endl;
     cout<<"imax="<<imax<<"   vmax="<<vmax<<"   sum="<<(int)sum
     <<"   3*sum/h="<<((int)(3*sum/h))<<endl;
     cout<<"(int)imax="<<(int)imax<<"  int(w2)="<<int(w2)<<endl;
     cout<<"iskew="<<iskew<<endl<<"alpha="<<alpha<<endl<<endl;
     */
    
    if(GrafT) { TIME_PRINT_ }
    
    return alpha;
    
  }//_____________________________________________________________________________
  
  
  // Функция быстрого преобразования Радона
  
  void GBitmap::toolsRadon( int sign,
                           uint *sharpness,
                           uint w2,
                           int g
                           ) {
    
    // Преобразование Радона имеет простой геометрический смысл — это интеграл от функции вдоль прямой...
    // https://ru.wikipedia.org/wiki/Преобразование_Радона
    
    // Говоря словами самоого Радона - нахождение функции точки на плоскости по значением его интегралов вдоль прямых... // стр 26
    // https://www.researchgate.net/profile/Elina_Shishkina3/publication/320181049_Preobrazovanie_Radona_na_ploskosti/links/59d31e07aca2721f436c2365/Preobrazovanie-Radona-na-ploskosti.pdf
    
    // Важнейшее свойство преобразования Радона – обратимость, т.е. возможность восстанавливать исходную функцию по ее преобразованию Радона. // стр 28
    // http://elar.urfu.ru/bitstream/10995/29000/1/978-5-7996-1252-8_2014.pdf
    
    
    // TIME_START  // time=0.078*2   w=2698 h= 4000
    
    uint w=ncolumns;   // ширина массива   IMAGE_WIDTH
    uint h=nrows;      // высота массива   IMAGE_HEIGHT
    
    //cout<<"h="<<h<<endl; cout<<"g="<<g<<endl; //if (g==24) {h=h/2; g=4;}     //***
    
    unsigned int w_g=w/g;       // w_8=w/8;  //***
    unsigned int x, y;
    
    uchar *p0=bytes_data;       // глобальный массив.
    
    unsigned int s=h*w2;
    
    // Объявление массивов p1 и p2.
    ushort *p1 = (ushort*)calloc(s, sizeof(ushort)); // с обнулением массива p1.
    ushort *p2 = (ushort*)malloc(s*sizeof(ushort*));
    
    // обнуление массива p1.
    ///memset(p1, 0, s*sizeof(ushort));
    
    unsigned int  n, d, sum;
    //uint Psum=255*g;
    uint Ps128=255*g-128; // задание порога для простой бинаризации после усреднения по "g". //uint  Psum=255*g;
    
    //*
    // cout<<"  g="<<g<<endl;
    
    // Универсальный; 1*8, 1*4, 1*2, 1*1 // однако time=0.1*2  при общем time=0.5.
    // С помощью этого алгоритма под управлением параметра sign=+/-1, создаются две транспонированные картинки повернутые
    // на противоположные углы, по которым в дальнейшем удобно считать разностные углы.
    // Суммарное число тактов цикла на единицу меньше длинны массива, поэтому особо оптимизировать не чего.
    for(y=0; y < h; y++) {
      p0 = bytes_data + y*w;
      for(x=0; x < w_g; x++) { // w_g=w/g;
        // обратная и прямая выборка из массива bytes_data и суммирование g (наример восьми) последовательных отсчетов.
        d=x*g; sum=0;
        if(sign>0) { for(n=0; n< g; n++) { sum+=*(w-1 - n - d + p0); } }
        else       { for(n=0; n< g; n++) { sum+=*(      n + d + p0); } }
        
        // первый вариант исходный: преобразование серого (от 255 до 0) в усредненное серое с динамическим
        // диапазоном от 0 до 8 ?, инверсия и записью в транспонированный массив p1.
        ///           p1[h*x + y]=(Psum-sum)/255;  // исходный. Не явная бинаризация и инверсия.
        // Не понятно что с динамическим диапазоном. Непонятно почему но этот вариант работает лучше.
        
        // Простая бинаризация с инверсией и запись в транспонированный массив p1.
        // После суммирования "g" пикселей с инверсией, получились сжатые по горизонтали серые буквы на черном фоне.
        ///if((Psum-sum)>128) p1[h*x + y]=255;  else p1[h*x + y]=0;
        if(sum<Ps128) p1[h*x + y]=1;  else p1[h*x + y]=0; // 20 марта 2019
        // 23 апреля 2019 // 255 на больших углах работает плохо, 1 отлично работает на всех углах.
        // cout<<"   p1="<<(ushort)p1[h*x + y]<<endl;
        
      } // x
    } // y
    //*/
    // Получили уменьшеный по горизонтали в "g" раз массив bytes_data_1, где каждый pix это сумма по горизонтали "g" pix исходного
    // массива bytes_data. Пустое место заполнено нулями (черное), т.е. сжатые по горизонтали белые буквы на черном фоне.
    
    // Здесь м.б. уменьшить размер массива в "g" раз, только надо понять как изменить w и h. Существенно улучшив быстродействие.
    
    /* //////////
     // Частный случай g=1; Необходим при сжатии входной картинки в "g" раз по горизонтали во внешней функции optimizationW(g).
     // С помощью этого алгоритма под управлением параметра sign=+/-1, создаются две транспонированные картинки повернутые
     // на противоположные углы, по которым в дальнейшем удобно считать разностные углы.  4 апреля 2019
     for(y=0; y < h; y++) {
     p0 = bytes_data + y*w;
     for(x=0; x < w; x++) {
     // обратная и прямая выборка из массива bytes_data.
     if(sign>0)  p1[h*x + y]=255 - *(w-1 - x + p0);
     else        p1[h*x + y]=255 - *(      x + p0);
     ///if(sign>0)  sum=*(w-1 - x + p0);
     ///else        sum=*(      x + p0);
     // Простая бинаризация с инверсией и запись в транспонированный массив p1. // бинаризация НЕ НУЖНА
     // Получились сжатые по горизонтали серые буквы на черном фоне.
     ///if(sum<128) p1[h*x + y]=1;  else p1[h*x + y]=0; // 20 марта 2019 // Ps128=255*g-128;
     // 23 апреля 2019 // 255 на больших углах работает плохо, 1 отлично работает на всех углах.
     // cout<<"   p1="<<(ushort)p1[h*x + y]<<endl;
     } // x
     } // y
     //*/
    
    
    /*
     // Вьювер на транспонированный массив, иначе понять ничего не возможно.
     // Такое же транспонирование как и в основном алгоритме.
     int h_=w; int w_=h;
     for(y=0; y < h_; y++) {
     for(x=0; x < w_; x++) {
     bytes_data[h_*x + y]=p1[y*w_ + x];
     } // x
     } // y
     //*/
    
    
    //TIME_START
    // Iterate
    // Быстрое преобразование Радона.
    unsigned int i, j, m;
    unsigned short *s1, *s2, *t1, *t2;
    unsigned short *x1=p1, *x2=p2;  //
    unsigned short *aux;
    unsigned int step=1;
    
    while(1){
      for(i=0; i<w2; i+=2*step) {
        for(j=0; j<step; j++) {
          
          s1=x1+h*(i+j);
          s2=x1+h*(i+j+step);
          
          t1=x2+h*(i+2*j);
          t2=x2+h*(i+2*j+1);
          
          for(m=0; m<h; m++){
            t1[m]=s1[m];
            t2[m]=s1[m];
            if( m+j<h )   { t1[m]+=s2[m+j]; }
            if( m+j+1<h ) { t2[m]+=s2[m+j+1]; }
          } // m
        } // j
      } // i
      // Swap the tables:
      // Меняем местами столбци:
      aux=x1;                // unsigned short *aux=x1;
      x1=x2;
      x2=aux;
      // Increase the step:
      // Увеличение шага:
      step*=2;
      if(step>=w2) break;
    } // while(1)
    /**/
    //TIME_PRINT_
    
    //TIME_START
    // перевести на указатели без умножений, однако time=0.017*2  при общем time=0.5.
    // Now, compute the sum of squared finite differences:
    // Теперь, вычисляем сумму квадратов конечных разностей:
    uint acc;
    ushort *d0;                 // unsigned short int *d0; //unsigned short int *col;
    int diff;
    uint h_1=h-1;
    for(x=0; x < w2; x++){
      d0=x1 + h*x;  acc=0;
      for(y=0; y<h_1; y++){ // h_1=h-1;       // for(y=0; y+1< h; y++)
        diff=*(d0 + y) - *(d0 + y+1);       // {diff=(int)(d0[ir])-(int)(d0[ir+1]);}
        acc+=diff*diff;
      } // y
      sharpness[w2-1 + sign*x]=acc;
      ///		cout_<<" "<<acc;
    } // x
    ///cout_<<END<<endl;
    //TIME_PRINT_
    
    /*
     // Now, compute the sum of squared finite differences:
     for(ic=0; ic<w2; ic++){
     unsigned int acc=0;
     unsigned short int *col=x1+h*ic;
     for(ir=0; ir+1<h; ir++){
     int diff=(int)(col[ir])-(int)(col[ir+1]);
     acc+=diff*diff;
     }
     sharpness[w2-1+sign*ic]=acc;
     
     }
     */
    
    
    // Освобождение массивов p1, p2.
    ///delete p1;     delete p2;
    if ( p1 !=NULL ) free(p1);
    if ( p2 !=NULL ) free(p2);
    
    ///TIME_PRINT
    
    /*
     // вывод псевдографики w*h    белый 255
     for ( y=0;  y< h; y++ ) {
     //scl=bytes_data + y*w;
     for ( x=0; x < w; x++ ) {
     // cout_<<(short)bytes_data[y*w + x]<<"";
     if(bytes_data[y*(w)+x]>128) {cout_<<"1";} else{cout_<<".";}
     //if ((x)%(w/8)==0) cout_<<endl;
     }
     cout_<<endl;
     }
     cout_<<endl;
     */
    /*
     // вывод псевдографики  (w/8)*h  ++++
     for ( x=0; x < w_8; x++ ){
     for ( y=0;  y < h; y++ ){
     cout_<<(short)p1[x*h + y]<<"";
     // if(p1[x*h+y]>1) {cout_<<"1";} else{cout_<<".";}
     // if ((x)%(w/8)==0) cout_<<endl;     [y*(w)+x]
     }
     cout_<<endl;
     }
     cout_<<endl;
     */
    
    //cout_<<"w="<<w<<"  w_8="<<w_8<<"  w2="<<w2<<"  h="<<h<<"  s="<<s<<endl;
    
    /**/
  }//_____________________________________________________________________________
  
  
  //******************************************************************************
  
  // Отимизация исходного массива bytes_data для определения угла наклона текста. Полностью переписано 12 марта 2019 г
  // Отладочная функция с рабочими алгоритмами.
  
  void GBitmap::optimizationSkew( unsigned int g ) {
    
    cout<<END<<"optimizationSkew(unsigned int g), version V0"<<endl;
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    if (GrafT) cout<<"optimizationSkew(unsigned int g), version V0,  g="<<g<<endl;
    
    
    TIME_START  // time=0.078*2   w=2698 h= 4000
    
    int h=nrows;        // высота массива   IMAGE_HEIGHT
    int w=ncolumns;     // ширина массива   IMAGE_WIDTH
    int w_h=w*h;        // размер массива   IMAGE_SIZE
    cout<<"  w="<<w<<" h="<<h<<" w_h="<<w_h<<endl;
    
    
    // обнуление массива p1.
    //   memset(bytes_data, 255, w_h);
    
    
    //++++ перевести на ++ указатели без умножений и главное
    //---- убать внутренний цикл по "n" заменив на рекурсивный интегратор. Нет смысла.
    //---- Проверить не линейное квантование по степени двойки. Не эффективно.
    // однако time=0.1*2  при общем time=0.5.
    
    // МОЖНО СДЕЛАТЬ размером w_h/g
    uchar *bytes_data_1=(uchar*)malloc(w_h);
    //uchar *bytes_data_1=(uchar*)calloc(w_h, 1); // с обнулением массива p1. // sizeof(uchar)
    
    memset(bytes_data_1, 255, w_h); // заполнение белым
    
    // указатели на массивы.
    uchar *p0=bytes_data; //глобальный массив.
    uchar *d0;
    uchar *p1=bytes_data_1;
    uchar *d1;
    
    g=8;
    
    if ( g<1 ) g=1;
    cout<<"g="<<g<<endl;
    int w_g=w/g;      // w_8=w/8;
    
    // С помощью этого параметра создаются две транспонированные картинки повернутые на противоположные стороны углы,
    // по которым в дальнейшем удобно считать разностные углы.
    int sign=-1;
    
    //int Psum=255*g;
    uint  Ps128=255*g-128;
    //int threshold=255/g/2; //threshold
    
    int x, y;
    int n, sum;
    int d=0;
    int max=0;
    int min=1<<30;
    
    
    //    binarisationF(99-1, 14);  // бинаризовать надо не транспонированный текст - 1
    
    //*
    
    // Работающий и более быстрый код, чем в основной программе.
    // С помощью этого алгоритма под управлением параметра sign=+/-1, создаются две транспонированные картинки повернутые
    // на противоположные углы, по которым в дальнейшем удобно считать разностные углы.
    // Суммарное число тактов цикла на единицу меньше длинны массива, поэтому особо оптимизировать не чего.
    for(y=0; y < h; y++) {
      
      d1=p1;  // сохраняем для выполнения цикла по "x"
      d=0;
      for(x=0; x < w_g; x++) { // w_g=w/g;
        
        //if(sign>0) { for(n=0; n< g; n++) { sum+=*(w-1 - n - d + p0); int v=w-1 - n - d  + y*w; if (v>max)max=v; if (v<min)min=v; } }
        //else       { for(n=0; n< g; n++) { sum+=*(      n + d + p0); int v=n + d + y*w;        if (v>max)max=v; if (v<min)min=v; } }
        // y < min_B  && (p0-bytes_data)<w_h;
        
        //int d=x*g;
        sum=0;
        d0=p0;  // сохраняем для выполнения цикла по "n"
        
        // Суммирование "g" последовательных отсчетов и сохранениение только этих сумм (сжатие массива по горизонтали в "g" раз).
        //if(sign>0) { d0+=w - 1 - d; for(n=0; n< g; n++) { sum+=*(d0 - n); } }   // sum+=*(w-1 - n - d + p0);
        //else       { d0+=d;         for(n=0; n< g; n++) { sum+=*(d0 + n); } }   // sum+=*(      n + d + p0);
        
        //long v  = d0 - bytes_data;
        //long vv = d1 - bytes_data_1;
        
        // обратная и прямая выборка из массива bytes_data и суммирование g (наример восьми) последовательных отсчетов.
        if(sign>0) { d0+=w - 1 - d; for(n=0; n< g; n++) { sum+=*(d0 - n); } }   // sum+=*(w-1 - n - d + p0);
        else       { d0+=d;         for(n=0; n< g; n++) { sum+=*(d0 + n); } }   // sum+=*(      n + d + p0);
        
        // Сохранение сжатого массива в транспонированном виде. // транспонирование bytes_data_1[h*x + y]=(bytes_data[y*w + x]);
        ///*d1=sum/g;    // bytes_data_1[h*x + y]=sum/8;
        
        /////bytes_data_1[h*x + y]=(Psum-sum)/255; // >>10  /1024  128*8=1024 // не явная бинаризация до 8 уровней и инверсия // rotation=-1.02106 исходный.
        // *d1=(Psum-sum)/255;  // исходный. Psum=255*g; с инверсией, т.е. белые буквы на черном фоне.
        //            *d1=255-sum/g;       // среднее с инверсией, т.е. белые буквы на черном фоне.
        //           *d1=sum/g;              // среднее
        
        //if(sum>128) *d1=255;   else *d1=0;    // без инверсии.
        //if(*d0>223) *d1=0;   else *d1=255;       // бинаризация после суммирования "g" пикселей с инверсией, т.е. белые буквы на черном фоне.
        //if((255-*d0)>32) *d1=255;   else *d1=0;       // бинаризация после суммирования "g" пикселей с инверсией, т.е. белые буквы на черном фоне.
        //if((255*g-sum)>128) *d1=255;   else *d1=0;    // бинаризация после суммирования "g" пикселей с инверсией, т.е. белые буквы на черном фоне.
        //if((255*g-sum)>128) *d1=8;   else *d1=0;       // бинаризация после суммирования "g" пикселей с инверсией, т.е. белые буквы на черном фоне.
        
        // После суммирования "g" пикселей с инверсией, получились бинаризованные и сжатые по горизонтали серые буквы на черном фоне.
        if(sum<Ps128) *d1=1;  else *d1=0;  // if(sum<Ps128) p1[h*x + y]=255;  else p1[h*x + y]=0;
        // 23 апреля 2019 // 255 на больших углах работает плохо, 1 отлично работает на всех углах.
        
        d+=g; // прыжок по оси "x" через "g"   // d=x*g;
        d1+=h; // указатель на выходной массив  // bytes_data_1[h*x + y]
        
        
      } // x
      p0+=w;  // p0 = bytes_data + y*w;
      p1++;   // p1 = bytes_data_1 + y;
    } // y
    
    // Получили уменьшеный по горизонтали в "g" раз массив bytes_data_1, где каждый pix это сумма по горизонтали "g" pix исходного массива bytes_data.
    // Пустое место заполнено нулями (черное).
    
    //*/
    
    
    
    //*
    // Вьювер на транспонированный массив, иначе понять ничего не возможно.
    // Такое же транспонирование как и в основном алгоритме.
    int h_=w; int w_=h;
    ///int h_=ncolumns; int w_=nrows;
    for(y=0; y < h_; y++) {
      for(x=0; x < w_; x++) {
        bytes_data[h_*x + y]=(bytes_data_1[y*w_ + x]);
      } // x
    } // y
    //*/
    
    
    
    /*
     // Предидущая, долго раборатавшая версия предобработки. Проблема с входным динамическим диапозоном (не квантует некоторые серые тексты).
     // однако time=0.1*2  при общем time=0.5.
     // полная копия из пр
     //  универсальный; 1*8, 1*4, 1*2, 1*1
     // С помощью этого алглритма под управлением параметра sign=+/-1, создаются две транспонированные картинки повернутые
     // на противоположные стороны углы, по которым в дальнейшем удобно считать разностные углы.
     for(y=0; y < h; y++) {
     p0 = bytes_data + y*w;
     for(x=0; x < w_g; x++) {
     // выборка из массива bytes_data и суммирование g (наример восьми) последовательных отсчетов.
     d=x*g; sum=0;
     if(sign>0) { for(n=0; n< g; n++) { sum+=*(w-1 - n - d + p0); } }
     else       { for(n=0; n< g; n++) { sum+=*(      n + d + p0); } }
     
     // первый вариант: преобразование серого (от 255 до 0) в усредненное серое с динамическим
     // диапазоном от 0 до 8, инверсия и запись в транспонированный массив p1.
     ///p1[h*x + y]=(Psum-sum)/255; // >>10  /1024  128*8=1024 // не явная бинаризация и инверсия // rotation=-1.02106 основной.
     //p1[h*x + y]=g-sum/g; // ~sum/g; // 255-sum/g;    // (255*g-sum)/255; g-sum/255; // rotation=-1.1609 // 5 марта 2019
     // cout<<"   p1="<<(ushort)p1[h*x + y]<<endl;
     
     bytes_data_1[h*x + y]=(Psum-sum)/255;
     //p1[h*x + y]=255-sum/g;
     /////p1[h*x + y]=(sum)/255;
     
     // второй вариант: для входного ч/б массива bytes_data // НЕ АКТУАЛЕН
     // подсчет числа едениц в горизонтальном байте, запись в массив p1.
     ///p1[h*x + y]=sum;
     } // x
     } // y
     //*/
    
    
    cout<<"  g="<<g<<"  max="<<max<<" min="<<min<<endl;
    
    // освобождение массива bytes_data_1.
    if ( bytes_data_1 !=NULL ) free(bytes_data_1);
    
    
    if(GrafT) { TIME_PRINT_ }
    
  }//_____________________________________________________________________________
  
  
  
  
  /*
   // Вычисление w2 как ближайшей степени двойки w_g, причем w2 >= w_g,
   // напрямер если w=1035 то w2=2048.
   uint w2=1;
   while( w2<w_g ){ w2<<=1; }  // <<1 умножение на 2
   
   // Size of sharpness table
   // Размер массива для суммы квадратов конечных разностей.
   unsigned int ssize=2*w2-1;
   unsigned int s=h*w2;
   //*/
  
  /*
   // Отлажена //
   uchar bitcount[256];    // таблица для у
   uint i, j, cnt;
   
   for(i=0; i<256; i++)
   {
   j=i, cnt=0;
   do cnt+=j&1; while(j>>=1);
   bitcount[i]=cnt;
   
   // uint w2=1;
   // while( w2<w_g ){ w2<<=1; }  // <<1 умножение на 2
   // cout<<"  i="<<i<<" bitcount[i]="<<(ushort)bitcount[i]<<endl;
   /// bytes_data[cnt*31*w + i]=0;
   }
   //*/
  
  /*
   //TIME_START
   
   
   // Предидущая, долго раборатавшая версия предобработки. Проблема с входным динамическим диапозоном (не квантует некоторые серые тексты).
   // однако time=0.1*2  при общем time=0.5.
   
   //  универсальный; 1*8, 1*4, 1*2, 1*1
   // С помощью этого алглритма под управлением параметра sign=+/-1, создаются две транспонированные картинки повернутые
   // на противоположные стороны углы, по которым в дальнейшем удобно считать разностные углы.
   for(y=0; y < h; y++) {
   p0 = bytes_data + y*w;
   for(x=0; x < w_g; x++) {
   // выборка из массива bytes_data и суммирование g (например восьми) последовательных отсчетов.
   d=x*g; sum=0;
   if(sign>0) { for(n=0; n< g; n++) { sum+=*(w-1 - n - d + p0); } }
   else       { for(n=0; n< g; n++) { sum+=*(      n + d + p0); } }
   
   // первый вариант: преобразование серого (от 255 до 0) в усредненное серое с динамическим
   // диапазоном от 0 до 8, инверсия и запись в транспонированный массив p1.
   p1[h*x + y]=(Psum-sum)/255; // >>10  /1024  128*8=1024 // не явная бинаризация и инверсия // rotation=-1.02106 основной.
   ///p1[h*x + y]=g-sum/g; // ~sum/g; // 255-sum/g;    // (255*g-sum)/255; g-sum/255; // rotation=-1.1609 // 5 марта 2019
   // cout<<"   p1="<<(ushort)p1[h*x + y]<<endl;
   
   // второй вариант: для входного ч/б массива bytes_data // НЕ АКТУАЛЕН
   // подсчет числа едениц в горизонтальном байте, запись в массив p1.
   ///p1[h*x + y]=sum;
   } // x
   } // y
   
   //TIME_PRINT_
   
   
   
   
   if ( bytes_data_1 !=NULL ) free(bytes_data_1); // освобождение массива bytes_data_1
   
   // Переупаковка (транспонирование) массива bytes_data. Замена вертикальных строк массива горизонтальными строками.
   p0=bytes_data;   p1=bytes_data_1;
   for ( x=0; x < w; x++ ) {    // time=0.37
   for ( y=0; y < w_h; y+=w ){
   *p1=*(p0+y);   p1++; // p1++;  сквозной индекс в цикле переупаковки
   } // y
   p0++;
   } // x
   
   //*/
  
  //******************************************************************************
  
  /*
   //  универсальный; 1*8, 1*4, 1*2, 1*1
   m=0;
   for(y=0; y < h; y++) {       // ir
   p0 = bytes_data + y*w;   m++;  n=0;
   d0 = p0;
   for(x=0; x < w-8-1; x++) {  // ic
			// выборка из массива bytes_data
			// и суммирование g (восьми) последовательных отсчетов
			n++;
			sum=(*(d0)+*(d0+1)+*(d0+2)+*(d0+3)+*(d0+4)+*(d0+5)+*(d0+6)+*(d0+7))/8;
			// sum+=*(d + p0); //sum+=*(n + d + p0);     *(d+x)
			// первый вариант: преобразование серого (от 255 до 0) в усредненное
			// серое (от 0 до 8), запись в транспонированный массив p1
			/// *d0=(Psum-sum)/255; // >>10  /1024  128*8=1024  // 2040=255*8
   *d0=sum/1;
			//				bytes_data_buf[h*x + y]=(Psum-sum)/255;
			
			// второй вариант: для входного массива bytes_data ч/б
			// подсчет числа едениц в горизонтальном байте, запись в массив p1
			////			p1[h*x + y]=sum;
   d0++;
   } // x
   } // y
   //*/
  
  
  // два варианта входного массива bytes_data:  серый или черное белый
  
  // первый вариант:
  // входной массив bytes_data серый (от 255 до 0), каждый байт char:
  // белое соответствует коду 255, черное 0
  // усреднение по серому восьми последовательных отсчетов (sum)
  // и преобразование в новое серое (от 0 до 8): белое кодируется 0  черное 8,
  // запись серого в массив p1
  
  // второй вариант:
  // входной массив bytes_data ч/б, каждый байт char: белое соответствует
  // коду 0, черное 1 (в каждом байте используется всего один разряд из восьми)
  // и подсчет числа единиц (sum) в восьми последовательных отсчетах,
  // запись суммы в массив p1
  
  //******************************************************************************
  
  
  // http://www.radgs.com/docs/help/win32.graph.freeimage.html
  
  
  //******************************************************************************
  
  /*
   unsigned char* sumbit=new unsigned char[256];
   
   // создание таблицы для подсчета числа едениц в горизонтальном байте
   cout_<<END<<endl;
   unsigned int i, j, ir, ic, cnt;
   for(i=0; i<256; i++) {
   j=i, cnt=0;
   do cnt+=j&1;  while(j>>=1);
   sumbit[i]=cnt;
   //cout_<<" "<<cnt;
   }
   cout_<<END<<endl;
   */
  
  //******************************************************************************
  
  
  /*
   // Iterate
   // быстрое преобразование Радона
   unsigned int i, j, ir, ic, m;
   unsigned short *s1, *s2, *t1, *t2;
   unsigned short *x1=p1, *x2=p2;  //
   unsigned int ds1, ds2, dt1, dt2;
   //unsigned int nPx=s;
   //  cout_<<"nPx="<<nPx<<endl;
   unsigned short *aux;
   unsigned int step=1;
   while(1){
   for(i=0; i<w2; i+=2*step) {
   for(j=0; j<step; j++) {
   // Columns-sources:  // Столбцы-источники:
   //ds1=h*(i+j);       if(ds1>nPx){cout_<<"ds1="<<ds1; continue;} s1=x1+ds1; 	   // int
   //ds2=h*(i+j+step);  if(ds2>nPx){cout_<<"ds2="<<ds2; continue;} s2=x1+ds2;
   
   s1=x1+h*(i+j);
   s2=x1+h*(i+j+step);
   
   // Columns-targets:  // Столбцы-целей:
   //dt1=h*(i+2*j);     if(dt1>nPx){cout_<<"dt1="<<dt1; continue;} t1=x2+dt1;
   //dt2=h*(i+2*j+1);   if(dt2>nPx){cout_<<"dt2="<<dt2; continue;} t2=x2+dt2;
   
   t1=x2+h*(i+2*j);
   t2=x2+h*(i+2*j+1);
   
   for(m=0; m<h; m++){
   t1[m]=s1[m];
   t2[m]=s1[m];
   if( m+j<h )   { t1[m]+=s2[m+j]; }
   if( m+j+1<h ) { t2[m]+=s2[m+j+1]; }
   } // m
   } // j
   } // i
   // Swap the tables:
   aux=x1;                // unsigned short *aux=x1;  aux=x1;
   x1=x2;
   x2=aux;
   // Increase the step:  // Увеличение шага:
   step*=2;
   if(step>=w2) break;
   } // while(1)
   */
  
  
}
