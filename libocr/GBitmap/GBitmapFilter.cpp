//  Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .

#include "GBitmap.h"
//#include <smmintrin.h> // для =_mm_popcnt_u64(ss);


namespace ocr{
  
  
  // действующая версия // (вторая, основная)
  
  /// ГОТОВАЯ fast version Gaussian (blur) ///
  
  //*****************************************************************************
  
  // функция размытия (blur) массива bytes_data двухмерным Гауссианом ( Gaussian ).
  // Основная и надежная.
  void  GBitmap::gaussian(int amplitude) {
    
    // ss "ширина" (amplitude) Гауссиана в пикселях. Физический смысл, "ss" это область усреднения с весами близкими к Гауссиану.
    // Входной массив bytes_data может быть: как серым от 0-черного до 255-белого, так и черно-белым: 0-черный 255-белый.
    // На выходе bytes_data всегда серый.
    // bytes_data это unsigned char
    
    //  * Идея 1 *  пока не реализовано
    // Адаптивное сглаживание.
    // Идея состоит в том, что степень сглаживания графического текста обратно пропорциональна степени
    // "курчавости" текста (числу Мадельброта) вычесленному в небольшой области вокруг каждой точки графического текста.
    //  * Реализация *
    // Скользящия квадратная область S*S пробегает по всему исходному битовому массиву.
    // Для каждой точки этого массива в квадратной области S*S вычисляется две величины:
    // - площадь ( суммарное количество черных пикселей попавших в область S*S )
    // - длина периметра или контура ( суммарное количество переходов из черного в белое и из белого в черное,
    // попавших в область S*S, по вертикали и по горизонтали ). Вычисляется сдвигом битового регистра длинной в w*h
    // Отношение длинны периметра (контура) к площади называется числом Мадельброта
    // Адаптивно сглаживаем картинку с управлением от вычисленного числа Мадельброта.
    // Для увеличения быстродействия величины площади и длинны периметра вычисляются по предпросчитанному интегрольному массиву.
    // В этой функции эта идея не реализованна.
    
    //  * Идея 2 * реализована в этой фунции
    /// Теория размытия (blur) битового массива (изображения) двухмерным Гауссианом. Реализованна функция. ///
    // Двухмерный Гауссиан использует фиксированную область усредннения в пикселях, где ss ее "ширина"
    // Одномерные фильтры с прямоугольной и треугольной импульсной характеристикой (где k это ss):
    // -прямоугольная рекурсивная весовая функция. Соответствует одномерному фильтру с прямоугольной импульсной характеристикой
    // y(n)=y(n-1)+x(n)-x(n-2k-1)
    // -треугольная рекурсивная весовая функция. Соответствует одномерному фильтру с треугольной импульсной характеристикой
    // y(n)=-y(n-2)+2y(n-1)+x(n-2k-2)-2x(n-k-1)+x(n)
    // Импульсная характеристика фильтра это его реакция на еденичный импульс. Ее удобно применять для отладки фильтра.
    // Рекурсивная весовая функция это удобная форма для дискретной (програмной) реализации соответствующего фильтра.
    // Если к одному и тому же массиву данных применить два раза подряд фильтр с треугольной импульсной характеристикой,
    // то это эквивалентно применению фильтра с гладкий импульсной характеристикой практически точно совпадающий
    // по форме с одномерным Гауссианом ( Gaussian ).
    
    // Если к двухмерному массиву данных применить одномерный Гауссианом сначала по горизонтали, а затем по вертикали,
    // то это эквивалентно применению двухмерного Гауссиана.
    // Для увеличения быстродействия, удобнее сначала выполнять горизонтальный прогон Гауссом, затем транспонировать массив,
    // опять горизонтальный прогон Гауссом и снова транспонирование массива ( транспонировать, т.е. поворачивать на +90°).
    
    
    TIME_START // time=0.585 сек,  w=4064 h=2472,  amplitude=4,  _Image2OCR/__Page_09___.png
    // time=2.14 сек   w=16224 × h=2464  w*h=40 млн пикселей  //  (w=2698 h=4000)
    // time=0.63 сек   w=2621  × h=3979  w*h=10 млн пикселей
    // time=0.22 сек   w=3491  × h=1017  w*h=3.5 млн пикселей
    // первые "ss" и последние "ss" пикселей изображения в этой версии защищены от краевых эффектов
    // за счет создания защитных областей pr2_w в начале и в конце всех массивов.
    
    if(amplitude==0)return;
    
    int x,y;
    int w,h;
    w=ncolumns; // ширина массива  IMAGE WIDTH в пикселях
    h=nrows;    // высота массива  IMAGE HEIGHT в пикселях
    int w_h=w*h;
    unsigned char *p0=bytes_data; // входной и выходной массив, для черно белых изображений p0=0,255 или серых p0=0-255;
    int ss=amplitude;  // "ss" зто "ширина" области усредннения Гауссиана в пикселях.
    int w_;
    // вспомогательные переменные для увеличения быстродействия
    int wh_ss2, wh_ss4;
    
    // Ограничения на размер области усреднения ss
    if ( ss<=2 ) ss=2;   if ( ss>64 ) ss=64;
    //ss=4;  // test //
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
    if (GrafT) {
      cout<<"Сглаживание (blur) Гауссианом gaussian()    amplitude="<<amplitude<<endl;
      cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl;
    }
    
    
    // Вычисление величины защитной области pr2_w в начале и в конце всех массивов.
    int pr1=ss*2+8;  // protection area // после отладки сделать ss*2+8; (во время отладки ss*1+2;)
    int pr2=pr1*2;
    int pr2_w=(pr2/w)*w + w; // защитная область должна быть кратна "w" и не может быть меньше "w".
    ///int pr2_w4=pr2_w*sizeof(unsigned int); // для массивов ReBuf и ImBuf
    if (GrafT) cout<<"ширина области усредннения  ss="<<ss<<",  защитная область  pr2="<<pr2<<",  защитная область кратная w   pr2_w="<<pr2_w<<endl;
    
    // размер массивов в байтах sizeBuf, это размер исходного массива плюс
    // две защитные области pr2_w в начале и в конце массива.
    unsigned int sizeBuf=w_h + pr2_w + pr2_w; // sizeBuf количество элементов в массиве
    ///unsigned int sizeBuf4=sizeBuf*sizeof(unsigned int); // длина массива в байтах
    if (GrafT) cout<<"размер исходного массива в байтах   w_h="<<w_h<<",   размер массивов с защитными областями sizeBuf="<<sizeBuf<<endl;
    
    // масштабирующие коэффициенты необходимы для уменьнения динамического диапазона размытого серого
    // до динамического диапазона байта (0-255) после применения Гауссиана.
    int ss_2=ss*2;
    int ss_m2=ss*ss;
    int ss_m3=ss_m2*ss;
    int ss_m4=ss_m3*ss; // реально использыется только этот, остальные нужны для отладки.
    if (GrafT)cout<<"масштабирующий коэффициент для уменьнения динамического диапазона серого  ss_m4="<<ss_m4<<endl;
    
    // указатели
    unsigned char* bytes_data_1, *p1;
    unsigned char* bytes_data_2, *p2;
    unsigned int* ReBuf, *d1;
    unsigned int* ImBuf, *d2;
    
    // Массивы. Каждый элемент инициализируется в 0.
    bytes_data_1 = (unsigned char*)calloc(sizeBuf,sizeof(unsigned char)); // p1
    bytes_data_2 = (unsigned char*)calloc(sizeBuf,sizeof(unsigned char)); // p2
    ReBuf = (unsigned int*)calloc(sizeBuf,sizeof(unsigned int)); // d1
    ImBuf = (unsigned int*)calloc(sizeBuf,sizeof(unsigned int)); // d2
    // calloc(n,size); unsigned n;
    // количество элементов unsigned size; длина каждого элемента в байтах // lalloc=(long*)calloc(40, sizeof(long));
    
    ///ImBuf = (unsigned short*)malloc(sizeBuf); // d1
    ///ReBuf = (unsigned short*)malloc(sizeBuf); // d2
    
    // test memset //
    ///memset(ReBuf, 0, 4*sizeBuf);   /// d1==ReBuf; ImBuf==d2  // sizeBuf количество элементов    //////////////////////////////////////
    ///memset(ReBuf, 0, 4*pr2_w);     memset(ReBuf + pr2_w + w_h, 0, 4*pr2_w);
    // начало (указатель), значение одного байта, количество символов в байтах (длина) unsigned
    // for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<ReBuf[x]; if ((x+1)%32==0)cout<<endl; } // x
    
    /*
     int sf_rg=sizeof(unsigned long);
     int w_h_64=w_h/sf_rg;  // sizeof(unsigned long)=8
     unsigned long *bytes_data0_64=(unsigned long*)bytes_data;    // приведение к unsigned long
     unsigned long *bytes_data1_64=(unsigned long*)bytes_data_1;  // приведение к unsigned long
     unsigned long *bytes_data2_64=(unsigned long*)bytes_data_2;  // приведение к unsigned long
     //unsigned long *p0_64, *p1_64;
     */
    
    // тест //
    ////memset(bytes_data, 0, w_h);    // тест черная плашка
    //  memset(bytes_data, 255, w_h);  // тест белая  плашка
    
    //////////////
    // инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный
    for ( x=0; x < w_h; x++ ){ bytes_data_1[x+pr2_w]=~bytes_data[x]; }
    ///for ( x=0; x < w_h_64; x++ ) { bytes_data1_64[x+pr2]=~bytes_data0_64[x]; } // инвертируем по 8 байт одновременно
    // инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 1-черный
    ///for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data0_64[x] & 0x1010101010101010; } // обрабатываем по 8 байт одновременно
    //////////////
    /*
     // Инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный.
     for ( int x=0; x < w_h; x++ ){ bytes_data[x]=~bytes_data[x]; } // Инвертируем по 1 байту.
     int w_h_64=w_h/sizeof(ulong);  // sizeof(ulong)=8
     ulong *bytes_data_64=(ulong*)bytes_data;    // приведение к типу ulong
     // Инвертируем одновременно по 8 байт. Последний участок массива длинной от 0 до 8 байт не инвертируется.
     for ( int x=0; x < w_h_64; x++ ) { bytes_data_64[x]=~bytes_data_64[x]; }
     int wh_=w_h_64*sizeof(ulong);
     // инверсия последнего участка массива длинной от 0 до 8 байт.
     for (int x=wh_; x<w_h; x++){ bytes_data[x]=~bytes_data[x]; }
     //cout<<"w="<<w<<",  h="<<h<<"    w_h_64="<<w_h_64<<" w_h-w_h_64*8="<<w_h-w_h_64*8<<" wh_="<<wh_<<endl;
     //*/
    
    /// Горизонтальное размытие (blur) одномерным Гауссианом двухмерного массива данных (изображения) ///
    
    // Горизонтальное применение прямой треугольной весовой функции
    p1=bytes_data_1 + pr2_w;   d1=ReBuf + pr2_w;  // pr1=ss*1+2;
    wh_ss2=w_h + ss_2;
    for ( x=0; x < wh_ss2; x++ ) {    // time=0.41 16224 × 2464  // ss_2=ss*2;
      // треугольная весовая функция, прямая фильтрация
      // ReBuf[x]=-ReBuf[x-2]+2*ReBuf[x-1+ImBuf[x-2*s ]-2*ImBuf[x-ss]+ImBuf[x];
      *d1=-*(d1-2)+(*(d1-1)<<1)+*(p1-ss_2)-(*(p1-ss)<<1)+*p1;       // <<1=2*
      //cout<<" "<<(unsigned short)*d1;
      p1++;   d1++;  // p0=bytes_data_1+x;   d1=ReBuf+x;
    } // x
    ///        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<ReBuf[x]/ss_m2; if ((x+1)%32==0)cout<<endl; } // x
    
    
    // Горизонтальное применение инверсной треугольной весовой функции
    p2=bytes_data_2 + w_h + pr2_w + ss_2;   d1=ReBuf + w_h + pr2_w + ss_2;   d2=ImBuf + w_h + pr2_w + ss_2;
    wh_ss4=w_h + ss_2 + ss_2;
    for ( x=wh_ss4; x > 0; x-- ) { // time=0.53 16224 × 2464   // ss_2=ss*2;
      // треугольная весовая функция, инверсная фильтрация
      // ImBuf[x]=-ImBuf[x+2]+2*ImBuf[x+1]+ReBuf[x+ss_2]-2*ReBuf[x+ss]+ReBuf[x];
      *d2=-*(d2+2)+(*(d2+1)<<1)+*(d1+ss_2)-(*(d1+ss)<<1)+*d1;          // <<1=2*
      // уменьнение динамического диапазона размытого серого до динамического диапазона байта (0-255)
      *p2=*d2/ss_m4;
      //cout<<" "<<(unsigned short)*p2;
      p2--;  d1--;  d2--; // p2=bytes_data+x;   d1=ReBuf+x;   d2=ImBuf+x;
    } // x
    ///        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<(unsigned short)bytes_data_2[x]; if ((x+1)%32==0)cout<<endl; } // x
    ///TIME_PRINT_
    /**/
    
    
    
    ///TIME_START
    // реально это не поворот на -90°, а зеркальный flip.
    // Поворот на -90°. Переупаковка (транспонирование) горизонтального массива строк в массив вертикальных строк.
    p2=bytes_data_2 + pr2_w;   p1=bytes_data_1 + pr2_w; /// сдвигаем в начало массива p2 на + pr2_w   /// сдвигаем обратно в массиве p1 на + pr2_w
    for ( x=0; x < w; x++ ) {    // time=0.37
      for ( y=0; y < w_h; y+=w ){ /// sizeBuf   w_
        //*(p1 + index_)=*(p2 + x + y);  index_++;  // index_+=dlt; int dlt=1;
        *p1=*(p2+y);  p1++; // p1++;  сквозной индекс в цикле переупаковки
        // *p1=*(p2+y); cout<<" "<<(unsigned short)*p1;  p1++;     // *p1=*p0;   p1++;  p0+=w;
      } // y
      p2++; // +x
    } // x
    ///        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<(unsigned short)bytes_data_1[x]; if ((x+1)%32==0)cout<<endl; } // x // sizeBuf  w_h
    ///TIME_PRINT_
    /**/
    
    
    /*
     // ТЕСТ, поворот еще на +90° до +180°
     int w_=h;   // int h_=w;    // меняем местами w и h по любому
     //p2=bytes_data_2;   d1=ReBuf;       // возвращение в исходное положение
     p2=bytes_data_2;   p1=bytes_data_1;  // поворот еще на +90° до +180°, тест
     unsigned int index_=w_h; // сквозной индекс в цикле переупаковки
     for ( x=0; x < w_; x++ ) {    // time=0.45=0.25
     p1++; // +x
     for ( y=0; y < w_h; y+=w_ ){
     // *(p2 + index_)=*(d1 + x + y);  index_--; // index_+=dlt; int dlt=1;
     // *p2=*(d1+y) ;   p2++; // d1++;  // возвращение в исходное положение
     *p2=*(p1+y) ;   p2--; // d1++;    // поворот еще на +90°, до +180°, тест
     } // y
     } // x
     for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<(unsigned short)bytes_data_2[x]; if ((x+1)%32==0)cout<<endl; } // x
     */
    
    
    //*******************************************************************************************
    
    
    /// Вертикальное размытие (blur) одномерным Гауссианом двухмерного массива данных (изображения) ///
    
    ///TIME_START
    
    // обязательное обнуление // d1
    memset(ReBuf, 0, sizeBuf*4);   /// d1==ReBuf; ImBuf==d2  // sizeBuf количество элементов   /////////////////////////////////////////
    ///memset(ReBuf, 0, pr2_w*4);     memset(ReBuf + pr2_w + w_h, 0, pr2_w*4);
    // начало (указатель), значение одного байта, количество символов в байтах (длина) unsigned
    ///        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<ReBuf[x]/ss_m2; if ((x+1)%32==0)cout<<endl; }
    
    
    // обязательное обнуление начального участка массива bytes_data_1 от 0 до pr2_w, для чистого старта рекурсивного фильтра
    memset(bytes_data_1, 0, pr2_w);    // p1
    // обязательное обнуление конечного участка массива bytes_data_1 от pr2_w + w_h до sizeBuf, для чистого старта рекурсивного фильтра
    memset(bytes_data_1 + pr2_w + w_h, 0, pr2_w);
    ///        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<(unsigned short)bytes_data_1[x]; if ((x+1)%32==0)cout<<endl; } // x // sizeBuf  w_h
    
    
    // Вертикальное применение прямой треугольной весовой функции
    
    p1=bytes_data_1 + pr2_w;   d1=ReBuf + pr2_w;
    wh_ss2=w_h + ss_2;
    for ( x=0; x < wh_ss2; x++ ) {    // time=0.26  16224 × 2464
      // треугольная весовая функция, прямая фильтрация
      // ReBuf[x]=-ReBuf[x-2]+2*ReBuf[x-1+ImBuf[x-2*s ]-2*ImBuf[x-ss]+ImBuf[x];
      *d1=-*(d1-2)+(*(d1-1)<<1)+*(p1-ss_2)-(*(p1-ss)<<1)+*p1;       // <<1=2*
      ///cout<<" "<<(unsigned short)*d1;
      p1++;   d1++;  // p0=bytes_data_1+x;   d1=ReBuf+x;
    } // x
    ///        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<ReBuf[x]/ss_m2; if ((x+1)%32==0)cout<<endl; } // x
    ///TIME_PRINT_
    
    ///TIME_START
    // Не обязательное обнуление начального и конечного участка массива  bytes_data_2  // p2
    memset(bytes_data_2, 0, pr2_w);     memset(bytes_data_2 + pr2_w + w_h, 0, pr2_w);
    // Не обязательное обнуление начального и конечного участка массива ImBuf  /// ImBuf=d2;  d1=ReBuf;
    memset(ImBuf, 0, pr2_w*4);     memset(ImBuf + pr2_w + w_h, 0, pr2_w*4);
    
    
    // Вертикальное применение инверсной треугольной весовой функции
    
    p2=bytes_data_2 + w_h + pr2_w + ss_2;   d1=ReBuf + w_h + pr2_w + ss_2;   d2=ImBuf + w_h + pr2_w + ss_2;
    wh_ss4=w_h + ss_2 + ss_2;
    for ( x=wh_ss4; x > 0; x-- ) { // time=0.32  16224 × 2464
      // треугольная весовая функция, инверсная фильтрация
      // ImBuf[x]=-ImBuf[x+2]+2*ImBuf[x+1]+ReBuf[x+ss_2]-2*ReBuf[x+ss]+ReBuf[x];
      *d2=-*(d2+2)+(*(d2+1)<<1)+*(d1+ss_2)-(*(d1+ss)<<1)+*d1;          // <<1=2*
      // уменьнение динамического диапазона размытого серого до динамического диапазона байта (0-255)
      *p2=*d2/ss_m4; // для внутреннего формата программы 0-белый 255-черный   // *p0=(d*255)/ss_m3;
      p2--;  d1--;  d2--; // p2=bytes_data+x;   d1=ReBuf+x;   d2=ImBuf+x;
    } // x
    ///        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<(unsigned short)bytes_data_2[x]; if ((x+1)%32==0)cout<<endl; } // x
    
    
    // *******************************************************************************************
    /**/
    
    
    ///TIME_START
    // Поворот на +90°. Возвращаем в исходное положение и записываем в исходный массив bytes_data
    w_=h; //int n=0;  // меняем местами w и h по любому    // int w_=h;  int h_=w;
    p0=bytes_data;   p2=bytes_data_2 + pr2_w;  // index_=0;  ///  + pr2_w  сдвигаем в начало массива
    for ( x=0; x < w_; x++ ) {    // time=0.25
      for ( y=0; y < w_h; y+=w_ ){ // w_h
        // *(p0 + index_)=*(p2 + x + y);  index_--; // index_+=dlt; int dlt=1;
        // за одно выполняем инверсию "~" и записываем результат в исходный массив p0
        *p0=~(*(p2+y));   p0++; // n++; // p0++;  сквозной индекс в цикле переупаковки  //////////////
      } // y
      p2++; // +x
    } // x
    ///        for ( x=0; x < w_h; x++ ) { cout<<" "<<(unsigned short)bytes_data[x]; if ((x+1)%32==0)cout<<endl; } // x
    //cout<<"n="<<n<<endl;
    /**/
    
    // инверсия уровней "~" необходима для преобразования внутреннего формата программы 0-белый (1-255)-серый в
    // общепринятый стандарт 0-черный (1-255)-серый для выходного массива bytes_data
    
    // заполняем нулями технологический бордюр в 2 пиксела внизу изображения
    memset(bytes_data+ncolumns*nrows-ncolumns*2, 255, ncolumns*2);
    
    
    // освобождение массивов bytes_data_1, bytes_data_2, ImBuf,  ReBuf
    if ( bytes_data_1 !=NULL ) free(bytes_data_1);
    if ( bytes_data_2 !=NULL ) free(bytes_data_2);
    if ( ImBuf !=NULL ) free(ImBuf);
    if ( ReBuf !=NULL ) free(ReBuf);
    /**/
    
    TIME_PRINT_
    
    
    
    // вспомогательные переменные для предотвращения выхода за пределы массива
    // вспомогательные переменные для увеличения быстродействия
    
    /*
     ///TIME_START
     // Поворот на +90°. Возвращаем в исходное положение
     ///w_=sizeBuf/w;   // int w_=h;  int h_=w;   // меняем местами w и h по любому
     w_=h; // меняем местами w и h по любому // int w_=h;  int h_=w;
     p1=bytes_data_1;   p2=bytes_data_2 + pr2_w;  // index_=0;  ///  + pr2_w  сдвигаем в начало массива
     //p2=bytes_data_2 + pr2_w;   p1=bytes_data_1 + pr2_w;   // index_=0;  /////p2=bytes_data_2;--p0=bytes_data; ///  + pr2_w  сдвигаем в начало массива
     for ( x=0; x < w_; x++ ) {    // time=0.25
     /////     p2++; // +x
     for ( y=0; y < w_h; y+=w_ ){ // w_h
     // *(p1 + index_)=*(d1 + x + y);  index_--; // index_+=dlt; int dlt=1;
     // за одно выполняем инверсию
     *p1=*(p2+y);   p1++; // d1++;  сквозной индекс в цикле переупаковки // возвращение в исходное положение
     } // y
     p2++; // +x
     } // x
     for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<(unsigned short)bytes_data_1[x]; if ((x+1)%32==0)cout<<endl; } // x
     
     
     //   for ( x=0; x < w_h; x++ ){ bytes_data[x]=~bytes_data_2[x+pr2_w]; }
     
     // инверсия уровней выходного массива внутреннего формата программы 0-белый (1-255)-серый в общепринятый стандарт 0-черный (1-255)-серый
     for ( x=0; x < w_h; x++ ){ bytes_data[x]=~bytes_data_1[x+pr2_w]; }
     ///for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data1_64[x+pr2]; } // инвертируем по 8 байт одновременно
     */
    
    
    
    ///TIME_PRINT_
    ///if (GrafT) { cout<<"n0_min="<<n0_min<<"    n0_max="<<n0_max<<endl; } ////////
    ///int n0=0; int n0_max=0;   int mx=w_h*h;   int n0_min=mx; ////////
    ///if( n0 <= n0_min ) { n0_min=n0; } ////////
    ///if( n0 > n0_max ) { n0_max=n0; } ////////
    ///n0++; ////////
    
    ///int w_=sizeBuf/h;   // int w_=w;
    ///w_=sizeBuf/w;   // int w_=h;  int h_=w;   // меняем местами w и h по любому
    
    /*
     // приведение уровней bytes_data из 0 и 255 к 0 и 1       // ~
     //for ( y=0; y < w_h; y++ ){ bytes_data[y]=(bytes_data[y]>>7); }
     for ( y=0; y < w_h; y++ ){ *(p0+y)>>=7; }    /// *p0=(d*255)/ss_m3;
     */
    // инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный
    //for ( x=0; x < w_h; x++ ) { if (bytes_data[x]) bytes_data[x]=0;  // else bytes_data[x]=1; } // по 1 байту //else bytes_data[x]=255;
    
    ///unsigned char a,b=255; a=~b; cout<<"  a="<<(unsigned short)a; a=~b&1;  cout<<"  a="<<(unsigned short)a; cout<<endl;
    //unsigned int c=0x1010101; cout<<"  c="<<c; cout<<endl; // 0x10101010 // 16843009  //0b01011110 двоичный
    //    unsigned int a,b=0xFFFFFFFFFFFFFFFF;
    ////unsigned long a,b=0; // 0x101010101010101==72340172838076673
    ////a=~b; cout<<"  a="<<a; a=~b & 0x1010101010101010;  cout<<"  a="<<a; cout<<endl;
    
    //-----------------------------------------------------------------------------------------------------------
    
    
  }//____________________________________________________________________________
  
  
  // работающая версия // (первая запасная) // TMP test
  
  /// ГОТОВАЯ fast version Gaussian (blur) ///
  
  //*****************************************************************************
  
  // функция размытия (blur) массива bytes_data двухмерным Гауссианом ( Gaussian ).
  // Чуть быстрее основной, вместо 4х массивов как в основном gaussian здесь используются 3.
  // Подглючивает.
  
  void  GBitmap::gaussianT(int amplitude) {
    
    // ss "ширина" (amplitude) Гауссиана в пикселях.
    // входной массив bytes_data может быть как серым: от 0-черного до 255-белого, так и черно-белым: 0-черный 255-белый.
    // bytes_data это unsigned char
    
    //  * Идея 1 *
    // Адаптивное сглаживание.
    // Идея состоит в том, что степень сглаживания графического текста обратно пропорциональна степени
    // "курчавости" текста (числу Мадельброта) вычесленному в небольшой области вокруг каждой точки графического текста.
    //  * Реализация *
    // Скользящия квадратная область S*S пробегает по всему исходному битовому массиву.
    // Для каждой точки этого массива в квадратной области S*S вычисляется две величины:
    // - площадь ( суммарное количество черных пикселей попавших в область S*S )
    // - длина периметра или контура ( суммарное количество переходов из черного в белое и из белого в черное,
    // попавших в область S*S, по вертикали и по горизонтали ). Вычисляется сдвигом битового регистра длинной в w*h
    // Отношение длинны периметра (контура) к площади называется числом Мадельброта
    // Адаптивно сглаживаем картинку с управлением от вычисленного числа Мадельброта.
    // Для увеличения быстродействия величины площади и длинны периметра вычисляются по предпросчитанному интегрольному массиву.
    // В этой функции эта идея не реализованна.
    
    /*
     /// Теория размытия (blur) битового массива (изображения) двухмерным Гауссианом. Реализованна функция. ///
     // Двухмерный Гауссиан использует фиксированную область усредннения в пикселях, где ss ее "ширина"
     // Одномерные фильтры с прямоугольной и треугольной импульсной характеристикой (где k это ss):
     // -прямоугольная рекурсивная весовая функция. Соответствует одномерному фильтру с прямоугольной импульсной характеристикой
     // y(n)=y(n-1)+x(n)-x(n-2k-1)
     // -треугольная рекурсивная весовая функция. Соответствует одномерному фильтру с треугольной импульсной характеристикой
     // y(n)=-y(n-2)+2y(n-1)+x(n-2k-2)-2x(n-k-1)+x(n)
     // Импульсная характеристика фильтра это его реакция на еденичный импульс. Удобно применять для отладки фильтра.
     // Рекурсивная весовая функция это удобная форма для дискретной (програмной) реализации соответствующего фильтра.
     // Если к одному и тому же массиву данных применить два раза подряд фильтр с треугольной импульсной характеристикой,
     // то это эквивалентно применению фильтра с гладкий импульсной характеристикой практически точно совпадающий
     // по форме с одномерным Гауссианом ( Gaussian ).
     
     // Если к двухмерному массиву данных применить одномерный Гауссианом сначала по горизонтали, а затем по вертикали,
     // то это эквивалентно применению двухмерного Гауссиана.
     // Для увеличения быстродействия, удобнее сначала выполнять горизонтальный прогон Гауссом, затем транспонировать массив,
     // опять горизонтальный прогон Гауссом и снова транспонирование массива ( транспонирование, т.е. поворот на +90°).
     */
    
    TIME_START // time=0.57 сек,  w=4064 h=2472,  amplitude=4,  _Image2OCR/__Page_09___.png
    // time=2.14 сек   w=16224 × h=2464  w*h=40 млн пикселей  //  (w=2698 h=4000)
    // time=0.63 сек   w=2621  × h=3979  w*h=10 млн пикселей
    // time=0.22 сек   w=3491  × h=1017  w*h=3.5 млн пикселей
    // первые "ss+ss" и последние "ss" пикселей изображения не защищены от краевых эффектов
    
    if(amplitude==0)return;
    
    int x,y;
    int w,h;
    w=ncolumns; // ширина массива  IMAGE WIDTH в пикселях
    h=nrows;    // высота массива  IMAGE HEIGHT в пикселях
    int w_h=w*h;
    unsigned char *p0=bytes_data;      // входной и выходной массивы, 0-черный 255-белый
    int ss=amplitude;  // ss "ширина" (амплитуда) Гауссиана в пикселях.
    
    // размеры массивов в байтах
    unsigned int sizeBuf=w_h*sizeof(unsigned int) + 512;   // + ss*2 // + 64; //   ЗАВЫШЕНО В 4 РАЗА
    unsigned int sizeBufInt=sizeBuf/sizeof(unsigned int);
    //sizeBuf=sizeBuf/4;
    //cout<<"w_h="<<w_h<<"  sizeBuf="<<sizeBuf<<"  sizeBufInt="<<sizeBufInt<<endl;
    
    /*
     // размеры массивов в байтах
     unsigned int sizeBuf_bd1=w_h + 512;
     unsigned int sizeBuf=w_h + 512;
     unsigned int sizeBufT=w_h*sizeof(unsigned int) + 512;   // + ss*2  //   ЗАВЫШЕНО В 4 РАЗА
     unsigned int sizeBufInt=sizeBufT/sizeof(unsigned int);
     //        unsigned int sizeBufInt=w_h + 512;
     cout<<"w_h="<<w_h<<"  sizeBuf="<<sizeBuf<<endl;
     cout<<"sizeBufInt="<<sizeBufInt<<"  sizeBufInt="<<sizeBufInt<<endl;
     // calloc(n,size); unsigned n; количество элементов unsigned size; длина каждого элемента в байтах // lalloc=(long*)calloc(40, sizeof(long));
     */
    
    // указатели
    unsigned char* bytes_data_1, *p1;
    unsigned int* ReBuf, *d1;
    unsigned int* ImBuf, *d2;
    
    // Массивы. Каждый элемент инициализируется в 0.
    bytes_data_1 = (unsigned char*)calloc(sizeBuf,sizeof(unsigned char)); // p1  /// ПРОВЕРИТЬ РАЗМЕР sizeBuf
    ImBuf = (unsigned int*)calloc(sizeBuf,sizeof(unsigned int)); // d1
    ReBuf = (unsigned int*)calloc(sizeBuf,sizeof(unsigned int)); // d2
    // calloc(n,size); unsigned n; количество элементов unsigned size; длина каждого элемента в байтах
    // lalloc=(long*)calloc(40, sizeof(long));
    ///ImBuf = (unsigned short*)malloc(sizeBuf); // d1
    ///ReBuf = (unsigned short*)malloc(sizeBuf); // d2
    
    
    //ss=4;  // "ширина" Гауссиана в пикселях
    
    // ss "ширина" Гауссиана в пикселях. Размер области усредннения ss=2-64,
    // для черно белых p0=0,255 или серых изображений p0=0-255;
    if ( ss<3 ) ss=2;   if ( ss>64 ) ss=64;
    // max ss=255 p0=0,1; при массивах типа int и *(d1-3)=*(d1-3)/ss;
    // max ss=40  p0=0,1; при массивах типа short
    // max ss=214 p0=0,1; при массивах типа int без *(d1-3)=*(d1-3)/ss;
    // max ss=214 p0=0,255; при массивах типа int и *(d1-3)=*(d1-3)/ss;
    // max ss=64  p0=0,255; при массивах типа int без *(d1-3)=*(d1-3)/ss;
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
    if (GrafT) {
      cout<<"Сглаживание (blur) Гауссианом gaussian()    amplitude="<<amplitude<<endl;
      cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
    
    // вспомогательные переменные для предотвращения выхода за пределы массива
    int  s2=ss*2+1,  s4=ss*4;
    // вспомогательные переменные для увеличения быстродействия
    int wh_s2=w_h+s2;
    int wh_s4=w_h+s4;
    int ss_2=ss*2;
    int ss_m2=ss*ss;
    int ss_m3=ss_m2*ss;
    int ss_m4=ss_m3*ss;
    
    //ПЕРЕНЕСТИ ++ ЗА АЛГОРИТМ
    
    // обнуление ImBuf,ReBuf ( где ImBuf, ReBuf глобальные )
    ///memset(ImBuf,0,sizeBuf);      memset(ReBuf,0,sizeBuf);  // time=0.24 16224 × 2464
    
    //memset(bytes_data, 255, w_h);  // тест белая плашка
    //memset(bytes_data, 0, w_h);    // тест черная плашка // char 1, short 2, int 4.
    /*
     // приведение уровней bytes_data из 0 и 255 к 0 и 1       // ~
     //for ( y=0; y < w_h; y++ ){ bytes_data[y]=(bytes_data[y]>>7); }
     for ( y=0; y < w_h; y++ ){ *(p0+y)>>=7; }    /// *p0=(d*255)/ss_m3;
     */
    
    
    /// Горизонтальное размытие (blur) одномерным Гауссианом двухмерного массива данных (изображения) ///
    
    ///TIME_START
    // обязательно обнуление начального участка массива bytes_data от 0 до s2+1 для чистого старта рекурсивного фильтра
    memset(bytes_data, 0, s2+1); // начало, значение, размер заполняемой части массива в байтах
    
    //bytes_data[s2+1]=255;
    //cout<<endl;  for ( y=0; y < s2*4; y++ ){cout<<"  "<<(unsigned short)bytes_data[y];}  cout<<endl;
    //cout<<endl;  for ( y=w_h-ss; y < sizeBufInt; y++ ){cout<<"  "<<(unsigned short)bytes_data[y];}  cout<<endl;
    
    // первое прямое применение треугольной весовой функции
    ////////int n0=0; int n0_max=0; int n0_min=1<<30; //////// проверено на многих файлах,  напр: _Image2OCR/__Page_09___.png
    // не вылетает за граници, была не правильно выбрана константа int n0_min=w_h*h;  11 февр 2019
    p0=bytes_data+s2;   d1=ReBuf+s2;
    ////        for ( y=s2; y < wh_s4; y++ ) { // s2=ss*2+1  // wh_s4=w_h+s4;   // time=0.41 16224 × 2464
    for ( y=s2; y < w_h-s2; y++ ) {
      
      
      ////////if( n0 <= n0_min ) { n0_min=n0; } ////////
      ////////if( n0 > n0_max ) { n0_max=n0; } ////////
      ////////n0++; ////////
      
      // p0=bytes_data+y;   d1=ReBuf+y;
      p0++;   d1++;
      // треугольная весовая функция, прямая фильтрация
      // ReBuf[y]=-ReBuf[y-2]+2*ReBuf[y-1]+ImBuf[y-2*s ]-2*ImBuf[y-ss]+ImBuf[y];
      *d1=-*(d1-2)+(*(d1-1)<<1)+*(p0-ss_2)-(*(p0-ss)<<1)+*p0;       // <<1=2*2
    } // y
    ///TIME_PRINT_
    ////////if (GrafT) { cout<<"n0_min="<<n0_min<<"    n0_max="<<n0_max<<"    w_h="<<w_h<<endl; } ////////
    
    
    //cout<<endl;  for ( y=0; y < s2*4; y++ ){cout<<"  "<<ReBuf[y];}  cout<<endl;
    //cout<<endl;  for ( y=w_h-ss; y < sizeBufInt; y++ ){cout<<"  "<<ReBuf[y];}  cout<<endl;
    
    ///TIME_START
    // обязательно обнуление конечного участка массива ReBuf для чистого старта обратного рекурсивного фильтра
    ///d1=ReBuf;
    ///for ( y=wh_s2; y < sizeBufInt; y++ ) { *(d1+y)=0; }  // wh_s2=wh+s2;   // time=0
    memset(ReBuf+4*wh_s2, 0, 4*(sizeBufInt-wh_s2));  // начало (указатель), значение, количество символов в байтах (длина) unsigned
    
    // второе инверсное применение треугольной весовой функции
    /////        p0=bytes_data+wh_s4;   d1=ReBuf+wh_s4;   d2=ImBuf+wh_s4;
    p0=bytes_data+w_h;   d1=ReBuf+wh_s4;   d2=ImBuf+wh_s4;
    /////        for ( y=wh_s4; y > 0; y-- ) {  // wh_s4=w_h+s4;  // time=0.53 16224 × 2464
    for ( y=w_h-s4; y > 0; y-- ) {
      //p0=bytes_data+y;   d1=ReBuf+y;   d2=ImBuf+y;
      p0--;  d1--;  d2--;
      // треугольная весовая функция, инверсная фильтрация
      // ImBuf[y]=-ImBuf[y+2]+2*ImBuf[y+1]+ReBuf[y+ss_2]-2*ReBuf[y+ss]+ReBuf[y];
      *d2=-*(d2+2)+(*(d2+1)<<1)+*(d1+ss_2)-(*(d1+ss)<<1)+*d1;          // <<1=2*
      // уменьнение динамического диапазона размытого серого до динамического диапазона байта (0-255)
      // bytes_data[y]=(ImBuf[y]*255)/ss_m4;  // >>12
      *p0=*d2/ss_m4;    //*p0=(d*255)/ss_m3;
    } // y
    ///TIME_PRINT_
    /**/
    
    //cout<<endl;  for ( y=0; y < s2*4; y++ ){cout<<"  "<<(unsigned short)bytes_data[y];}  cout<<endl;
    //cout<<endl;  for ( y=w_h-ss; y < sizeBufInt; y++ ){cout<<"  "<<(unsigned short)bytes_data[y];}  cout<<endl;
    
    //memset(ReBuf,0,sizeBuf);
    
    
    ///TIME_START
    // Поворот на -90°. Переупаковка (транспонирование) горизонтального массива строк в массив вертикальных строк.
    p0=bytes_data;   p1=bytes_data_1;   // index_=0;
    for ( x=0; x < w; x++ ) {    // time=0.37
      /////      p0++; // +x
      for ( y=0; y < w_h; y+=w ){
        // *(p1 + index_)=*(p0 + x + y);  index_++;  // index_+=dlt; int dlt=1; // for ( y=0; y < h; y++ ){
        *p1=*(p0+y);   p1++; // p1++;  сквозной индекс в цикле переупаковки    // *p1=*p0;   p1++;  p0+=w;
      } // y
      p0++; // +x
    } // x
    ///TIME_PRINT_
    /**/
    
    
    /*
     // ТЕСТ, поворот еще на +90° до +180°
     int w_=h;   // int h_=w;    // меняем местами w и h по любому
     //p0=bytes_data;   d1=ReBuf;       // возвращение в исходное положение
     p0=bytes_data;   p1=bytes_data_1;  // поворот еще на +90° до +180°, тест
     unsigned int index_=w_h; // сквозной индекс в цикле переупаковки
     for ( x=0; x < w_; x++ ) {    // time=0.45=0.25
     p1++; // +x
     for ( y=0; y < w_h; y+=w_ ){
     // *(p0 + index_)=*(d1 + x + y);  index_--; // index_+=dlt; int dlt=1;
     // *p0=*(d1+y) ;   p0++; // d1++;  // возвращение в исходное положение
     *p0=*(p1+y) ;   p0--; // d1++;    // поворот еще на +90°, до +180°, тест
     } // y
     } // x
     */
    
    //*******************************************************************************************
    
    // обнуление ImBuf-d2,  ReBuf-d1
    //memset(ImBuf,0,sizeBuf);      memset(ReBuf,0,sizeBuf);  // time=0.24 16224 × 2464
    
    
    /// Вертикальное размытие (blur) одномерным Гауссианом двухмерного массива данных (изображения) ///
    
    ///TIME_START
    // обязательно обнуление начального участка массива bytes_data_1 от 0 до s2+1 для чистого старта рекурсивного фильтра
    memset(bytes_data_1, 0, s2+1);
    
    // первое прямое применение треугольной весовой функции
    p1=bytes_data_1+s2;   d1=ReBuf+s2;
    for ( y=s2; y < wh_s4; y++ ) { // s2=ss*2+1  // wh_s4=w_h+s4;   // time=0.26  16224 × 2464
      //p0=bytes_data+y;   d1=ReBuf+y;
      p1++;   d1++;
      // треугольная весовая функция, прямая фильтрация
      // ReBuf[y]=-ReBuf[y-2]+2*ReBuf[y-1+ImBuf[y-2*s ]-2*ImBuf[y-ss]+ImBuf[y];
      *d1=-*(d1-2)+(*(d1-1)<<1)+*(p1-ss_2)-(*(p1-ss)<<1)+*p1;       // <<1=2*
      //*p1=*d1/ss_m2;
    } // y
    ///TIME_PRINT_
    
    ///for ( y=0; y < sizeBuf; y++ ) { bytes_data_1[y]=ReBuf[y]/ss_m2; }
    
    ///TIME_START
    // обязательно обнуление конечного участка массива ReBuf для чистого старта обратного рекурсивного фильтра
    ///d1=ReBuf;
    ///for ( y=wh_s2; y < sizeBufInt; y++ ) { *(d1+y)=0; }  // wh_s2=w_h+s2;  // time=0
    memset(ReBuf+4*wh_s2, 0, 4*(sizeBufInt-wh_s2));  // начало (указатель), значение, количество символов в байтах (длина) unsigned
    
    // второе инверсное применение треугольной весовой функции
    ///////      p1=bytes_data_1+wh_s4;   d1=ReBuf+wh_s4;   d2=ImBuf+wh_s4;
    p1=bytes_data_1+wh_s4;   d1=ReBuf+wh_s4;   d2=ImBuf+wh_s4;
    /////        for ( y=wh_s4; y > 0; y-- ) {
    for ( y=w_h-s4; y > 0; y-- ) { // wh_s4=w_h+s4;   // time=0.32  16224 × 2464
      //p0=bytes_data+y;   d1=ReBuf+y;   d2=ImBuf+y;
      p1--;  d1--;  d2--;
      // треугольная весовая функция, инверсная фильтрация
      // ImBuf[y]=-ImBuf[y+2]+2*ImBuf[y+1]+ReBuf[y+ss_2]-2*ReBuf[y+ss]+ReBuf[y];
      *d2=-*(d2+2)+(*(d2+1)<<1)+*(d1+ss_2)-(*(d1+ss)<<1)+*d1;          // <<1=2*
      // уменьнение динамического диапазона размытого серого до динамического диапазона байта (0-255)
      // bytes_data_1[y]=ImBuf[y]*255/ss_m4;  // >>12
      *p1=*d2/ss_m4;  // *(d2-3)=*(d2-3)/ss_m4;
    }
    ///TIME_PRINT_
    
    
    
    //*******************************************************************************************
    /**/
    
    //for ( y=6; y < sizeBuf; y++ ) { bytes_data_1[y-6]=bytes_data_1[y]; }
    
    
    ///TIME_START
    // Поворот на +90°. Возвращаем в исходное положение
    int w_=h;   // int h_=w;   // меняем местами w и h по любому
    p0=bytes_data;   p1=bytes_data_1;  // index_=0;
    for ( x=0; x < w_; x++ ) {    // time=0.25
      /////     p1++; // +x
      for ( y=0; y < w_h; y+=w_ ){
        //*(p0 + index_)=*(d1 + x + y);  index_--; // index_+=dlt; int dlt=1;
        *p0=*(p1+y);   p0++; // d1++;  сквозной индекс в цикле переупаковки // возвращение в исходное положение
        ///*p0=*(d2+y)/ss_m4;   p0++; // d1++;  сквозной индекс в цикле переупаковки // возвращение в исходное положение
      } // y
      p1++; // +x
    } // x
    /**/
    
    
    // освобождение массивов bytes_data_1, ImBuf,  ReBuf
    if ( bytes_data_1 !=NULL ) free(bytes_data_1);
    if ( ImBuf !=NULL ) free(ImBuf);
    if ( ReBuf !=NULL ) free(ReBuf);
    /**/
    
    TIME_PRINT_
    
    
    //-----------------------------------------------------------------------------------------------------------
    
    
  }//____________________________________________________________________________
  
  
  // работающая версия //
  
  /// ГОТОВАЯ  fast version Gaussian (blur) /// декабрь 2018
  
  //*****************************************************************************
  
  // функция размытия (blur) массива bytes_data двухмерным Гауссианом ( Gaussian ).
  // Сделана на основе gaussianT, но не подглючивает. Не много быстрее. Не используются боковые массивы,
  // поэтому в начале и в конце массива возможны белые однопиксельные полоски длинной в 2*s.
  
  void  GBitmap::gaussianF(int amplitude) {
    
    // s "радиус" (amplitude) Гауссиана в пикселях (s=2-64). Размер области усредннения это "диаметр" s+s Гауссиана в пикселях.
    // Например s=3 веса одномерной области усредннения выглядят примерно так:   000139931000
    // Входной массив bytes_data может быть как серым: от 0-черного до 255-белого, так и черно-белым: 0-черный 255-белый.
    // 255,255,255,255,255,0,255,255,255,255,255,255 - это псевдо графическая картинка с 1 черным pix на белым фоном.
    // bytes_data это unsigned char.
    
    /*
     /// Теория размытия (blur) битового массива (изображения) двухмерным Гауссианом. Реализованна функция. ///
     // Двухмерный Гауссиан использует фиксированную область усредннения в пикселях, где s ее "радиус"
     // Одномерные фильтры с прямоугольной и треугольной импульсной характеристикой (где k это s):
     // - прямоугольная рекурсивная весовая функция. Соответствует одномерному фильтру с прямоугольной импульсной характеристикой
     // y(n)=y(n-1)+x(n)-x(n-2k-1)
     // - треугольная рекурсивная весовая функция. Соответствует одномерному фильтру с треугольной импульсной характеристикой
     // y(n)=-y(n-2)+2y(n-1)+x(n-2k-2)-2x(n-k-1)+x(n)
     // Импульсная характеристика фильтра это его реакция на еденичный импульс. Удобно применять для отладки фильтра.
     // Рекурсивная весовая функция это удобная форма для дискретной (програмной) реализации соответствующего фильтра.
     // Если к одному и тому же массиву данных применить два раза подряд фильтр с треугольной импульсной характеристикой,
     // то это эквивалентно применению фильтра с гладкий импульсной характеристикой практически точно совпадающий
     // по форме с одномерным Гауссианом ( Gaussian ).
     
     // Если к двухмерному массиву данных применить одномерный Гауссианом сначала по горизонтали, а затем по вертикали,
     // то это эквивалентно применению двухмерного Гауссиана.
     // Для увеличения быстродействия, удобнее сначала выполнять горизонтальный прогон Гауссом, затем транспонировать массив,
     // опять горизонтальный прогон Гауссом и снова транспонирование массива ( транспонирование, т.е. поворот на +90°).
     // Отличная теория и реализация:
     // https://software.intel.com/en-us/articles/iir-gaussian-blur-filter-implementation-using-intel-advanced-vector-extensions
     */
    
    //TIME_START // time=0.53 сек,  w=4064 h=2472,  amplitude=4,  _Image2OCR/__Page_09___.png
    
    // time=0.024 сек   w=618,  h=880,  радиус=4, время выполнения прямо пропорционально площади изображения.
    // первые "s+s" и последние "s+s" пикселей изображения не защищены от краевых эффектов.
    
    if(amplitude==0)return;
    
    int x,y;
    int w,h;
    w=ncolumns;             // ширина массива  IMAGE WIDTH в пикселях
    h=nrows;                // высота массива  IMAGE HEIGHT в пикселях
    int w_h=w*h;            // размер массива
    int s=amplitude;        // s "радиус" (амплитуда) Гауссиана в пикселях. "Диаметр" Гауссиана равен s+s.
    int sizeInt= sizeof(int);
    
    // указатели
    uchar *p0=bytes_data;   // входной и выходной массив, 0-черный 255-белый
    uchar *bytes_data_1, *p1;
    uint  *ReBuf, *d1;
    uint  *ImBuf, *d2;
    // Массивы. Каждый элемент инициализируется в 0.
    uint sizeBuf=w_h+64;
    // массив функционально аналогичен bytes_data
    bytes_data_1 = (uchar*)calloc(sizeBuf, sizeof(uchar)); // p1
    // буферные массиввы для хранения промежуточных результатов прогона треугольной весовой функции
    ImBuf = (uint*)calloc(sizeBuf, sizeInt); // d1
    ReBuf = (uint*)calloc(sizeBuf, sizeInt); // d2
    // calloc(n,size); unsigned n; количество элементов unsigned size; длина каждого элемента в байтах
    
    // Массив. // таблица для нормировки Гауссиана по площади //
    //uint table[64]={1,1,16,74,226,537,1051,8,9,10,11,12,13,14,15};
    // Массив. // таблица для нормировки Гауссиана по площади //
    //                1,2,3, 4, 5, 6,  7,8,9,10,11,12,13,14
    ////////uint table[64]={1,1,4,19,45,86,147,8,9,10,11,12,13,14,15};
    
    // Ограничения на "радиус" Гауссиана в пикселях, s от 2 до 64.
    if ( s<3 ) s=2;   if ( s>64 ) s=64;
    ////////s=6;  // "радиус" Гауссиана в пикселях
    
    // переменная необходима для уменьшения динамического диапазона размытого серого
    // до динамического диапазона байта (0-255). Нормализует прямой и инверсный прогон.
    ////////int s_m4=table[s];
    int s_m4=s*s*s*s;
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
    if (GrafT) {
      cout<<"Сглаживание (blur) Гауссианом gaussianF()    радиус="<<s<<endl;
      cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h<<" пикселей"<<endl; }
    /*
     //  тест
     /////////////////////
     //            memset(bytes_data, 0, w_h);  // На Гауссиан нужно подавать 255 белая плашка, серое это текст
     //          memset(bytes_data+8, 0, w_h-16);    // тест 0 черная плашка для выяснения динамического диапазона не верно
     // 255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255
     
     //   255,255,255,255,255,0,255,255,255,255,255,255, это графическая картинка с одним черным pix и белым фоном
     //         for ( x=0; x < w_h; x++ ){ cout<<"   x="<<x<<" bytes_data="<<(ushort)bytes_data[x]<<endl; } cout<<endl;
     
     memset(bytes_data, 255, w_h);  // На Гауссиан нужно подавать 255 белая плашка, серое это текст
     bytes_data[w_h/2+w/2]=0;  //bytes_data[w_h/2+w/2+1]=0;
     /////////////////////
     */
    // Инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный.
    // Для реальной картинки полученной при открытии файла необходимо инверсия.
    ///for ( x=0; x < w_h; x++ ){ bytes_data[x]=~bytes_data[x]; }
    ///for ( x=0; x < w_h; x++ ){ bytes_data[x]=255-bytes_data[x]; }
    int w_h_64=w_h/sizeof(ulong);  // sizeof(ulong)=8
    ulong *bytes_data_64=(ulong*)bytes_data;    // приведение к ulong
    // Инвертируем одновременно по 8 байт. Последний участок массива длинной от 0 до 8 байт не инвертируется.
    for ( int x=0; x < w_h_64; x++ ) { bytes_data_64[x]=~bytes_data_64[x]; }
    int wh_=w_h_64*sizeof(ulong);
    // инверсия последнего участка массива длинной от 0 до 8 байт.
    for (int x=wh_; x<w_h; x++){ bytes_data[x]=~bytes_data[x]; }
    
    // exit(0);
    
    // вспомогательные переменные
    int  s2=s*2; // "диаметр" Гауссиана в пикселях
    int wh_s2=w_h-s2;
    
    
    //------------------------------------------------------------------------------------------------------------------
    
    /// Горизонтальное размытие (blur) одномерным Гауссианом двухмерного массива данных (изображения) ///
    
    
    // обязательное обнуление начального участка массива bytes_data от 0 до s2 для чистого старта прямого рекурсивного фильтра
    memset(bytes_data, 0, s2); // начало, значение, начало+конец в байтах // s2+1
    
    // первое горизонтальное применение прямой треугольной весовой функции
    p0=bytes_data+s2;   d1=ReBuf+s2;  // s2=s*2;   "радиус" Гауссиана в пикселях
    for (int x=0; x < wh_s2; x++ ) {  // wh_s2=w_h-s2;
      // треугольная весовая функция, прямая фильтрация
      // ReBuf[x]=-ReBuf[x-2]+2*ReBuf[x-1]+ImBuf[x-2*s ]-2*ImBuf[x-ss]+ImBuf[x];
      ///*d1=-*(d1-2)+(*(d1-1)<<1)+*(p0-ss_2)-(*(p0-ss)<<1)+*p0;       // <<1=2*2
      *d1=-*(d1-2)+(*(d1-1)<<1)+*(p0-s2)-(*(p0-s)<<1)+*p0;       // <<1=2*2
      // p0=bytes_data+x;   d1=ReBuf+x;
      p0++;   d1++;
    } // x
    //for ( x=0; x < w_h; x++ ){ cout<<"   x="<<x<<" bytes_data="<<ReBuf[x]<<endl; } cout<<endl;
    //for ( x=0; x < w_h; x++ ){ cout<<"   x="<<x<<" ReBuf="<<ReBuf[x]<<endl; } cout<<endl; // w_h
    
    // обязательное обнуление конечного участка массива bytes_data от 0 до s2 для чистого старта обратного рекурсивного фильтра
    memset(bytes_data+w_h-s2, 0, s2);
    // обязательное обнуление конечного участка массива ReBuf для чистого старта обратного рекурсивного фильтра
    memset(ReBuf+w_h-s2, 0, s2*sizeInt);  // начало (указатель), значение, количество символов в байтах (длина) *sizeof(uint)
    // НЕ обязательное обнуление начального участка массива ReBuf для симметрии
    //memset(ReBuf, 0, s2*sizeInt);
    
    //for ( x=0; x < w_h; x++ ){ cout<<"   x="<<x<<" bytes_data="<<(ushort)bytes_data[x]<<endl; } cout<<endl;
    //for ( x=0; x < w_h; x++ ){ cout<<"   x="<<x<<" ReBuf="<<ReBuf[x]<<endl; } cout<<endl; // w_h
    
    
    // второе горизонтальное применение инверсной треугольной весовой функции
    d1=ReBuf+w_h-s2;   d2=ImBuf+w_h-s2;   p0=bytes_data+w_h-s2;
    for (int x=0; x < wh_s2; x++ ) {
      // треугольная весовая функция, инверсная фильтрация
      // ImBuf[y]=-ImBuf[y+2]+2*ImBuf[y+1]+ReBuf[y+ss_2]-2*ReBuf[y+ss]+ReBuf[y];
      *d2=-*(d2+2)+(*(d2+1)<<1)+*(d1+s2)-(*(d1+s)<<1)+*d1;          // <<1=2*
      // уменьнение динамического диапазона размытого серого до динамического диапазона байта (0-255)
      // bytes_data[y]=(ImBuf[y]*255)/ss_m4;  // >>12
      *p0=*d2/s_m4;  //    //*p0=(d*255)/ss_m3;  ///////// (s*s*s)
      //p0=bytes_data+y;   d1=ReBuf+y;   d2=ImBuf+y;
      p0--;  d1--;  d2--;
    } // x
    
    //for ( x=0; x < w_h; x++ ){ cout<<"   x="<<x<<" bytes_data="<<(ushort)bytes_data[x]<<endl; } cout<<endl;
    //for ( x=0; x < w_h; x++ ){ bytes_data[x]=~bytes_data[x]; }
    //for ( x=0; x < w_h; x++ ){ bytes_data[x]=255-bytes_data_1[x]; }
    //------------------------------------------------------------------------------------------------------------------
    
    // Поворот массива на 90°.
    
    // Переупаковка (транспонирование) массива bytes_data. Замена вертикальных строк массива горизонтальными строками.
    p0=bytes_data;   p1=bytes_data_1;
    for ( x=0; x < w; x++ ) {    // time=0.37
      for ( y=0; y < w_h; y+=w ){
        *p1=*(p0+y);   p1++; // p1++;  сквозной индекс в цикле переупаковки
      } // y
      p0++;
    } // x
    
    //for ( x=0; x < w_h; x++ ){ cout<<"   x="<<x<<" bytes_data="<<(ushort)bytes_data_1[x]<<endl; } cout<<endl;
    //for ( x=0; x < w_h; x++ ){ bytes_data[x]=~bytes_data_1[x]; }
    
    //------------------------------------------------------------------------------------------------------------------
    
    /// Вертикальное размытие (blur) одномерным Гауссианом двухмерного массива данных (изображения) ///
    
    // обязательное обнуление начального участка массива bytes_data_1 от 0 до s2 для чистого старта рекурсивного фильтра
    memset(bytes_data_1, 0, s2); // s2+1
    // обнуление массивов ImBuf,  ReBuf
    memset(ImBuf,0,sizeBuf*sizeInt);      memset(ReBuf,0,sizeBuf*sizeInt);  // time=0.24 16224 × 2464
    
    //for ( x=0; x < w_h; x++ ){ bytes_data[x]=bytes_data_1[x]; }
    
    // первое вертикальное применение треугольной прямой весовой функции
    p1=bytes_data_1+s2;   d1=ReBuf+s2;
    for (int x=0; x < wh_s2; x++ ) { // wh_s2=w_h-s2;
      // треугольная весовая функция, прямая фильтрация
      // ReBuf[x]=-ReBuf[x-2]+2*ReBuf[x-1]+ImBuf[x-2*s ]-2*ImBuf[x-ss]+ImBuf[x];
      *d1=-*(d1-2)+(*(d1-1)<<1)+*(p1-s2)-(*(p1-s)<<1)+*p1;       // <<1=2*2
      //p0=bytes_data+x;   d1=ReBuf+x;
      p1++;   d1++;
    } // x
    
    //for ( x=0; x < w_h; x++ ){ cout<<"   x="<<x<<" bytes_data="<<ReBuf[x]<<endl; } cout<<endl;
    //for ( x=0; x < w_h; x++ ){ bytes_data[x]=~ReBuf[x]; }
    
    // обязательное обнуление конечного участка массива bytes_data_1 от 0 до s2 для чистого старта обратного рекурсивного фильтра
    memset(bytes_data_1+wh_s2, 0, s2);
    // обязательное обнуление конечного участка массива ReBuf для чистого старта обратного рекурсивного фильтра
    memset(ReBuf+wh_s2, 0, s2*sizeInt);  // начало (указатель), значение, количество символов в байтах (длина) unsigned
    // НЕ обязательное обнуление начального участка массива ReBuf для симметрии
    //memset(ReBuf, 0, s2*sizeInt);
    
    //for ( x=0; x < w_h; x++ ){ bytes_data[x]=~ReBuf[x]; }
    
    // второе вертикальное применение инверсноей треугольной весовой функции
    d1=ReBuf+w_h-s2;   d2=ImBuf+w_h-s2;   p1=bytes_data_1+w_h-s2;
    for (int x=0; x < wh_s2; x++ ) {
      // треугольная весовая функция, инверсная фильтрация
      // ImBuf[y]=-ImBuf[y+2]+2*ImBuf[y+1]+ReBuf[y+ss_2]-2*ReBuf[y+ss]+ReBuf[y];
      *d2=-*(d2+2)+(*(d2+1)<<1)+*(d1+s2)-(*(d1+s)<<1)+*d1;          // <<1=2*
      // уменьнение динамического диапазона размытого серого до динамического диапазона байта (0-255)
      // bytes_data[y]=(ImBuf[y]*255)/ss_m4;  // >>12
      *p1=*d2/s_m4;  //    //*p0=(d*255)/ss_m3;  ///////// (s_m4) (s*s*s)
      //p0=bytes_data+y;   d1=ReBuf+y;   d2=ImBuf+y;
      p1--;  d1--;  d2--;
    } // x
    
    //for ( x=0; x < w_h; x++ ){ cout<<"   x="<<x<<" bytes_data="<<(ushort)bytes_data_1[x]<<endl; } cout<<endl;
    //for ( x=0; x < w_h; x++ ){ bytes_data[x]=~bytes_data_1[x]; }
    
    
    //------------------------------------------------------------------------------------------------------------------
    
    // Поворот массива на 90° (возвращение в исходное состояние).
    
    // Переупаковка (транспонирование) массива bytes_data. Замена вертикальных строк массива горизонтальными строками.
    // Инверсия уровней выходного массива из внутреннего формата программы 0-белый 255-черный в общепринятый стандарт 0-черный 255-белый,
    int w_=h; // меняем местами w и h по любому
    p0=bytes_data;   p1=bytes_data_1;
    for ( x=0; x < w_; x++ ) {    // time=0.37
      for ( y=0; y < w_h; y+=w_ ){
        *p0=~(*(p1+y));   p0++; // p1++;  сквозной индекс в цикле переупаковки // Инверсия  *p0=~(*(p1+y)); // *p0=255-*(p1+y);
      } // y
      p1++;
    } // x
    /**/
    
    //for ( x=0; x < w_h; x++ ){ cout<<"   x="<<x<<" bytes_data="<<(ushort)bytes_data[x]<<endl; } cout<<endl;
    //for ( x=0; x < w_h; x++ ){ bytes_data[x]=bytes_data[x]; }
    
    
    /*
     int sum=0;
     for ( x=0; x < w_h; x++ ){ sum+=(ushort)((uchar)(~bytes_data[x])); }
     cout<<"sum="<<sum<<endl;
     
     //int col1 = max(inX1, 0);
     int max=0;
     for ( x=0; x < w_h; x++ ){
     if ( (ushort)((uchar)(~bytes_data[x])) > max ) { max=(ushort)((uchar)(~bytes_data[x])); }
     }
     cout<<"max="<<max<<endl;
     
     //for ( x=0; x < 16; x++ ){ cout<<"   x="<<x<<" ~bytes_data="<<255-((ushort)bytes_data[x])<<endl; } cout<<endl;
     for ( x=w_h/2+w/2-s2; x < w_h/2+w/2+s2; x++ ){ cout<<"   x="<<x<<" ~bytes_data="<<(ushort)((uchar)(~bytes_data[x]))<<endl; } cout<<endl;
     */
    // Параметр связан с полушириной "c" колокола графика следующим образом: w=c*2*sqrt(2ln)=c*2.35482    c=w/2.35482;
    // При этом интеграл по всей числовой прямой (в связи со свойствами экспоненциальной функции) — константа[1]: sum=a*c*sqrt(2pi)=a*c*2,50663
    // sum=a*w*2,50663/2.35482=a*w*1,06447
    
    /*
     for ( x=0; x < w_h; x++ ){
     if ( (ushort)((uchar)(~bytes_data[x])) !=0 ) cout<<"   x="<<x<<" ~bytes_data="<<(ushort)((uchar)(~bytes_data[x]))<<endl;
     } cout<<endl;
     */
    //uchar b=~254;
    //cout<<"   (ushort)b="<<(ushort)((uchar)(~254))<<endl;
    
    //------------------------------------------------------------------------------------------------------------------
    
    // освобождение массивов bytes_data_1, ImBuf,  ReBuf
    if ( bytes_data_1 !=NULL ) free(bytes_data_1);
    if ( ImBuf !=NULL ) free(ImBuf);
    if ( ReBuf !=NULL ) free(ReBuf);
    
    //TIME_PRINT_
    
    
  }//____________________________________________________________________________
  
  
  // ГОТОВАЯ version  21 февраля 2019
  
  //*****************************************************************************
  
  // Функция размытия (blur) серого или битового массива bytes_data усреднением скользящим квадратом
  // размером BASExBASE на основе массива интегральных сумм integralImg.
  void  GBitmap::FilterIntegral(int BASE) {
    
    //  * Идея *
    // Функция FilterIntegral() по коду аналогична функции binarisationF(), хотя совершенно разные по результату примененич.
    // В обоих функциях выполняется усреднение исходной графической картинки скользящим квадратом размером BASExBASE.
    // В функции адаптивного порога binarisationF() от этого среднего отсчитываетя порог Tr как число процентов и
    // выполняутся бинаризация.
    // В функции "blur"  FilterIntegral() размытие графической картинки выполняется этим же скользящим квадратом размером BASExBASE.
    
    //  * Реализация *
    // В обоих функциях усреднение исходной графической картинки выполняется на базе массива интегральных сумм integralImg.
    // Далее идет переполнение: uint sum, суммы серого по всей площади исходной графической картинки.
    
    //  * Особенности применения *
    // В этой версии расширин максимальный размер обрабатываемой картинки за счет суммирования в массиве интегральных сумм
    // белого с кодировкой "0", а не "255" как раньше. Белого в обрабатываемой картинке на порядок больше чем черного.
    // Переполнение uint sum, как суммы серого по всей площади, наступает при больших размерах графической картинки.
    // Теперь практический максимум обрабатываемого размера 24960*4620 и более.
    // 1 апреля 2019.
    
    if(BASE==0)return;
    
    
    // Check arguments and init variables
    short w=ncolumns;   // ширина массива   IMAGE_WIDTH
    short h=nrows;      // высота массива   IMAGE_HEIGHT
    int w_h=w*h;        // размер массива   IMAGE_SIZE
    
    
    //TIME_START // time=0.165 сек,  w=4064 h=2472,  _Image2OCR/__Page_09___.png
    
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
    if (GrafT) {
      cout<<"Функция размытия (blur) скользящим квадратом FilterIntegral    BASE="<<BASE<<endl;
      cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
    
    
    // ограничения на размер буквы BASE в пикселях, где
    // BASE ориентировачно средний размер буквы или строки по всей странице, в Tenjur=46.
    if (BASE < 2) BASE = 2;   if (BASE > 128) BASE = 128;
    
    
    // ОБНУЛЕНИЕ border
    ///////variationBorder(0, s2-5);
    
    ///////invert();
    
    
    /////////////////////////////////////////////////////////////////////////////
    
    // create the integral image. //
    // интегральная яркость, integrated brightness. //
    
    
    // входной серый и выходной ч.б. массивы, 0-черный 255-белый
    ///uchar *p0=bytes_data; //глобальный массив
    
    // массив интегральных сумм
    uint *integralImg = (uint*)malloc(w_h*sizeof(uint*));
    
    // выход в случае отсутствия свободной памяти запрашиваемого размера.
    if (integralImg==NULL) {DC("integralImg"); return;}
    
    
    // Подсчет интегральных сумм яркостей для работы скользящего суммирующего квадрата площадью S*S. //
    
    uchar *p0 = bytes_data;
    uchar *d0;
    uint  *p1 = integralImg;
    uint  *d1;
    uint sum=0; // сумма серого (сумма яркостей) папавшая в площадь квадрата.
    
    //*
    // Обработка нулевой строки y=0; (первой по счету).
    for (int x=0; x<w; x++)
    {
      // подсчет интегральных сумм яркостей для работы скользящего суммирующего квадрата S*S.
      sum+=255-*(p0+x);   // sum+=255-bytes_data[x];  // sum+= *p0;   p0++;
      *(p1 + x) = sum;    // integralImg[x]=sum;  // *p1 = sum;   p1++;
    } //x
    
    // Обработка всех остальных строк y=1; и т.д.
    for (int y=1; y<h; y++)
    {
      // обнуляем сумму в этом столбце // reset this column sum.
      sum=0;
      // вспомогательные переменные для увеличения быстродействия.
      p0+=w;  // p0 = bytes_data + y*w;
      d0=p0;  // сохраняем для выполнения цикла по "x"
      p1+=w;  // p1 = integralImg + y*w;
      d1=p1;  // сохраняем для выполнения цикла по "x"
      
      for (int x=0; x<w; x++)
      {
        // подсчет интегральных сумм яркостей для работы скользящего суммирующего квадрата S*S.
        sum+=255-*d0;        // sum+=255-*(p0 + x);         // sum+=255-bytes_data[y*w + x];
        *d1 = *(d1-w) + sum; // *(p1+x) = *(p1+x-w) + sum;  // integralImg[y*w + x]=integralImg[y*w + x - w] + sum;
        d0++;                // p0 = bytes_data + y*w + x;
        d1++;                // p1 = integralImg + y*w + x;
        ///             cout<<"  y="<<y<<"  x="<<x<<"  *(p0 + x)="<<(short)*(p0 + x)<<"  sum="<<sum<<"  *(p1 + x)="<<*(p1 + x)<<endl; // /255
      } //x
    } //y
    //*/
    
    /////////////////////////////////////////////////////////////////////////////////
    
    //*
    
    // Усреднение.//
    
    int s2=BASE/2; // половина стороны суммирующего квадрата
    if (GrafT) {cout<<"  BASE="<<BASE<<"  s2+s2="<<s2+s2<<endl;}
    
    // вспомогательные переменные, для увеличения быстродействия.
    uint count = (s2+s2)*(s2+s2); // площадь суммирующего квадрата count=S*S (не заходит за border).
    uint count255 = count*255;
    
    int s2_w=s2*w;  // s2 это половина стороны суммирующего квадратапо по оси "x", s2_w соответственно по оси "y".
    // border "b" ограничивает область сканирования текста суммирующим квадратом, предотвращая выход за граници массива, b>=s2.
    int b=s2+1;     // border по оси "x", с запасом в 1 pix ( +1 ). /////
    int b_w=b*w;    // border по оси "y", с запасом в 1 pix ( +w ).
    
    // *p1-*p4 и *d1-*d4 указатели на координаты углов суммирующего квадрата.
    uint *p2, *p3, *p4;
    uint *d2, *d3, *d4;
    uint *p;
    
    
    // Учет border в начале цикла.
    p0 = bytes_data + b + b_w; // указатель на обрабатываемый серый пиксель.
    p = integralImg + b + b_w; // указатель на центр суммирующего квадрата (S*S region), от него отсчитывается +-s2.
    // b это начальное смещение цикла по "x" т.е. border, при этом цикл начинается с "0".
    // b_w это начальное смещение цикла по "y" т.е. border, при этом цикл начинается с "0".
    // Учет border в конце цикла.
    int w2b=w-b-b;   // размер страници в pix по "y" минус border.
    int h2b=h-b-b;   // размер страници в pix по "x" минус border.
    
    // Задание координат углов суммирующего квадрата (border уже учетен).
    
    // указатель на левый верхний угол суммирующего квадрата.
    p1 = p - s2 - s2_w;
    // -s2 это смещение по "x" в "-" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix
    
    // указатель на правый верхний угол суммирующего квадрата.
    p2 = p + s2 - s2_w;
    //  s2 это смещение по "x" в "+" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix.
    
    // указатель на левый нижний угол суммирующего квадрата.
    p3 = p - s2 + s2_w;
    // -s2 это смещение по "x" в "-" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix.
    
    // указатель на правый нижний угол суммирующего квадрата.
    p4 = p + s2 + s2_w;
    //  s2 это смещение по "x" в "+" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix.
    
    
    for (int y=0; y<h2b; y++){ // h2b1=h-b-b;
      
      d0=p0;  d1=p1;  d2=p2;  d3=p3;  d4=p4; // сохраняем указатели *p0-*p4 для выполнения цикла по "x"
      
      for (int x=0; x<w2b; x++){ // w2b1=w-b-b;
        
        // сумма серого папавшая в площадь квадрата S*S.
        // I(x,y)=s(x2,y2)-s(x1,y2)-s(x2,y1)+s(x1,x1)
        // sum = integralImg[y*w + x - s2*w - s2] - integralImg[y*w + x - s2*w + s2]
        // - integralImg[y*w + x + s2*w - s2] +  integralImg[y*w + x + s2*w + s2];
        sum =*d1 - *d2 - *d3 + *d4;
        
        /// Усреднение ///
        //*d0=255-sum/count;
        *d0=(count255-sum)/count; // наверно более мелкие градации уровней.
        // *p0=sum; TECT на визуализацию области скользящего квадрата.
        
        d0++;  d1++;   d2++;   d3++;   d4++; // d0 = bytes_data + y*w + x; // d1 = integralImg + y*w + x;
        
      } // x
      
      p0+=w;  p1+=w;  p2+=w;  p3+=w;  p4+=w; // p0 = bytes_data + y*w; // p1 = integralImg + y*w;
      
    }  // y
    //*/
    
    
    // освобождение массива integralImg.
    if ( integralImg !=NULL ) free(integralImg);
    
    //TIME_PRINT_
    
    
  }//____________________________________________________________________________
  
  
  
  
  
  
  
  
}
