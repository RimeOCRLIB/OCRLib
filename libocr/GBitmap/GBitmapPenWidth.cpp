//  Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .

#include "GBitmap.h"

#ifdef ASM_OS64_SSE42_POPCNT_ATT
#include <smmintrin.h>  // для_mm_popcnt_u64
#endif

namespace ocr{
  
  //*****************************************************************************
  
  
  
  // Текущая функция. // начата 30 января 2019
  
  // Тестирование распознования макета.
  // float GBitmap::TextDetect() {
  
  //_____________________________________________________________________________
  
  
  
  
  
  // Рабочая функция, но пока не применялась. // начата 16 февраля 2019,  не большие изменения 1 апреля 2019.
  
  // Функция вычисляет, для каждой точки графического текста, среднею (по квадрату или региону) толщину штриха.
  // Возвращает массив в котором для каждого пиксела записано среднее значение толщины штриха по квадрату размером BASExBASE).
  
  void  GBitmap::LineWidthRegion(int BASE) {
    
    
    //  * Особенности применения *
    // Перед применением функции текст должен быть бинаризован, например с помощью функции адаптивного порога binarisationF(96, 14);
    
    //  * Идея 1 *
    // Вычисление по площади скользящего квадрата средней толщины штриха.
    //  * Идея 1 *  пока не реализовано АДАПТИРОВАТЬ ТЕКСТ
    // Адаптивное сглаживание.
    // Идея состоит в том, что степень сглаживания графического текста обратно пропорциональна степени
    // "курчавости" текста (числу Мадельброта) вычесленному в небольшой области вокруг каждой точки графического текста.
    //  * Реализация *
    // Скользящия квадратная область S*S пробегает по всему исходному битовому массиву.
    // Для каждой точки этого массива в квадратной области S*S вычисляется две величины:
    // - площадь ( суммарное количество черных пикселей попавших в область S*S )
    // - длина периметра или контура ( суммарное количество переходов из черного в белое и из белого в черное,
    // попавших в область S*S, по вертикали и по горизонтали ). Вычисляется сдвигом битового регистра длинной в w*h
    // Отношение длинны периметра (контура) "P" к площади "S" называется числом Мадельброта
    // Адаптивно сглаживаем картинку с управлением от вычисленного числа Мадельброта.
    // Для увеличения быстродействия величины площади и длинны периметра вычисляются по предпросчитанному интегрольному массиву.
    // В этой функции эта идея не реализованна.
    
    // * Идея 2 *
    // Вычисление средней толщины штриха по всему тексту или его области фиксированного размера BASExBASE.
    // Считаем что весь текст это огромный сильно вытянутый прямоугольник с площадью "S" и периметром "P"
    // Площадь такого прямоугольника размером L на D равна S=D*P/2; (при d<<P), где
    // "L" длина прямоугольника по широкой стороне, а "D" ширина прямоугольника по узкой стороне т.е. среднея толщина штриха.
    // Отсюда D*P/2=S;  окончательно D=2*S/P; где "D" float.
    // Если учитывать соразмерность "D" и "P", то придется решать квадратное уравнение вида D*D-D*P/2+S=0;
    // Площадь прямоугольника "S" равна площади черного по всей исходной картинке.
    // Длинна периметра "P" равна площади контуров (толщиной в 1pix ) по всей исходной картинке.
    // Выделение контуров реализованно при помощи простейшего пространственного Лапласиана в виде матрици.
    
    // Вывод формулы квадратного уравнения для вычисления средней толщины штриха.
    // Площать черного по всему тексту "S" и длина периметра "P" этого черного, равна площади
    // огромного сильно вытянутого прямоугольника с такой же площадью "S" и тем же периметром "P".
    // "D" искомая ширина прямоугольника.
    // D*(P-2*D)/2=S; >> D*(P-2*D)=S*2; >> -2*D*D+D*P=S*2; >> 2*D*D-P*D+2*S=0; >> D*D-D*P/2+S=0;
    
    // * Идея 3 *
    
    // Мандельброт Б. Фрактальная геометрия природы. — Москва: Институт компьютерных исследований, 2002, 656 стр.
    // 12 СООТНОШЕНИЯ МЕЖДУ ДЛИНОЙ, ПЛОЩАДЬЮ И ОБЪЕМОМ
    
    // После операции "~"  поразрядная инверсия компилятору необходимо напомнить, что число было изначально uchar
    // например bytes_data[x]=((uchar)(~bytes_data[x]))/2;
    
    
    
    int w=ncolumns;     // ширина массива   IMAGE_WIDTH
    int h=nrows;        // высота массива   IMAGE_HEIGHT
    int w_h=w*h;        // размер массива   IMAGE_SIZE
    uint  sumT=0;       // сумма единиц (площадь черного) папавшая в площадь квадрата.
    //ulong  sumT=0;       // сумма единиц (площадь черного) папавшая в площадь квадрата.
    ulong sumP=0;       // сумма серого (длина контура) папавшая в площадь квадрата.
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
    if (GrafT) {
      cout<<"Среднее значение толщины штриха по региону LineWidthRegion()"<<endl;
      cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h<<" пикселей"<<endl; }
    
    
    // Функция преобразования серого массива в битовый массив (адаптивный порог).
    //binarisationF(98, 14); // дописать бордер
    binarisation(96, 4);
    
    TIME_START
    
    // Функция быстро инвертирует массив bytes_data.  // FilterIntegral(int BASE) {
    invert();
    
    // ОБНУЛЕНИЕ border
    // variationBorder(255, 64);  // 255, 8
    
    
    // входной серый и выходной ч.б. массивы, 0-черный 255-белый (без инверсии)
    // *p0=bytes_data; //глобальный массив.
    
    // Массив интегральных сумм. Каждый элемент инициализируется в 0.
    // первый uint каждого ulong массива является интегральной суммой площади черного
    // второй uint каждого ulong массива является интегральной суммой площади однопиксельных контуров.
    ulong *integralImg = (ulong*)calloc( w_h+64, sizeof(ulong) ); // инициализируется в 0 увеличивая время с time=0.107448 до time=0.186362
    
    // выход в случае отсутствия свободной памяти запрашиваемого размера.
    if (integralImg==NULL) {DC("integralImg"); return;}
    
    // указатели на массивы.
    uchar *p0=bytes_data; //глобальный массив.
    uchar *d0;
    ulong *p1=integralImg;
    ulong *d1;
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    
    //*
    // ЗАПОЛНЕНИЕ МАССИВА ИНТЕГРАЛЬНЫХ СУММ ПЛОЩАДИ ЧЕРНОГО И ДЛИННЫ КОНТУРОВ. //
    // для работы скользящего суммирующего квадрата площадью S*S. //
    
    int w_1=w+1;
    int w_h_=w_h-w_1;
    
    // Вычисление длинны внешнего контура (периметра), проведенного вокруг черного, по всей исходной картинке. //
    
    // обнуление участка от 0 до w_1 включительно
    memset(integralImg, 0, w_1);    // тест черная плашка
    
    // Вычисление длинны контуров вокруг черного на исходной картинке (ч.б. изображение превращается в контурное).
    for (int x=w_1; x<w_h_; x++){
      d0=bytes_data+x;
      // если текущий пиксель "d1" исходной картинки черный.
      if (*d0==255 ) { // 255
        
        // Вычисление длинны внешнего контура (периметра), проведенного вокруг черного, по всей исходной картинке.
        // Используется Матрица простейшего пространственного Лапласиана:
        
        //      d2                -w                  *(d0-w)
        
        // d8   d0   d4      -1        +1        *(d0-1)   *(d0+1)
        
        //      d6                +w                  *(d0+w)
        
        // Если центральная точка исходной картинки d1 массива bytes_data черная (255), то любой окружающей ее пиксел
        // матрици (d2, d4, d6, d8) равный нулю, записывается соответственно в этот же массив как серая единица (96), постепенно
        // вырисовывая серый контур (серый для наглядности). Запись в массив, а не непосредственный подсчет длинны контура,
        // позвояет устранить влияние на длинну контура, наложения серых единиц (от соседних центральных точек d1).
        if(*(d0-w)==0)*(d0-w)=96;  if(*(d0-1)==0)*(d0-1)=96;  if(*(d0+1)==0)*(d0+1)=96;  if(*(d0+w)==0)*(d0+w)=96;
        
        // ПЕРЕДЕЛАТЬ ??? на
        // d2++;  d8++;   d0++;   d4++;   d6++; // d0 = bytes_data + y*w + x;
        
      } // if
      
    } // x
    //*/
    
    // Функция быстро инвертирует массив bytes_data.
    //invert();  // ТЕСТ
    
    ///bytes_data[32]=96;  // ТЕСТ
    
    //*
    // Заполнение массива интегральных сумм ulong по площади черного и длинне контуров.
    // Обработка нулевой строки по "x"  для y=0; (первой по счету).
    p0=bytes_data;
    p1=integralImg;
    uchar b_data;
    for (int x=0; x<w; x++)
    {
      b_data=*p0; // b_data=bytes_data[x];
      
      // Вычисление интегральных сумм по площади черного и заполнение первого uint в массиве ulong integralImg.
      if (b_data==255) {
        sumT++;     // подсчет единиц (количество черного) по "x" для первого uint. /////// sumT мб uint
      }
      
      // Заполнение массива интегральных сумм по площади серого (по длинне контуров) и заполнение второго uint.
      if (b_data==96) {
        sumP+=0x0000000100000000; // подсчет единиц (количество серого) по "x" сразу для второго uint.
        // 0x0000000100000000 это единица во втором uint.
        b_data=0; // и убираем серое в исходном массиве.
      }
      
      // заполнение первого uint и второго uint.
      *p1 = (sumT + sumP)*4;    // integralImg[x]=sumT + sumP;
      
      // Инверсия уровней внутреннего формата программы 0-белый 255-черный, в общепринятый стандарт 0-черный 255-белый.
      *p0=~b_data;
      //cout<<"   *p1="<<*p1<<endl;
      
      p0++;
      p1++;
      
    } //x
    if (GrafT) {cout<<"   sumT="<<sumT<<"   sumP="<<sumP<<endl;}
    
    //*
    // Заполнение массива интегральных сумм ulong по площади черного и длинне контуров.
    // Обработка по "x" и "y" всех остальных строк для y=1,2,3 и т.д.
    p0=bytes_data;
    p1=integralImg;
    for (int y=1; y<h; y++)
    {
      // обнуляем суммы.
      sumT=0;     sumP=0;
      // вспомогательные переменные для увеличения быстродействия.
      p0+=w;  // p0 = bytes_data + y*w;
      d0=p0;  // сохраняем для выполнения цикла по "x"
      p1+=w;  // p1 = integralImg + y*w;
      d1=p1;  // сохраняем для выполнения цикла по "x"
      
      for (int x=0; x<w; x++)
      {
        b_data=*d0; // b_data=bytes_data[x];
        
        // Вычисление интегральных сумм по площади черного и заполнение первого uint в массиве ulong integralImg.
        if (b_data==255) {
          sumT++;     // подсчет единиц (количество черного) по "x" для первого uint.
        }
        
        // Заполнение массива интегральных сумм по площади серого (по длинне контуров) и заполнение второго uint.
        if (b_data==96) {
          sumP+=0x0000000100000000;  // подсчет единиц (количество серого) по "x" сразу для второго uint.
          // 0x0000000100000000 это единица во втором uint.
          b_data=0; // и убираем серое в исходном массиве.
        }
        
        // подсчет единиц (количество серого) по "y" с помощью *(d1-w) и заполнение второго uint.
        ///*d1 = *(d1-w) + sumT + sumP;    // integralImg[y*w + x]=integralImg[y*w + x - w] + sumT + sumP;
        *d1 = *(d1-w) + (sumT + sumP)*4;    // integralImg[y*w + x]=integralImg[y*w + x - w] + sumT + sumP;
        ///*d1 = (sumT + sumP)<<2 + *(d1-w);    // integralImg[y*w + x]=integralImg[y*w + x - w] + sumT + sumP;
        // <<2 (*4) формирование защитного интервала для последующих двух вычитоний при вычислении площади.
        // складывая несколько ulong мы паралельно и не зависимо складываем соответствующие uint составляющие эти ulong.
        
        // Инверсия уровней внутреннего формата программы 0-белый 255-черный, в общепринятый стандарт 0-черный 255-белый.
        /////                *d0=~b_data;
        
        //cout<<*d1<<endl;
        //cout<<"   *d0="<<(ushort)*d0<<endl;
        
        d0++;       // d0 = bytes_data + y*w + x;
        d1++;       // d1 = integralImg + y*w + x;
        
      } //x
    } //y
    /// ~ потенциально инверсия действует не по всему тексту, следи за w_h_
    //*/
    /**/
    
    /////////////////////////////////////////////////////////////////////////////
    
    // ПОДСЧЕТ ПЛОЩАДИ ЧЕРНОГО И ДЛИННЫ КОНТУРОВ В КВАДРАТНОЙ ОБЛАСТИ. //
    
    //*
    
    // Адаптивный порог. //
    // perform thresholding. //
    
    ///int Tr=90; // не нужен
    // ограничения на процент от порога  Tr.
    ///if (Tr < 16) Tr = 16;   if (Tr > 99) Tr = 99;
    
    // ограничения на размер буквы BASE в пикселях.
    if (BASE < 4) BASE = 4;   if (BASE > 128) BASE = 128;
    
    // Оставлено для теста
    ///int S=BASE*35/10;  // S в 3,5 больше размера буквы или строки //////////
    ///int s2=S/2; // половина стороны суммирующего квадрата //////////
    int s2=BASE/2; // половина стороны суммирующего квадрата
    
    // вспомогательные переменные, для увеличения быстродействия.
    ///uint count = (s2+s2)*(s2+s2); // площадь суммирующего квадрата count=S*S (не заходит за border).;
    
    int s2_w=s2*w;  // s2 это половина стороны суммирующего квадратапо по оси "x", s2_w соответственно по оси "y".
    // border "b" ограничивает область сканирования текста суммирующим квадратом, предотвращая выход за граници массива, b>=s2.
    int b=s2+1;     // border по оси "x", с запасом в 1 pix ( +1 ). 1 апреля 2019. ///////////////////////////////////////////
    int b_w=b*w;    // border по оси "y", с запасом в 1 pix.
    if (GrafT) {cout<<"   BASE="<<BASE<<"  s2="<<s2<<"  b="<<b<<endl;}
    
    // *p1-*p4 и *d1-*d4 указатели на координаты углов суммирующего квадрата.
    ulong *p2, *p3, *p4;
    ulong *d2, *d3, *d4;
    ulong *p;
    
    
    // Учет border в начале цикла.
    p0 = bytes_data + b + b_w; // указатель на обрабатываемый серый пиксель.
    p = integralImg + b + b_w; // указатель на центр суммирующего квадрата (S*S region), от него отсчитывается +-s2.
    // b это начальное смещение цикла по "x" т.е. border, при этом цикл начинается с "0".
    // b_w это начальное смещение цикла по "y" т.е. border, при этом цикл начинается с "0".
    // Учет border в конце цикла.
    int w2b=w-b-b;   // размер страници в pix по "y" минус border. 1 апреля 2019.
    int h2b=h-b-b;   // размер страници в pix по "x" минус border.
    
    // Задание координат углов суммирующего квадрата (border уже учетен).
    
    // указатель на левый верхний угол суммирующего квадрата.
    p1 = p - s2 - s2_w;
    // -s2 это смещение по "x" в "-" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix
    
    // указатель на правый верхний угол суммирующего квадрата.
    p2 = p + s2 - s2_w;
    //  s2 это смещение по "x" в "+" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix.
    
    // указатель на левый нижний угол суммирующего квадрата.
    p3 = p - s2 + s2_w;
    // -s2 это смещение по "x" в "-" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix.
    
    // указатель на правый нижний угол суммирующего квадрата.
    p4 = p + s2 + s2_w;
    //  s2 это смещение по "x" в "+" на величину s2 pix, -s2_w смещение по "y" в "-" на величину s2 pix.
    
    ulong sum=0;    // сумма серого (сумма яркостей) папавшая в площадь квадрата.
    float st, pt;   // сумма единиц (площадь черного) папавшая в площадь квадрата.
    // сумма серого (длина контура) папавшая в площадь квадрата.
    float L=0, D=0;
    float Discriminant;
    float sqrt_D;
    int n=0;
    for (int y=0; y<h2b; y++){ // h2b1=h-b-b;
      
      d0=p0;  d1=p1;  d2=p2;  d3=p3;  d4=p4; // сохраняем указатели *p0-*p4 для выполнения цикла по "x"
      
      for (int x=0; x<w2b; x++){ // w2b1=w-b-b;
        
        // сумма серого папавшая в площадь квадрата S*S.
        // I(x,y)=s(x2,y2)-s(x1,y2)-s(x2,y1)+s(x1,x1)
        // sum = integralImg[y*w + x - s2*w - s2] - integralImg[y*w + x - s2*w + s2]
        // - integralImg[y*w + x + s2*w - s2] +  integralImg[y*w + x + s2*w + s2];
        //sum=*d1 - *d2 - *d3 + *d4; // исправить и в bF
        sum=(*d1  + *d4 - *d3 - *d2)/4;
        ///sum=(*d1  + *d4 - *d3 - *d2)>>2; // исправить и в bF // << * // >> /
        // складывая несколько ulong мы паралельно и не зависимо складываем со
        // >>2 (/4) ликвидация защитного интервала после выполненных двух вычитоний при вычислении площади.
        
        // складывая и вычитая несколько ulong мы паралельно и не зависимо складываем соответствующие uint составляющие эти ulong.
        
        // Распаковка координат из sum (ulong) в два uint с приведением к float.
        st=(float)(sum & 0xFFFFFFFF);       // st=*((uint*) & sum);
        pt=(float)((sum>>32) & 0xFFFFFFFF); // pt=*((uint*) & sum+1);
        
        // Распаковка координат из sum (ulong) в два uint с приведением к float.
        //st=*((uint*) & sum);
        //pt=*((uint*) & sum+1);
        //if ( pt<1 ) pt=1;
        
        ///st =(float)((*d1) & 0xFFFFFFFF - (*d2) & 0xFFFFFFFF - (*d3) & 0xFFFFFFFF + (*d4) & 0xFFFFFFFF);
        ///pt =(float)((*d1>>32) & 0xFFFFFFFF - (*d2>>32) & 0xFFFFFFFF - (*d3>>32) & 0xFFFFFFFF + (*d4>>32) & 0xFFFFFFFF);
        
        //cout<<st<<"  "<<pt<<endl;
        ///               *d0=st; // TECT
        //////*d0=1*sum/count; // *p0=sum; TECT на визуализацию области скользящего квадрата.
        
        // Вычисление средней толщины штриха "D" по региону BASE*BASE.
        // Решение квадратного уравнения вида D*D-D*pt/2+st=0;  // D*D-D*P/2+S=0;
        Discriminant=pt*pt/16-st;
        //if (Discriminant<0) {cout<<"Ошибка в функции LineWidthRegion(),  Discriminant="<<Discriminant<<" < 0"<<endl; return;} // return(0);}
        if (Discriminant>=0) {
          sqrt_D=sqrtf(Discriminant); // корень квадратный из дискриминанта (Discriminant)
          L=pt/4 + sqrt_D; // длина широкой стороны вытянутого прямоугольника
          D=pt/4 - sqrt_D; // длина узкой стороны вытянутого прямоугольника, т.е. среднея толщина штриха.
        }
        else {
          L=2;  n++; // D=1.1;L=254.1;
        }
        //cout<<D<<endl;
        
        
        //*d0=(uchar)D; // TECT
        //*d0=(uchar)(D*128) + *d0/3; // TECT
        //*d0=(uchar)(pt*3); // TECT
        *d0=(uchar)(D*100); // TECT *100  *10
        
        
        d0++;  d1++;   d2++;   d3++;   d4++; // d0 = bytes_data + y*w + x; // d1 = integralImg + y*w + x;
        
      } // x
      
      p0+=w;  p1+=w;  p2+=w;  p3+=w;  p4+=w; // p0 = bytes_data + y*w; // p1 = integralImg + y*w;
      
    }  // y
    //*/
    cout<<"   n="<<n<<"   D="<<D<<endl;
    
    
    /////////////////////////////////////////////////////////////////////////////
    
    
    //cout<<"   bytes_data[x]="<<(ushort)bytes_data[x]<<endl;
    
    ///for (int x=0; x<w_h; x++){
    
    // Нормировка и распаковка ulong.
    // binarisationF(96, 14) n=1859248 // binarisation(96, 3) n=1859248 // _Image2OCR/__Page_09___.png // pt=606049
    st=integralImg[w_h-1] & 0xFFFFFFFF;       // получение первого uint из ulong integralImg.
    pt=(integralImg[w_h-1]>>32) & 0xFFFFFFFF; // получение второго uint из ulong integralImg.
    ///st=integralImg[x] & 0xFFFFFFFF;       // получение первого uint из ulong integralImg.
    ///pt=(integralImg[x]>>32) & 0xFFFFFFFF; // получение второго uint из ulong integralImg.
    // 0xFFFFFFFF это маска для получения uint из ulong.
    if (GrafT) {
      cout<<"   st="<<st<<"   pt="<<pt<<endl;
      cout<<"   integralImg[w_h-1]="<<integralImg[w_h-1]<<"   pt="<<pt<<endl; }
    
    
    // Вычисление средней толщины штриха "D".
    // Решение квадратного уравнения D*D-D*P/2+S=0;  //
    Discriminant=pt*pt/16-st;
    ///if (Discriminant<0) {cout<<"Ошибка в функции LineWidthRegion(),  Discriminant="<<Discriminant<<" < 0"<<endl; return;} // return(0);}
    sqrt_D=sqrtf(Discriminant); // корень квадратный из дискриминанта (Discriminant)
    L=pt/4 + sqrt_D; // длина широкой стороны вытянутого прямоугольника
    D=pt/4 - sqrt_D; // длина узкой стороны вытянутого прямоугольника, т.е. среднея толщина штриха.
    if (GrafT) {cout<<"   Решение квадратного уравнения, средняя толщина штриха D="<<D<<"   L="<<L<<endl;}
    
    //if (D==0) { cout<<x<<"   D="<<D<<endl; }
    //            bytes_data[x]=D*128 + bytes_data[x]/3; // TECT
    
    ///} // x
    //bytes_data[w_h/2-1]=0;
    //bytes_data[w_h/2-2]=0;
    //bytes_data[w_h/2-3]=0;
    //bytes_data[w_h/2-4]=0;
    /*
     // Решение квадратного уравнения D*D-D*P2+S=0; с помощью итераций.
     // Вычисление средней толщины штриха "d".
     // Считаем что периметр "Pt" много больше толщина штриха "d"  Pt>>d,
     // поэтому длиная сторона сильно вытянутого прямоугольника равна L=Pt/2;
     if ( pt<1 ) pt=1;
     float d=2*st/pt;    //  среднея толщина штриха полученная с помощью итераций.
     if (GrafT) {cout<<"   Итерационное решение уравнения (1 итерация), средняя толщина штриха d="<<d<<endl;}
     
     // уточнение средней толщины  штриха "d", вместо решения квадратного уравнения вида 2*d*d+P*d-2*S=0;
     // первое уточнение средней толщины штриха (первая итерация).
     if ( pt-2*d>0 ) d=2*st/(pt-2*d); // учет ситуации когда "d" не на много меньше чем "L"
     // второе уточнение средней толщины штриха "d".
     if ( pt-2*d>0 ) d=2*st/(pt-2*d);
     // третье уточнение средней толщины штриха "d".
     if ( pt-2*d>0 ) d=2*st/(pt-2*d);
     if (GrafT) {cout<<"   Итерационное решение уравнения (3 итерация), средняя толщина штриха d="<<d<<endl;}
     // В итоге среднея толщина  штриха "d" полученная с помощью итераций почти всегда равна
     // толщине штриха "D" полученной решением квадратного уравнения.
     //*/
    
    
    
    // Filter
    ///gaussianF(4); // BASE/4
    FilterIntegral(BASE/2);
    
    /*
     //TECT
     // (96, 3) // _Image2OCR/__Page_09___.png
     for (int x=0; x<w*h; x++){ if ( (ushort)bytes_data[x]>0 ) cout<<(ushort)bytes_data[x]<<endl;} // x
     //*/
    
    // Функция быстро инвертирует массив bytes_data.
    invert();
    
    
    // копирование bytes_data_1 в bytes_data
    ////memcpy(bytes_data, bytes_data_1, w_h);  // адрес буфера назначения, адрес источника, количество байт для копирования.
    
    
    
    
    /*
     uchar scaling=255; // Уменьшение изображения фокальной линии (графемы) букв в "scaling" раз (2,3,4,5,...) с
     // сохранением площади черного. Серая подложка не выводится. При scaling=1 выводится изображение 1:1 с серой подложкой.
     
     uchar *bytes_data_1, *p1;
     sizeBuf=w_h+64; // размер массива с запасом
     // Массив для копии bytes_data.
     bytes_data_1=(uchar*)malloc(sizeBuf); // *p1
     //int b_data, b_data_1; // переменные соответствующих массивов.
     uchar *p0;
     
     // Уменьшение изображения в "scaling" раз с сохранением площади черного. Без серой подложки. // time=0.012  w*h=4 млн. пикселей
     // Изображение берем в bytes_data, сохраняем уменьшенное изображение в bytes_data_1 и копируем обратно в bytes_data.
     if (scaling>1) {
     memset(bytes_data_1, 255, w_h); // заливка bytes_data_1 белым
     for (int y=0; y < h; y++){          // time=0.012  w*h=4 млн. пикселей
     p0=bytes_data + y*w;
     p1=bytes_data_1 + (y/scaling)*w;
     for (int x=0; x < w; x++){
     if (*(p0+x)==0) *(p1+x/scaling)=0; // 0-черный для общепринятого стандарта
     } // x                                 // 255-черный для внутреннего формата
     } // y
     memcpy(bytes_data, bytes_data_1, w_h);     // адрес буфера назначения, адрес источника, количество байт для копирования
     } // if
     //*/
    
    
    // освобождение массивов
    if ( integralImg !=NULL ) free(integralImg);
    
    if(GrafT) { TIME_PRINT_ }
    
    /*
     // ТЕСТЫ //
     
     // Запаковка в ulong (integralImg) двух uint с двумя интегральными суммами.
     integralImg[4]=0;
     uint S=2;
     ulong P=4;
     
     // Запаковка в ulong (integralImg) двух uint с двумя интегральными суммами.
     *(uint*)&integralImg[4]=S;      *((uint*)&integralImg[4]+1)=P;
     cout<<"1 integralImg[4]="<<integralImg[4]<<endl;
     
     // Запаковка первого uint в ulong
     integralImg[4]=S;
     // Запаковка втрого uint в ulong
     integralImg[4]+=P<<32;  // P<<32 сдвиг подсчитанного значения P во второй uint
     cout<<"2 integralImg[4]="<<integralImg[4]<<endl;
     
     // Реальное применнение
     integralImg[4]=0;
     // подсчет единиц в первом uint
     integralImg[4]++; //
     // подсчет единиц во втром uint
     // прибавляем по единице (1<<32=0x100000000) сразу ко второму uint
     integralImg[4]+=0x0000000100000000; // 0x100000000 // 0x7F7F7F7F7F7F7F7F
     integralImg[4]+=0x100000000;
     integralImg[4]+=0x100000000;
     integralImg[4]+=0x100000000;
     cout<<"3 integralImg[4]="<<integralImg[4]<<endl;
     
     
     // Роспаковка координат из ulong (integralImg) в два uint с двумя интегральными суммами.
     // Извлечение первого uint из ulong
     S=(integralImg[4]<<32)>>32;
     // <<32 - второй uint выходит за пределы ulong и стирается, >>32 место второго uint заполняется 0 и
     // первый uint возвращается на свое место.
     cout<<"integralImg[4]="<<integralImg[4]<<"   S="<<S<<endl;
     // Извлечение втрого uint из ulong
     P=integralImg[4]>>32;
     // >>32 второй uint смещается на место первого uint и место второго uint заполняется 0.
     cout<<"integralImg[4]="<<integralImg[4]<<"   P="<<P<<endl;
     //*/
    
    // возвращение толщины штриха в пикселях и долях пикселя (float).
    ///return D;
    
    
  }//_____________________________________________________________________________
  
  
  // ДОРАБОТКА LineWidthImg
  // Восстановление bytes_data из bytes_data_1. LineWidthImg теоретически в мелких деталях может изменить bytes_data
  //memcpy(bytes_data, bytes_data_1, w_h); //////////////////// это надо делать в LineWidthImg
  
  //_____________________________________________________________________________
  
  
  
  // Рабочая функция, применяется. // закончена 30 января 2019
  
  // Вычисление средней толщины штриха по всей исходной картинке.
  // Возвращает среднею толщину штриха в пикселях и долях пиксела.
  float GBitmap::LineWidthImg () {
    
    // Перед применением функции текст должен быть бинаризован, например с помощью функции адаптивного порога binarisation(92,3);
    
    // Вычисление средней толщины штриха.
    // Считаем что весь текст это огромный сильно вытянутый прямоугольник с площадью "S" и периметром "P"
    // Площадь такого прямоугольника размером L на D равна S=D*P/2; (при d<<P), где
    // "L" длина прямоугольника по широкой стороне, а "D" ширина прямоугольника по узкой стороне т.е. среднея толщина штриха.
    // Отсюда D*P/2=S;  окончательно D=2*S/P; где "D" float.
    // Если учитывать соразмерность "D" и "P", то придется решать квадратное уравнение вида D*D-D*P/2+S=0;
    // Площадь прямоугольника "S" равна площади черного по всей исходной картинке.
    // Длинна периметра "P" равна площади контуров (толщиной в 1pix ) по всей исходной картинке.
    // Выделение контуров реализованно при помощи простейшего пространственного Лапласиана в виде матрици.
    
    // Тестирование чисел Мандельброта.
    // Мандельброт Б. Фрактальная геометрия природы. — Москва: Институт компьютерных исследований, 2002, 656 стр.
    // 12 СООТНОШЕНИЯ МЕЖДУ ДЛИНОЙ, ПЛОЩАДЬЮ И ОБЪЕМОМ.
    
    // После операции "~"  поразрядная инверсия компилятору необходимо напомнить, что число было изначально uchar
    // например bytes_data[x]=((uchar)(~bytes_data[x]))/2;
    
    // lineWidth()=61 (в функции убраны тонкие линии),  LineWidthImg ()=5.5 на печа __Page_09___.png
    // lineWidth()=64 (в функции убраны тонкие линии),  LineWidthImg ()=5.61 на печа __Page_09___.png // в печа убраны рамки
    
    
    int w=ncolumns;     // ширина массива   IMAGE_WIDTH
    int h=nrows;        // высота массива   IMAGE_HEIGHT
    int w_h=w*h;        // размер массива   IMAGE_SIZE
    uint S_t=0;         // площадь черного по всей исходной картинке.
    uint P_t=0;         // длина периметра (площадь контуров толщиной в 1pix ) по всей исходной картинке.
    // указатели на bytes_data.
    uchar *d0;
    
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
    if (GrafT) {
      cout<<"Функция вычисления средней толщины штриха LineWidthImg ()"<<endl;
      cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h<<" пикселей"<<endl; }
    
    
    // Функция преобразования серого массива в битовый массив (адаптивный порог).
    ////binarisation(92, 3);
    
    TIME_START
    
    // Быстро инвертирует массив bytes_data.
    // invert();
    
    //*
    // Инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный.
    // Для выделения контуров эта инверсия не обязательна, но без нее крайне не удобно для понимания и отладки.
    //// for ( x=0; x < w_h; x++ ){ bytes_data[x]=~bytes_data[x]; } // Инвертируем по 1 байтУ.
    int w_h_64=w_h/sizeof(ulong);  // sizeof(ulong)=8
    ulong *bytes_data_64=(ulong*)bytes_data;    // приведение к типу ulong
    // Инвертируем одновременно по 8 байт. Последний участок массива длинной от 0 до 8 байт не инвертируется.
    for ( int x=0; x < w_h_64; x++ ) { bytes_data_64[x]=~bytes_data_64[x]; }
    int wh_=w_h_64*sizeof(ulong);
    // инверсия последнего участка массива длинной от 0 до 8 байт.
    for (int x=wh_; x<w_h; x++){ bytes_data[x]=~bytes_data[x]; }
    //cout<<"w="<<w<<",  h="<<h<<"    w_h_64="<<w_h_64<<" w_h-w_h_64*8="<<w_h-w_h_64*8<<" wh_="<<wh_<<endl;
    //*/
    
    
    // Выделение контуров (ч.б. изображение превращается в контурное).
    int w_1=w+1;
    int w_h_=w_h-w_1;
    for (int x=w_1; x<w_h_; x++){
      d0=bytes_data+x;
      // если текущий пиксель "d1" исходной картинки черный.
      if (*d0==255 ) {
        
        // Вычисление площади черного по всей исходной картинке.
        // Далее идет переполнение: uint sum, суммы серого по всей площади исходной графической картинки./////////////////////////////////////////////////
        S_t++;
        
        // Вычисление длинны внешнего контура (периметра), проведенного вокруг черного, по всей исходной картинке.
        // Используется Матрица простейшего пространственного Лапласиана:
        
        //      d2                -w                  *(d0-w)
        
        // d8   d0   d4      -1        +1        *(d0-1)   *(d0+1)
        
        //      d6                +w                  *(d0+w)
        
        // Если центральная точка исходной картинки d1 массива bytes_data черная (255), то любой окружающей ее пиксел
        // матрици (d2, d4, d6, d8) равный нулю, записывается соответственно в этот же массив как серая единица (96), постепенно
        // вырисовывая серый контур (серый для наглядности). Запись в массив, а не непосредственный подсчет длинны контура,
        // позвояет устранить влияние наложения серых единиц (от соседних центральных точек d1), на длинну контура.
        if(*(d0-w)==0)*(d0-w)=96;  if(*(d0-1)==0)*(d0-1)=96;  if(*(d0+1)==0)*(d0+1)=96;  if(*(d0+w)==0)*(d0+w)=96;
        
      } // if
      
    } // x
    // L=542546   D=1
    
    // Вычисление суммарной длинны контуров вокруг черного по всей исходной картинке.
    for (int x=0; x<w_h; x++){
      uchar b_data=bytes_data[x];
      // Просто подсчитывается количество серого (96) в массиве контуров bytes_data.
      if (b_data==96) {P_t++; b_data=0;} // и убираем серое в исходном массиве
      // Инверсия уровней внутреннего формата программы 0-белый 255-черный, в общепринятый стандарт 0-черный 255-белый.
      bytes_data[x]=~b_data;
    } // x
    /// ~ потенциально инверсия действует не по всему тексту, следи за w_h
    /**/
    
    // Нормировка.
    float St=S_t;
    if ( P_t<1 ) P_t=1;
    float Pt=P_t;
    if (GrafT) {cout<<"   St="<<St<<"   Pt="<<Pt<<endl;}
    
    // Вывод формулы квадратного уравнения для вычисления средней толщины штриха.
    // Площать черного по всему тексту "S" и длина периметра "P" этого черного, равна площади
    // огромного сильно вытянутого прямоугольника с такой же площадью "S" и тем же периметром "P".
    // "D" искомая ширина прямоугольника.
    // D*(P-2*D)/2=S; >> D*(P-2*D)=S*2; >> -2*D*D+D*P=S*2; >> 2*D*D-P*D+2*S=0; >> D*D-D*P/2+S=0;
    
    
    // Вычисление средней толщины штриха "D".
    // Решение квадратного уравнения D*D-D*P/2+S=0;
    float Discriminant=Pt*Pt/16-St; // (P/2)*(P/2)/4 - 4*St/4
    if (Discriminant<0) {cout<<"Ошибка в функции lineStyleDetect(),  Discriminant="<<Discriminant<<" < 0"<<endl; return(0);}
    float sqrt_D=sqrtf(Discriminant); // корень квадратный из дискриминанта (Discriminant)
    float L=Pt/4 + sqrt_D; // длина широкой стороны вытянутого прямоугольника
    float D=Pt/4 - sqrt_D; // длина узкой стороны вытянутого прямоугольника, т.е. среднея толщина штриха.
    if (GrafT) {cout<<"   Решение квадратного уравнения, средняя толщина штриха D="<<D<<"   L="<<L<<endl;}
    
    //*
    // Решение квадратного уравнения D*D-D*P2+S=0; с помощью итераций.
    // Вычисление средней толщины штриха "d".
    // Считаем что периметр "Pt" много больше толщина штриха "d"  Pt>>d,
    // поэтому длиная сторона сильно вытянутого прямоугольника равна L=Pt/2;
    float d=2*St/Pt;    //  среднея толщина штриха полученная с помощью итераций.
    if (GrafT) {cout<<"   Итерационное решение уравнения (1 итерация), средняя толщина штриха d="<<d<<endl;}
    
    // уточнение средней толщины  штриха "d", вместо решения квадратного уравнения вида 2*d*d+P*d-2*S=0;
    // первое уточнение средней толщины штриха (первая итерация).
    if ( Pt-2*d>0 ) d=2*St/(Pt-2*d); // учет ситуации когда "d" не на много меньше чем "L"
    // второе уточнение средней толщины штриха "d".
    if ( Pt-2*d>0 ) d=2*St/(Pt-2*d);
    // третье уточнение средней толщины штриха "d".
    if ( Pt-2*d>0 ) d=2*St/(Pt-2*d);
    if (GrafT) {cout<<"   Итерационное решение уравнения (3 итерация), средняя толщина штриха d="<<d<<endl;}
    // В итоге среднея толщина  штриха "d" полученная с помощью итераций почти всегда равна
    // толщине штриха "D" полученной решением квадратного уравнения.
    //*/
    
    //*
    // Мандельброт Б. Фрактальная геометрия природы. — Москва: Институт компьютерных исследований, 2002, 656 стр.
    // 12 СООТНОШЕНИЯ МЕЖДУ ДЛИНОЙ, ПЛОЩАДЬЮ И ОБЪЕМОМ.
    ///float Mt=St/Pt;
    ///if (GrafT) {cout<<"   Число Мандельброта Mt=St/Pt="<<Mt<<endl;}
    float Mt=St/sqrtf(Pt);
    if (GrafT) {cout<<"   Число Мандельброта Mt=St/sqrtf(Pt)="<<Mt<<endl;}
    //*/
    
    if(GrafT) { TIME_PRINT_ }
    
    // возвращение толщины штриха в пикселях и долях пикселя (float).
    return D;
    
    //----------------------------------------------------------------------------------------------------------------------------
    
    ///int max_x=0; int max_y=0;
    ///int max=0;
    ///int min=1<<30;
    ///if ( b_data>max ) {max=b_data; max_x=x;}
    ///if ( b_data<min ) {min=b_data;}
    
    // Тест на равенство операций "~x" и "255-x"
    ///for ( uchar x=0; x < 255; x++ ){
    ///    cout<<"   x="<<(short)x<<"   ~x="<<(short)(uchar)(~x) <<"   255-x="<<(short)(255-x)<<endl; // (short)(uchar) & 0x7F
    ///}
    
    
    /*
     // TEST //
     for (int x=0; x<w_h; x++){
     bytes_data[x]=0;
     
     //if ( x==w_h/2+16 ) bytes_data[x]=255;      // один пиксель
     
     //if ( x==w_h/2+16 ) bytes_data[x]=255;      // два диагональных пикселя
     //if ( x==w_h/2+17+w ) bytes_data[x]=255;
     
     //if ( x==w_h/2+16 ) bytes_data[x]=255;      // четыре+четыре диагональных пикселя
     //if ( x==w_h/2+17+w ) bytes_data[x]=255;
     //if ( x==w_h/2+18+w+w ) bytes_data[x]=255;//
     //if ( x==w_h/2+19+w+w+w ) bytes_data[x]=255;//
     //if ( x==w_h/2+16+1 ) bytes_data[x]=255;
     //if ( x==w_h/2+17+1+w ) bytes_data[x]=255;
     //if ( x==w_h/2+18+1+w+w ) bytes_data[x]=255;//
     //if ( x==w_h/2+19+1+w+w+w ) bytes_data[x]=255;//
     
     //if ( x>w_h/2+8 && x<w_h/2+1+24) bytes_data[x]=255;      // однопиксельная горизонтальная линия
     //if ( x>w_h/2+w+8 && x<w_h/2+w+1+24) bytes_data[x]=255;  // однопиксельная горизонтальная линия
     //if ( x>w_h/2-w+8 && x<w_h/2-w+1+24) bytes_data[x]=255;  // однопиксельная горизонтальная линия
     
     //if ( x>w_h/2+16 && x<w_h/2+16+1+1) bytes_data[x]=255; // однопиксельная вертикальная линия
     //if ( x>w_h/2+w+16 && x<w_h/2+w+16+1+1) bytes_data[x]=255;
     //if ( x>w_h/2+2*w+16 && x<w_h/2+2*w+16+1+1) bytes_data[x]=255;
     //if ( x>w_h/2+3*w+16 && x<w_h/2+3*w+16+1+1) bytes_data[x]=255;
     //if ( x>w_h/2+4*w+16 && x<w_h/2+4*w+16+1+1) bytes_data[x]=255;
     //if ( x>w_h/2+5*w+16 && x<w_h/2+5*w+16+1+1) bytes_data[x]=255;
     
     } // x
     */
    
  }//_____________________________________________________________________________
  
  
  // Функция определения средней толщины штриха в буквах по всему графическому тексту (в пикселях).
  // Древняя разработка, получилась не очень точная, практического смысла применения не имеет, есть
  // более точный аналог  LineWidthImg ().
  
  int  GBitmap::lineWidth() {
    
    // Возвращает среднее значение толщины штриха line_w в буквах по всему графическому тексту (в пикселях).
    // Значение толщина штриха возвращается в десятых долях пикселя: 38 это 3,8 pix
    // Входной массив bytes_data должен быть черно-белым: 0-черный 255-белый или черно-белым: 0-черный 1-белый.
    // bytes_data это unsigned char.
    
    //  * Идея *
    // Определения толщины штриха для черо-белого графического текста.
    // Идея состоит в том, что подсчитывается длина всех непрерывных вертикальных и горизонтальных "черных" слайсов.
    // толщиной в один пиксель по всему графическоу тексту. Отбрасываются все длинные слайсы, уменьшаются веса коротких
    // слайсов и подсчитывается количество оставшихся "черных" слайсов каждой длинны.
    // Длинна слайса, встречающегося по всему графическому тексту, наибольшее число раз и есть толщина штриха в буквах.
    
    //  * Особенности *
    // Для серого графического текста, для пределения толщины штриха, предварительно применяют
    // функцию адаптивного порога binarisation(int Tr, int BASE) получая необходимый черо-белый графическй текст
    
    
    /**/
    ///        TIME_START
    // горизонтальное сканирование слайсов (быстрое) //
    // time=0.1   сек  w=16224 × h=2464  w*h=40 млн.pix  line_wd=98   line_w=10pix  // 137  line_w=14pix   //  (w=2698 h=4000)
    // time=0.033 сек  w=2621  × h=3979  w*h=10 млн.pix  line_wd=79   line_w=8 pix  // 87   line_w=9 pix
    // time=0.016 сек  w=2112  × h=3008  w*h=6  млн.pix  line_wd=37   line_w=4 pix
    
    // вертикальное сканирование слайсов (медленное) //
    // time=0.45  сек  w=16224 × h=2464  w*h=40 млн.pix  line_wd=100  line_w=10pix    //  (w=2698 h=4000)
    // time=0.1   сек  w=2621  × h=3979  w*h=10 млн.pix  line_wd=105  line_w=11pix    //  x+=3 // time=0.04
    // time=0.045 сек  w=2112  × h=3008  w*h=6  млн.pix  line_wd=44   line_w=4 pix
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    uint w=ncolumns; // ширина массива  IMAGE WIDTH
    uint h=nrows;    // высота массива  IMAGE HEIGHT
      
    if (GrafT) {
      cout<<"Определение толщины штриха lineWidth()"<<endl;
      cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl;
    }
    
    TIME_START
    
    int x,y;
    int w_h=w*h;
    
    // управляющие переменные
    unsigned char lineWH=2;
    // lineWH=0 вычисляется толщина штриха по горизонтали (быстрое)
    // lineWH=1 вычисляется толщина штриха по вертикали (медленние)
    // lineWH=2 вычисляется среднее значение толщины штриха по вертикали и горизонтали (время выполнения сумма предид.)
    unsigned char n=1;        // уменьшения площади сканирования текста в "n" раз при вертикальное (медленным) поиске слайсов
    unsigned int lw_Max=32;   // максимально возможная толщина штриха
    // вспомогательные переменные
    unsigned int line_w=0;    // среднее значение толщины штриха по всему графическому тексту.
    unsigned int line_wd=0;   // то же что и line_w но в десятых долях пикселя
    unsigned int lw=0;        // текущая толщина штриха в буквах графического текста
    unsigned int lw_Sum=0;    // суммарное количество разных "черных" слайсов по всему графическому тексту.
    unsigned int md_Max=0;    // максимальное количество "черных" слайсов одной длинны во всем тексте
    unsigned int x_Max=0;     // длина "черного" слайса наиболее часто встречающегося по всему тексту
    // вспомогательные переменные для увеличения быстродействия
    unsigned int s;
    // вспомогательные переменные для предотвращения выхода за пределы массива
    int w_h_1=w_h-1;
    int w_h_w=w_h-w;
    
    // указатели
    unsigned char *p0=bytes_data;    // входной массив, 0-черный 255-белый или 0-черный 1-белый
    uint *middle_data, *d1;  // массив распределения длинн "черных" слайсов, где
    // длина слайса является адресом массива, а содержимое это количество слайсов данной длинны
    
    // Массивы. Каждый элемент инициализируется в 0.
    middle_data = (unsigned int*)calloc(lw_Max+8,sizeof(unsigned int)); // d1
    
    
    // ввести old_p0
    
    // уменьшения площади сканирования графического текста при вертикальное (медленным) поиске слайсов
    // если пдощать графического текста больше 1 млн.pix то обсчитываем только каждую третью колонку
    n=1;
    if ( w_h >1000000 ) n=3;
    
    //lineWH=0; // тест
    ///TIME_START
    
    /// горизонтальное сканирование слайсов (быстрое)  ///
    if (lineWH==0 || lineWH==2) {
      
      // подсчет количество "черных" слайсов каждой длинны (длинной от 1 до lw_Max).
      // заполение массива распределения длинн "черных" слайсов
      p0=bytes_data;  d1=middle_data; lw=0;
      for ( x=0; x < w_h_1; x++ ) {   // w_h_1=w_h-1;   // time=0.017 16224 × 2464
        // подсчет длинны "черного" слайса
        if (*p0==0) {  // если встретился "черный" пиксел
          lw++;
          // запись в массив middle_data колличества "черных" слайсов, где длина слайса является адресом массива
          if (*(p0+1)>0) { // если следующий пиксел "белый"
            if (lw<lw_Max) { *(d1+lw)=*(d1+lw)+1; }  // если "черный" слайс не длинный  // *(d1+lw)++;
            //if (lw<lw_Max) { *(d1+lw)++; }  // если "черный" слайс не длинный
            lw=0;
          } // (*(p0+1)>0)
        } // if (*p0==0)
        p0++; // p0=bytes_data+x;
      } // y
      
    } // if (lineWH
    
    /**/
    
    
    /// вертикальное сканирование слайсов (медленние в 3 раза, при n=1) ///
    if (lineWH==1 || lineWH==2) {
      
      // подсчет количество "черных" слайсов каждой длинны (длинной от 1 до lw_Max).
      // заполение массива распределения длинн "черных" слайсов
      d1=middle_data; lw=0;      // x+=3 быстрее раза в 2.5 чем x++
      for ( x=0; x < w; x+=n ) { // x++, time=0.45 16224 × 2464 то же что и вращение time=0.37 (0.25) и обычный подсчет time=0.1
        p0=bytes_data+x;
        for ( y=0; y < w_h_w; y+=w ){    // w_h_w=w*h-w;
          // подсчет длинны "черного" слайса
          if (*p0==0) {  // если встретился "черный" пиксел
            lw++;
            // запись в массив middle_data колличества "черных" слайсов, где длина слайса является адресом массива
            if (*(p0+w)>0) { // если следующий пиксел "белый"
              if (lw<lw_Max) { *(d1+lw)=*(d1+lw)+n; }  // если "черных" слайс не длинный, "n"- вес одного пикселя // +n; //////////
              //if (lw<lw_Max) { *(d1+lw)++; }  // если "черных" слайс не длинный
              lw=0;
            } // (*(p0+1)>0)
          } // if (*p0==0)
          p0+=w;  // p0=bytes_data+w;
        } // y
      } // x
      
    } // if (lineWH
    ///TIME_PRINT_
    /**/
    
    
    if (GrafT) { cout<<endl;  for ( x=0; x < lw_Max; x++ ){cout<<"  "<<middle_data[x];}  cout<<endl; }
    
    // Таблица весов количества "черных" слайсов всему графическому тексту.
    // С помощью таблицы уменьшается влияние очень коротких слайсов длинной в 1,2... пикселя.
    d1=middle_data;  // d1[1]*=0.1; // (float)4.1
    
    /*
     *(d1+1)=*(d1+1)*(float)0.1;   *(d1+2)=*(d1+2)*(float)0.3;    *(d1+3)=*(d1+3)*(float)0.4;    *(d1+4)=*(d1+4)*(float)0.5;
     *(d1+5)=*(d1+5)*(float)0.6;   *(d1+6)=*(d1+6)*(float)0.7;    *(d1+7)=*(d1+7)*(float)0.7;    *(d1+8)=*(d1+8)*(float)0.7;
     *(d1+9)=*(d1+9)*(float)0.8;   *(d1+10)=*(d1+10)*(float)0.8;  *(d1+11)=*(d1+11)*(float)0.8;  *(d1+12)=*(d1+12)*(float)0.9;
     */
    
    
    // вычисление длинны x_Max и количества md_Max "черныхо" слайсов, самых встречающихся по всему тексту
    md_Max=0;
    for ( x=1; x < lw_Max; x++ ) {  // x=2 не учитываем пиксели нулевого и единичного размера
      if (md_Max < middle_data[x]) { md_Max=middle_data[x];  x_Max=x; }
    } // x
    if (GrafT) { cout<<"md_Max="<<md_Max<<"   x_Max="<<x_Max<<endl; }
    /**/
    
    if (GrafT) { cout<<endl;  for ( x=0; x < lw_Max; x++ ){cout<<"  "<<middle_data[x];}  cout<<endl; }
    
    
    // подсчет среднего по "черных" слайсом площадь которых лежит от максимума до половины максимума суммарной площади
    line_wd=0;  lw_Sum=0;
    for ( x=1; x < lw_Max; x++ ) {
      if (middle_data[x] > md_Max/2) {  // md_Max*2/3
        line_wd+=middle_data[x]*x;
        lw_Sum+=middle_data[x];
        ///cout<<"x="<<x<<endl;
      } // if
    } // y
    if (GrafT) { cout<<"lw_Sum="<<lw_Sum<<endl; }
    
    
    // значение толщина штриха в десятых долях пикселя: 38 это 3,8 pix
    if (lw_Sum == 0 ) { lw_Sum=1; }
    line_wd=line_wd*10/lw_Sum;
    
    
    // точное округление толщины штриха до целых пикселей
    //line_w=46; // тест
    // "s" порог между пикселями: 5,15,25,35,45,,,,. Пиксели могут принимать значения от 1 ло 320 (в десятых долях)
    s=(line_wd/10)*10+5;
    if (line_wd >= s ) { line_w=line_wd/10+1; }
    else line_w=line_wd/10;
    
    if ( line_wd<20 ) line_wd=10;   if ( line_wd>lw_Max*10 ) line_wd=lw_Max*10;
    if (GrafT) { cout<<"*толщина* штриха в десятых долях пикселя line_wd="<<line_wd<<endl; }
    // line_w толщина штриха в пикселях. Максимально возможная толщина штриха lw_Max=32,
    if ( line_w<2 ) line_w=1;   if ( line_w>lw_Max ) line_w=lw_Max;
    if (GrafT) { cout<<"*толщина* штриха в пикселях line_w="<<line_w<<endl; }
    /**/
    
    if (GrafT) { cout<<endl;  for ( x=0; x < 20; x++ ){cout<<"  "<<(unsigned short)bytes_data[x];}  cout<<endl; }
    
    if (GrafT) {
      cout<<"оптимальное значение *толщины* штриха для данного текста   line_wd="<<80/10<<"."<<80%10<<" pix"<<endl;
      cout<<"фактическое значение *толщины* штриха в пикселях                     line_wd="<<line_wd/10<<"."<<line_wd%10<<" pix"<<endl; }
    
    
    // освобождение массивов bytes_data_1
    if ( middle_data !=NULL ) free(middle_data);
    /**/
    
    if(GrafT) { TIME_PRINT_ }
    
    // возвращение толщины штриха в пикселях.
    ///return line_w;
    // возвращение толщины штриха в десятых долях пикселя.
    return line_wd;
    
    
    //----------------------------------------------------------------------------------------------------------------
    /*
     middle_data[1]*=(float)0.1;    middle_data[2]*=(float)0.3;    middle_data[3]*=(float)0.4;
     middle_data[4]*=(float)0.5;    middle_data[5]*=(float)0.6;    middle_data[6]*=(float)0.7;
     middle_data[7]*=(float)0.7;    middle_data[8]*=(float)0.7;    middle_data[9]*=(float)0.8;
     middle_data[10]*=(float)0.8;   middle_data[11]*=(float)0.8;   middle_data[12]*=(float)0.9;
     */
    /*
     *(d1+1)=*(d1+1)/10;     *(d1+2)=*(d1+2)*3/10;    *(d1+3)=*(d1+3)*4/10;    *(d1+4)=*(d1+4)*5/10;
     *(d1+5)=*(d1+5)*6/10;   *(d1+6)=*(d1+6)*7/10;    *(d1+7)=*(d1+7)*7/10;    *(d1+8)=*(d1+8)*7/10;
     *(d1+9)=*(d1+9)*8/10;   *(d1+10)=*(d1+10)*8/10;  *(d1+11)=*(d1+11)*8/10;  *(d1+12)=*(d1+12)*9/10;
     */
    
  }//____________________________________________________________________________
  
  
  // Тестовая функция.
  
  // Выделение контуров при помощи простейшего пространственного Лапласиана.
  // Отлажена работает, но не понадобилась в работе // модифицированна декабрь 2018
  // Реально разобратся с порогом и знаками.
  
  void GBitmap::detectContourT() {
    
    // Пространственный Лапласиан, убирает сплошные черные области и подчеркивает граници,
    // а ч.б. изображение превращает в контурное, с двухпиксельными контуром,
    // что благоприятно для алгоритмов определения угла наклона текста.
    ////////////// Функция сдвигает исходную картинку на 4 pix к началу координат.
    // После операции "~"  поразрядная инверсия необходимо напомнить, что число было изначально uchar
    // например bytes_data[x]=((uchar)(~bytes_data[x]))/2;
    
    // Вызов функции предобработка битовой картинки.
    ///	detectContour();
    
    
    int w=ncolumns;     // ширина массива   IMAGE_WIDTH
    int h=nrows;        // высота массива   IMAGE_HEIGHT
    int w_h=w*h;        // размер массива   IMAGE_SIZE
    
    int x,y;
    uchar *A=bytes_data;
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
    if (GrafT) {
      cout<<"Функция выделения контуров detectContourT()"<<endl;
      cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h<<" пикселей"<<endl; }
    
    
    TIME_START
    // Функция быстро инвертирует массив bytes_data.
    invert();
    
    /*
     // Инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный.
     // Для реальной картинки полученной при открытии файла необходимо инверсия.
     ///for ( x=0; x < w_h; x++ ){ bytes_data[x]=(~bytes_data[x])/4; }
     for ( x=0; x < w_h; x++ ){ bytes_data[x]=((uchar)(~bytes_data[x]))/1; }  //  & 0x7F7F7F7F7F7F7F7F
     uint w_h_64=w_h/sizeof(ulong);  // sizeof(ulong)=8
     ulong *bytes_data_64=(ulong*)bytes_data;    // приведение к ulong
     // Инвертируем одновременно по 8 байт. Последний участок массива длинной от 0 до 8 бит не инвертируется.
     // Последний участок массива длинной s+s в дальнейшем все равно будет обнулятся.
     ///for ( x=0; x < w_h_64; x++ ) { bytes_data_64[x]=~bytes_data_64[x]; }
     */
    
    ///for ( uchar x=0; x < 255; x++ ){
    ///    cout<<"   x="<<(short)x<<"   ~x="<<(short)(uchar)(~x) <<"   255-x="<<(short)(255-x)<<endl; // (short)(uchar) & 0x7F
    ///}
    
    
    
    
    
    int max_x=0; int max_y=0;
    int max=0;
    int min=1<<30;
    int b_data;
    for (x=0; x<w_h; x++) {
      b_data=bytes_data[x];
      if ( b_data>max ) {max=b_data; max_x=x; max_y=y;}
      if ( b_data<min ) {min=b_data;}
    } //x
    cout<<endl;
    cout<<"   min="<<min<<"   max="<<max<<"   max_x="<<max_x<<"   max_y="<<max_y<<endl;
    
    
    
    
    
    // вспомогательные переменные.
    uchar *d0,*d1,*d2,*d3,*d4,*d5; // *p,
    
    // Матрица весов пространственного Лапласиана.
    //      -1
    //       0
    //  -1 0 4 0 -1
    //       0
    //      -1
    /*
     // Вычисление пространственного Лапласиана в двух циклах
     max_x=0; max_y=0;
     max=0;
     min=1<<30;
     for (int y=5; y<h_3; y++){ // h_3=h-3;
     
     d0=A+(y-4)*w-4;  // A[y-4][x-4]
     d1=A+y*w;        // A[y][x]
     d2=d1+2*w;       // A[y+2][x]
     d3=d1-2*w;       // A[y-2][x]
     d4=d1+2;         // A[y][x+2]
     d5=d1-2;         // A[y][x-2]
     
     for (int x=5; x<w_3; x++){ // w_3=w-3;
     
     //  выделение граници в 2 пиксела
     // A[y-4][x-4]=4*A[y][x]-A[y+2][x]-A[y-2][x]-A[y][x+2]-A[y][x-2];
     *(d0+x)=b_data=(abs( *(d1+x)*4-*(d2+x)-*(d3+x)-*(d4+x)-*(d5+x) ))/4;  // ~   abs  (uchar)
     
     if ( b_data>max ) {max=b_data; max_x=x; max_y=y;}
     if ( b_data<min ) {min=b_data;}
     
     ///		 *(bytes_data + y*w + x)=0;
     
     //#ifdef DEBUGLVL
     //	   drawData[0][y-5][x-5]=255+*(d+x)*196;  // draw it
     //#endif
     
     } // x
     }  // y
     // Пространственный Лапласиан сдвигает исходную картинку на 4 pix к началу координат.
     
     cout<<endl;
     cout<<"   min="<<min<<"   max="<<max<<"   max_x="<<max_x<<"   max_y="<<max_y<<endl;
     */
    
    // ДОДЕЛАТЬ ПИКСЕЛЬНУЮ привязку с удобным файлом
    //    inputPath="/_Image2OCR/_1Draw_pix32.jpg";               // точка
    
    // Вычисление пространственного Лапласиана  в одном цикле
    max_x=0;
    max=0;
    min=1<<30;
    
    d0=A-4*w-4;      // A[y-4][x-4]   A+(y-4)*w-4;
    d1=A;            // A[y][x]        d1=A+y*w;
    d2=d1+2*w;       // A[y+2][x]
    d3=d1-2*w;       // A[y-2][x]
    d4=d1+2;         // A[y][x+2]
    d5=d1-2;         // A[y][x-2]
    
    /////*(A+4*w+4)=255;
    
    for (int x=4+4*w; x<w_h-3-3*w; x++){
      //  выделение граници в 2 пиксела
      // A[y-4][x-4]=4*A[y][x]-A[y+2][x]-A[y-2][x]-A[y][x+2]-A[y][x-2];
      *(d0+x)=b_data=(abs( *(d1+x)*4-*(d2+x)-*(d3+x)-*(d4+x)-*(d5+x) ))/4;  // ~   abs  (uchar)
      if ( b_data>max ) {max=b_data; max_x=x; max_y=y;}
      if ( b_data<min ) {min=b_data;}
      //   *(d0+x)=255;
    } // x
    // Пространственный Лапласиан сдвигает исходную картинку на 4 pix к началу координат.
    
    cout<<endl;
    cout<<"   min="<<min<<"   max="<<max<<"   max_x="<<max_x<<"   max_y="<<max_y<<endl;
    /**/
    
    /*
     max=0;
     min=1<<30;
     for (x=0; x<w_h; x++) {
     b_data=bytes_data[x];
     if ( b_data>max ) max=b_data;
     if ( b_data<min ) min=b_data;
     } //x
     cout<<endl;
     cout<<"   min="<<min<<"   max="<<max<<endl;
     */
    
    
    
    /* //--------
     // Компенсация сдвига исходной картинки на 4 pix к началу координат.
     max_x=0; max_y=0;
     max=0;
     min=1<<30;
     for (int y=0; y<h_5; y++){     // h_5=h-5;
     //d0=A+y*w;                  // A[y][x]
     d1=A+(y+4)*w+4;           // A[y+4][x+4]
     d0=A+y*w;
     for (int x=0; x<w_5; x++){ // w_5=w-5;
     b_data=*(d0+x)=*(d1+x);       // A[y][x]=A[y+4][x+4];   // ~ Инверсия уровней массива
     if ( b_data>max ) {max=b_data; max_x=x; max_y=y;}
     if ( b_data<min ) {min=b_data;}
     } // x
     }  // y
     cout<<endl;
     cout<<"   min="<<min<<"   max="<<max<<"   max_x="<<max_x<<"   max_y="<<max_y<<endl;
     
     */
    
    // Функция быстро инвертирует массив bytes_data.
    invert();
    
    
    
    TIME_PRINT_
    
    // *(d+x)=*(d1+x)*2-*(d2+x)-*(d3+x); // -*(d4+x)-*(d5+x)
    //  (нормировка скана)
    
    
    
    // Применить функцию detectContour
    // заготовка для получения контурного изображения, без бинаризации.
    // проход матрицей x+d, x-d, x+w*d, x-w*d, где d=3.
    //for (x=0; x<w; x++)
    //{
    
    
    //    for (y=0; y<h; y++)
    //    {
    //        bytes_data[x]=abs(bytes_data[x] - bytes_data[x+w]);
    //    } //y
    //} //x
    
    // визуализация серым фокальных линий (по 8 байт одновременно). ( внутренний формат программы 255-черный, 0-белый ).
    ///for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=(bytes_data0_64[x]>>1)&0x7F7F7F7F7F7F7F7F; } // деление на 2 и прим. 64 р маски.
    // Черное (255) становится серым (127), белое (0) остается белым.
    // 0x7F7F7F7F7F7F7F7F  64 р маска для деление на 2, маска убирает передвинувшиеся (при сдвиге) из соседних байт разряды.
    
    
    ////////////////////////////////////////////////////////////////////////////////////////
    
    // Оператор Лапласа (Лапласиан) 3×3 имеет маску следующего вида:
    // Матрица весов пространственного Лапласиана.
    //    -1-1-1
    //    -1 8-1
    //    -1-1-1
    
    // Оператор Марра выделения краев "ступенчатого" типа основан на поиске точек пересечения нуля второй пространственной производной f(x,y). Для этого используется оператор Лапласа ∇2, где ∇ - оператор Гамильтона ⟨∂∂x,∂∂y⟩, примененный после сглаживания изображения гауссовским линейным фильтром с симметричной маской G(σ,x,y), или непосредственно осуществляется свертка с маской ∇2G(σ,x,y). Этот фильтр известен также как РГР-фильтр (разность гауссовских распределений), так как форма маски ∇2G(σ) хорошо аппроксимируется разностью гауссовских масок G(σ1)−G(σ2) с соотношением σ1/σ2=1,7. В работе [217] показано, что РГР-фильтр является также хорошим приближением точного решения задачи регуляризации для оператора Лапласа при наложенном на f(x,y) условии минимума среднего квадрата второй производной.
    
    // http://wiki.technicalvision.ru/index.php/Операторы_Марра_и_Лапласа
    
    // https://ru.wikipedia.org/wiki/Оператор_Кэнни
    
    // https://ru.wikipedia.org/wiki/Оператор_Собеля
    
    // https://ru.wikipedia.org/wiki/Выделение_границ
    
    // Об интеллекте» Джеффа Хокинса.
    
    
  }//_____________________________________________________________________________
  
  
  // Отлаженные базовые примеры popcnt, таблиц и горизонтальных сумм на SSE.
  
  void GBitmap::testPopCnt(){
#ifdef ASM_OS64_SSE42_POPCNT_ATT    
    //команда для перевода ассемблерного вывода в нотацию Intel
    //команду необходимо добавить в раздел команд дебаггера
    //в любом breakpoint проекта.
    //settings set target.x86-disassembly-flavor intel
    
    // Здесь тестируются:
    // - popcnt_u64 подсчет едениц
    // - ТАБЛИЦИ в регистрах SSE. Один регистр SSE это таблица на 16 бит, как массив на 16 бит.
    // - ГОРИЗОНТАЛЬНЫЕ СУММЫ в регистрах SSE.
    // - Способы задания тестого 128 битного числа для интринсики (intrinsics).
    // - Способы задания 128 бит чисел для Assembler.
    
    // Все это работает на intrinsics, но на Assembler генерится сильно избыточный код для
    // реального использования надо брать Assembler куски кода из DisAssembler и офармлять
    // их как Assembler вставки.
    
    
    // INTEL справочник
    // https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=4512,4512,4820
    
    //------------------------------------------------------------------------------
    
    // ПЕРЕСПЕКТИВА //
    
    //ВЕСА, ПРОРАБОТАТЬ ОТДЕЛЬНО.
    //__m128i _mm_maddubs_epi16 (__m128i a, __m128i b)
    //Вертикально умножьте каждое беззнаковое 8-разрядное целое число из a на соответствующее 8-разрядное целое число со знаком из b, чтобы получить промежуточные 16-разрядные целые числа со знаком. Горизонтально добавьте соседние пары 16-разрядных целых чисел с промежуточными знаками и запакуйте насыщенные результаты в dst.
    // PMADDUBSW — (Multiply and Add Packed Signed and Unsigned Bytes)
    
    //__m128i _mm_sad_epu8 (__m128i a, __m128i b)
    // Вычислить абсолютные различия упакованных 8-разрядных целых без знака в a и b, затем суммировать по горизонтали каждые 8 ​​последовательных разностей, чтобы получить два 16-разрядных целых без знака, и упаковать эти 16-разрядные целые числа без знака в младшие 16 битов 64-разрядных элементов. в дст.
    
    // __m128i _mm_minpos_epu16 (__m128i a)
    // Горизонтально вычислите минимум среди упакованных 16-разрядных целых чисел без знака в a, сохраните минимум и индекс в dst и обнулите оставшиеся биты в dst.
    
    
    //------------------------------------------------------------------------------
    
    //  подсчет едениц аппаратным алгоритмом popcnt. Регистровые суммы.
    /// uint SumBit1=_mm_popcnt_u64(255);
    /// cout<<"   SumBit1="<<SumBit1<<endl;
    
    //------------------------------------------------------------------------------
    
    // ТАБЛИЦИ SSE на прямерах с popcnt //
    
    // подсчет едениц popcnt алгоритмом на таблицах в регистре SSE3 //
    // Это интересный SSE3 параллельного алгоритма 4 бита поиска. Идея от Wojciech Muła, реализация от Марат Духан answer. Благодаря @Apriori для напоминания мне этот алгоритм. Ниже лежит сердце алгоритма, он очень умный, в основном подсчитывает бит для байтов, используя регистр SSE, как 16-байтную таблицу поиска и нижние полубайты в качестве индекса, из которых выбраны ячейки таблицы. Затем суммирует числа.
    // https://stackoverrun.com/ru/q/7610241
    // https://stackoverflow.com/questions/17354971/fast-counting-the-number-of-set-bits-in-m128i-register/17355341#17355341
    // https://stackoverflow.com/questions/25078285/replacing-a-32-bit-loop-counter-with-64-bit-introduces-crazy-performance-deviati
    
    //*/
    // Сам 8 битный действующий intrinsics алгоритм popcnt:
    
    // Трансляция 8-битного целого числа (байта) "a" на все элементы dst. // __m128i v = _mm_set1_epi8(a);
    __m128i a = _mm_set1_epi8(255); // тестовое входное число
    // маска на младшие 4 бита 00001111 на все элементы dst.
    static const __m128i popcount_mask = _mm_set1_epi8(0x0F);
    // таблица в регистре SSE на 16 бит (как массив на 16 бит)
    static const __m128i popcount_table = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);
    // взятие значения первого полубайта из таблици
    const __m128i pcnt0 = _mm_shuffle_epi8(popcount_table, _mm_and_si128(a, popcount_mask));
    // взятие значения второго полубайта из таблици
    const __m128i pcnt1 = _mm_shuffle_epi8(popcount_table, _mm_and_si128(_mm_srli_epi16(a, 4), popcount_mask));
    __m128i d = _mm_add_epi8(pcnt0, pcnt1); // сложение результатов работы двух одинаковых таблиц
    
    // суммирование по горизонтали отдельно 8 байт и отдельно 8 байт и получение двух разных ushort
    __m128i v_sum = _mm_sad_epu8(d, _mm_setzero_si128()); // _mm_setzero_si128() это ноль
    int SumBit3=_mm_extract_epi16(v_sum, 0) + _mm_extract_epi16(v_sum, 4); // суммирование двух ushort
    cout<<"   SumBit3="<<SumBit3<<endl;
    // Результат: 255 это 8 бит *16=128
    
    int SumBit2=_mm_cvtsi128_si32 (d); // SSE2 movd
    SumBit2=0x0F & SumBit2;
    cout<<"   SumBit2="<<SumBit2<<endl;
    // Результат: 15 это 4 бита 00001111
    // сдесь зачем то все переменные __m128i либо static const либо const
    //*/
    
    /*
     // Исходник в виде функции 8 битного алгоритма popcnt без маски.
     static const __m128i popcount_mask = _mm_set1_epi8(0x0F);
     static const __m128i popcount_table = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);
     static inline __m128i popcnt8(__m128i n) {
     const __m128i pcnt0 = _mm_shuffle_epi8(popcount_table, _mm_and_si128(n, popcount_mask));
     const __m128i pcnt1 = _mm_shuffle_epi8(popcount_table, _mm_and_si128(_mm_srli_epi16(n, 4), popcount_mask));
     return _mm_add_epi8(pcnt0, pcnt1);
     }
     // есть версия с маской ///const __m128i x = _mm_xor_si128(a, b);
     //*/
    // https://stackoverrun.com/ru/q/7610241
    
    /*/
     // Функция popcnt64 подсчитывает количество битов в младшей и старшей 64-битных частях регистра SSE:
     static inline __m128i popcnt64(__m128i n) {
     const __m128i cnt8 = popcnt8(n);
     return _mm_sad_epu8(cnt8, _mm_setzero_si128());
     }
     //*/
    
    /*/
     // Наконец, функция popcnt 128 ниже подсчитывает количество бит во всем 128-битном регистре:
     static inline int popcnt128(__m128i n) {
     const __m128i cnt64 = popcnt64(n);
     const __m128i cnt64_hi = _mm_unpackhi_epi64(cnt64, cnt64);
     const __m128i cnt128 = _mm_add_epi32(cnt64, cnt64_hi);
     return _mm_cvtsi128_si32(cnt128);
     }
     //*/
    
    /*/
     // However, a more efficient way to implement popcnt128 is to use hardware POPCNT instruction (on processors which support it):
     static inline int popcnt128(__m128i n) {
     const __m128i n_hi = _mm_unpackhi_epi64(n, n);
     #ifdef _MSC_VER
     return __popcnt64(_mm_cvtsi128_si64(n)) + __popcnt64(_mm_cvtsi128_si64(n_hi));
     #else
     return __popcntq(_mm_cvtsi128_si64(n)) + __popcntq(_mm_cvtsi128_si64(n_hi));
     #endif
     }
     //*/
    
    // https://stackoverflow.com/questions/17354971/fast-counting-the-number-of-set-bits-in-m128i-register/17355341#17355341
    
    //------------------------------------------------------------------------------
    
    
    
    
    // ГОРИЗОНТАЛЬНЫЕ СУММЫ.
    
    // ТЕОРИЯ. //
    // если считать не единици а байты, то функция может работать с серыми файлами.
    
    // САМЫЙ БЫСТРЫЙ СПОСОБ ГОРИЗОНТАЛЬНОГО СУММИРОВАНИЯ БАЙТОВОГО ВЕКТОРА SSE БЕЗ ЗНАКА
    
    
    //*/
    // Вы можете сделать это с SSE2 _mm_sad_epu8 (psadbw), например:
    
    // Работающтй код быстрого способа горизонтального суммирования байтового вектора.
    // Трансляция 8-битного целого числа (байта) "a" на все элементы dst. // __m128i v = _mm_set1_epi8(a);
    __m128i v = _mm_set1_epi8(15); // тестовое входное число
    // суммирование по горизонтали отдельно 8 байт и отдельно 8 байт и получение двух разных ushort
    __m128i vsum = _mm_sad_epu8(v, _mm_setzero_si128()); // _mm_setzero_si128() это ноль
    int SumBit1=_mm_extract_epi16(vsum, 0) + _mm_extract_epi16(vsum, 4); // суммирование двух ushort
    cout<<"   SumBit1="<<SumBit1<<endl;
    // Результат: 15*16=240
    // Описание работы команд и агоритма:
    // SSE2 _mm_sad_epu8 (psadbw). Вычисление абсолютных разностей упакованных 8-разрядных целых чисел без знака uchar "a" и "b", затем суммирование по горизонтали каждых 8 разностей, для получчения двух 16-разрядных целых чисел без знака ushort, и упаковка эти 16-разрядные целые числа без знака ushort в младшие 16 битов 64-разрядных элементов 128-разрядного слова dst.
    // SSE2 _mm_extract_epi16(__m128i a, int imm8).  Извлечение 16-битное целое число ushort из "a", выбранного с помощью int imm8, и сохранение результата в нижнем элементе dst.
    //*/
    
    // Исходник быстрого способа горизонтального суммирования.
    //inline uint32_t _mm_sum_epu8(const __m128i v)
    //{
    //    __m128i vsum = _mm_sad_epu8(v, _mm_setzero_si128());
    //    return _mm_extract_epi16(vsum, 0) + _mm_extract_epi16(vsum, 4);
    //}
    
    // https://stackoverrun.com/ru/q/7610241
    
    //-----
    
    /*/
     // горизонтальные суммы // РАЗОБРАТЬСЯ
     
     Integer:
     pshufd - удобная копия и перетасовка. Бит и байтовые сдвиги, к сожалению, на месте, а punpckhqdq помещает большую половину адресата в низкую половину результата, напротив способа movhlps может извлечь верхнюю половину в другой регистр.
     
     Использование movhlps для первого шага может быть хорошим для некоторых процессоров, но только если у нас есть коррекция нуля. pshufd - это безопасный выбор, и быстро все после Merom.
     
     int hsum_epi32_sse2(__m128i x) {
     #ifdef __AVX__
     __m128i hi64  = _mm_unpackhi_epi64(x, x);           // 3-operand non-destructive AVX lets us save a byte without needing a mov
     #else
     __m128i hi64  = _mm_shuffle_epi32(x, _MM_SHUFFLE(1, 0, 3, 2));
     #endif
     __m128i sum64 = _mm_add_epi32(hi64, x);
     __m128i hi32  = _mm_shufflelo_epi16(sum64, _MM_SHUFFLE(1, 0, 3, 2));    // Swap the low two elements
     __m128i sum32 = _mm_add_epi32(sum64, hi32);
     return _mm_cvtsi128_si32(sum32);       // SSE2 movd
     //return _mm_extract_epi32(hl, 0);     // SSE4, even though it compiles to movd instead of a literal pextrd r32,xmm,0
     }
     
     # gcc 5.3 -O3
     pshufd xmm1,xmm0,0x4e
     paddd  xmm0,xmm1
     pshuflw xmm1,xmm0,0x4e
     paddd  xmm0,xmm1
     movd   eax,xmm0
     
     int hsum_epi32_ssse3_slow_smallcode(__m128i x){
     x = _mm_hadd_epi32(x, x);
     x = _mm_hadd_epi32(x, x);
     return _mm_cvtsi128_si32(x);
     }
     
     // http://qaru.site/questions/2411/fastest-way-to-do-horizontal-float-vector-sum-on-x86
     //*/
    
    //------------------------------------------------------------------------------
    
    
    // Способы задания 128 бит чисел для Assembler
    
    // Так 128 бит практически задается в распозновании unsigned long + unsigned long
    /// unsigned long long constF[2]={ 0x5555555555555555, 0x5555555555555555 } // { 0 };
    /// movups            xmm5, [constF];  // Пересылка данных (128 бит),
    // для следующего числа в массиве [constF+16]
    
    //------------------------------------------------------------------------------
    
    // Способы задания тестого 128 битного числа для интринсиков
    
    // Пословное заполнение 128 битного числа, есть слова: char, shopt, int, __m64 версии
    ///__m128i _mm_setr_epi16 (short e7, short e6, short e5, short e4, short e3, short e2, short e1, short e0)
    // Примеры пословного заполнения 128 битного числа
    //__m128i popcount_table = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);
    //unsigned long long v;
    //__m128i v=0x1;
    
    // Трансляция 8-битного целого числа (байта) "a" на все элементы dst. Это свойство может генерировать vpbroadcastb.
    ///__m128i v = _mm_set1_epi8(a);
    // Пример: 1 во всех байтах
    /// __m128i v = _mm_set1_epi8(1);
    
    // Заполнение нулями.
    /// _mm_setzero_si128() // Return vector of type __m128i with all elements set to zero.
    
    //----
    
    // Не тестировали.
    
    // Выполнение boost (не тестировали):
    ///#include <boost/multiprecision/cpp_int.hpp>
    ///using namespace boost::multiprecision;
    ///int128_t v=1;
    
    // Это лучше, чем строки и массивы, особенно если вам нужно выполнить с ним арифметические операции.
    // __int128_t поддерживается на x86-64. Он реализован в 64-битных целочисленных регистрах с использованием кода с добавлением-переносом и расширенной точностью для сдвигов, умножений и т. Д. (Регистры векторов SSE 128b не полезны ни для чего, кроме boolean (AND / OR / XOR), потому что они не могут сделать ни одного добавления 128b. SSE может делать два добавления 64b или несколько меньших элементов).
    // https://legkovopros.ru/questions/14721/exiz-t-c-z-td-reshenie-dlya-int128-dlya-vsex-kompilyatorov-dublikat
    
    // константы можно задавать <= 64р как long, но как задать второй long.
    ///__int128_t q=0xFFFFFFFFFFFFFFFF; // работает __int128_t, __int128 при <= 64
    ///unsigned __int128 q=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // не работает, не более >64.
    
    /*/
     // PDF БЫСТРЫЙ ЦИФРОВОЙ АЛГОРИТМ ОЦЕНКИ АМПЛИТУДЫ, МГНОВЕННОЙ ЧАСТОТЫ И ФАЗЫ УЗКОПОЛОСНОГО РАДИОСИГНАЛА Глушков А.Н
     
     // z′=0,828427(y0 +y1)−0,3431452⋅y0y1,
     // z′ = y0 + y1 − 0,75⋅ y0 y1
     
     Недостатком структурной схемы, показанной на рис. 1, является то, что нели-
     нейная операция (4) извлечения квадратного корня из суммы квадратов величин y0 и
     y1 для оценки амплитуды весьма трудоемка в части аппаратных и программных ресур-
     сов устройств. Для решения проблемы разработана процедура приближенного вычис- ления этой величины [3]
     z′=0,828427(y0 +y1)−0,3431452⋅y0y1, (14)
     которая требует меньших вычислительных затрат. Зависимости z и z′ от величин y0 и
     y1 , изменяющихся в диапазоне от 0 до 1, показаны на рис. 2, а. На рис. 2, б приведена
     зависимость погрешности приближения (14), которая оказывается вполне удовлетвори- тельной, т.к. разность ∆ z между вычисленным точным значением z и приближенным
     значением z′значительно меньше z:
     ∆z = z − z′. (15) Можно предложить более простой вариант вычисления величины (4) вида
     z′ = y0 + y1 − 0,75⋅ y0 y1 (16) с более удобными для цифровых вычислений множителями.
     //*/
    
    //------------------------------------------------------------------------------
    //------------------------------------------------------------------------------
    
    /*
     // ТЕСТ //исходник
     //gcc source.c -O0 -m64-o sourc
     #include <smmintrin.h>
     unsigned int mH=64;
     unsigned long long  *bytes_data_1=(unsigned long long*)malloc(mH*sizeof(unsigned long long*));
     unsigned long long  *p0=bytes_data_1;
     unsigned long long  *p1=bytes_data_1;
     unsigned long long  *p2=bytes_data_1;
     //unsigned long long m;
     unsigned long long Si;
     long long SumBitOn=0, SumBitOff=0;
     
     for ( unsigned long long m=0; m < mH; m++ ) { // mH д.б. четным
     // получение слайса (64 бита картинки) из транспонированного скана SInt
     Si=*(p0+m);
     if(Si > 0) {
     // Умножение (&) маски On на транспонированный скан SInt
     //Sb1=Si & *(p1+m);
     // Умножение (&) маски Off на транспонированный скан SInt
     //Sb2=Si & *(p2+m);
     // Регистровые суммы маски On  (подсчет единиц) по  X
     SumBitOn+=_mm_popcnt_u64(Si & *(p1+m));
     // Регистровые суммы маски Off (подсчет единиц) по  X
     SumBitOff+=_mm_popcnt_u64(Si & *(p2+m));
     } // if
     } // m
     //*/
    
    //------------------------------------------------------------------------------
    //------------------------------------------------------------------------------
    
    /*/
     
     TIME_START
     
     // ТЕСТ переназначения регистров popcnt и add. 12 апреля 2019.
     
     // Сама функция взята из setMatrix_Point_32_64_SSE.cpp
     // Переназначены регистры popcnt и add.
     // По утверждения авторов реальное быстродействие должно увеличится в 2 раза:
     // https://stackoverflow.com/questions/25078285/replacing-a-32-bit-loop-counter-with-64-bit-introduces-crazy-performance-deviati
     // На статичесих входных данных нет никакой разници.
     
     unsigned long long mH=1000000000; // mH=(8-128) высота и mW=32 ширина (габарит), битовой маски перефирийной области  "Off"  mH=1000000000;
     
     unsigned long long  sIntA   =0xFFFFFFFFFFFFFFFF;
     unsigned long long  maskOnA =0x00FFFF0000FFFF00;
     unsigned long long  maskOffA=0xF000000FF000000F;
     long long deltaSum=0;
     
     // переход в режим Assembler 64р
     __asm {
     
     // Установка накопительных 64p регистров  r8 и r9 и переменной цикла rdx в ноль или mov eax, 0
     xor             rdx, rdx;       // установка ноля  0x0000000000000000
     xor             r8,  r8;        // установка ноля  0x0000000000000000
     xor             r9,  r9;        // установка ноля  0x0000000000000000
     
     ////     mov             r11,  0xFFFFFFFFFFFFFFFF;         // установка ноля
     ////     mov             r12,  0xFFFFFFFFFFFFFFFF;         // установка ноля
     
     
     ////  начало цикла по переменной в регистре  rdx, шаг цикла 8, количество циклов mH/2
     //  8 число байт в 64 разрядном регистре, считаем 2 слайса за один цикл, количество циклов: mH*8/2 = mH*4 = mH<<2
     mov       rcx, mH;               //  загрузка количества циклов mH
     shl       rcx, 2;                //  умножение  rcx на *4 или lea  rcx,[rcx*4]; //  умножение  rcx на *4 + смещение на один (8) цикл
     loop_start:
     
     
     
     // вычисление адреса транспонированного скана sIntA
     ///mov       rax, sIntA;            //  вычисление адреса слайса скана
     ///add       rax, p;                //  добавление к адресу слайса смещения на переменную p
     ///lea       rax, [rax+rdx];        //  добавление к адресу маски переменной цикла   //add       rax, rdx;
     mov       r10, rcx;            //  загрузка слайса скана в регистр r10
     //                 mov             r10,  0xFFFFFFFFFFFFFFFF;
     
     // переход, если два подряд идущих слайса (64р) равны нолю (маски и единици не считаем)
     cmp       r10, 0;
     je          if_zero;               // je переход если  флаг ноля FZ=0     jz
     
     // вычисление адреса, умножение маски On на транспонированный скан sIntA
     ///mov       rax, maskOnA;          //  вычисление адреса маски maskOnA
     ///lea       rax, [rax+rdx];        //  добавление к адресу маски переменной цикла   //add       rax, rdx;
     mov       r11, maskOnA;            //  загрузка маски On в регистр r11 0x00FFFFFFFFFFFF00;
     //                 mov             r11,  0xFFFFFFFFFFFFFFFF;
     and       r11, r10;              //  применение & маски On к слайсу скана // and       r11, r10
     
     // вычисление адреса, умножение маски Off на транспонированный скан SInt
     ///mov       rax, maskOffA          //  вычисление адреса маски maskOffA
     ///lea       rax, [rax+rdx];        //  добавление к адресу маски переменной цикла   //add       rax, rdx;
     mov       r12, maskOffA;            //  загрузка маски maskOffA в регистр r12 0xFFFFFF00FFFFFF0;
     //                 mov             r12,  0xFFFFFFFFFFFFFFFF;
     
     and       r12, r10;              //  применение & маски maskOffA к слайсу скана
     
     
     ////////////////////////////
     
     
     // Регистровые суммы маски On (подсчет единиц) по  X и Y, инструкция popcnt была добавлена в "Nehalem" (SSE4.2).
     // Регистр rax свободен.
     popcnt    r11, r11;              // подсчет количества единиц скана попавших в маску On по горизонтали.
     add       r8,  r11;              // накопление единиц попавших в маску On в регистре r8
     // (подсчет маскированной площади всего признака).
     
     // Регистровые суммы маски Off (подсчет единиц) по X и Y
     popcnt    r12, r12;              // подсчет количества единиц скана попавших в маску Off по горизонтали.
     add       r9,  r12;              // накопление единиц попавших в маску Off в регистре r9
     // (подсчет маскированной площади всей защитной области).
     
     if_zero:
     
     
     ////  окончание цикла, шаг цикла 8       // add  +8   // sub -8
     add             rdx, 8;          // в rdx находится переменная цикла
     cmp             rdx, rcx;        // в rcx находится количество циклов mH*4
     jl                  loop_start;      // jl перейти, jle перейти, если меньше или равно
     
     
     // Регистровая разность площадей скана попавших маску Off и маску On
     sub       r8,  r9;               // вычитание количества единиц попавших в маску Off регистр r9,
     // из единиц попавших в маску On регистр r8.
     
     // заносим разности площадей On и Off в накопительную переменную  deltaSum
     mov       deltaSum, r8;          // сохранение разности площадей On и Off в переменной deltaSum
     //*/
    
    /*/
     // Регистровые суммы маски On (подсчет единиц) по  X и Y
     popcnt    rax, r11;              // подсчет единиц маскированного слайса скана по X, инструкция была добавлена ​​в "Nehalem" (SSE4.2)
     add       r8,  rax;              // суммирование единиц попавших в маску On в регистре r8 (подсчет маскированной площади признака)
     
     // Регистровые суммы маски Off (подсчет единиц) по X и Y
     popcnt    rax, r12;              // подсчет количества единиц маскированного слайса скана по X (подсчет горизонтальных сумм)
     sub       r8,  rax;              // вычитание единиц попавших в маску Off из регистра r8
     
     if_zero:
     
     
     ////  окончание цикла, шаг цикла 8       // add  +8   // sub -8
     add             rdx, 8;          // в rdx находится переменная цикла
     cmp             rdx, rcx;        // в rcx находится количество циклов mH*4
     jl                  loop_start;      // jl перейти, jle перейти, если меньше или равно
     
     
     
     // заносим разности площадей On и Off в накопительную переменную  deltaSum
     mov       deltaSum, r8;          // сохранение разности площадей On и Off в переменной deltaSum
     
     
     ////////////////////////////
     
     
     // возврат из режима Assembler
     } // __asm
     
     cout<<"   deltaSum="<<deltaSum<<endl; // time=0.7
     
     TIME_PRINT_
     //*/
    
    //------------------------------------------------------------------------------
    //------------------------------------------------------------------------------
    
    #endif
    
  }
  
  
  
  
} // namespace ocr
