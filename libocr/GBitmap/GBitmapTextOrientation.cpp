//  Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .

#include "GBitmap.h"

#ifdef ASM_OS64_SSE42_POPCNT_ATT
#include <smmintrin.h>  // для_mm_popcnt_u64
#endif

namespace ocr{
  
  //*****************************************************************************
  
  // Функция автоматического переформирования Тибетского графического текста по вертикали.
  // Меняет местами верх и низ графического текста .
  // Предусмотреть несколько отработчиков разных поворотов, для начала с ручным управлением: зеркальный  и т.д.
  
  void  GBitmap::textVerticalRotation(int Orient, int *lnOrient, int *lnHeight) {
    
    // Функция осушествляет вертикальный зеркальный поворот или вертикальный поворот графического текста  на +180°
    // в соответствии с параметром полученному от подпрограммы textOrientation.
    // Возвращает те же параметры что и функция textOrientation.
    
    // Orient=1; - вертикальное зеркальное отражение графического текста, Orient=2; поворот текста на +180°.
    
    if (Orient<1) return;
    
    int GrafT=0;    // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
    float rotation=0;
    int lineOrient=0;    int lineHeight=0;
    // Вызов функции определения пространственной ориентации Тибетского графического текста.
    textOrientation( &lineOrient, &lineHeight );
    // Возвращает параметр вертикальной ориентации:
    // lineOrient==1 текст нормально ориентирован, -1 текст повернут на 180°,  0 ориентация текста определена не достоверно.
    // Возвращает оценку средней высоты строки lineHeight (без влияния рамок вокруг текста) и завышает высоту маленьких строк.
    
    if (GrafT) { cout<<"Функция вертикального поворота Тибетского графического текста  textVerticalRotation()"<<endl;
      cout<<" lineOrient ="<<lineOrient<<",  lineHeight="<<lineHeight<<endl; }
    
    // Поворот изображения // time=0.11 w=16224 × h=2464 rotation== +180°
    if(lineOrient==-1){
      // Вызов функции вертикального зеркального отражения графического текста.
      if ( Orient==1) { VerticalMirror();
        if (GrafT) { cout<<"Функция VerticalMirror выполнила зеркальное отражение текста по вертикали"<<endl; }}
      // Вызов функции поворота изображения на произвольный угол rotation или дискретные углы  +180°, +90°, -90°
      if ( Orient==2) { rotateFast(180);
        if (GrafT) { cout<<"Функция textVerticalRotation повернула текст на +180°  rotation="<<rotation<<endl; }}
    }
    
    if(lineOrient==0){
      if (GrafT) cout<<"Функция textVerticalRotation, ориентация текста определена не достоверно"<<endl;
    }
    
    
    // Возвращаем параметр вертикальной ориентации.
    *lnOrient=lineOrient;
    // Возвращаем оценку средней высоты строки.
    *lnHeight=lineHeight;
    
    /**/
    
  }//____________________________________________________________________________
  
  
  //*****************************************************************************
  
  // Функция вертикального зеркального отражения графического текста. 23 марта 2019.
  void  GBitmap::VerticalMirror() {
    
    // Функция осушествляет вертикальное зеркальное отражение графического текста.
    // Меняет местами верх и низ графического текста перестановкой строк по вертикали.
    
    int w=ncolumns;     // ширина массива   IMAGE_WIDTH
    int h=nrows;        // высота массива   IMAGE_HEIGHT
    int w_h=w*h;        // размер массива   IMAGE_SIZE
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    if (GrafT) { cout<<"Функция вертикального зеркального отражения графического текста  VerticalMirror()"<<endl;
      cout<<"  w="<<w<<",  h="<<h<<",  w_h="<<w_h<<endl; }
    
    TIME_START
    
    uchar *p0 = bytes_data;
    uchar *d0;
    uchar *p1 = bytes_data;
    uchar *d1;
    
    //*
    int h_2=h/2;
    p1=p1 + h*w - w;
    for (int y=0; y<h_2; y++) // h_2=h/2;
    {
      // вспомогательные переменные для увеличения быстродействия.
      d0=p0;  // сохраняем для выполнения цикла по "x".
      d1=p1;  // сохраняем для выполнения цикла по "x".
      for (int x=0; x<w; x++)
      {
        // Обмен байтами из разных строк.
        uchar rg1=*d1;
        *d1=*d0;
        *d0=rg1;
        d0++;       // p0 = bytes_data + y*w + x;
        d1++;       // p1 = bytes_data + h*w - y*w + x;
        // ТЕСТ на выход за пределы массива.
        //long p=d0-bytes_data;   if (p<4 || p>(w_h/2-4)) cout<<"w*h="<<w*h<<",  p="<<p<<endl;
        //long p=d1-bytes_data;   if (p<4 || p>(w_h-4)) cout<<"w*h="<<w*h<<",  p="<<p<<endl;
      } //x
      p0+=w;          // p0 = bytes_data + y*w;
      p1-=w;          // p1 = bytes_data + h*w - y*w;
    } //y
    //*/
    
    if(GrafT) { TIME_PRINT_ }
    
    // для ulong версии
    /*
     int w_h_64=w_h/sizeof(ulong);               // sizeof(ulong)=8
     ulong *bytes_data_64=(ulong*)bytes_data;    // приведение bytes_data к типу ulong
     
     // Инвертируем по 8 байт одновременно. Последний участок массива длинной от 0 до 8 байт не инвертируется.
     //    for ( int x=0; x < w_h_64; x++ ) { bytes_data_64[x]=~bytes_data_64[x]; }
     // инверсия последнего участка массива длинной от 0 до 8 байт.
     int wh_=w_h_64*sizeof(ulong);
     //    for (int x=wh_; x<w_h; x++){ bytes_data[x]=~bytes_data[x]; }
     //*/
    
  }//____________________________________________________________________________
  
  
  
  //*****************************************************************************
  
  // функция определения пространственной ориентации Тибетского графического текста.
  
  void  GBitmap::textOrientation(int *lineOrient, int *lineHeight) {
    
    // Определяет пространственную ориентацию Тибетского графического текста и возвращает.
    // orientation=1;  текст нормально ориентирован.
    // orientation=-1; текст повернут на 180.
    // orientation=0;  ориентация текста определена не достоверно.
    // Возвращает среднею высоту строки lineHeight  (без влияния рамок вокруг текста)
    // Входной массив bytes_data это unsigned char и может быть любым черно-белым или серым.
    
    //  * Идея *
    // Буквы Тибетского текста часто в верхней части имеют ярко выраженную горизонтальную полку.
    // Нижняя часть букв не имеет характерных графических особенностей.
    // По этому суммарная яркость строки по горизонтали имеет выраженную ассимерию между нижней и верхней половиными строк.
    // Вычисляя эту ассиметрию можно определить верхнею и нижнею часть строки.
    
    //  * Реализация *
    // оптимальное число колонок 3-4, если разбивать текст на большее число колонок, то внутри колонки может не хватить
    // статистики для определения ориентации текста. Меньшее число колонок так же не позволяет правильно определить
    // ориентацию текста, из встречающихся вертикальных деформаций по длинных печа.
    
    //  * Особенности применения *
    // Перед применением функции не забыть повернуть графическй текст.
    // Функция возвращает среднею высоту строки lineHeight без влияния рамок вокруг текста.
    // Среднея высота это все таки больше оценка высоты строки, чем ее истинное значение.
    
    
    
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
    TIME_START
    
    if (GrafT) { cout<<"Определение пространственной ориентации Тибетского текста   textOrientation()"<<endl; }
    
    int x,y;
    int w,h;    //int w_h=w*h;
    w=ncolumns; // ширина массива  IMAGE WIDTH
    h=nrows;    // высота массива  IMAGE HEIGHT
    if (GrafT) { cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
    
    // управляющие переменные
    int m=3; // количество вертикальных колонок в которых производится  независимый анализ ориентации текста
    int thresholdAsm1=2;      // порог, выше которого коэффициент ассиметрии считается легитимным
    int thresholdAsm2=50;     // порог, ниже которого коэффициент ассиметрии считается легитимным
    int orientM=0;            // параметр ориентации Тибетского графического текста в одной колонке
    int orientMean=0;         // возвращаемый параметр ориентации Тибетского графического текста по всем колонкам.
    
    // вспомогательные переменные
    int n=0;             // переменная строк
    int md;              // суммарный горизонтальный размер "m" колонок
    int w_n;             // переменная используемая для приведение уровней графического текста к уровню белого=0  // w_n=w/ns+1;
    int max_s1, max_s2;  // значение максимума (амплитуды) горизонтальных сумм внутри первой, второй половины строки
    int lineHgM=0;       // вычисленная средняя высота строки по одной колонки
    int lineHgMean=0;    // вычисленная средняя высота строки по всем колонкам
    int NLine=0;         // вычисленное количество легитимных строк в печа
    int MLine;           // вычисленное количество легитимных колонок в печа (количество колонок, где есть хотя бы одна строка)
    int asymetr;         // вычисленный средний коэффициент ассиметрии строки приведенный к 100 процентам
    int asymetrM=0;      // средний коэффициент ассиметрии asymmetry строки приведенный к 100 процентам:
    // в полностью симметричной строке коэффициент ассиметрии asymmetry стремится к 0 (обычно -2 до 2),
    // в ассиметричной строке стремится к 100 процентам (обычно 5-15),
    // в ассиметричной строке повернутой на 180 градусов стремится к -100 процентам (обычно те же 5-15, но отрицательные)
    
    // вспомогательные переменные для увеличения быстродействия
    int s;        // ,sum,snorm
    int n1,n3;
    int n00,n11;
    int b1,b2,b3;
    
    // вспомогательные переменные для предотвращения выхода за пределы массива
    
    // указатели
    unsigned char *p0=bytes_data;    // входной массив, 0-черный 255-белый ( с 0-черный 1-белый не работает)
    int *BufS1, *d1;  // массив //
    int *BufS2;       // массив // *d2
    int *BufS3, *d3;  // массив //
    int sizeBufS=h;
    int sizeBufS_bytes=sizeBufS*sizeof(int);
    
    // Массивы. Каждый элемент инициализируется в 0.
    BufS1 = (int*)calloc(sizeBufS+32,sizeof(int)); // d1
    BufS2 = (int*)calloc(sizeBufS+32,sizeof(int)); // d2
    BufS3 = (int*)calloc(sizeBufS+32,sizeof(int)); // d3
    
    OCRFilter *SP=OCRFilter::create(nrows);  // необходима для filterHigh()
    
    // Увеличение шага сканирования графического текста (по ширине w). Для увеличения быстродействия.
    // Если ширина графического текста больше 5000 pix то суммируем пиксели через n
    int ns=w/5000+1;         // if(ns>10) ns=10;
    //ns=1; //ns=500;
    if (GrafT) { cout<<"шаг сканирования графического текста    ns="<<ns<<endl; }
    
    // Увеличение степени сглаживания горизонтальных сумм для сверхбольших печа. Если горизонтальная длина
    // графического текста больше 10000 pix, то коэффициенты сглаживания увеличиваются вдвое и т.д.
    int mf=w/10000 + 1;
    int KHigS1=3*mf;    // 4 min     // KHig1=(8-24) // KHigS=KFStrok*4+8;filter
    int KHigS2=12*mf;
    int KHigS3=128*mf;  // пока 80 зто максимум, надо 160*m
    if (GrafT) { cout<<"величина увеличения сглаживания горизонтальных сумм   mf="<<mf<<endl; }
    
    
    // отступы от краев (бордюр) x0, x1, y0, y1, блокируют влияние грязи с краев текста.
    // Возможный захват бордюром не большой части текста в данном случае не критичен.
    int br=8;   // 6
    int x0=0, x1=0, y0=0, y1=0;
    y0=h/br;  y1=h-h/br; // x0=w/br
    
    //переменные для визуализации гистограмми
    int M=6; static short delta=10; int ss;
    
    //int index=0;     // 2   // test
    
    
    //************************************************************************************************************
    
    // цикл по числу вертикальных колонок в которых производится  независимый анализ ориентации текста
    MLine=m;
    for (int index=0; index < m; index++){
      
      md=(w-w*2/br)/m; // суммарный горизонтальный размер "m" колонок
      // динамический бордюр
      x0=w/br + index*md;   x1=x0 + md;  if(x1 > w) x1=w;
      ///cout<<"index="<<index<<"   md="<<md<<"   x0="<<x0<<"   x1="<<x1<<endl;
      // int x0=w/br;  int x1=w-w/br;  // классический вариант статического бордюра
      
      // обнуление массива BufS1
      memset(BufS1, 0, sizeBufS_bytes);  // начало (указатель), значение, количество символов в байтах (длина) unsigned.
      
      if (GrafT) {
        // горизонтальные линии, паказывающая область работы колонок.
        for(y=y0; y < y0+5; y++) { for (x=x0; x<x1; x++) { bytes_data[y*w+x]*=0.1; } }
        for(y=y1; y < y1+5; y++) { for (x=x0; x<x1; x++) { bytes_data[y*w+x]*=0.1; } }
        // вертикальные линии, паказывающая область работы колонок.
        for(y=y0; y < y1; y++) { for (x=x0; x<x0+5; x++) { bytes_data[y*w+x]*=0.5; } }
      }
      
      // подсчет горизонтальных (horizontal_sum) сумм  //
      w_n=(x1-x0)/ns+1;   // переменная используемая для приведение уровней графического текста к уровню белого=0// w_n=w/ns+1;
      d1=BufS1;
      for (y=y0; y < y1; y++){       // 16224 × 2464 // time=0.13      // time=0.031
        s=0;
        p0=bytes_data + y*w;
        for (int x=x0; x < x1; x+=ns){
          if ( *(p0+x)>0 ) { s++; }  //s+=*(p0+x);  // time=0.11
        } // x
        // приведение уровней графического текста к уровню белого 0 и уровню черного 1
        *(d1+y)=(w_n-s)*ns;
      } // y
      //cout<<endl;
      /**/
      
      
      // слабая фильтрация  KHigS1=3*mf;
      // начало BufS1 так же используется для хранения координат координат верха и низа строк
      // для графического текста с горизонтальной длинной меньше 7000 pix (mf=1) сглаживание не используем
      if ( mf >= 1 ) { SP->filterHigh( (int*)BufS1, h, KHigS1); }
      // визуализация BufS1
      if (GrafT) {    if (GrafT ) {  }
        M=6; delta=10;   // uint
        for(y=0; y<h; y++) { ss=(BufS1[y]/M)+delta; if (ss>w)ss=w; for (x=delta; x<ss; x++) { bytes_data[y*w+x]*=0.6; } }
      }
      
      
      // копирование BufS1 в BufS2
      memcpy(BufS2, BufS1, sizeBufS_bytes);  // адрес буфера назначения, адрес источника, количество байт для копирования
      // средняя фильтрация KHigS2=12*mf;
      SP->filterHigh( (int*)BufS2, h, KHigS2) ;
      // визуализация BufS2
      if (GrafT) {
        M=6; delta=10;
        for(y=0; y<h; y++) { ss=(BufS2[y]/M)+delta; if (ss>w)ss=w; for (x=delta; x<ss; x++) { bytes_data[y*w+x]*=0.6; } }
      }
      
      
      // копирование BufS2 в BufS3
      memcpy(BufS3, BufS2, sizeBufS_bytes); // адрес буфера назначения, адрес источника, количество байт для копирования
      // сильная фильтрация KHigS3=128*mf;  // пока 80 - зто максимум того, что позволяет filterHigh(), поэтому сглаживаем 3 раза
      SP->filterHigh( (int*)BufS3, h, KHigS3 );
      SP->filterHigh( (int*)BufS3, h, KHigS3 );
      SP->filterHigh( (int*)BufS3, h, KHigS3 );
      /**/
      // визуализация BufS3
      if (GrafT) {
        M=6; delta=10;     // uint
        for(y=0; y<h; y++) { ss=(BufS3[y]/M)+delta; if (ss>w)ss=w; for (x=delta; x<ss; x++) { bytes_data[y*w+x]*=0.6; } }
      }
      
      
      // бинаризация BufS2 //
      // здесь BufS3 становится меандром, который используется для вычисления координат верха и низа строк
      for (y=0; y < h; y++) { if ( BufS2[y] > BufS3[y] + 8 ) { BufS3[y]=1024; } else { BufS3[y]=0; } } // y
      // обнуление хвостов
      memset(BufS3, 0, 4*y0);   memset(BufS3+y1, 0, 4*(h-y1));   // начало (указатель), значение, количество символов в байтах (длина) unsigned
      //for (y=y1; y < h; y++) { BufS3[y]=0; }
      // визуализация границ строк (гистограмма)
      if (GrafT) {
        M=1; delta=w/8;
        for(y=0; y<h; y++) { ss=(BufS3[y]/M)+delta; if (ss>w)ss=w; for (x=delta; x<ss; x++) { bytes_data[y*w+x]*=0.6; } }
      }
      
      
      // подсчет числа строк и их координат //
      n1=0;  n3=0;
      //for (y=y0-1; y < y1; y++){ // y=y0-1;
      for (y=0; y < h; y++){
        d3=BufS3+y;
        // вычисление координаты верха строки
        if ( *d3<*(d3+1) ) { n1+=4; BufS1[n1]=y; }
        // вычисление координаты низа строки
        if ( *d3>*(d3+1) ) { n3+=4; BufS1[n1+2]=y; BufS1[n1+3]=0; }
      } // y
      if (GrafT) { cout<<"число строк  (n1)/4="<<n1/4<<"  (n3)/4="<<n3/4<<endl; }
      
      
      asymetrM=0;      // вычисленный средний коэффициент ассиметрии
      lineHgM=0;       // вычисленная средняя высота строки
      NLine=0;         // вычисленное количество легитимных строк в печа
      
      // Отбрасывание рамок. Убираем по 1 строке (или по 2) сверху и по 1 строке (или по 2) снизу
      n00=4; n11=n1+4; // одна строка это 4    // for (n=4; n < n1+4; n+=4)
      if ( n1 > 5*4 && n1 <= 7*4) { n00=4+4; n11=n1+4-4; }    if ( n1 > 7*4 ) { n00=4+8; n11=n1+4-8; }
      
      // вычисление коэффициента ассиметрии и средней высоты строки графического текста  //
      for (n=n00; n < n11; n+=4){  // цикл по числу строк
        max_s1=0;   max_s2=0;
        b1=BufS1[n];  b2=BufS1[n+2];  b3=(b1+b2)/2;
        // вычисление максимума (амплитуды) горизонтальных сумм внутри первой половины строки
        for ( y=b1; y < b3; y++){ if ( BufS1[y] > max_s1 ) { max_s1=BufS1[y]; } }
        // вычисление максимума (амплитуды) горизонтальных сумм внутри второй половины строки
        for ( y=b3; y < b2; y++){ if ( BufS1[y] > max_s2 ) { max_s2=BufS1[y]; } }
        // маленькие амплитуды не обсчитываем
        if ( max_s1<16 || max_s2<16) { max_s1=0; max_s2=0; }
        // вычисление коэффициента ассиметрии , как разности амплитуд горизонтальных сумм выше и ниже
        // середины строки (в пределах строки), приведенной к 100 процентам
        asymetr=(max_s1 - max_s2)*100/(max_s1 + max_s2 + 1);
        ////cout<<"asymetr="<<asymetr<<"   b1="<<b1<<"   b3="<<b3<<"   b2="<<b2<<endl;
        if (GrafT) { cout<<"asymetr="<<asymetr<<endl; }
        // вычисление суммарного коэффициента ассиметрии и суммарной высоты строки графического текста, только если
        // коэффициент ассиметрии лежит между значениями порогов thresholdAsm1=2 и thresholdAsm2=50 т.е. от 3 до 49.
        if ( (asymetr>thresholdAsm1 && asymetr<thresholdAsm2 )||( asymetr<-thresholdAsm1 && asymetr>-thresholdAsm2))
        { asymetrM+=asymetr;  lineHgM+=(b2-b1);  NLine++; }
      } // n
      // cout<<endl;
      
      // нормировка средней высоты строки графического текста по одной колонке.
      if ( NLine==0 ) { lineHgM=0; MLine--; }  else { lineHgM/=NLine;  lineHgMean+=lineHgM; }
      if (GrafT) { cout<<"средняя высота строки   lineHgM="<<lineHgM<<endl;
        cout<<"число легитимных строк  NLine="<<NLine<<endl; }
      
      // нормировка среднего коэффициента ассиметрии.
      if ( NLine==0 ) { asymetrM=0; }  else { asymetrM/=NLine; }
      if (GrafT) { cout<<"средний коэффициент ассиметрии   asymetrM="<<asymetrM<<endl; }
      
      // установка параметра ориентации Тибетского графического текста по каждой колонке.
      orientM=0;
      if ( asymetrM >  thresholdAsm1 ) orientM=1;
      if ( asymetrM < -thresholdAsm1 ) orientM=-1;
      orientMean+=orientM;
      if (GrafT) { cout<<"параметр ориентации Тибетского графического текста     orientM="<<orientM<<endl; }
      /**/
      
      
    } // index
    
    // последняя (крайне правая) вертикальная линия, паказывающая область работы колонок.
    if (GrafT) { for(y=y0; y < y1; y++) { for (x=x1; x<x1+5; x++) { bytes_data[y*w+x]*=0.5; } }  }
    
    //************************************************************************************************************
    
    // вычисление средней высоты строки графического текста по всем колонкам.
    // MLine это количество колонок, где есть хотя бы одна строка
    if ( MLine > 0 ) { lineHgMean/=MLine; }  else { lineHgMean=0; }
    ///cout<<endl<<"средняя высота строки по всем колонкам   lineHgMean="<<lineHgMean<<endl;
    if (GrafT) { cout<<"число легитимных колонок в печа   MLine="<<MLine<<endl; }
    //*lineHeight=(float)lineHgMean*0.8;
    *lineHeight=lineHgMean*(float)0.8; // (float)0.8;
    
    // окончательная установка параметра ориентации Тибетского графического текста по всем колонкам.
    if ( orientMean >=  1 ) orientMean=1;    if ( orientMean <= -1 ) orientMean=-1;
    //if (GrafT) { cout<<"orientMean="<<orientMean<<endl; }
    *lineOrient=orientMean;
    
    // освобождение массивов
    if ( BufS1 !=NULL ) free(BufS1);
    if ( BufS2 !=NULL ) free(BufS2);
    if ( BufS3 !=NULL ) free(BufS3);
    
    
    if(GrafT) { TIME_PRINT_ }
    
  }//____________________________________________________________________________
  
  
  
  
  //---------------------------------------------------------------------------
  /// TMP ///
  
  // memset(horizontal_sum, 255, 4*h);  // начало (указатель), значение, количество символов в байтах (длина) unsigned
  
  // граници выделяем механизмом растискивания
  
  // общая переменная (9999) - оценка средней высота строки, для всего батча, нужна для textOrientation() и textClean()
  // если не подсчитана, то программы запускают свой подсчет
  
  // сглаживание KHig1=8(8-24) и KHig10 как порог, как в binarisation или Лапласиане. Меандр как нахождение максимума продольных сумм строк, фактическое
  // нахождение мах, деление площади на две части, вычисление ассиметрии, простая статистическая обработка результатов по строкам.
  //  сильная фильтрация (80, надо 128-256) исходных горизонтальных сумм
  // вычисление максимума maxF сильно фильтрованных исходных сумм
  
  
  //KHigS=0;       // оптимальный параметр фильтрации строк
  //DeltaNstr=0;   // вычисленная высота строки
  //NStrok=0;      // вычисленное колличество строк в печа
  
  // if ( w>1000 ) { то подсчет horizontal_sum выполняем 3 не зависимыми вертикальными блоками}
  //  else { то выполняем обычный подсчет horizontal_sum по всей площади }
  
  //---------------------------------------------------------------------------
  
  /*
   int dot_gain=7;
   int g1, g2, g3, g4;
   cout<<"dot_gain="<<dot_gain<<endl;
   
   int dg=dot_gain/2;        // cout<<"dg="<<dg<<endl;   // division
   g1=dg;  g2=dg;  g3=dg;  g4=dg;
   dg=dot_gain%2;            // cout<<"dg="<<dg<<endl;   // modulo
   g1+=dg;  g3+=dg;
   cout<<"g1="<<g1<<"   g2="<<g2<<"    g3="<<g3<<"   g4="<<g4<<endl;
   */
  
  
  ///*(d1+y)=snorm=(w_n-s)*ns;
  // подсчет вертикальных интегральных сумм (лесенка)
  ///sum+=snorm; *(d4+y)=sum;
  // cout<<"_"<<(short)*(d1+y);
  // int max_y=0;       // координаты максимума горизонтальных сумм в строке
  // int max_s=0;         // максимальное значение горизонтальных сумм в строке
  // d2=BufS2+y; d3=BufS3+y;   if ( *d2 >*d3 ) { *d3=1024; } else { *d3=0; }
  
  /*
   asymetr=49; ///  3-49
   // только если коэффициент ассиметрии лежит между значениями порогов thresholdAsm1=2 и thresholdAsm2=50 т.е. от 3 до 49
   if ( (asymetr>thresholdAsm1 && asymetr<thresholdAsm2 )||( asymetr<-thresholdAsm1 && asymetr>-thresholdAsm2))
   { cout<<"параметр     asymetr="<<asymetr<<endl; }
   */
  
  // вычисление средней высоты строки графического текста.
  ///if ( asymetr>thresholdAsm1 || asymetr<-thresholdAsm1 ) { lineHgM+=(b2-b1); NLine++; }
  // вычисление среднего коэффициента ассиметрии.
  ///asymetrM+=asymetr;
  /*
   max_s1=44; max_s2=24;
   if ( max_s1<16 || max_s2<16) { max_s1=0; max_s2=0; }
   cout<<"параметр     max_s1="<<max_s1<<"            параметр     max_s2="<<max_s2<<endl;
   */
  // обнуление массива BufS3
  ///memset(BufS3, 0, 4*y0);     memset(BufS3+y1, 0, sizeBufS_bytes);  // начало (указатель), значение, количество символов в байтах (длина) unsigned
  //for (y=y1; y < h; y++) { BufS3[y]=0; }
  
  
  /*
   // Отбрасывание рамок. Убираем по 1 строке (или по 2) сверху и по 1 строке (или по 2) снизу
   n00=4; n11=n1+4; // одна строка это 4    // for (n=4; n < n1+4; n+=4)
   if ( n1 > 5*4 && n1 <= 7*4) { n00=4+4; n11=n1+4-4; }    if ( n1 > 7*4 ) { n00=4+8; n11=n1+4-8; }
   ///int max_y1;  int max_y2; int max_dy;  int asm_y;
   
   // вычисление коэффициента ассиметрии и средней высоты строки графического текста  //
   for (n=n00; n < n11; n+=4){  // цикл по числу строк
   max_s1=0;   max_s2=0;
   b1=BufS1[n];  b2=BufS1[n+2];  b3=(b1+b2)/2;
   // вычисление максимума (амплитуды) горизонтальных сумм внутри первой половины строки
   for ( y=b1; y < b3; y++){ if ( BufS1[y] > max_s1 ) { max_s1=BufS1[y]; } }  // max_y1=y;
   // вычисление максимума (амплитуды) горизонтальных сумм внутри второй половины строки
   for ( y=b3; y < b2; y++){ if ( BufS1[y] > max_s2 ) { max_s2=BufS1[y]; } }  // max_y2=y;
   ///max_dy=max_y2-max_y1;    asm_y=max_dy*100/48; // (b2-b1+1)
   ///max_dy=max_y2-max_y1;    asm_y=((b3-max_y1)-(max_y2-b3))*100/(max_y2 - max_y1 + 1); // (b2-b1+1)
   // маленькие амплитуды не обсчитываем
   if ( max_s1<16 || max_s2<16) { max_s1=0; max_s2=0; }
   // вычисление коэффициента ассиметрии , как разности амплитуд горизонтальных сумм выше и ниже
   // середины строки (в пределах строки), приведенной к 100 процентам
   asymetr=(max_s1 - max_s2)*100/(max_s1 + max_s2 + 1);
   ///cout<<"asymetr="<<asymetr<<"   b1="<<b1<<"   max_y1="<<max_y1<<"   b3="<<b3<<"   max_y2="<<max_y2<<"   b2="<<b2<<endl;
   ////cout<<"asymetr="<<asymetr<<"   b1="<<b1<<"   b3="<<b3<<"   b2="<<b2<<endl;
   ////cout<<"asymetr="<<asymetr<<"   max_dy="<<max_dy<<"   asm_y="<<asm_y<<endl;
   if (GrafT) { cout<<"asymetr="<<asymetr<<endl; }
   // вычисление суммарного коэффициента ассиметрии и суммарной высоты строки графического текста, только если
   // коэффициент ассиметрии лежит между значениями порогов thresholdAsm1=2 и thresholdAsm2=50 т.е. от 3 до 49.
   if ( (asymetr>thresholdAsm1 && asymetr<thresholdAsm2 )||( asymetr<-thresholdAsm1 && asymetr>-thresholdAsm2))
   { asymetrM+=asymetr;  lineHgM+=(b2-b1);  NLine++; }
   } // n
   // cout<<endl;
   */
  
  
  
  
  
  //-------------------------------------------------------------------------------------------------------------------
  
  
  // Функция вычисления вертикального размера Тибетской буквы "B" в графическом тексте по координатам мышки.
  // 14 марта 2019
  
  float  GBitmap::scaleTibetanB(int xB, int yB) {
    
    // Функция получает на вход координаты центра Тибетской буквы "B", полученные с помощью мышки.
    // Возвращает вертикальный размер float Тибетского буквы "B" с pix.
    // Входной массив bytes_data должен быть бинаризован.
    
    // Вручную ставим коортинаты xB,yB центр Тибетской буквы "B". Из него проводим вертикальную линию в верх и в низ.
    // Считаем переходы из черного в белое и наоборот из белого черное.
    
    int w=ncolumns;         // ширина массива   IMAGE_WIDTH
    int h=nrows;            // высота массива   IMAGE_HEIGHT
    int w_h=w*h;            // размер массива   IMAGE_SIZE
    
    int y;
    int min_B=6;            // вертикальный минимальный измеряемый размер Тибетской буквы "B" в pix. 1<minH_B<8
    int max_B=256;          // вертикальный максимальный измеряемый размер Тибетской буквы "B" в pix.
    float heightTib_B;      // вычисляемый вертикальный размер Тибетской буквы "B" в пикселях и долях пикселя (float).
    
    if(xB==0 || yB==0) { heightTib_B=0; return 0; }
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    if (GrafT) {
      cout<<"Функция вычисления вертикального размера Тибетской буквы <B> по координатам мышки"<<endl;
      cout<<"  w="<<w<<"  h="<<h<<"  w*h="<<w_h<<"  xB="<<xB<<"  yB="<<yB<<endl; }
    
    TIME_START
    
    // ограничения координат мышки на выход за пределы массива. /////////////
    if (xB < min_B) xB = min_B;   if (xB > w-min_B) xB = w-min_B;
    if (yB < min_B) yB = min_B;   if (yB > h-min_B) yB = h-min_B;
    
    
    uchar *p0 = bytes_data; // глобальный массив
    //uchar b_data;         b_data=255; // гарантированно стартуем с белого цвета "255".
    
    // TMP бинаризация по уровню 128
    //for (y=yB; y < w_h; y++){ bytes_data[y]=(bytes_data[y]/128)*255; } // y
    
    
    //*
    // Блокировка шума в окрестностях точки старта.
    // Заполнение белым вертикальной пиксельной линии длинной minH_B симметричной относительно точки старта.
    p0 = bytes_data + w*(yB-min_B/2) + xB;   // установка точки старта по координатам мышки выше на minH_B/2.
    for (y=0; y < min_B  && (p0-bytes_data)<w_h; y++){
      *p0=255;
      ///*p0=0; // ТЕСТ вертикальная черная пиксельная линия длинной minH_B, блокирует выполнение следующиго цикла!
      p0+=w;      // p0 = bytes_data + w*(y+yB-min_B/2) + xB;
    } // y
    //*/
    
    
    // ОБРАБОТКА ВЕРХНЕГО ШТРИХА ТИБЕТСКОЙ БУКВЫ "B". //
    
    //*
    // Поиск верхнего штриха буквы "B".
    p0 = bytes_data + w*yB + xB;   // установка точки старта по координатам мышки. Проверка выхода за массив (p0-bytes_data)<w_h
    for (y=0; *p0==255  && y<max_B  && (p0-bytes_data)<w_h; y++){ // пока фон (*p0) белого цвета.
      ///*p0=0; // ТЕСТ вертикальная черная пиксельная линия, блокирует выполнение следующиго цикла!
      //cout<<"  y="<<y<<"  *p0="<<(int)*p0<<endl;
      ///long v=(p0-bytes_data);    cout<<"  y="<<y<<"  v="<<v<<endl;
      p0-=w;      // p0 = bytes_data + y*w + xB;
    } // y
    
    // расстояние от центра буквы до нижнеей граници верхнего штриха.
    int h1=y;
    // координаты нижнеей граници верхнего штриха буквы "B".
    int y1=yB-y;
    //*/
    
    //*
    // Вычисление толщины верхнего штриха буквы "B".
    p0 = bytes_data + w*y1 + xB; // установка точки старта по нижней границе верхнего штриха буквы "B".
    for (y=0; *p0==0  && y<max_B  && (p0-bytes_data)<w_h; y++){ // пока штрих (b_data) черного цвета.
      ///*p0=255; // ТЕСТ вертикальная белая пиксельная линия, блокирует выполнение следующиго цикла !.
      //cout<<"  y="<<y<<"  *p0="<<(int)*p0<<endl;
      p0-=w;      // p0 = bytes_data + y*w + xB + h1;
    } // y
    
    // толщина верхнего штриха буквы "B".
    float t1=y-1;
    //*/
    
    
    // ОБРАБОТКА НИЖНЕГО ШТРИХА ТИБЕТСКОЙ БУКВЫ "B". //
    
    //*
    // Поиск нижнего штриха буквы "B".
    p0 = bytes_data + w*yB + xB; // установка точки старта по координатам мышки.
    for (y=0; *p0==255 && y<max_B  && (p0-bytes_data)<w_h; y++){ // пока фон (b_data) белого цвета.
      ///*p0=0;   // ТЕСТ вертикальная черная пиксельная линия, блокирует выполнение следующиго цикла !.
      //cout<<"  y="<<y<<"  *p0="<<(int)*p0<<endl;
      p0+=w;      // p0 = bytes_data + y*w + xB;
    } // y
    
    // расстояние от центра буквы до верхней граници нижнего штриха.
    int h2=y;
    // координаты верхней граници нижнего штриха буквы "B".
    int y2=yB+h2;
    //*/
    
    //*
    // Вычисление толщины нижнего штриха буквы "B".
    p0 = bytes_data + w*y2 + xB; // установка точки старта по верхней границе нижнего штриха буквы "B".
    for (y=0; *p0==0  && y<max_B  && (p0-bytes_data)<w_h; y++){ // пока штрих (b_data) черного цвета.
      //*p0=255; // ТЕСТ вертикальная белая пиксельная линия, блокирует выполнение следующиго цикла !.;
      //cout<<"  y="<<y<<"  *p0="<<(int)*p0<<endl;
      p0+=w;      // p0 = bytes_data + y*w + xB + h1;
    } // y
    
    // толщина нижнего штриха буквы "B".
    float t2=y-1;
    //*/
    
    
    // Расстояние от начала нижнего штрихи до начала верхнего штриха.
    heightTib_B=(h1 + h2) - 1;
    // точка старта xB,yB учитывается дважды, при старте вверх и при старте вниз, поэтому нужна последлея "-1".
    
    if (GrafT) cout<<"  h1="<<h1<<"  t1="<<t1<<"  h2="<<h2<<"  t2="<<t2<<"    heightTib_B="<<heightTib_B<<endl;
    
    // Расстояние от середины нижнего штрихи до середины верхнего штриха. Высота Тибетской буквы "B".
    heightTib_B = heightTib_B + (t1 + t2)/2;
    
    if (GrafT) cout<<"  END heightTib_B="<<heightTib_B<<endl;
    
    
    if(GrafT) { TIME_PRINT_ }
    
    // Возвращение вертикального размера Тибетской буквы "B" в пикселях и долях пикселя (float).
    return heightTib_B;
    
    
    /*
     // Правильный вызов функции.
     // Функция вычисления вертикального размера Тибетской буквы "B" в графическом тексте по координатам мышки.//
     // На вход функции должен подаваться именно тот массив в который тыкались мышкой с правильными
     // w=img->columns(); и h=img->rows(); , либо с пересчитанными параметрами xB, yB.
     if((xB && yB)>0) {
     // Восстановление исходной картинки bytes_data.
     ///memcpy(img->bytes_data, bytes_data_1, w_h); // надо так w=img->columns(); и h=img->rows();
     float heightTib_B=img->scaleTibetanB(xB, yB); // 815, 631
     if((GrafT)>0) {
     cout<<"Функция вычисления вертикального размера Тиб. буквы B по координатам мышки, heightTib_B="<<heightTib_B<<endl;
     }
     }
     //*/
    
    
  }//------------------------------------------------------------------------------------------------------------------------------------------------
  
  
  //*/
  
  
  
  // Функция вычисления вертикального размера Тибетской буквы "B" в графическом тексте по координатам мышки.
  // То же что и scaleTibetanB, но выполнена не на указателях, а на массивах с [].
  // 14 марта 2019
  
  float  GBitmap::scaleTibetanBM(int xB, int yB) {
    
    // Функция получает на вход координаты центра Тибетской буквы "B", полученные с помощью мышки.
    // Возвращает вертикальный размер float Тибетского буквы "B" с pix.
    // Входной массив bytes_data должен быть бинаризован.
    
    // Вручную ставим коортинаты xB,yB центр Тибетской буквы "B". Из него проводим вертикальную линию в верх и в низ.
    // Считаем переходы из черного в белое и наоборот из белого черное.
    
    int w=ncolumns;         // ширина массива   IMAGE_WIDTH
    int h=nrows;            // высота массива   IMAGE_HEIGHT
    int w_h=w*h;            // размер массива   IMAGE_SIZE
    
    int y;
    int min_B=6;            // вертикальный минимальный измеряемый размер Тибетской буквы "B" в pix. 1<minH_B<8
    int max_B=256;          // вертикальный максимальный измеряемый размер Тибетской буквы "B" в pix.
    float heightTib_B;      // вычисляемый вертикальный размер Тибетской буквы "B" в пикселях и долях пикселя (float).
    
    if(xB==0 || yB==0) { heightTib_B=0; return 0; }
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    if (GrafT) {
      cout<<"Функция вычисления вертикального размера Тибетской буквы <B> по координатам мышки"<<endl;
      cout<<"  w="<<w<<"  h="<<h<<"  w*h="<<w_h<<"  xB="<<xB<<"  yB="<<yB<<endl; }
    
    TIME_START
    
    // ограничения координат мышки на выход за пределы массива. /////////////
    if (xB < min_B) xB = min_B;   if (xB > w-min_B) xB = w-min_B;
    if (yB < min_B) yB = min_B;   if (yB > h-min_B) yB = h-min_B;
    
    
    uint p0=0; // size_t  ulong
    //uchar b_data;         b_data=255; // гарантированно стартуем с белого цвета "255".
    
    
    //*
    // Блокировка шума в окрестностях точки старта.
    // Заполнение белым вертикальной пиксельной линии длинной minH_B симметричной относительно точки старта.
    p0 = w*(yB-min_B/2) + xB;   // установка точки старта по координатам мышки выше на minH_B/2.
    for (y=0; y < min_B  && p0<w_h; y++){
      bytes_data[p0]=255;
      ///bytes_data[p0]=0; // ТЕСТ вертикальная черная пиксельная линия длинной minH_B, блокирует выполнение следующиго цикла!
      p0+=w;
    } // y
    //*/
    
    
    // ОБРАБОТКА ВЕРХНЕГО ШТРИХА ТИБЕТСКОЙ БУКВЫ "B". //
    
    //*
    // Поиск верхнего штриха буквы "B".
    p0 = w*yB + xB;   // установка точки старта по координатам мышки. Проверка выхода за массив (p0-bytes_data)<w_h
    for (y=0; bytes_data[p0]==255  && y<max_B  && p0<w_h; y++){ // пока фон (bytes_data[p0]) белого цвета.
      ///bytes_data[p0]=0; // ТЕСТ вертикальная черная пиксельная линия, блокирует выполнение следующиго цикла!
      p0-=w;
    } // y
    
    // расстояние от центра буквы до нижнеей граници верхнего штриха.
    int h1=y;
    // координаты нижнеей граници верхнего штриха буквы "B".
    int y1=yB-y;
    //*/
    
    //*
    // Вычисление толщины верхнего штриха буквы "B".
    p0 =  w*y1 + xB; // установка точки старта по нижней границе верхнего штриха буквы "B".
    for (y=0; bytes_data[p0]==0  && y<max_B  && p0<w_h; y++){ // пока штрих (bytes_data[p0]) черного цвета.
      ///bytes_data[p0]=255; // ТЕСТ вертикальная белая пиксельная линия, блокирует выполнение следующего цикла !.
      p0-=w;
    } // y
    
    // толщина верхнего штриха буквы "B".
    float t1=y-1;
    //*/
    
    
    // ОБРАБОТКА НИЖНЕГО ШТРИХА ТИБЕТСКОЙ БУКВЫ "B". //
    
    //*
    // Поиск нижнего штриха буквы "B".
    p0 = w*yB + xB; // установка точки старта по координатам мышки.
    for (y=0; bytes_data[p0]==255 && y<max_B  && p0<w_h; y++){ // пока фон (b_data) белого цвета.
      ///bytes_data[p0]=0;   // ТЕСТ вертикальная черная пиксельная линия, блокирует выполнение следующиго цикла !.
      p0+=w;
    } // y
    
    // расстояние от центра буквы до верхней граници нижнего штриха.
    int h2=y;
    // координаты верхней граници нижнего штриха буквы "B".
    int y2=yB+h2;
    //*/
    
    //*
    // Вычисление толщины нижнего штриха буквы "B".
    p0 = w*y2 + xB; // установка точки старта по верхней границе нижнего штриха буквы "B".
    for (y=0; bytes_data[p0]==0  && y<max_B  && p0<w_h; y++){ // пока штрих (bytes_data[p0]) черного цвета.
      //bytes_data[p0]=255; // ТЕСТ вертикальная белая пиксельная линия, блокирует выполнение следующиго цикла !.;
      //cout<<"  y="<<y<<"  *p0="<<(int)*p0<<endl;
      p0+=w;
    } // y
    
    // толщина нижнего штриха буквы "B".
    float t2=y-1;
    //*/
    
    
    // Расстояние от начала нижнего штрихи до начала верхнего штриха.
    heightTib_B=(h1 + h2) - 1;
    // точка старта xB,yB учитывается дважды, при старте вверх и при старте вниз, поэтому нужна последлея "-1".
    
    if (GrafT) cout<<"  h1="<<h1<<"  t1="<<t1<<"  h2="<<h2<<"  t2="<<t2<<"    heightTib_B="<<heightTib_B<<endl;
    
    // Расстояние от середины нижнего штрихи до середины верхнего штриха. Высота Тибетской буквы "B".
    heightTib_B = heightTib_B + (t1 + t2)/2;
    
    if (GrafT) cout<<"  END heightTib_B="<<heightTib_B<<endl;
    
    if(GrafT) { TIME_PRINT_ }
    
    // Возвращение вертикального размера Тибетской буквы "B" в пикселях и долях пикселя (float).
    return heightTib_B;
    
    
    
    /*
     // Правильный вызов функции.
     // Функция вычисления вертикального размера Тибетской буквы "B" в графическом тексте по координатам мышки.//
     // На вход функции должен подаваться именно тот массив в который тыкались мышкой с правильными
     // w=img->columns(); и h=img->rows(); , либо с пересчитанными параметрами xB, yB.
     if((xB && yB)>0) {
     // Восстановление исходной картинки bytes_data.
     ///memcpy(img->bytes_data, bytes_data_1, w_h); // надо так w=img->columns(); и h=img->rows();
     float heightTib_B=img->scaleTibetanB(xB, yB); // 815, 631
     if((GrafT)>0) {
     cout<<"Функция вычисления вертикального размера Тиб. буквы B по координатам мышки, heightTib_B="<<heightTib_B<<endl;
     }
     }
     //*/
    
    //w=3264  h=5100  w*h=16646400  xB=815  yB=631
    //h1=14  t1=10  h2=12  t2=11    heightTib_B=25
    //END heightTib_B=35.5
    
    
  }//------------------------------------------------------------------------------------------------------------------------------------------------
  
  
  //*/
  
  // Функция определения и инверсии яркости в сером графическом тексте. // 27 марта 2019
  // Функция определяет и ивертирует негативное изображение в сером графическом тексте. time=0.05
  
  int  GBitmap::textNegative() {
    
    // Функция считает среднее количество серого по всему графическому тексту (вне бордюра).
    // Если среднее меньше чем 128, то вся картинка инвертируется.
    // Возвращает параметр negative=0 нормальное изображение, =1 негативное изображение.
    
    int w=ncolumns;     // ширина массива   IMAGE_WIDTH
    int h=nrows;        // высота массива   IMAGE_HEIGHT
    int w_h=w*h;        // размер массива   IMAGE_SIZE
    int negativ=0;
    
    int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    if (GrafT) {
      cout<<"Функция определения и инверсии негативного изображения в сером графическом тексте.  textNegative()"<<endl;
      cout<<"  w="<<w<<",  h="<<h<<",  w_h="<<w_h<<endl; }
    
    TIME_START
    
    // ТЕСТ на инверсию входного массива битмап bytes_data с уровнями 0-255.
    ///invert();
    // ТЕСТ на border
    ///memset(bytes_data, 255, w_h); // начало, значение, размер заполняемой части массива в байтах.
    
    
    // Величина  part_bord как часть от наименьшего из "w" и "h".
    int part_bord=8; // от 16 до 4
    if (part_bord < 4) part_bord = 4;        if (part_bord > 16) part_bord = 16;
    // Бордер одинаковый по горизонтали и вертикали.
    int bord=h/part_bord;         // border, если картинка длиная.
    if (h>w) bord=w/part_bord;    // border, если картинка высокая.
    if (bord < 2) bord = 2;        if (bord > 128) bord = 128;
    //if (bord > w/4) bord = w/4;    if (bord > h/4) bord = h/4;
    
    uchar *p0 = bytes_data;
    uchar *d0;
    ulong Sum=0;    // сумма яркостей по всему графическому тексту вне бордюра.
    uint n=1;       // количество пикселей по всему графическому тексту вне бордюра.
    
    //*
    // задание параметров бордюров для циклов.
    p0 = bytes_data + bord + bord*w;
    int h_2b = h - 2*bord;
    int w_2b = w - 2*bord;
    
    // Циклы подсчета средней яркости картинки вне бордюра.
    for (int y=0; y<h_2b; y++) // h_2b=h-2*bord;
    {
      d0=p0;  // сохраняем для выполнения цикла по "x".
      for (int x=0; x<w_2b; x++)
      {
        //*d0=0;    // ТЕСТ на border
        Sum+=*d0;
        n++;
        d0++;       // p0 = bytes_data + y*w + x;
        // ТЕСТ на выход за пределы массива.
        // long p=d0-bytes_data;   if (p<4 || p>(w_h/2-4)) cout<<"w*h="<<w*h<<",  p="<<p<<endl;
      } //x
      p0+=w;          // p0 = bytes_data + y*w;
    } //y
    //*/
    
    // средняя яркость по всему графическому тексту вне бордюра.
    uint average_Sum=(uint)(Sum/n);
    if (GrafT) cout<<"  n="<<n<<"  Sum="<<Sum<<"  average_Sum="<<average_Sum<<endl;
    
    // Если средняя яркость меньше чем 128, то вся картинка инвертируется.
    if (average_Sum<128) {
      invert();           // инверсия входного массива битмап bytes_data с уровнями 0-255.
      negativ=1;
      if (GrafT) cout<<"  Выполнена инверсия серого негативного изображения."<<endl;
    }
    
    if(GrafT) { TIME_PRINT_ }
    
    // Возвращение вертикального размера Тибетской буквы "B" в пикселях и долях пикселя (float).
    return negativ;
    
    
    //------------------------------------------------------------------------------
    
    
    // Функция определения и инверсии яркости в сером графическом тексте построенной
    // на входой бинаризации и суммировании единиц. РАБОТАЕТ.
    
    /*
     // ТЕСТ функция быстрого преобразования серого массива в битовый массив по фиксированному порогу 128.
     // Бинаризуем по 8 байт одновременно, получили "0" черное "255" белое. Белое это 8 едениц "11111111"
     //binarisation64();
     
     // Площадь бордера
     //int S_bord=2*w*bord + 2*h*bord - 4*bord*bord;
     int S_bord=2*bord*(w + h - 2*bord);
     //cout<<"  w="<<w<<"  h="<<h<<"  bord="<<bord<<"  S_bord="<<S_bord<<endl;
     
     
     // Заполнение border глобального массива bytes_data,
     // общепринятый формат массива 0-черный, 255-белый.
     
     uint t=255; // белый
     ///uchar *p0=bytes_data;
     ///uchar *d0;
     uint bord_w=bord*w;
     uint bord_2=bord*2;
     int h_1=h-1;
     
     // надо запомнить, а за тем восстановить bytes_data
     
     // заполнение верхнего горизонтального border величиной t.
     memset(bytes_data, t, bord_w); // начало, значение, размер заполняемой части массива в байтах.
     
     // заполнение левого и правого вертикального border.
     p0=bytes_data - bord + w;   // + w начинаем со второй строки
     for (int y=0; y<h_1; y++) { // h_1=h-1;
     d0=p0;  // сохраняем для выполнения цикла по "x"
     // цикл стирает сразу оба бордера: левый и правый.
     for (int x=0; x<bord_2; x++) { // bord_2=bord*2;
     *d0=t;  // long p=d0-bytes_data; cout<<"w*h="<<w*h<<",  p="<<p<<endl;
     d0++;   // d0=bytes_data + y*w + x;
     } //x
     p0+=w;      // p0=bytes_data + y*w;
     } //y
     
     // заполнение нижнего горизонтального border.
     memset(bytes_data+w_h-bord_w, t, bord_w);
     
     
     int w_h_64=w_h/sizeof(ulong);               // sizeof(ulong)=8
     ulong *bytes_data_64=(ulong*)bytes_data;    // приведение bytes_data к типу ulong
     
     uint SumBit=0;
     uint SumBit2=0;
     
     // подсчет единиц (белого) 64 разрядными словами по всей картинке, кроме бордеров.
     for ( int x=0; x < w_h_64; x++ ) {
     
     //#ifdef ASM_OS64_SSE42_POPCNT_ATT
     // подсчет единиц  в 64 разрядном слове с помощью быстрой, но новой _mm_popcnt_u64.
     SumBit+=_mm_popcnt_u64(bytes_data_64[x]);
     //#else
     
     // подсчет единиц в 64 разрядном слове с помощью функции SumBit64 регистровыми сдвигами
     ulong Sb=bytes_data_64[x];
     if(Sb > 0) {                                   // 0xFFFFFFFF
     // Подсчет единиц
     Sb-=(Sb >> 1) & 0x5555555555555555;        // 2-битовые ячейки
     Sb=(Sb & 0x3333333333333333) + ((Sb >> 2) & 0x3333333333333333); // 4-битовые
     Sb=(Sb + (Sb >> 4)) & 0x0F0F0F0F0F0F0F0F;  // 8-битоовые
     Sb+=Sb >> 8;                               // 16-битовые
     Sb+=Sb >> 16;                              // 32-битовая ячейка
     Sb+=Sb >> 32;                              // 64-битовая ячейка
     SumBit2+=Sb & 0xFF;   // & 0xFF обнуляем старшие разряды, содержащие "мусор"
     }
     
     //#endif
     //bytes_data_64[x]=0;
     } // int x
     
     SumBit/=8; // Белое это 8 едениц "11111111"
     SumBit2/=8;
     // Далее все считаем в пикселях
     
     //Учет белого "1", папавшего в бордер.
     SumBit-=S_bord;
     
     if (SumBit<w_h/2) { invert(); cout<<"  инверсия"<<endl; } // инверсия входного массива битмап bytes_data с уровнями 0-255.
     
     cout<<"  w_h="<<w_h<<"  SumBit="<<SumBit<<endl;
     cout<<"  w_h="<<w_h<<"  SumBit2="<<SumBit2<<endl;
     
     // инверсия входного массива битмап bytes_data с уровнями 0-255.
     //invert();
     
     //*/
    
    
    
  }//------------------------------------------------------------------------------------------------------------------------------------------------
  
  
} // namespace ocr
