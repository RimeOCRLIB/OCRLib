//
// _______GraphOCR.cpp
// Copyright (c) Open Source Buddhism Library 2020 www.buddism.ru
// ****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  May Buddha Dharma bring benefit and peace in all the world.
// ****************************************************************************
//
// C- This software is subject to, and may be distributed under, the
// C- GNU General Public License, either Version 2 of the license,
// C- or (at your option) any later version. The license should have
// C- accompanied the software or you may obtain a copy of the license
// C- from the Free Software Foundation at http://www.fsf.org

#include "GGraphOCR.h"
#include "../OCRString/php2stl.h"
namespace ocr {
// ----- initialization
GGraphOCR::GGraphOCR(void) {
	printCorrelation = 0; ///<вывод отлдки корреляции буквы
    
    //лимиты точности корреляции
    clusterCorrelationLimit=95;     // лимит точности сравнения базовых кластеров с кластерами буквы и текста
    
    correlationLimit=0.5;           // количество линий буквы совпавших с текстом достаточное для начала проверки геометрии буквы
    letterCorrelationLimit=93;      // лимит окончания проверки буквы
    letterCorrelationLimitGroup=70;
    letterCorrelationLimitVoronov=50;      // лимит начала проверки буквы по lookup4
    //лимит корреляции совпадают с лимитом корреляции базовых кластеров, но меньше на единицу для устранения неоднозначности
    limitBaseClusterCorrelation=clusterCorrelationLimit-1;
    limitAlphaMid = 37;             // лимит разницы углов лучей к концу и середине OCRLine
    limitAlpha  =   27;             // лимит разницы углов лучей к концу и 1/3 OCRLine
    grammarMode = OCR_TEXT_CORRELATION;
    grammarModeLetterID=0;
    pointSearchLimit = 5;  // лимит поиска точки - limitCluster=(letter.letterH+letter.letterW)/pointSearchLimit*scale;
    
} //____________________________________________________________

// ------- destructor
GGraphOCR::~GGraphOCR() {} //____________________________________________________________


/** @bref Функция создает таблицы хеша для всех типов OCRStar.  */
void GGraphOCR::buildHashTable() {
	/**
	(вместо двойных звезд п4реписать на кластеры)
	 Для поиска DStar эталона в тексте используем значение хеша каждого DStar.
	 Для расчета значения хеша используем кодировки типов двух центральных звездочек и
	 кодировки типов звездочек расположенных на лучах их созвездий. Для кодировки DStar
	 состоящего из двух созвездий, достаточно 12 бит. На практике используется short. Всего
	 существует 801 вид DStar для всех видов узора. Такой хеш является кодом типа DStar и
	 использование его для поиска позволяет использовать хеш таблицу без пропусков и повторов.

	 Алгоритм вычисления хеша:
	 Хеш вычисляется как последовательное вычисление двух шести разрядных хешей двух
	 звездочек, объединение этих хешей в двенадцатиразрядное слово и получение порядкового
	 номера типа DStar по заранее вычисленной таблице массива 30000 байт.

	 Индекс хеша звездочки формируется как набор 12 битов поискогового регистра.
	 Первые три бита это код центральной звездочки.
	 Далее для каждого луча звездочки начиная с первого после луча который соединяет две
	 звездочки DStar против часовой стрелки считываем коды типов звездочек концов лучей. Коды
	 записываем как пары бит поискогового регистра. Нулевое значение пары заполняет оставшиеся
	 биты поискогового регистра в том случае если звездочка имеет меньше чем четыре луча. По
	 индексу поискогового регистра из заранее вычисленной таблицы получаем порядковай номер
	 хеша звездочки. Порядок сборки поискового регистра Обнуляем значение регистра short.
	 Записываем в первый байт код центральной звездочки
	 X_POINT - 4 (100 в двоичной системе)
	 T_POINT - 3 (011 в двоичной системе)
	 P_POINT - 2 (010 в двоичной системе)
	 L_POINT - 0 (010 в двоичной системе)
	 прибавляем к поисковому регистру код звездочки первого луча
	 сдвинутый на 3 бита в (умноженный на 8)
	 прибавляем к поисковому регистру код следующей звездочки
	 сдвинутый на 6 бит в (умноженный на 64)
	 прибавляем к поисковому регистру код следующей звездочки
	 сдвинутый на 9 бит в (умноженный на 512)
	 прибавляем к поисковому регистру код следующей звездочки
	 сдвинутый на 12 бит в (умноженный на 4096)
	 Если центральная звездочка не имеет соответствующего луча
	 прекращаем заполнение регистра.

	 Два двенадцати разрядных хеша по таблице переводятся в два шести разрядных слова
	 DStar при объединении в двенадцати разрядное слово дают 801 значений из 32000 возможных.

	 По индексу двенадцатиразрядного хеша получаем порядковый номер типа DStar из заранее
	 вычисленной таблицы массива 30000 байт.

	 Вычисление таблицы компактного хеша звездочки выполняется
	 путем вычисляния значение поискового регистра для каждого
	 луча звездочки как стартового луча обхода лучей звездочки.
	 Наибольшее значение поискового
	 регистра используется для получения компактного хеша звездочки из таблицы.
	 Всего 108 видов упорядоченных звездочек.

	 */

	if (hashTableReady) return;

	char name[4] = {'4', '3', '2', '1'};
	char S1;
	// char S2='0';
	char s1[5];
	vector<string> hash;
	string str;
	memset(s1, 0, 5);
	int max = 0;
	short hashIndex = 1;
	int size;

	//создание списка всех комбинаций типа центральной звездочки и типов звездочек на концах
	//лучей

	for (int n6 = 0; n6 < 4; n6++) {
		memset(s1, 48, 4);

		S1 = name[n6]; //тип коренной звездочки
		int type1 = S1;

		for (int n7 = 0; n7 < 4; n7++) {
			s1[0] = name[n7];
			if (type1 == '1') {
				str = S1;
				str += s1;
				hash.push_back(str);
				continue;
			}
			for (int n8 = 0; n8 < 4; n8++) {
				s1[1] = name[n8];
				if (type1 == '2') {
					str = S1;
					str += s1;
					hash.push_back(str);
					continue;
				}
				for (int n9 = 0; n9 < 4; n9++) {
					s1[2] = name[n9];
					if (type1 == '3') {
						str = S1;
						str += s1;
						hash.push_back(str);
						continue;
					}
					for (int n10 = 0; n10 < 3; n10++) {
						s1[3] = name[n10];
						str = S1;
						str += s1;
						hash.push_back(str);
					}
				}
			}
		}
	}

	// for(int n6=0; n6 < hash.size(); n6++) cout<<hash[n6]<<endl;

	//собираем хеш DStar из комбинации двух значений хеша звездочек
	size = (int)hash.size();
	hashTableStar = (uchar *)calloc(2, 20000);	   //таблица неупорядоченного хеша OCRStar
												   //таблица упаковки хеша звездочки в DStar
	hashTableOCRStar = (ushort *)calloc(2, 20000); //таблица упорядоченного хеша OCRStar
	hashTable = (ushort *)calloc(2, 62000);		   //таблица упорядоченного хеша DStar

	for (int n = 0; n < size; n++) {
		// DR(hash[n]<<endl);
		//создаем таблицу упаковки неупорядоченного хеша звездочки
		char *p = &hash[n][0];
		ushort h = (*p - 48);
		p++;
		h += (*p - 48) << 3;
		p++;
		h += (*p - 48) << 6;
		p++;
		h += (*p - 48) << 9;
		p++;
		h += (*p - 48) << 12;
		if (h > max) max = h;
		hashTableStar[h] = n + 1;
	}
	// DR("max1:"<<max<<endl);
	max = 0;

	//создаем таблицу комбинаций двух звездочек
	//первые лучи звездочек должны совпадать по типу
	//поскольку звездочки соединены фокальной линией
	for (int n = 0; n < size; n++) {
		char c0 = hash[n][0]; //тип первой звездочки DStar
		char c1 = hash[n][1]; //тип второй звездочки DStar
		for (int m = 0; m < size; m++) {
			//упаковываем первый хеш
			if (hash[m][1] != c0 || hash[m][0] != c1)
				continue; //звездочки не сочетаются по типу звездочек на концах лучей
						  // DR(hash[n]<<"_"<<hash[m]<<"\n";
			char *p = &hash[n][0];
			ushort h = (*p - 48);
			p++;
			h += (*p - 48) << 3;
			p++;
			h += (*p - 48) << 6;
			p++;
			h += (*p - 48) << 9;
			p++;
			h += (*p - 48) << 12;
			//получаем значение хеша первой звездочки
			ushort h1 = hashTableStar[h];
			// DR("h1:"<<h1;
			//упаковываем второй хеш
			p = &hash[m][0];
			h = (*p - 48);
			p++;
			h += (*p - 48) << 3;
			p++;
			h += (*p - 48) << 6;
			p++;
			h += (*p - 48) << 9;
			p++;
			h += (*p - 48) << 12;
			//получаем значение хеша второй звездочки
			ushort h2 = hashTableStar[h];
			// DR(" h2:"<<h2<<endl);
			//упаковываем хеш двух звездочек
			ushort h3 = h2 << 12;
			h3 += h1;
			if (h3 > max) max = h3;
			//хеш прямого и обратного порядка звездочек имеет один и тот же hashIndex
			//поэтому мы увеличиваем hashIndex только в том случае
			//если такое сочетание звездочек уникально для прямого и обратного их расположения
			// hashTable[h3]=hashIndex;
			// hashIndex++;

			//вычисляем адрес хеша обратного порядка звездочек
			//заносим такое же значение hashIndex
			ushort h4 = h1 << 12;
			h4 += h2;
			if (h4 > max) max = h4;
			if (hashTable[h3] == 0 && hashTable[h4] == 0) {
				hashIndex++;
				hashTable[h3] = hashIndex;
				hashTable[h4] = hashIndex;
				// DR("+"<<hashIndex<<endl);
			}
		}
	}
	// DR("max="<<max<<" hashIndex:"<<hashIndex<<endl);

	/**
	 Вычисление таблицы упорядоченного компактного хеша OCRStar.
	 Значение поискового регистра звездочки зависит от того какой луч выбирается как стартовый
	 для обхода лучей звездочки. Поэтому вычисляется значение поискового регистра для каждого
	 луча звездочки как стартового луча обхода лучей звездочки. Наибольшее значение поискового
	 регистра используется для получения компактного хеша звездочки из таблицы.
	 */

	//вычисление таблицы упаковки хеша
	size = (int)hash.size();
	hashIndex = 1;
	max = 0;
	// DR("2 hash___"<<endl);

	for (int n = 0; n < size; n++) {
		str = hash[n];
		// DR(str<<endl);
		//читаем тип первой звездочки
		if (str[0] == '1') {
			//вычисляем поисковый регистр
			char *p = &hash[n][0];
			ushort h = (*p - 48);
			p++;
			h += (*p - 48) << 3;
			//записываем в таблицу
			hashTableOCRStar[h] = hashIndex;
			hashIndex++;
			if (h > max) max = h;
			// DR("+"<<str<<endl);
		}
		if (str[0] == '2') {
			//вычисляем поисковый регистр
			char *p = &hash[n][0];
			ushort h = (*p - 48);
			p++;
			h += (*p - 48) << 3;
			p++;
			h += (*p - 48) << 6;
			p++;
			//проверяем есть ли такое значение в таблице
			if (hashTableOCRStar[h]) continue;
			//проверяем второй вариант обхода лучей
			p = &hash[n][0];
			short h1 = (*p - 48);
			h1 += (*(p + 2) - 48) << 3;
			h1 += (*(p + 1) - 48) << 6;
			//проверяем есть ли такое значение в таблице
			if (hashTableOCRStar[h1]) continue;

			//значение хеша еще не записано в таблицу
			//записываем значение hashIndex по всем трем адресам

			hashTableOCRStar[h] = hashIndex;
			hashTableOCRStar[h1] = hashIndex;
			hashIndex++;
			if (h > max) max = h;
			if (h1 > max) max = h1;
			// DR("+"<<str<<endl);
		}
		if (str[0] == '3') {
			//вычисляем поисковый регистр
			char *p = &hash[n][0];
			ushort h = (*p - 48);
			p++;
			h += (*p - 48) << 3;
			p++;
			h += (*p - 48) << 6;
			p++;
			h += (*p - 48) << 9;
			p++;
			//проверяем есть ли такое значение в таблице
			if (hashTableOCRStar[h]) continue;
			//проверяем второй вариант обхода лучей
			p = &hash[n][0];
			ushort h1 = (*p - 48);
			h1 += (*(p + 2) - 48) << 3;
			h1 += (*(p + 3) - 48) << 6;
			h1 += (*(p + 1) - 48) << 9;
			//проверяем есть ли такое значение в таблице
			if (hashTableOCRStar[h1]) continue;
			//проверяем третий вариант обхода лучей
			p = &hash[n][0];
			ushort h2 = (*p - 48);
			h2 += (*(p + 3) - 48) << 3;
			h2 += (*(p + 1) - 48) << 6;
			h2 += (*(p + 2) - 48) << 9;
			//проверяем есть ли такое значение в таблице
			if (hashTableOCRStar[h2]) continue;

			//значение хеша еще не записано в таблицу
			//записываем значение hashIndex по всем трем адресам

			hashTableOCRStar[h] = hashIndex;
			hashTableOCRStar[h1] = hashIndex;
			hashTableOCRStar[h2] = hashIndex;
			hashIndex++;
			if (h > max) max = h;
			if (h1 > max) max = h1;
			if (h2 > max) max = h2;
			// DR("+"<<str<<endl);
		}

		if (str[0] == '4') {
			//вычисляем поисковый регистр
			char *p = &hash[n][0];
			ushort h = (*p - 48);
			p++;
			h += (*p - 48) << 3;
			p++;
			h += (*p - 48) << 6;
			p++;
			h += (*p - 48) << 9;
			p++;
			h += (*p - 48) << 12;
			p++;
			//проверяем есть ли такое значение в таблице

			if (hashTableOCRStar[h]) continue;
			//проверяем второй вариант обхода лучей
			p = &hash[n][0];
			ushort h1 = (*p - 48);
			h1 += (*(p + 2) - 48) << 3;
			h1 += (*(p + 3) - 48) << 6;
			h1 += (*(p + 4) - 48) << 9;
			h1 += (*(p + 1) - 48) << 12;

			//проверяем есть ли такое значение в таблице
			if (hashTableOCRStar[h1]) continue;
			//проверяем третий вариант обхода лучей
			p = &hash[n][0];
			ushort h2 = (*p - 48);
			h2 += (*(p + 3) - 48) << 3; // 42323  42323
			h2 += (*(p + 4) - 48) << 6;
			h2 += (*(p + 1) - 48) << 9;
			h2 += (*(p + 2) - 48) << 12;
			//проверяем есть ли такое значение в таблице
			if (hashTableOCRStar[h2]) continue;
			//проверяем четвертый вариант обхода лучей
			p = &hash[n][0];
			ushort h3 = (*p - 48);
			h3 += (*(p + 4) - 48) << 3;
			h3 += (*(p + 1) - 48) << 6;
			h3 += (*(p + 2) - 48) << 9;
			h3 += (*(p + 3) - 48) << 12;
			//проверяем есть ли такое значение в таблице
			if (hashTableOCRStar[h3]) continue;

			//значение хеша еще не записано в таблицу
			//записываем значение hashIndex по всем четырем адресам

			hashTableOCRStar[h] = hashIndex;
			hashTableOCRStar[h1] = hashIndex;
			hashTableOCRStar[h2] = hashIndex;
			hashTableOCRStar[h3] = hashIndex;
			hashIndex++;
			if (h > max) max = h;
			if (h1 > max) max = h1;
			if (h2 > max) max = h2;
			if (h3 > max) max = h3;

			// DR("+"<<str<<endl);
		}
	}
	hashTableReady = 1;
	// cout<<"max="<<max<<" hashIndex:"<<hashIndex<<endl);

} //________________________________________________________________

/** @bref Функция иницаализирует таблицу хеша в GGraph данными GGraphOCR */
void GGraphOCR::initHashTable(GGraph &graph) {
	/**
	 В том случае если GGraphOCR создает много екземпляров класса GGraph
	 то таблицы хера создаем в GGraphOCR и передаем в GGraph указатели на таблицы.
	 Это нужно например при создании OCR шрифта из набора изображений
	*/

	if (!hashTableReady) buildHashTable();
	graph.hashTable = hashTable;
	graph.hashTableStar = hashTableStar;
	graph.hashTableOCRStar = hashTableOCRStar;
	graph.hashTableReady = 2;

} //________________________________________________________________

} // namespace ocr
