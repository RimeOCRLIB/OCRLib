#include "GBitset.h"

///////////////////////////////////////////////////////////////////////////////
                             //  Structure  //
//  ----------------------------------------------------------------------------
// Запуск подпрограммы структурализации букв.
//  ----------------------------------------------------------------------------

void GBitset::StructureWorld(){

  int x,y,d,g; ///
  int mx,my; 
  //int xp0,xp1,yp0,yp1;
  int y0,y1,x0,x1,s0,s1,s3,s4,s5;   //  ,sy0,sy1
  int LimY1,NWord;  //  ,res,maxres,Prg1,Prg2,
  int w=ncolumns;
  bool *d1,*d2;
  bool  *A=bits_data;	

//TIME_START


   m=6; // max количество параметров на одну точку в массмве ReBuf

   int NStrok = (int)strArray->size();
   for ( Nstr=0; Nstr < NStrok; Nstr++ ){ // Цикл по количеству строк NStrok
       // получение оптимального коэффициента вертикальной фильтрации для каждой строки
////       DltNstrN = strArray[0][Nstr].y1 - strArray[0][Nstr].y0;
////       DltNstrNKh = DltNstrN*DeltaKh/100;  //=DltNstrN*ncolumns/srcW*srcH/nrows;

         NWord = (int)strArray[0][Nstr].wordArray.size();
         for ( Nwrd=0; Nwrd < NWord; Nwrd++ ){ // Цикл по количеству квадратиков NWord

////////////////////////////////////////////////////////////////////////////////

///   Nstr=2;  Nwrd=20;

   // обнуление ImBuf, ReBuf ( где ImBuf, ReBuf глобальные )
   memset(ReBuf,0,4*(ncnr+512));      memset(ImBuf,0,4*(ncnr+512)); ///


                /// получение координат прямоугольников и точек из структуры по x по y
             wordOCR *wP=&strArray[0][Nstr].wordArray[Nwrd];
             // x0,x1, y0,y1 координаты квадрата вокруг буквы
             x0 = wP->x0;    x1 = wP->x1;    y0 = wP->y0;    y1 = wP->y1;

             // получение области поиска стеков - прямоугольников
             s0=y0-(y1-y0);     s1=y1+(y1-y0)/15;  //
             s3=x0-(x1-x0)/9;   s4=x1+(x1-x0)/9;   //

             // LimY1 нижний лимит строки
             LimY1=strArray[0][Nstr].LimY1;
             if ( s0 < LimY1 ) { s5=LimY1; }
             if ( s0+(s1-s0)/2 < LimY1 ) { s5=s0+(s1-s0)/2; }
             if ( s0 > LimY1 ) { s5=s0; }
             s0=s5;
/**/
             // проверка выхода области поиска стеков за граници массива
             if ( s0 <  1 ) { s0=s1=1; }    if ( s1 > nrows-2 ) { s0=s1=nrows-1; }
             if ( s3 <  1 ) { s3=s4=1; }    if ( s4 > ncolumns-2) { s3=s4=ncolumns-1; }

             // запись области поиска стеков - прямоугольников в структуру
    ///         wP->xt0 = s3;   wP->xt1 = s4;   wP->yt0 = s0;   wP->yt1 = s1;

   // m=6; // max количество параметров на одну точку в массмве ReBuf
   // Оптимальная обработка ширины точки
   g=0;
   for (y=s0; y<s1; y++){       //+1  +1
       d1=A+y*w;                  //A[y][x]   // d1=A+y*w;
       d2=d1+1;                   //A[y][x+1]
       mx=s3;
       for (x=s3; x<s4; x++){   // xp1-1
           d=*(d2+x)-*(d1+x);     // delta=ImBuf[x+1]-ImBuf[x];
           if ( d )  {  // !=0    // !=0  считаем только в точках изменения
              if ( d > 0 )  { mx=x; }
              // координаты середины горизонтальной средней полосы по y, по x1, x0
              else {
               ImBuf[g]=y;  ImBuf[g+1]=x;  ImBuf[g+2]=mx;   g+=m;
              } // d > 0
           } // !=0
           // 0.8 визуализация плашки (серым) //
#ifdef DEBUGLVL_GREY           
if( GrafT[8][1] ) { drawData[0][y][x]*=0.9; }
#endif           
       }  // for x
   }  // for y

   ImBf=g;

/**/
//DM(END); DM(g1<<" g1 ");



  // Оптимальная обработка высоты точки
  // вертикальные полосы проводим только через центры горизонтальных полос
  g=0; //wp=s4-s3;
  for (x=s3; x<s4; x++) {
       d1=A+x;                  //A[y][x]
       my=s0;
       for (y=s0; y<s1; y++){
           d2=d1+y*w;        //A[y+1][x]
           d=*(d2+w)-*d2;    // delta=ImBuf[y+w]-ImBuf[y];
           if ( d )  {       // !=0  считаем только в точках изменения
              if ( d > 0 )  { my=y; }  // my предидущая координата y
              else {
         ////         if ( ImBuf[x]==(y + my + 2)/2 )  { // если совпадают игреки средней  + 0
                  // определение координаты пересечения вертикальной и
                  // горизонтальной средней полосы по координатам x, y,
                  ReBuf[g]=x;          ReBuf[g+1]=y+1;           ReBuf[g+2]=my;
                  ReBuf[g+3]=ImBuf[x]; ReBuf[g+4]=ImBuf[x+1]+1;  ReBuf[g+5]=ImBuf[x+2];
                  g+=m;
        ////         } // ImBuf[x]
             } // d > 0
           } // !=0
       }  // for y
  }  // for x

  ReBf=g;
/**/

///   n+1 - верх y1,   n+2 - низ y0,   n+4 - право x1,    n+5 - лево x0   ///

#ifdef DEBUGLVL_GREY
if( GrafT[8][1] ) {
   for (x=0; x<ImBf; x+=m){  // y  x +1
   // визуализация вертикальной полосы в виде кривой в один пиксел
    drawData[0][ImBuf[x]][(ImBuf[x+1]+ImBuf[x+2])/2]*=0;  // *=.0-черная *= .9-серая
   }  // for x                                            //  =1 -черная  =255-белая
   for (x=0; x<ReBf+1; x+=m){
   // визуализация горизонтальной полосы в виде кривой в один пиксел
    drawData[0][(ReBuf[x+1]+ReBuf[x+2])/2][ReBuf[x]]*=0;
   // визуализация центра распознаваемой точки в виде белого пикселя
///       drawData[0][ReBuf[x+1]][ReBuf[x]]=255;
   }  // for x
}
#endif             
/**/

////////////////////////////////////////////////////////////////////////////////

         } // for Nwrd  // Цикл по количеству букв Nwrd

   } // for Nstr // Цикл по количеству строк NStrok


//if( GrafT[8][0] ) { DM(END);  DM(88888<<" StructureWorld ");  DM(END); }
//TIME_PRINT

}//_____________________________________________________________________________


