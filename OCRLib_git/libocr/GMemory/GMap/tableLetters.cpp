#include "GMap.h"

//#define REMARK

using namespace std;


void GMap::tableLetters(){
    
    // создание структуры для работы с реальными координатами пар букв в распознаваемом тексте
    // выполняется один раз на весь распознаваемый текст не зависимо от размера словаря
    int print=0;

#ifdef REMARK 
    print=1;
#endif
    
    DR(endl<<endl<<"******************************************************************************************************************"<<endl)    
    DR(endl<<"Start program *table_Letters*"<<endl)
    
        
    unsigned int x,s,n,m;   // ,y,s0,olds,p 
    int bl,blp,bc;        // ,bc,bm,counter
    unsigned short ds,bf;     // ,di
    
    wstring str;
    

    
    
#ifdef REMARK    
    // проверяем что на входе функции (вывод на экран распознаваемого текста) 
    DR(endl<<"получили на вход функции table_Letters распознаваемый текст text_data, массив BufUpT, шрифтом, UTF-16 (short)"<<endl)
    s=0;
    for(x=0; x < text_size1; x++){ //text_size1 размер массива распознаваемого текста без переводов каретки Enter
        DR(x);    str=(wchar_t)BufUpT[text_data[x]]; DR(Unicode_to_UTF(str)<<"  ")
        ////str=(wchar_t)BufUpT[text_data[x]]; DR(Unicode_to_UTF(str); // DR(Unicode_to_UTF(dictionary_data[x])  // str=(wchar_t)BufUpT[text_data[x]];
        ///        DR(text_data[x]<<"   ";
        if ( x==BufET[s] ){ DR(endl) s++; }  // перевод каретки Enter текста
    }
    //DR(endl)
    /**/             
#endif        
    

TIME_START
    
    ///задачи структуры:
    // Самодельная структура предназначена для получения координат пар букв в распознаваемом тексте (м.б. в словаре) по компактному коду пары букв, 
    // с учетом того что конкретная пара букв в распознаваемом тексте может встечаться более одного раза. 
    
    ///устройство структуры.
    // структура для получения координат пар букв в распознаваемом тексте состоит из двух массивов:
    // - массива адресов (позиций) letters_data пар букв встечающихся в распознаваемом тексте один раз. Адресом массива является компактный код пары букв. 
    // - массива адресов пар букв clusters_data встечающихся более одного раза. Этот массив адресов представляет собой таблицу, состоящею из ячеек.   (card_data)
    //   Количество ячеек равно количеству разных пар букв во всем распознаваемом тексте, встречающихся более одного раза.
    //   В каждой ячейке находятся адреса одинаковых пар букв в распознаваемом тексте.
    
    ///применение структуры для получения координат пар букв в распознаваемом тексте:
    // - если пара букв в распознаваемом тексте встречается один раз, то происходит выборка адреса пары букв из массива адресов и  
    //   работа со структурой для данного кода пары букв заканчивается.
    // - если пара букв в распознаваемом тексте встречается более одного раза, то происходит обращение к сответствующкй ячейке таблицы адресов 
    //   в которой записаны все адреса пары букв по которым она встречактся в тексте. Происходит выборка всех адресов пары букв и  
    //   работа со структурой для данного кода пары букв заканчивается.    

    
    
    /// определение размерности структуры ( параметров массива адресов и таблицы адресов ) для работы с реальными координатами пар букв в распознаваемом тексте:
    
    // создание разреженного массива адресов (позиций) пар букв встечающихся в распознаваемом тексте один раз (без учета одинаковых). 
    // позиция в тексте пары букв=letters_data[компактный код пары букв]
    // т.е. адрес массива - компактный код пар букв, содержимое - позиция в распознаваемом тексте пары букв
///    int  *letters_data; 
    letters_size=nLetterP; // количество разных пар букв в словаре 
    letters_data_vector=GStr<int>::create();
    letters_data_vector->resize(letters_size+32);   // запрос памяти c обнулением
    letters_data=(int*)letters_data_vector->dataPtr();

    // создание вспомогательного разреженного массива BufLpT количества пар букв распознаваемого текста
    // адрес в массиве - компактный код пар букв, содержимое - количество этих пар букв в распознаваемом тексте
    size_BufLpT=nLetterP; // nLetterP количество разных пар букв в словаре // 65536
    if ( size_BufLpT > 65536 ){ size_BufLpT=65536; }
    BufLpT_vector=GStr<ushort>::create();
    BufLpT_vector->resize(size_BufLpT+32);   // запрос памяти c обнулением
    BufLpT=(ushort*)BufLpT_vector->dataPtr();

    // подсчет вспомогательных параметров для создания массива адресов пар букв clusters_data встечающихся более одного раза.
    n=m=s=0;
    for(x=0; x < text_size1; x++) { // text_size1 размер массива распознаваемого текста без переводов каретки Enter
        ds=text_data[x];
        // заполнение массива адресами (позициями) пар букв в распознаваемом тексте
///        letters_data[ds]=x; // в массиве letters_data на позиции "ds" находится код "x"
        // заполнение массива числами равными количеству пар букв в тексте
        //bf=BufLpT[ds]++;  // BufLpT[ds]++; // bf=BufLpT[ds]+=1;
        bf=BufLpT[ds]+=1;
        // подсчет количество пар букв "n", встречающихся во всем тексте более одного раза 
        // подсчет числа разновидностей пар букв "m", встречающихся во всем тексте более одного раза
        if ( bf > 1 ){ s++; }    if ( bf==2 ){ m++; }   // if ( bf==2 ){ n+=2; }   эквивалентно n+m //n++;
        ////          DR(ds<<" ";
    } // x
    DR(endl)
    
    n=s+m;

    DR("s="<<s<<endl)
    // "n" количество пар букв, встречающихся во всем тексте более одного раза
    DR("количество пар букв, встречающихся во всем тексте более одного раза   n="<<n<<endl)
    // "m" количество разновидностей пар букв "m" (цепочек,кластеров адресов), встречающихся во всем тексте более одного раза 
    DR("количество разновидностей пар букв (цепочек,кластеров адресов), встречающихся во всем тексте более одного раза   m="<<m<<endl)
    
    
    // количество разных пар букв в распознаваемом тексте        
    nLetterPT=text_size1-s;  // nLetterPT=<nLetterP;  // text_size1 размер массива распознаваемого текста без переводов каретки Enter  ////////////////
    DR("количество разных пар букв во всем распознаваемом тексте nLetterPT=text_size1-s="<<nLetterPT<<endl)                                      ////////////////
    
    
    // плотный массив цепочек адресов (позиций) ОДИНАКОВЫХ пар букв в распознаваемом тексте (в тексте легко встечаются одинаковые пары букв)
    // как в хеш, clusters_data массив цепочек (array of clusters)
///    int  *clusters_data
    clusters_size=n+2*m+1; // размер массива clusters_data, с учетом двух служебных ячейек на одну разновидность пар букв "m", unsigned int
    // +1 т.к. нулевая ячейка массива не используется  // n+m+1;
    //clusters_size=2048-32;
    clusters_data_vector->resize(clusters_size+32);    // запрос памяти c обнулением   
    clusters_data=(int*)clusters_data_vector->dataPtr();

    //DR(endl<<"размер массива clusters_data    clusters_size="<<clusters_size<<endl)
    
    // копия массива clusters_data, предназначена для его восстановления, а именно счетчиков адресов цепочек, с помощью memcpy
    clusters_copy_vector->resize(clusters_size+32);    // запрос памяти c обнулением
    clusters_copy=(int*)clusters_copy_vector->dataPtr();
    
    // Заполнение разреженного массива letters_data адресами (позициями), пар букв встечающихся в распознаваемом тексте один раз. 
    // Адресом массива является компактный код пары букв.
    // Адреса пар букв в плотный массив clusters_data поступают поступают псевлослучайно, поэтому используется свой счетчик адресов (counter) 
    // для каждого кластера.

    n=1;
    for(x=0; x < text_size1 ; x++) { // text_size1 размер массива распознаваемого текста без переводов каретки Enter  // nLetterPT
        ds=text_data[x];      // компактный код пары букв в распознаваемом тексте 
        bf=BufLpT[ds];        // количество разных пар букв во всем распознаваемом тексте
        bl=letters_data[ds];  // адреса (позиции) пар букв встечающихся в распознаваемом тексте один раз (без учета одинаковых).
                              // или ссылки на массив цепочек адресов (позиций) ОДИНАКОВЫХ пар букв в распознаваемом тексте  
                              // (в тексте легко встечаются одинаковые пары букв)
        
        // заполнение массива адресами (позициями) пар букв в распознаваемом тексте встречающихся однократно
        if ( bf == 1 ) {                                      
            // в массиве letters_data по адресу "ds" (компактный код пары букв) находится адрес (позиция) в тексте пары букв "x"
            // адреса в массиве letters_data>0  должны начинаться с единици, поэтому x+1
            letters_data[ds]=x+1;   // позиция в тексте пары букв = letters_data [компактный код пары букв] 
        } // ( bf == 1 )
        
        // запись ссылок в массив letters_data (ссылки искуственно отрицательные ), разметка массива clusters_data
        if ( bl == 0 && bf > 1 ) {  
            // заполняем массив letters_data ссылками (адресами), по которым находятся цепочки адресов (ячееки кластера) 
            // в плотном массиве clusters_data, ОДИНАКОВЫХ пар букв. Искуственно помечаем эти ссылки знаком минус,
            // что бы указать, что это ссылка на заголовок цепочки, а не позиция в тексте пары букв
            bl=letters_data[ds]=-n;     // в массив letters_data на позицию "ds" домещаем код "-n"   //  -(n+bf);
            // в заголовок каждой цепочки пишем количество адресов в цепочке (длинну цепочки, одна цифра), искуственно помечаем это 
            // количество адресов со знаком минус, в следующею ячейку пишем копию заголовка количества адресов в цепочке 
            // со знаком плюс, это будет счетчик адресов (counter) в цепочке (ячеек кластера)
            // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44                        
            clusters_data[n]=-bf;     ////clusters_data[n]=-bf;    clusters_data[n+1]=bf;
            // вычисляем положение заголовков каждой цепочки в плотном массиве цепочек адресов  clusters_data[x]
            n=n+2+bf;             
        } // ( bl == 0 )
        
        // заполнение кластеров в массиве clusters_data 
        if ( bl < 0 ) {
            /*
            // превращаем bl в положительнай адрес blp, т.к. число bl искуственно отрицательно
            blp=-bl;
            // расстояние от ячейки счетчика свободных адресов до первой свободной ячейки кластера
            m=-clusters_data[blp+1]-clusters_data[blp];  
            // заполняем первый, второй, третий и т.д. адреса в цепочке ячеек кластера
            clusters_data[blp+2+m]=x;
            // уменьшаем значение счетчика свободных адресов в цепочке на единицу (значение счетчика свободных адресов искуственно положительно)
            clusters_data[blp+1]-=1;
             // после полного завершения цикла по "x" все счетчики свободных адресов (вторая цифра в заголовке кластера) устанаввливаются в ноль
             // первая цифра в заголовке кластера всегда количество адресов в цепочке со знаком минус,
             // 0  -3  0  2  56  63  -2  0  8  17  -2  0  9  42  -2  0  10  43  -2  0  23  57  -2  0  24  71  -2  0  26  47  -2  0  38  44  
            */             
            // превращаем bl в положительнай адрес blp, т.к. число bl искуственно отрицательно,  +1 положение счетчика свободных адресов
            blp=-bl+1;  
            // заполняем первый, второй, третий и т.д. адреса в цепочке ячеек кластера
            clusters_data[blp+1+clusters_data[blp]]=x;   // это выражение аналог x, только извлеченный из массива цепочек адресов clusters_data[x]
            // увеличиваем счетчик свободных адресов в цепочке на единицу 
            clusters_data[blp]+=1;
            /**/ 
        } // if ( bl < 0 )
        
    } // x
    DR(endl)
    /**/
    
    
    // после полного завершения цикла по "x" все счетчики свободных адресов (вторая цифра в заголовке кластера "3") устанаввливаются
    // в значение равное количеству адресов в цепочке 
    // первая цифра в заголовке кластера "-3" всегда количество адресов в цепочке со знаком минус. Кластер "-3  3  2  56  63" 
    // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44 

    //for(x=0; x < clusters_size-1; x++) { if( clusters_data[x] < 0 ) { clusters_data[x+1]=-clusters_data[x]; }  } // x
    // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44 
    
 
    // TMP 
    // просмотр плотного массива цепочек адресов  clusters_data[x]
    DR(endl<<"clusters_data[x]"<<endl)
    DR("11 просмотр плотного массива цепочек адресов  clusters_data[x]"<<endl)    
    for(x=0; x < clusters_size; x++) { // letters_size=nLetterPT количество разных пар букв в распознаваемом тексте
        bc=clusters_data[x];
        ///DR(x<<"_"<<bc<<"  ";
        DR(bc<<"  ")
    } // x
    DR(endl<<endl)
    
    
    // копия массива clusters_copy, предназначена для восстановления  массива clusters_data, после любого обращения к нему
    memcpy(clusters_copy, clusters_data, clusters_size*4); // memcpy(buf2, buf1, SIZE);
    // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44
    
    // TMP
    // просмотр плотного массива цепочек адресов  clusters_copy[x]
    DR(endl<<"clusters_copy[x]"<<endl)
    DR("1234 просмотр плотного массива цепочек адресов  clusters_copy[x]"<<endl)    
    for(x=0; x < clusters_size; x++) { 
        bc=clusters_copy[x];
        ///DR(x<<"_"<<bc<<"  ";
        DR(bc<<"  ")
    } // x
    DR(endl<<endl)
    
// просмотр //
    
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    
    
#ifdef REMARK    
     DR("размер распознаваемого текста в буквах без переводов каретки, пробелов или точек    text_size1="<<text_size1<<endl)
     DR("количество разных пар букв во всем распознаваемом тексте     nLetterPT="<<nLetterPT<<endl)
     DR("суммарное количество одинаковых пар букв во всем тексте     clusters_size="<<clusters_size<<endl)
///     DR("количество разновидностей цепочек одинаковых пар букв во всем тексте    size_BufEL="<<size_BufEL<<endl)
     DR("количество различных пар букв в словаре     nLetterP="<<nLetterP<<endl)
     /**/
    

    // просмотр разреженного массива BufLpT[x]
    // выведены только не нулевае значения!
    
    DR(endl<<"BufLpT[x]"<<endl)    
    DR("перебор всех значений [x] массива  BufLpT[x],  выведены только не нулевае значения отклика массива !"<<endl)
    DR("число (m) разных пар букв,  компактный код пары букв [x] _ первая буквы пары выведена шрифтом (ག)"<<endl)
    
    for(x=0; x < size_BufLpT; x++) { // size_BufLpT=nLetterP; количество разных пар букв в словаре
        ds=BufLpT[x];
        if (ds!=0) {
            ///DR(ds<<"_"<<x<<"_";   str=(wchar_t)BufUpT[x]; DR(Unicode_to_UTF(str)<<"    ";
            ///DR(ds<<"_"<<x<<"  ";
            DR(ds<<" ")
            //DR(letters_data[x]<<" ";   str=(wchar_t)BufUpT[x]; DR(Unicode_to_UTF(str)<<"   ";            
        } // if
        //DR(letters_data[x]<<" ";
    } // x
    DR(endl)
    /**/    
/////////////    nLetterPT=m; // количество разных пар букв в распознаваемом тексте // nLetterPT=<nLetterP;
    
    
    // просмотр разреженного массива BufLpT[x] через распознаваемый текст
    DR(endl<<"BufLpT[x]"<<endl)
    DR("просмотр разреженного массива  BufLpT[x]  через распознаваемый текст (первая буквы пары выведена шрифтом ག)"<<endl)
    DR("число (m) разных пар букв,  первая буквы пары выведена шрифтом (ག)"<<endl)
    s=0;
    for(x=0; x < text_size1; x++){ //text_size1 размер массива распознаваемого текста без переводов каретки Enter
        ds=text_data[x];
        DR(BufLpT[ds]);    str=(wchar_t)BufUpT[ds]; DR(Unicode_to_UTF(str)<<"  ")  
        //        DR(text_data[x]<<"   ";
        if ( x==BufET[s] ){ DR(endl) s++; }  // перевод каретки Enter текста
    }
    DR(endl)    
   
     

    // просмотр разреженного массива letters_data[x] через распознаваемый текст     
    // позиция в тексте пары букв=letters_data[компактный код пары букв]
    
    DR(endl<<"letters_data[x]"<<endl)
    DR("просмотр разреженного массива  letters_data[x]  через распознаваемый текст (первая буквы пары выведена шрифтом ག)"<<endl)
    DR("позиция в тексте пары букв,  первая буквы пары выведена шрифтом (ག)"<<endl)
    // обращаемся к массиву letters_data[x]  по  "x" - компактному коду пары букв, получаем - позицию в тексте этой пары букв (адрес в тексте)
    s=0;
    for(x=0; x < text_size1; x++){ //text_size1 размер массива распознаваемого текста без переводов каретки Enter
        ds=text_data[x];
        bl=letters_data[ds];
        // Внимание! Адреса пар букв в тексте прописаны в массиве letters_data>0 и начинаются с единици поэтому bl-1
        if ( bl > 0 ){ DR(bl-1); } else { DR(bl); }    str=(wchar_t)BufUpT[ds]; DR(Unicode_to_UTF(str)<<"  ")  
        ///DR(letters_data[ds];    str=(wchar_t)BufUpT[ds]; DR(Unicode_to_UTF(str)<<"  ";  
        //        DR(text_data[x]<<"   ";
        if ( x==BufET[s] ){ DR(endl) s++; }  // перевод каретки Enter текста
    }
    DR(endl)      
    
    
    
    // просмотр плотного массива цепочек адресов  clusters_data[x]
    DR(endl<<"clusters_data[x]"<<endl)
    DR("просмотр плотного массива цепочек адресов  clusters_data[x]"<<endl)    
    for(x=0; x < clusters_size; x++) { // letters_size=nLetterPT количество разных пар букв в распознаваемом тексте
        bc=clusters_data[x];
        ///DR(x<<"_"<<bc<<"  ";
        DR(bc<<"  ")
    } // x
    DR(endl<<endl)
    
    
    // просмотр плотного массива цепочек адресов clusters_data[x] через распознаваемый текст
    // восстановление распознаваемого текста через массив цепочек адресов
    ///DR(endl<<"clusters_data[x]"<<endl)
    // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44
    DR("восстановление распознаваемого текста через массив цепочек адресов  clusters_data[x]"<<endl)
    s=0;  n=0;
    for(x=0; x < text_size1; x++) { // letters_size=nLetterPT количество разных пар букв в распознаваемом тексте        
      ds=text_data[x];      // компактный код пары букв в распознаваемом тексте 
      bl=letters_data[ds]; 
      if ( bl != 0 ) {
        // заполнение массива адресами (позициями) пар букв в распознаваемом тексте встречающихся однократно
        if ( bl > 0 ) { 
            // Внимание! Адреса пар букв в тексте прописаны в массиве letters_data>0 и начинаются с единици поэтому bl-1
            DR(bl-1);    str=(wchar_t)BufUpT[ds]; DR(Unicode_to_UTF(str)<<"  ")  
            //        DR(text_data[x]<<"   ";
            if ( x==BufET[s] ){ DR(endl) s++; }  // перевод каретки Enter текста
            if ( bl-1==x ) n++; // проверка на совпадение восстановленного и исходного распознаваемого текста
        } // ( bl > 0 )
        else {                         
            blp=-bl;  // превращаем bl в положительнай адрес blp, т.к. число bl искуственно отрицательно
            cnt=clusters_data[blp+1];   // считываем значение счетчика адресов,  +1 положение счетчика свободных адресов
            // считывание первого, второго, третьего и т.д. адресов в цепочке ячеек кластера
            for(m=0; m < cnt; m++) {
              bc=clusters_data[blp+2+m];   // bc аналог x, только извлеченный из массива цепочек адресов clusters_data[x]
               if ( bc==x ) n+=cnt;        // проверка на совпадение восстановленного и исходного распознаваемого текста
               // вывод на экран восстановленного распознаваемого текста
               DR(bc);    str=(wchar_t)BufUpT[text_data[bc]]; DR(Unicode_to_UTF(str)<<"  ")  // ds 
               ///        DR(text_data[x]<<"   ";
               if ( x==BufET[s] ){ DR(endl) s++; }  // перевод каретки Enter распознаваемого текста 
            } // for(m=0;
            // устанавливаем счетчик адресов в цепочке (вторая цифра в заголовке кластера) в ноль 
            // для исключения повторных обращений к данному кластеру.
            clusters_data[blp+1]=0;
            
        } // else
        
      } // if ( bl != 0 )
        
    } // x
    DR("n="<<n<<"    "<<"text_size1="<<text_size1<<"   ")
    if ( n==text_size1 ) DR("ОК"<<endl)
/**/
   
        
    // после полного завершения цикла по "x" все счетчики свободных адресов устанавливаются в ноль,
    // первая цифра в заголовке кластера это всегда количество адресов в цепочке со знаком минус
    // 0  -3  0  2  56  63  -2  0  8  17  -2  0  9  42  -2  0  10  43  -2  0  23  57  -2  0  24  71  -2  0  26  47  -2  0  38  44

    
    // после просмотра обязательно восстанавливаем исходное значение счетчика адресов в цепочке (ячеек кластера) 
    // равное количеству адресов в цепочке (вторая цифра в заголовке)    
    for(x=0; x < clusters_size-1; x++) { if( clusters_data[x] < 0 ) { clusters_data[x+1]=-clusters_data[x]; }  } // x
    // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44

    DR("после просмотра все счетчики свободных адресов возвращаются в значение равное количеству адресов в цепочке"<<endl)
    //DR(endl<<endl)
    
    TIME_PRINT

#endif    
    
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    // TMP 
    // просмотр плотного массива цепочек адресов  clusters_data[x]
    DR(endl<<"clusters_data[x]"<<endl)
    DR("просмотр плотного массива цепочек адресов  clusters_data[x]"<<endl)    
    for(x=0; x < clusters_size; x++) { // letters_size=nLetterPT количество разных пар букв в распознаваемом тексте
        bc=clusters_data[x];
        ///DR(x<<"_"<<bc<<"  ";
        DR(bc<<"  ")
    } // x
    DR(endl<<endl)
    

  

////      exit(0);  //////// 
    

    
}//--------------------------------------------------------------------------------------------------------------------------------------------  



//-------------------------------------------------------------------------------------------------------//


//-------------------------------------------------------------
// текст для кнопок //
// для любых процессоров, код на "C".
// для процессоров Intel с SSE3, код на "ASM".
// для процессоров Intel с SSE4.2 с командой POPCNT, код на "ASM".
// For all processors, the code in "C".
// For Intel processors with SSE3, code for "ASM".
// For Intel processors with SSE4.2, with the team POPCNT, code for "ASM".
//-------------------------------------------------------------

///#include <unistd.h>       // для определения количества процессорных ядер в системе num_cores
///#include <sys/utsname.h>  // определяет версию ядра Linux, поддержка AVX было добавлена в ядро 2.6.30

///#include <smmintrin.h>
///#include <xmmintrin.h>    // Подключаем xmmintrin.h, пишем векторизованный код, компилируем с флагом -msse3. Компилятор распределяет регистры XMM#, 
// планирует команды и режимы адресации. Удобно, интуитивно просто.

//#include <immintrin.h>  // не компелит

// Узнать версию ядра Linux, поддержка AVX было добавлена в ядро 2.6.30    //  
// http://www.kernel.org/doc/man-pages/online/pages/man2/uname.2.html
/*
 uname() returns system information in the structure pointed to by buf.  The
 utsname struct is defined in <sys/utsname.h>:
 
 struct utsname {
 char sysname[];    // Operating system name (e.g., "Linux") 
 char nodename[];   // Name within "some implementation-defined
 // network" 
 char release[];    // OS release (e.g., "2.6.28") 
 char version[];    // OS version 
 char machine[];    // Hardware identifier 
 #ifdef _GNU_SOURCE
 char domainname[]; /* NIS or YP domain name 
 #endif
 };
 
 The length of the arrays in a struct utsname is unspecified (see NOTES); the
 fields are terminated by a null byte ('\0').
 */

/*
struct utsname buf;
uname(&buf);
DR("Узнать версию ядра Linux в системе   uname="<<buf.release<<endl) // #include <sys/utsname.h>


// Определение количества процессорных ядер в системе Linux // #include <unistd.h>
int num_cores = sysconf(_SC_NPROCESSORS_ONLN);
DR("количество процессорных ядер в системе   num_cores="<<num_cores<<endl)
*/

/* 
 // http://habrahabr.ru/blogs/hi/99367/
 //#include <immintrin.h>  // заголовочный файл immintrin.h с описанием соответствующих intrinsic-функций. // smmintrin.h // xmmintrin.h
 Поддержка AVX реализована в следующих популярных компиляторах: GCC начиная с версии 4.4
 Параметры компиляции, которые включают компиляцию SSEx intrinsic-функций в AVX инструкции следующие: -mavx — для GCC
 Включение этого заголовочного файла автоматически влечёт за собой включение заголовочных файлов всех SSE-intrinsic'ов. Что касается 128-битных инструкций AVX, то для них нет ни только отдельных хидеров, но и отдельных intrinsics-функций. Вместо этого для них используются intrinsic-функции для SSEx-инструкций, а тип инструкций (SSE или AVX), в которые будут компилироваться вызовы этих intrinsic-функций задаётся в параметрах компилятора. Это означает, что смешать SSE и AVX формы 128-битных инструкций в одном компилируемом файле не получится, и если вы хотите иметь и SSE, и AVX версии функций, то вам придётся писать их в разных компилируемых файлах (и компилировать эти файлы с разными параметрами).
 Intrinsics — набор функций и типов данных, поддерживаемых компилятором, для предоставления высокоуровневого доступа к SSE инструкциям.
 */   

/*    
 Вызов подпрограмм возврат из них - CALL, RET. Команда call передает управление ближней или дальней процедуре с запоминанием в стеке адреса точки возврата. Команда ret возвращает управление из процедуры вызывающей программе, адрес возврата получает из стека. Пример:
 
 ..code..
 call 0455659
 ..more code..
 Код с адреса 455659:
 add eax, 500
 mul eax, edx
 ret
 
 Когда выполняется команда call, процессор передает управление на код с адреса 455659, и выполняет его до команды ret, а затем возвращает управление команде следующей за call. Код который вызывается командой call называется процедурой. Вы можете поместить код, который вы часто используете в процедуру и каждый раз когда он вам нужен вызывать его командой call.
 */

//-------------------------------------------------------------


///table_letters=(unsigned int*)malloc(letters_size*4+32);  // запрос памяти без заполнения 0  // dictionary_size*sizeof(int)
///memset(table_letters,0,letters_size*4+32); // обнуление dictionary_data

//text_data=(unsigned short*)calloc(text_size+32,2);   // запрос памяти c обнулением
//DR("text_size="<<text_size<<endl)
/**/

/*
// выбираем наименьший из letters_sizeA, letters_sizeB
unsigned int  letters_sizeA, letters_sizeB;    
letters_sizeA=letters_sizeB=nLetterP;
///letters_sizeA=letters_sizeB=text_size1;
//if ( text_size1 < nLetterP ){ letters_sizeA=letters_sizeB=text_size1; }
DR(endl<<"letters_sizeA=letters_sizeB=letters_sizeA="<<letters_sizeA<<endl)
DR(endl<<"letters_sizeA=letters_sizeB=text_size1="<<text_size1<<endl)
*/


// определение параметров (размерности) таблицы координат букв в тексте:

// создание массива адресов границ цепочек для clusters_data
///    unsigned int  *BufEL;
///    unsigned int  size_BufEL=m; // размер массива size_BufEL  // nLetterP количество разных пар букв в словаре // 65536
///    BufEL=(unsigned int*)calloc(size_BufEL+32,4);   // запрос памяти c обнулением    


// nLetterPT количество разных пар букв в распознаваемом тексте
//     for(x=0; x < nLetterPT; x++) { DR(BufEL[x]<<" "; } // x
//     DR(endl) 

/*
 // создание массива таблиц распознаваемого текста        
 for(x=0; x < text_size1; x++) { 
 //       BufLpT[x]!=0                      
 } // x
 DR(endl)  
 */

/*
// просмотр разреженного массива BufLpT[x] через распознаваемый текст 
DR(endl<<"просмотр разреженного массива BufLpT[x] через распознаваемый текст"<<endl)
s=0;
for(x=0; x < text_size1; x++){ //text_size1 размер массива распознаваемого текста без переводов каретки Enter        
    str=(wchar_t)BufUpT[text_data[x]]; DR(Unicode_to_UTF(str)  
    if ( x==BufET[s] ){ DR(endl) s++; }  // перевод каретки Enter текста
}
//DR(endl)

// просмотр разреженного массива BufLpT[x] через распознаваемый текст 
s=0;
for(x=0; x < text_size1; x++){ //text_size1 размер массива распознаваемого текста без переводов каретки Enter
    DR(BufLpT[text_data[x]];      
    if ( x==BufET[s] ){ DR(endl) s++; }  // перевод каретки Enter текста
}
//DR(endl)
*/


/*
// просмотр разреженного массива letters_data[x]  // выведены только не нулевае значения!          // позиция в тексте пары букв=letters_data[компактный код пары букв]

DR(endl<<"letters_data[x]"<<endl)
DR("перебор всех значений [x] массива  letters_data[x],  выведены только не нулевае значения отклика массива !"<<endl)
DR("позиция в тексте пары букв (ds) _ компактный код пары букв (x) _ первая буквы пары выведена шрифтом (ག)"<<endl)   

// обращаемся к массиву letters_data[x]  по  "x" - компактному коду пары букв, получаем - позицию в тексте этой пары букв (адрес в тексте)
///m=0;       
for(x=0; x < letters_size; x++) { // letters_size=nLetterPT количество разных пар букв в распознаваемом тексте
    di=letters_data[x];
    if (di != 0) {
        ///          m++;
        DR(di<<"_"<<x<<"_";   str=(wchar_t)BufUpT[x]; DR(Unicode_to_UTF(str)<<"    "; 
        //DR(di<<"_";   str=(wchar_t)BufUpT[text_data[di]]; DR(Unicode_to_UTF(str)<<"  ";
    }  // if             
} // x
DR(endl<<endl)
///   DR("количество разных пар букв в распознаваемом тексте (без учета одинаковых) m="<<m<<endl)
*/

 /*
 // заполнение первого адреса в цепочке адресов
 clusters_data[n+2]=x;
 // уменьшаем счетчик свободных адресов в цепочке на единицу, количество адресов помечено знаком минус!  // оставшихся заполненных
 clusters_data[n+1]+=1;      // bc=clusters_data[n+1]+=1;              
 */ 

///bm=-bf;
///for(y=bm; y > 0 ; y--) { } 

//-------------------------------------------------------------------------------------------------------

/*
// просмотр плотного массива цепочек адресов clusters_data[x] через распознаваемый текст
// восстановление распознаваемого текста через массив цепочек адресов
///DR(endl<<"clusters_data[x]"<<endl)
DR("восстановление распознаваемого текста через массив цепочек адресов  clusters_data[x]"<<endl)
s=0;  n=0;
for(x=0; x < text_size1; x++) { // letters_size=nLetterPT количество разных пар букв в распознаваемом тексте        
    ds=text_data[x];      // компактный код пары букв в распознаваемом тексте 
    bl=letters_data[ds]; 
    
    // заполнение массива адресами (позициями) пар букв в распознаваемом тексте встречающихся однократно
    if ( bl >= 0 ) {                                      
        DR(bl;    str=(wchar_t)BufUpT[ds]; DR(Unicode_to_UTF(str)<<"  ";  
        //        DR(text_data[x]<<"   ";
        if ( x==BufET[s] ){ DR(endl) s++; }  // перевод каретки Enter текста
        if ( bl==x ) n++; // проверка на совпадение восстановленного и исходного распознаваемого текста
    } // ( bl > 0 )
    else {             // if ( bl < 0 ) {
        
        blp=-bl+1;  // превращаем bl в положительнай адрес blp, т.к. число bl искуственно отрицательно,  +1 положение счетчика свободных адресов
        cnt=clusters_data[blp];   ////// заремачить
        
        // перед началом проверки фразы восстанавливаем значение счетчика адресов в цепочке (ячеек кластера) равное нолю
        // ...... // if ( p==0 ) { cnt=0; }  else { cnt=clusters_data[blp]; }
        
        // считывание первого, второго, третьего и т.д. адресов в цепочке ячеек кластера
        bc=clusters_data[blp+1+cnt];   // bc аналог x, только извлеченный из массива цепочек адресов clusters_data[x]
        ///bc=clusters_data[blp+1+clusters_data[blp]];   // bc аналог x, только извлеченный из массива цепочек адресов clusters_data[x]
        // увеличиваем счетчик свободных адресов в цепочке на единицу
        cnt++;  ///cnt=clusters_data[blp]+=1;  // clusters_data[blp]=cnt+=1;          
        // после полного завершения цикла по "x" все счетчики свободных адресов возвращаются в значение равное количеству адресов в цепочке (вторая цифра в заголовке)
        
        // вывод на экран восстановленного распознаваемого текста
        DR(bc;    str=(wchar_t)BufUpT[text_data[bc]]; DR(Unicode_to_UTF(str)<<"  ";  // ds 
        ///        DR(text_data[x]<<"   ";
        if ( x==BufET[s] ){ DR(endl) s++; }  // перевод каретки Enter распознаваемого текста            
        
        //// обнуляем счетчики свободных адресов (вторая цифра в заголовке) // проверить!!!
        // т.е. восстанавливаем исходное значение счетчика адресов в цепочке (ячеек кластера) равное нолю.
        // Как только счетчик достигает своего максимального значения, равного значению из предыдущей ячейки, он сбрасывается в ноль
        if ( cnt==-clusters_data[blp-1] ) { cnt=0; }
        //if ( cnt==-clusters_data[blp-1] ) { cnt=555; }
        
        clusters_data[blp]=cnt;
        
        
        if ( bc==x ) n++; // проверка на совпадение восстановленного и исходного распознаваемого текста
    } //
    
} // x
DR("n="<<n<<"    "<<"text_size1="<<text_size1<<"   ";
if ( n==text_size1 ) DR("ОК"<<endl)
*/ 


//-------------------------------------------------------------------------------------------------------


/*             // рабочий код
// заполнение разреженного массива letters_data адресами (позициями), пар букв встечающихся в распознаваемом тексте один раз. 
// Адресом массива является компактный код пары букв.
n=1;
for(x=0; x < text_size1 ; x++) { // text_size1 размер массива распознаваемого текста без переводов каретки Enter  // nLetterPT
    ds=text_data[x];      // компактный код пары букв в распознаваемом тексте 
    bf=BufLpT[ds];        // количество разных пар букв во всем распознаваемом тексте
    bl=letters_data[ds];  // адреса (позиции) пар букв встечающихся в распознаваемом тексте один раз (без учета одинаковых).
    // или ссылки на массив цепочек адресов (позиций) ОДИНАКОВЫХ пар букв в распознаваемом тексте (в тексте легко встечаются одинаковые пары букв) 
    
    // заполнение массива адресами (позициями) пар букв в распознаваемом тексте встречающихся однократно
    if ( bf == 1 ) {                                      
        // в массиве letters_data по адресу "ds" (компактный код пары букв) находится адрес (позиция) в тексте пары букв "x"
        letters_data[ds]=x;   // позиция в тексте пары букв = letters_data [компактный код пары букв] 
    } // ( bf == 1 )
    
    // запись ссылок в массив letters_data (ссылки искуственно отрицательные ), разметка массива clusters_data
    if ( bl == 0 && bf > 1 ) {  
        // заполнение массива letters_data ссылками (адресами), по которым находятся цепочки адресов (ячееки кластера) в плотном массиве clusters_data, ОДИНАКОВЫХ пар букв
        // искуственно помечаем эти ссылки знаком минус, что бы указать, что это ссылка на заголовок цепочки, а не позиция в тексте пары букв
        bl=letters_data[ds]=-n;     // в массив letters_data на позицию "ds" домещаем код "-n"   //  -(n+bf);
        // в заголовок каждой цепочки пишем количество адресов в цепочке (длинну цепочки, одна цифра), искуственно помечаем это количество адресов знаком минус,
        // в следующею ячейку пишем копию заголовка количество адресов в цепочке, это будет счетчик адресов (counter) в цепочке (ячеек кластера)            
        clusters_data[n+1]=clusters_data[n]=-bf;    
        ////clusters_data[n]=-bf;                    
        // вычисляем положение заголовков каждой цепочки в плотном массиве цепочек адресов  clusters_data[x]
        n=n+2+bf;             
    } // ( bl == 0
    
    // заполнение кластеров в массиве clusters_data 
    if ( bl < 0 ) {
        
        blp=-bl;  // превращаем bl в положительнай адрес blp, т.к. число bl искуственно отрицательно            
        m=clusters_data[blp+1]-clusters_data[blp];  // расстояние от ячейки счетчика свободных адресов до первой свободной ячейки кластера
        // заполнение первого, второго, третьего и т.д. адресов в цепочке ячеек кластера
        clusters_data[blp+2+m]=x;
        // уменьшаем счетчик свободных адресов в цепочке на единицу
        bc=clusters_data[blp+1]+=1;
        // после полного завершения цикла по "x" все счетчики свободных адресов оказываются установленными в ноль (вторая цифра в заголовке кластера) 
        
        // восстанавливаем значение счетчика адресов в цепочке (ячеек кластера) равное количеству адресов в цепочке
        // иначе после полного завершения цикла по "x" все счетчики свободных адресов оказываются установленными в ноль (вторая цифра в заголовке кластера)
        /// if ( bc == 0 ) { clusters_data[blp+1]=clusters_data[blp]; }  /// можно оптимизировать // переписать
        
        
        
//         blp=-bl+1;  // превращаем bl в положительнай адрес blp, т.к. число bl искуственно отрицательно,  +1 положение счетчика свободных адресов
         // заполнение первого, второго, третьего и т.д. адресов в цепочке ячеек кластера
//         clusters_data[blp+1+clusters_data[blp]]=x;   // это выражение аналог x, только извлеченный из массива цепочек адресов clusters_data[x]
         // увеличиваем счетчик свободных адресов в цепочке на единицу 
//         clusters_data[blp]+=1;      
         // после полного завершения цикла по "x" все счетчики свободных адресов возвращаются в значение равное количеству адресов в цепочке (вторая цифра в заголовке)
         // восстанавливаем значение счетчика адресов в цепочке (ячеек кластера) равное нолю // не забыть заремачить ///clusters_data[n]=/
//         clusters_data[n+1]=-bf;
//         if ( clusters_data[blp]==-clusters_data[blp-1] ) { clusters_data[blp]=0; }
         
        
    } // if ( bl < 0 )
    
} // x
// после полного завершения цикла по "x" все счетчики свободных адресов возвращаются в значение равное количеству адресов в цепочке (вторая цифра в заголовке кластера)
DR(endl)
*/

//-------------------------------------------------------------------------------------------------------

//// обнуляем счетчики свободных адресов (вторая цифра в заголовке) // проверить!!!
// т.е. восстанавливаем исходное значение счетчика адресов в цепочке (ячеек кластера) равное нолю.
// Как только счетчик достигает своего максимального значения, равного значению из предыдущей ячейки, он сбрасывается в ноль
////if ( cnt==-clusters_data[blp-1] ) { cnt=0; }
//if ( cnt==-clusters_data[blp-1] ) { cnt=555; 
// после полного завершения цикла по "x" все счетчики свободных адресов (вторая цифра в заголовке кластера) устанаввливаются в ноль
//----------
// после полного завершения цикла по "x" все счетчики свободных адресов (вторая цифра в заголовке кластера) устанаввливаются в ноль
// первая цифра в заголовке кластера всегда количество адресов в цеплчке со знаком минус,
// 0  -3  0  2  56  63  -2  0  8  17  -2  0  9  42  -2  0  10  43  -2  0  23  57  -2  0  24  71  -2  0  26  47  -2  0  38  44 

//----------

/*
clusters_data[n+1]=clusters_data[n]=-bf;

// вычисляем положение заголовков каждой цепочки в плотном массиве цепочек адресов  clusters_data[x]
n=n+2+bf;             
} // ( bl == 0 )

// заполнение кластеров в массиве clusters_data 
if ( bl < 0 ) {
    
    // превращаем bl в положительнай адрес blp, т.к. число bl искуственно отрицательно
    blp=-bl;              
    m=clusters_data[blp+1]-clusters_data[blp];  // расстояние от ячейки счетчика свободных адресов до первой свободной ячейки кластера
    // заполняем первый, второй, третий и т.д. адреса в цепочке ячеек кластера
    clusters_data[blp+2+m]=x;
    // уменьшаем значение счетчика свободных адресов в цепочке на единицу (значение счетчика свободных адресов искуственно отрицательное)
    clusters_data[blp+1]+=1;
    // 0  -3  0  2  56  63  -2  0  8  17  -2  0  9  42  -2  0  10  43  -2  0  23  57  -2  0  24  71  -2  0  26  47  -2  0  38  44
*/

//----------

/*
 // превращаем bl в положительнай адрес blp, т.к. число bl искуственно отрицательно
 blp=-bl;
 // расстояние от ячейки счетчика свободных адресов до первой свободной ячейки кластера
 m=-clusters_data[blp+1]-clusters_data[blp];  
 // заполняем первый, второй, третий и т.д. адреса в цепочке ячеек кластера
 clusters_data[blp+2+m]=x;
 // уменьшаем значение счетчика свободных адресов в цепочке на единицу (значение счетчика свободных адресов искуственно положительно)
 clusters_data[blp+1]-=1;
 // после полного завершения цикла по "x" все счетчики свободных адресов (вторая цифра в заголовке кластера) устанаввливаются в ноль
 // первая цифра в заголовке кластера всегда количество адресов в цепочке со знаком минус,
 // 0  -3  0  2  56  63  -2  0  8  17  -2  0  9  42  -2  0  10  43  -2  0  23  57  -2  0  24  71  -2  0  26  47  -2  0  38  44  
 */  

//----------

/*
// после полного завершения цикла по "x" все счетчики свободных адресов возвращаются в значение равное количеству адресов в цепочке
// со знаком минус (вторая цифра в заголовке), первая цифра в заголовке кластера всегда количество адресов в цепочке со знаком минус
// 0  -3  -3  2  56  63  -2  -2  8  17  -2  -2  9  42  -2  -2  10  43  -2  -2  23  57  -2  -2  24  71  -2  -2  26  47  -2  -2  38  44


// обнуляем счетчики свободных адресов (вторая цифра в заголовке)
// т.е. восстанавливаем исходное значение счетчика адресов в цепочке (ячеек кластера) равное нолю
// обязательна после выполнения просмотра плотного массива цепочек адресов clusters_data[x] через распознаваемый текст    
for(x=0; x < text_size1-1; x++) { if( clusters_data[x] < 0 ) { clusters_data[x+1]=0; }  } // x
// 0  -3  0  2  56  63  -2  0  8  17  -2  0  9  42  -2  0  10  43  -2  0  23  57  -2  0  24  71  -2  0  26  47  -2  0  38  44
*/

// после полного завершения цикла по "x" все счетчики свободных адресов (вторая цифра в заголовке кластера) устанаввливаются в ноль
// первая цифра в заголовке кластера всегда количество адресов в цепочке со знаком минус,
// 0  -3  0  2  56  63  -2  0  8  17  -2  0  9  42  -2  0  10  43  -2  0  23  57  -2  0  24  71  -2  0  26  47  -2  0  38  44   

//-------------------------------------------------------------------------------------------------------

              // рабочий код //


/**/
//-------------------------------------------------------------------------------------------------------

 
 
 
 