#include "GMap.h"

//#include <string.h>  // memcpy(buf2, buf1, SIZE);  std::memcpy
//using namespace std;0
//#include <iostream>    // for  itoa(input1,c,2); итак запускаеися


unsigned short GMap::lookupProcess3(unsigned int w, unsigned int oldw){
       
    //// функция поиска совпавшего непрерывного фрагмента фразы словаря длинной больше constantPhrase1 с 
    //// непрерывным фрагментом текста. С учетом точных координатах совпавших букв текста .
    
    unsigned int x,m;           // ,s0,s1 // ,y,p // n,
    int bl,blp,bc,cnt;          // ,bc,bm,counter
    unsigned short ds;          // ,bf    
    unsigned short LPhraseHits; // количество совпавших букв фразы Length Phrase Hits с буквами распознаваемого текста
    wstring str;
    /*
    // необходимы для вывода на экран
    unsigned int s=0, nc=0; 
    wstring str;        
*/ 


   

    //  Описание алгоритма:
    

    // Функции lookupProcess3 учитывающею шрифтовую (поространственную) геометрию текста.
    // Для этого оставляем для дальнейшей обработки фразы словаря имеющие непрерывный фрагмент совпавший с непрерывным
    // фрагментом распознаваемого текста. По достижении пороговой длины constantPhrase подряд идущих букв текста
    // совпавших с непрерывным фрагментом распознаваемого текста, останавливаем подсчет длины и переходим к следующему
    // уточняющему алгоритму N4, который работает только с фразами словаря прошедшими предидущий этап N1,N2 и N3.
    // Таких фраз примерно примерно в три раза меньше чем количество фраз словаря поступающих на этот алгоритм.
    // Алгоритм дает выйгрыш по быстродейсдвию примерно в три раза.
    // Информация о точных координатах совпавших букв текста уже присутствует.
                
    // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44
    //// убрать второе значение счетчика (3), использовать отдельный быстрый байтовый clusters_flag или clusters_copy исп memcpy(buf2, buf1, SIZE);
    w--;
    for(x=oldw; x < w; x++) { // w-1;
      ds=dictionary_data[x];  // компактный код пары букв в распознаваемом тексте
      bl=letters_data[ds];    // адреса (позиции) пар букв встечающихся в распознаваемом тексте один раз (без учета одинаковых).
      
      //str=(wchar_t)BufUpT[ds]; cout<<Unicode_to_UTF(str)<<"  ";
    
      if ( bl != 0 ) {
           
        // заполнение массива адресами (позициями) пар букв в распознаваемом тексте, встречающихся однократно (кодами пар букв по адресам)
        if ( bl > 0 ) { 
            BufTxt[bl-1]=ds; 
            ///// BufTxtS[bl-1]=x; // заполнение массива адресами пар букв в словарной фразе, встречающихся однократно 
            // вывод на экран восстановленного распознаваемого текста через разреженный массив 
            // Внимание! Адреса пар букв в тексте прописаны в массиве letters_data>0 и начинаются с единици поэтому bl-1
///         cout<<bl-1;    str=(wchar_t)BufUpT[ds]; cout<<Unicode_to_UTF(str)<<"  ";
            //        cout<<text_data[x]<<"   ";
///         if ( x==BufET[s] ){ cout<<endl; s++; }  // перевод каретки Enter текста
//          if ( bl-1==x-oldw ) nc++; // проверка на совпадение восстановленного и исходного распознаваемого текста
        } // ( bl > 0 )
           
        // заполнение массива адресами (позициями) пар букв в распознаваемом тексте, встречающихся более одного раза
        else {                                                 
            blp=-bl; // превращаем bl в положительнай адрес blp, т.к. число bl искуственно отрицательно 
            cnt=clusters_data[blp+1];   // считываем значение счетчика адресов,  +1 положение счетчика свободных адресов
            // считывание первого, второго, третьего и т.д. адресов в цепочке ячеек кластера
            for(m=0; m < cnt; m++) {
                bc=clusters_data[blp+2+m];   // bc аналог x, только извлеченный из массива цепочек адресов clusters_data[x]
                BufTxt[bc]=ds;
                ///// BufTxtS[bc]=x; // заполнение массива адресами пар букв в словарной фразе, встречающихся более одного раза
//              if ( bc==x-oldw ) nc+=cnt;         // проверка на совпадение восстановленного и исходного распознаваемого текста
                // вывод на экран восстановленного распознаваемого текста
               //cout<<bc;    str=(wchar_t)BufUpT[text_data[bc]]; cout<<Unicode_to_UTF(str)<<"  ";  // ds
                ///        cout<<text_data[x]<<"   ";
///             if ( x==BufET[s] ){ cout<<endl; s++; }  // перевод каретки Enter распознаваемого текста 
            } // for(m=0;
            // устанавливаем счетчик адресов в цепочке (вторая цифра в заголовке кластера) в ноль 
            // для исключения повторных обращений к данному кластеру.
            clusters_data[blp+1]=0;
            /**/

        } // else {
          
      } // if ( bl != 0 )                    
      
    } // x
///             cout<<endl;

    //cout<<"nc="<<nc<<"    "<<"LPhrase="<<LPhrase<<"   ";
    //if ( nc==LPhrase ) cout<<"ОК"<<endl;
 
/*
    // после выполнения основного цикла по x обязательно восстанавливаем исходное значение счетчика адресов в цепочке  
    // (ячеек кластера) равное количеству адресов в цепочке (вторая цифра в заголовке) clusters_size-1 29c, clusters_size1 27c
    //// использовать отдельный быстрый байтовый clusters_flag (в переспективе битовый) массив, обнулять memset clusters_data перевести на short
    unsigned int clusters_size1=clusters_size-1;
    for(x=0; x < clusters_size1; x++) { if( clusters_data[x] < 0 ) { clusters_data[x+1]=-clusters_data[x]; }  } // x
    // clusters_size-1 32c, clusters_size1 30c
    ///for(x=0; x < clusters_size1; x++) {
    ///    bc=clusters_data[x];
    ///    if( bc < 0 ) { clusters_data[x+1]=-bc; }  
    ///} // x
    // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44
*/
    // восстановления массива clusters_data (счетчиков адресов цепочек) из массива clusters_copy, после обращения к массиву clusters_data
    memcpy(clusters_data, clusters_copy, clusters_size*4); // memcpy(buf2, buf1, SIZE);

    
    
    // обнуление массива ОК
    ///memset(clusters_data,1,(clusters_size+32)*4);
    ////memset(clusters_data,0,(clusters_size+32)*4);
    
    /*
    // вывод на экран восстановленного текста BufTxt начертанием, как текст UTF-16 (short) 
    ///cout<<endl<<"вывод на экран восстановленного текста BufTxt начертанием, как текст UTF-16 (short)"<<endl;    
    ///for(x=0; x < size_BufTxt; x++) { cout<<x;  str=(wchar_t)BufUpT[BufTxt[x]]; cout<<Unicode_to_UTF(str)<<"  "; }  cout<<endl;
    for(x=0; x < size_BufTxt; x++) {
        ds=BufUpT[BufTxt[x]];                     
        if ( ds > 0 ) { str=(wchar_t)ds; cout<<x<<Unicode_to_UTF(str); } else { cout<<"_"; }
    }  
    cout<<endl;
    //cout<<"size_BufTxt="<<size_BufTxt;
    */
    
    
    // Вычисление фраз словаря имеющих непрерывный фрагмент длинной больше constantPhrase совпавший с непрерывным фрагментом текста.
    // На этом этапе явно присутствует информация о точных координатах совпавших букв текста. 29c
    //// перевести на 11111111
    LPhraseHits=0;
    //поскольку подсчитывается количество совпадений пар букв,
    //то для поиска подстроки содержащей нечетное количество букв последнюю букву нужно проверять особо. Потому LPhraseHits будет содержать на одну букву меньше совпадений.
    
    for(x=0;  x < size_BufTxt-1 && LPhraseHits < constantPhrase;  x++) {
        // счетчик длины непрерывного фрагмента фразы словаря совпавшего с непрерывным фрагментом текста, сброс счетчика  LPhraseHits++                  
        if ( BufTxt[x] > 0 ) { LPhraseHits++; }  else { LPhraseHits=0; }
    } // x
    /**/

    /*
    unsigned long long input=1;  input=input<<31;  input=input<<32;
    //unsigned int input=1;
    binaryPrint64(input, 2);  // изменен код binaryPrint64 в php2stl.cpp
    cout<<"    input="<<input<<endl;
    */
                                 // 53c //
    // возвращаем количество совпавших букв фразы с буквами распознаваемого текста по непрерывному фрагменту 
    return LPhraseHits;
    
    
         
/**/ 
}//--------------------------------------------------------------------------------------------------------------------------------------------  



//-------------------------------------------------------------------------------------------------------//

          // TTTTTTTTTTTT // ИСХОДНАЯ РАБОЧАЯ ФУНКЦИЯ


//#include <string.h>  // memcpy(buf2, buf1, SIZE);  std::memcpy
//using namespace std; 


unsigned short GMap::lookupProcess3_T(unsigned int w, unsigned int oldw){
    
    //// функция поиска совпавшего непрерывного фрагмента фразы словаря длинной больше constantPhrase1 с 
    //// непрерывным фрагментом текста. 
    
    unsigned int x,m;           // ,s0,s1 // ,y,p // n,
    int bl,blp,bc,cnt;          // ,bc,bm,counter
    unsigned short ds;          // ,bf    
    unsigned short LPhraseHits; // количество совпавших букв фразы Length Phrase Hits с буквами распознаваемого текста
    /*    
     // необходимы для вывода на экран
     unsigned int s=0, nc=0; 
     wstring str;        
    */ 
    
    
    
    
    /// уточняющий алгоритм N3. ///
    
    //  Описание алгоритма:
    // Алгоритм предназначен для дальнейшего уменьшения объема словаря ( Дает выйгрыш по быстродейсдвию примерно в три раза ).
    // Для этого оставляем для дальнейшей обработки фразы словаря имеющие непрерывный фрагмент совпавший с непрерывным
    // фрагментом распознаваемого текста. По достижении пороговой длины constantPhrase подряд идущих букв текста
    // совпавших с непрерывным фрагментом распознаваемого текста, останавливаем подсчет длины и переходим к следующему
    // уточняющему алгоритму N4, который работает только с фразами словаря прошедшими предыдущий этап N1,N2 и N3.
    // Таких фраз примерно примерно в три раза меньше чем количество фраз словаря поступающих на этот алгоритм.
    // Алгоритм дает выйгрыш по быстродейсдвию примерно в три раза, что дает возможность применить сложный уточняющий алгоритм N4.
    // Информация о точных координатах совпавших букв текста уже присутствует.
    
    
    
    // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44
    //// убрать второе значение счетчика (3), использовать отдельный быстрый байтовый clusters_flag или clusters_copy исп memcpy(buf2, buf1, SIZE);
    w--;
    for(x=oldw; x < w; x++) { // w-1;
        ds=dictionary_data[x];  // компактный код пары букв в распознаваемом тексте 
        bl=letters_data[ds];    // адреса (позиции) пар букв встечающихся в распознаваемом тексте один раз (без учета одинаковых).
        if ( bl != 0 ) { 
            
            // заполнение массива адресами (позициями) пар букв в распознаваемом тексте, встречающихся однократно
            if ( bl > 0 ) { 
                BufTxt[bl-1]=ds;
                // вывод на экран восстановленного распознаваемого текста через разреженный массив 
                // Внимание! Адреса пар букв в тексте прописаны в массиве letters_data>0 и начинаются с единици поэтому bl-1
                ///         cout<<bl-1;    str=(wchar_t)BufUpT[ds]; cout<<Unicode_to_UTF(str)<<"  ";  
                //        cout<<text_data[x]<<"   ";
                ///         if ( x==BufET[s] ){ cout<<endl; s++; }  // перевод каретки Enter текста
                //          if ( bl-1==x-oldw ) nc++; // проверка на совпадение восстановленного и исходного распознаваемого текста
            } // ( bl > 0 )
            
            // заполнение массива адресами (позициями) пар букв в распознаваемом тексте, встречающихся более одного раза
            else {                                                 
                blp=-bl; // превращаем bl в положительнай адрес blp, т.к. число bl искуственно отрицательно 
                cnt=clusters_data[blp+1];   // считываем значение счетчика адресов,  +1 положение счетчика свободных адресов
                // считывание первого, второго, третьего и т.д. адресов в цепочке ячеек кластера
                for(m=0; m < cnt; m++) {
                    bc=clusters_data[blp+2+m];   // bc аналог x, только извлеченный из массива цепочек адресов clusters_data[x]
                    BufTxt[bc]=ds;
                    //              if ( bc==x-oldw ) nc+=cnt;         // проверка на совпадение восстановленного и исходного распознаваемого текста
                    // вывод на экран восстановленного распознаваемого текста
                    ///             cout<<bc;    str=(wchar_t)BufUpT[text_data[bc]]; cout<<Unicode_to_UTF(str)<<"  ";  // ds 
                    ///        cout<<text_data[x]<<"   ";
                    ///             if ( x==BufET[s] ){ cout<<endl; s++; }  // перевод каретки Enter распознаваемого текста 
                } // for(m=0;
                // устанавливаем счетчик адресов в цепочке (вторая цифра в заголовке кластера) в ноль 
                // для исключения повторных обращений к данному кластеру.
                clusters_data[blp+1]=0;
                /**/
                
            } // else {
            
        } // if ( bl != 0 )                    
        
    } // x
    ///             cout<<endl;
    
    //cout<<"nc="<<nc<<"    "<<"LPhrase="<<LPhrase<<"   ";
    //if ( nc==LPhrase ) cout<<"ОК"<<endl;
    
    /*
     // после выполнения основного цикла по x обязательно восстанавливаем исходное значение счетчика адресов в цепочке  
     // (ячеек кластера) равное количеству адресов в цепочке (вторая цифра в заголовке) clusters_size-1 29c, clusters_size1 27c
     //// использовать отдельный быстрый байтовый clusters_flag (в переспективе битовый) массив, обнулять memset clusters_data перевести на short
     unsigned int clusters_size1=clusters_size-1;
     for(x=0; x < clusters_size1; x++) { if( clusters_data[x] < 0 ) { clusters_data[x+1]=-clusters_data[x]; }  } // x
     // clusters_size-1 32c, clusters_size1 30c
     ///for(x=0; x < clusters_size1; x++) {
     ///    bc=clusters_data[x];
     ///    if( bc < 0 ) { clusters_data[x+1]=-bc; }  
     ///} // x
     // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44
     */
    // восстановления массива clusters_data (счетчиков адресов цепочек) из массива clusters_copy, после обращения к массиву clusters_data
    memcpy(clusters_data, clusters_copy, clusters_size*4); // memcpy(buf2, buf1, SIZE);
    
    
    
    // обнуление массива ОК
    ///memset(clusters_data,1,(clusters_size+32)*4);
    ////memset(clusters_data,0,(clusters_size+32)*4);
    
    /*
     // вывод на экран восстановленного текста BufTxt начертанием, как текст UTF-16 (short) 
     ///cout<<endl<<"вывод на экран восстановленного текста BufTxt начертанием, как текст UTF-16 (short)"<<endl;    
     ///for(x=0; x < size_BufTxt; x++) { cout<<x;  str=(wchar_t)BufUpT[BufTxt[x]]; cout<<Unicode_to_UTF(str)<<"  "; }  cout<<endl;
     for(x=0; x < size_BufTxt; x++) {
     ds=BufUpT[BufTxt[x]];                     
     if ( ds > 0 ) { str=(wchar_t)ds; cout<<x<<Unicode_to_UTF(str); } else { cout<<"_"; }
     }  
     cout<<endl;
     //cout<<"size_BufTxt="<<size_BufTxt;
     */
    
    
    // Вычисление фраз словаря имеющих непрерывный фрагмент длинной больше constantPhrase совпавший с непрерывным фрагментом текста.
    // На этом этапе явно присутствует информация о точных координатах совпавших букв текста. 29c
    //// перевести на 11111111
    LPhraseHits=0;
    for(x=0;  x < size_BufTxt && LPhraseHits < constantPhrase;  x++) { 
        // счетчик длины непрерывного фрагмента фразы словаря совпавшего с непрерывным фрагментом текста, сброс счетчика  LPhraseHits++ .                 
        if ( BufTxt[x] > 0 ) { LPhraseHits++; }  else { LPhraseHits=0; }
    } // x
    /**/ 
    // 53c //
    // возвращаем количество совпавших букв фразы с буквами распознаваемого текста по непрерывному фрагменту 
    return LPhraseHits;
    
    
    
    /**/ 
}//-------------------------------------------------------------------------------------------------------------------------------------------- 


