#include "GMap.h"

//#define REMARK
#ifdef REMARK
#define DN(x) cout<<x;
#else
#define DN(x)
#endif

using namespace std;


void GMap::tableLettersOCR(){
    
    // создание структуры для работы с адресами пар букв в распознаваемом тексте  при поиске в неупорядоченном множестве пар
    // выполняется один раз на весь распознаваемый текст не зависимо от размера словаря
    // (*) поскольку пары не перекрываются, общее количество пар соответствуе половине длинны кодируемой строки
#ifdef REMARK
    int bc,cnt;
#endif
    
    DN(endl<<endl<<"******************************************************************************************************************"<<endl)    
    DN(endl<<"Start program *table_Letters*"<<endl)
    

    uint x,s,n,m;
    int bl,blp;
    mSIZE ds,bf;
    wstring str;

    
#ifdef REMARK 
    // проверяем что на входе функции (вывод на экран распознаваемого текста)
    DN(endl<<"получили на вход функции table_Letters распознаваемый текст text_data, массив BufUpT, шрифтом, UTF-16 (short)"<<endl)
    s=0;
    for(x=0; x < text_size1; x++){ //text_size1 размер массива распознаваемого текста без переводов каретки Enter
        //DN(x<<"-");
        str=(wchar_t)BufUpT[text_data[x]]; DN(Unicode_to_UTF(str)<<"  ")
        if ( x==BufET[s] ){ DN(endl) s++; }  // перевод каретки Enter текста
    }
    TIME_START
#endif
    

    
    ///задачи структуры clusters_data и letters_data:
    //Cтруктура предназначена для получения из массива адресов пар букв в распознаваемом тексте (м.б. в словаре) по компактному коду пары букв,
    // с учетом того что конкретная пара букв в распознаваемом тексте может встечаться более одного раза. 
    
    ///устройство структуры.
    // структура для получения адресов пар букв в распознаваемом тексте состоит из двух массивов:
    // - массива адресов (позиций) letters_data пар букв встечающихся в распознаваемом тексте один раз. Адресом массива является компактный код пары букв. 
    // - массива адресов пар букв clusters_data встечающихся более одного раза. Этот массив адресов представляет собой таблицу,
    // состоящую из записей. Каждая запись начинается с заголовка, состоящего из двух int. Первый это отрицательное значение количества пар в записи. Второе значение это счетчик заполненности записи.
    //   Количество записей равно количеству пар букв во всем распознаваемом тексте, встречающихся более одного раза.
    //   В каждой записи находятся адреса одинаковых пар букв в распознаваемом тексте.
    
    ///применение структуры для получения адресов пар букв в распознаваемом тексте:
    // - если пара букв в распознаваемом тексте встречается один раз, то происходит выборка адреса пары букв из массива адресов letters_data
    // и работа со структурой для данного кода пары букв заканчивается.
    // - если пара букв в распознаваемом тексте встречается более одного раза, то в letters_data записано отрицательное значение,
    // соответствующее адресу записи в clusters_data. По этому адресу происходит обращение к сответствующкй ячейке таблицы адресов
    //   в которой записаны все адреса пары букв по которым она встречается в тексте. Происходит выборка всех адресов пары букв и  
    //   работа со структурой для данного кода пары букв заканчивается.    

    /// определение размерности структуры ( параметров массива адресов и таблицы адресов ) для работы с реальными координатами пар букв в распознаваемом тексте:
    
    // создание разреженного массива адресов (позиций) пар букв встечающихся в распознаваемом тексте один раз (без учета одинаковых).
    // позиция в тексте пары букв=letters_data[компактный код пары букв]
    // т.е. адрес массива - компактный код пар букв, содержимое - позиция в распознаваемом тексте пары букв
    ///    int  *letters_data;
    letters_size=(uint)nLetterP; // количество разных пар букв в словаре
    letters_data_vector->reserve(letters_size);   // запрос памяти c обнулением
    letters_data=(int*)letters_data_vector->dataPtr();
    
    // создание вспомогательного разреженного массива BufLpT количества пар букв распознаваемого текста
    // адрес в массиве - компактный код пар букв, содержимое - количество этих пар букв в распознаваемом тексте
    size_BufLpT=nLetterP; // nLetterP количество разных пар букв в словаре // ALPHABET_SIZE
    if ( size_BufLpT > ALPHABET_SIZE ){ size_BufLpT=ALPHABET_SIZE; }
    BufLpT_vector->reserve(size_BufLpT);   // запрос памяти c обнулением
    BufLpT=BufLpT_vector->dataPtr();
  
    // подсчет вспомогательных параметров для создания массива адресов пар букв clusters_data встечающихся более одного раза.
    n=m=s=0;
    for(x=0; x < text_size1; x++) { // text_size1 размер массива распознаваемого текста без переводов каретки Enter.
        ds=text_data[x];
        // заполнение массива адресами (позициями) пар букв в распознаваемом тексте
///        letters_data[ds]=x; // в массиве letters_data на позиции "ds" находится код "x"
        // заполнение массива числами равными количеству пар букв в тексте
        //bf=BufLpT[ds]++;  // BufLpT[ds]++; // bf=BufLpT[ds]+=1;
        bf=BufLpT[ds]+=1;        
        if ( bf > 1 ){
            // подсчет числа пар букв "s", встречающихся во всем тексте более одного раза
            // с учетом того что одна (первая) пара букв каждой разновидности пропущена (bf>1).
            s++;
            // подсчет числа разновидностей пар букв "m", встречающихся во всем тексте более одного раза, т.е.
            // количества кластеров. Каждый кластер содержит адреса одинаковых пар.
            if ( bf==2 ){ m++; }   // приращение счетчика количества разновидностей пар букв
        }   
        ////          DN(ds<<" ";
    } // x
    DN(endl)
    
    // подсчет полного количества пар букв "n", встречающихся во всем тексте более одного раза.
    n=s+m;

    DN("s="<<s<<endl)
    // "n" количество пар букв, встречающихся во всем тексте более одного раза
    DN("количество пар букв, встречающихся во всем тексте более одного раза   n="<<n<<endl)
    // "m" количество разновидностей пар букв "m" (цепочек,кластеров адресов), встречающихся во всем тексте более одного раза 
    DN("количество разновидностей пар букв (цепочек,кластеров адресов), встречающихся во всем тексте более одного раза   m="<<m<<endl)
    
    
    // количество разных пар букв в распознаваемом тексте        
    nLetterPT=text_size1-s;  // nLetterPT=<nLetterP;  // text_size1 размер массива распознаваемого текста без переводов каретки Enter  ////////////////
    DN("количество разных пар букв во всем распознаваемом тексте nLetterPT=text_size1-s="<<nLetterPT<<endl)                                      ////////////////
    
    
    // плотный массив цепочек адресов (позиций) ОДИНАКОВЫХ пар букв в распознаваемом тексте (в тексте легко встечаются одинаковые пары букв)
    // как в хеш, clusters_data массив цепочек (array of clusters)
///    int  *clusters_data
    clusters_size=n+2*m+1; // размер массива clusters_data, с учетом двух служебных ячейек на одну разновидность пар букв "m", unsigned int
    // +1 т.к. нулевая ячейка массива не используется  // n+m+1;
    //clusters_size=2048-32;
    clusters_data_vector->reserve(clusters_size);    // reserve запрос памяти c обнулением
    clusters_data=(int*)clusters_data_vector->dataPtr();
    
    
    //DN(endl<<"размер массива clusters_data    clusters_size="<<clusters_size<<endl)
    
    // копия массива clusters_data, предназначена для его восстановления, а именно счетчиков адресов цепочек, с помощью memcpy
    clusters_copy_vector->reserve(clusters_size);    // запрос памяти c обнулением
    clusters_copy=(int*)clusters_copy_vector->dataPtr();
    
    // Заполнение разреженного массива letters_data адресами (позициями), пар букв встечающихся в распознаваемом тексте один раз. 
    // Адресом массива является компактный код пары букв.
    // Адреса пар букв в плотный массив clusters_data поступают поступают псевлослучайно, поэтому используется свой счетчик адресов (counter) 
    // для каждого кластера.

    n=1;
    for(x=0; x < text_size1 ; x++) { // text_size1 размер массива распознаваемого текста без переводов каретки Enter  // nLetterPT
        ds=text_data[x];      // компактный код пары букв в распознаваемом тексте 
        bf=BufLpT[ds];        // количество разных пар букв во всем распознаваемом тексте
        bl=letters_data[ds];  // адреса (позиции) пар букв встечающихся в распознаваемом тексте один раз (без учета одинаковых).
                              // или ссылки на массив цепочек адресов (позиций) ОДИНАКОВЫХ пар букв в распознаваемом тексте  
                              // (в тексте легко встечаются одинаковые пары букв)
        
        // заполнение массива адресами пар букв в распознаваемом тексте встречающихся однократно
        if ( bf == 1 ) {                                      
            // в массиве letters_data по адресу "ds" (компактный код пары букв) находится адреса в тексте пары букв "x"
            // адреса в массиве letters_data>0  должны начинаться с единицы, поэтому x+1
            ////letters_data[ds]=x+1;
            letters_data[ds]=x+1;   // letters_data [компактный код пары букв] = позиция в тексте пары букв
        } // ( bf == 1 )
        
        // запись ссылок в массив letters_data (ссылки искуственно отрицательные ), разметка массива clusters_data
        if ( bl == 0 && bf > 1 ) {  
            // заполняем массив letters_data ссылками (адресами), по которым находятся цепочки адресов (ячейки кластера) 
            // в плотном массиве clusters_data, ОДИНАКОВЫХ пар букв. Искуственно помечаем эти ссылки знаком минус,
            // что бы указать, что это ссылка на заголовок цепочки, а не позиция в тексте пары букв
            bl=letters_data[ds]=-n;     // в массив letters_data на позицию "ds" помещаем код "-n"   //  -(n+bf);
            // в заголовок каждой цепочки пишем количество адресов в цепочке (длинну цепочки, одна цифра), искуственно помечаем это 
            // количество адресов со знаком минус, в следующею ячейку пишем копию заголовка количества адресов в цепочке 
            // со знаком плюс, это будет счетчик адресов (counter) в цепочке (ячеек кластера)
            // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44                        
            clusters_data[n]=-bf;     ////clusters_data[n]=-bf;    clusters_data[n+1]=bf;
            // вычисляем положение заголовков каждой цепочки в плотном массиве цепочек адресов  clusters_data[x]
            n=n+2+bf;             
        } // ( bl == 0 )
        
        // заполнение кластеров в массиве clusters_data 
        if ( bl < 0 ) {
            /*
            // превращаем bl в положительнай адрес blp, т.к. число bl искуственно отрицательно
            blp=-bl;
            // расстояние от ячейки счетчика свободных адресов до первой свободной ячейки кластера
            m=-clusters_data[blp+1]-clusters_data[blp];  
            // заполняем первый, второй, третий и т.д. адреса в цепочке ячеек кластера
            clusters_data[blp+2+m]=x;
            // уменьшаем значение счетчика свободных адресов в цепочке на единицу (значение счетчика свободных адресов искуственно положительно)
            clusters_data[blp+1]-=1;
             // после полного завершения цикла по "x" все счетчики свободных адресов (вторая цифра в заголовке кластера) устанаввливаются в ноль
             // первая цифра в заголовке кластера всегда количество адресов в цепочке со знаком минус,
             // 0  -3  0  2  56  63  -2  0  8  17  -2  0  9  42  -2  0  10  43  -2  0  23  57  -2  0  24  71  -2  0  26  47  -2  0  38  44  
            */             
            // превращаем bl в положительнай адрес blp, т.к. число bl искуственно отрицательно,  +1 положение счетчика свободных адресов
            blp=-bl+1;  
            // заполняем первый, второй, третий и т.д. адреса в цепочке ячеек кластера
            ////clusters_data[blp+1+clusters_data[blp]]=x;
            clusters_data[blp+1+clusters_data[blp]]=x;   //заполнение записи в кластере адресами пары букв
            // увеличиваем счетчик свободных адресов в цепочке на единицу 
            clusters_data[blp]+=1;
            /**/ 
        } // if ( bl < 0 )
        
    } // x
    DN(endl)
    /**/
    
    
    // после полного завершения цикла по "x" все счетчики свободных адресов (вторая цифра в заголовке кластера "3") устанаввливаются
    // в значение равное количеству адресов в цепочке
    // первая цифра в заголовке кластера "-3" всегда количество адресов в цепочке со знаком минус. Кластер "-3  3  2  56  63" 
    // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44 

    //for(x=0; x < clusters_size-1; x++) { if( clusters_data[x] < 0 ) { clusters_data[x+1]=-clusters_data[x]; }  } // x
    // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44 
#ifdef REMARK
 
    // TMP 
    // просмотр плотного массива цепочек адресов  clusters_data[x]
    DN(endl<<"clusters_data[x]"<<endl)
    DN("11 просмотр плотного массива цепочек адресов  clusters_data[x]"<<endl)    
    for(x=0; x < clusters_size/graph; x++) { // letters_size=nLetterPT количество разных пар букв в распознаваемом тексте
        bc=clusters_data[x];
        ///DN(x<<"_"<<bc<<"  ";
        DN(bc<<"  ")
    } // x
    DN(endl<<endl)
#endif
    
    // копия массива clusters_copy, предназначена для восстановления  массива clusters_data, после любого обращения к нему
    memcpy(clusters_copy, clusters_data, clusters_size*4); // memcpy(buf2, buf1, SIZE);
    // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44
 
#ifdef REMARK     
    // TMP
    // просмотр плотного массива цепочек адресов  clusters_copy[x]
    DN(endl<<"clusters_copy[x]"<<endl)
    DN("1234 просмотр плотного массива цепочек адресов  clusters_copy[x]"<<endl)    
    for(x=0; x < clusters_size/graph; x++) {
        bc=clusters_copy[x];
        ///DN(x<<"_"<<bc<<"  ";
        DN(bc<<"  ")
    } // x
    DN(endl<<endl)
    
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    
    
     DN("размер распознаваемого текста в буквах без переводов каретки, пробелов или точек    text_size1="<<text_size1<<endl)
     DN("количество разных пар букв во всем распознаваемом тексте     nLetterPT="<<nLetterPT<<endl)
     DN("суммарное количество одинаковых пар букв во всем тексте     clusters_size="<<clusters_size<<endl)
///     DN("количество разновидностей цепочек одинаковых пар букв во всем тексте    size_BufEL="<<size_BufEL<<endl)
     DN("количество различных пар букв в словаре     nLetterP="<<nLetterP<<endl)
     /**/
    

    // просмотр разреженного массива BufLpT[x]
    // выведены только не нулевае значения!
    
    DN(endl<<"BufLpT[x]"<<endl)    
    DN("перебор всех значений [x] массива  BufLpT[x],  выведены только не нулевае значения отклика массива !"<<endl)
    DN("число (m) разных пар букв,  компактный код пары букв [x] _ первая буквы пары выведена шрифтом (ག)"<<endl)
    
    for(x=0; x < size_BufLpT; x++) { // size_BufLpT=nLetterP; количество разных пар букв в словаре
        ds=BufLpT[x];
        if (ds!=0) {
            ///DN(ds<<"_"<<x<<"_";   str=(wchar_t)BufUpT[x]; DN(Unicode_to_UTF(str)<<"    ";
            ///DN(ds<<"_"<<x<<"  ";
            DN(ds<<" ")
            //DN(letters_data[x]<<" ";   str=(wchar_t)BufUpT[x]; DN(Unicode_to_UTF(str)<<"   ";            
        } // if
        //DN(letters_data[x]<<" ";
    } // x
    DN(endl)
    /**/    
/////////////    nLetterPT=m; // количество разных пар букв в распознаваемом тексте // nLetterPT=<nLetterP;
    
    
    // просмотр разреженного массива BufLpT[x] через распознаваемый текст
    DN(endl<<"BufLpT[x]"<<endl)
    DN("просмотр разреженного массива  BufLpT[x]  через распознаваемый текст (первая буквы пары выведена шрифтом ག)"<<endl)
    DN("число (m) разных пар букв,  первая буквы пары выведена шрифтом (ག)"<<endl)
    s=0;
    for(x=0; x < text_size1/graph; x++){ //text_size1 размер массива распознаваемого текста без переводов каретки Enter
        ds=text_data[x];
        DN(BufLpT[ds]);    str=(wchar_t)BufUpT[ds]; DN(Unicode_to_UTF(str)<<"  ")
        //        DN(text_data[x]<<"   ";
        if ( x==BufET[s] ){ DN(endl) s++; }  // перевод каретки Enter текста
    }
    DN(endl)    
   
     

    // просмотр разреженного массива letters_data[x] через распознаваемый текст     
    // позиция в тексте пары букв=letters_data[компактный код пары букв]
    
    DN(endl<<"letters_data[x]"<<endl)
    DN("просмотр разреженного массива  letters_data[x]  через распознаваемый текст (первая буквы пары выведена шрифтом ག)"<<endl)
    DN("позиция в тексте пары букв,  первая буквы пары выведена шрифтом (ག)"<<endl)
    // обращаемся к массиву letters_data[x]  по  "x" - компактному коду пары букв, получаем - позицию в тексте этой пары букв (адрес в тексте)
    s=0;
    for(x=0; x < text_size1/graph; x++){ //text_size1 размер массива распознаваемого текста без переводов каретки Enter
        ds=text_data[x];
        bl=letters_data[ds];
        // Внимание! Адреса пар букв в тексте прописаны в массиве letters_data>0 и начинаются с единици поэтому bl-1
        if ( bl > 0 ){ DN(bl-1); } else { DN(bl); }    str=(wchar_t)BufUpT[ds]; DN(Unicode_to_UTF(str)<<"  ")
        ///DN(letters_data[ds];    str=(wchar_t)BufUpT[ds]; DN(Unicode_to_UTF(str)<<"  ";  
        //        DN(text_data[x]<<"   ";
        if ( x==BufET[s] ){ DN(endl) s++; }  // перевод каретки Enter текста
    }
    DN(endl)      
    
    
    
    // просмотр плотного массива цепочек адресов  clusters_data[x]
    DN(endl<<"clusters_data[x]"<<endl)
    DN("просмотр плотного массива цепочек адресов  clusters_data[x]"<<endl)    
    for(x=0; x < clusters_size/graph; x++) { // letters_size=nLetterPT количество разных пар букв в распознаваемом тексте
        bc=clusters_data[x];
        ///DN(x<<"_"<<bc<<"  ";
        DN(bc<<"  ")
    } // x
    DN(endl<<endl)
    
    

    // просмотр плотного массива цепочек адресов clusters_data[x] через распознаваемый текст
    // восстановление распознаваемого текста через массив цепочек адресов
    ///DN(endl<<"clusters_data[x]"<<endl)
    // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44
    DN("восстановление распознаваемого текста через массив цепочек адресов  clusters_data[x]"<<endl)
    s=0;  n=0;
    for(x=0; x < text_size1/graph; x++) { // letters_size=nLetterPT количество разных пар букв в распознаваемом тексте        
      ds=text_data[x];      // компактный код пары букв в распознаваемом тексте 
      bl=letters_data[ds]; 
      if ( bl != 0 ) {
        // заполнение массива адресами (позициями) пар букв в распознаваемом тексте встречающихся однократно
        if ( bl > 0 ) { 
            // Внимание! Адреса пар букв в тексте прописаны в массиве letters_data>0 и начинаются с единици поэтому bl-1
            DN(bl-1);    str=(wchar_t)BufUpT[ds]; DN(Unicode_to_UTF(str)<<"  ")
            //        DN(text_data[x]<<"   ";
            if ( x==BufET[s] ){ DN(endl) s++; }  // перевод каретки Enter текста
            if ( bl-1==x ) n++; // проверка на совпадение восстановленного и исходного распознаваемого текста
        } // ( bl > 0 )
        else {                         
            blp=-bl;  // превращаем bl в положительнай адрес blp, т.к. число bl искуственно отрицательно
            cnt=clusters_data[blp+1];   // считываем значение счетчика адресов,  +1 положение счетчика свободных адресов
            // считывание первого, второго, третьего и т.д. адресов в цепочке ячеек кластера
            for(m=0; m < cnt; m++) {
              bc=clusters_data[blp+2+m];   // bc аналог x, только извлеченный из массива цепочек адресов clusters_data[x]
               if ( bc==x ) n+=cnt;        // проверка на совпадение восстановленного и исходного распознаваемого текста
               // вывод на экран восстановленного распознаваемого текста
               DN(bc);    str=(wchar_t)BufUpT[text_data[bc]]; DN(Unicode_to_UTF(str)<<"  ")  // ds
               ///        DN(text_data[x]<<"   ";
               if ( x==BufET[s] ){ DN(endl) s++; }  // перевод каретки Enter распознаваемого текста 
            } // for(m=0;
            // устанавливаем счетчик адресов в цепочке (вторая цифра в заголовке кластера) в ноль 
            // для исключения повторных обращений к данному кластеру.
            clusters_data[blp+1]=0;
            
        } // else
        
      } // if ( bl != 0 )
        
    } // x
    DN("n="<<n<<"    "<<"text_size1="<<text_size1<<"   ")
    if ( n==text_size1 ) DN("ОК"<<endl)

   
        
    // после полного завершения цикла по "x" все счетчики свободных адресов устанавливаются в ноль,
    // первая цифра в заголовке кластера это всегда количество адресов в цепочке со знаком минус
    // 0  -3  0  2  56  63  -2  0  8  17  -2  0  9  42  -2  0  10  43  -2  0  23  57  -2  0  24  71  -2  0  26  47  -2  0  38  44

    
    // после просмотра обязательно восстанавливаем исходное значение счетчика адресов в цепочке (ячеек кластера) 
    // равное количеству адресов в цепочке (вторая цифра в заголовке)    
    for(x=0; x < clusters_size-1; x++) { if( clusters_data[x] < 0 ) { clusters_data[x+1]=-clusters_data[x]; }  } // x
    // 0  -3  3  2  56  63  -2  2  8  17  -2  2  9  42  -2  2  10  43  -2  2  23  57  -2  2  24  71  -2  2  26  47  -2  2  38  44

    DN("после просмотра все счетчики свободных адресов возвращаются в значение равное количеству адресов в цепочке"<<endl)
    //DN(endl<<endl)
    
    TIME_PRINT
  
    
#endif 
  

    /// exit(0);  ////////
    

    
}//--------------------------------------------------------------------------------------------------------------------------------------------  

