//  OCRLib  2015 www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  Will Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .


#include "GBitmap.h"
namespace ocr{
    

void GBitmap::test(){
    cout<<"Функция   test()="<<1<<endl;
    
    /*
     // вычисление w2 как ближайшей степени двойки w, причем w2 >= w,
     // напрямер если w=1035 то w2=2048
     //	unsigned int w2=1;
     //  while( w2<w_g ){ w2<<=1; }  // <<1 умножение на 2
     
     unsigned char rg=5;
     short rgm,w2;
     short dl_1, dl_2;
     
     rgm=rg;
     w2=1;  dl_1=dl_2=0;
     while( w2<rgm ){ w2<<=1; dl_1++;}  // <<1 умножение на 2
     w2>>=1; //dl_1--;
     cout<<"(short)rgm="<<(short)rgm<<"   (short)w2="<<(short)w2<<"   dl_1="<<dl_1<<endl;
     rgm=rgm/w2; // rgm=rgm%w2;
     
     w2=1;
     while( w2<rgm ){ w2<<=1; dl_2++;}  // <<1 умножение на 2
     cout<<"(short)rgm="<<(short)rgm<<"   (short)w2="<<(short)w2<<"   dl_2="<<dl_2<<endl;
     */
    
// 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
if (0) { cout<<endl<<"вывод отладочной информации 1"<<endl;
    
    //// ЦИКЛИЧЕСКИЙ СДВИГ (8 разрядный регистр замкнут в кольцо)////
    unsigned char rgc=1; //165  0xA5
    unsigned char rgm;
    rgm = (rgc >> 1) | (rgc << 7); // циклический сдвиг вправо на 1 разряд (1 pix)
    cout<<"(short)rgc="<<(short)rgc<<"   (short)rgm="<<(short)rgm<<endl;
    
    rgc = rgm;
    rgm = (rgc << 1) | (rgc >> 7); // циклический сдвиг влево на 1 разряд (умн)
    cout<<"(short)rgc="<<(short)rgc<<"   (short)rgm="<<(short)rgm<<endl;
    
    // циклическое растискивание на 1 разряд влево и 1 разряд вправо (8 разрядный регистр замкнут в кольцо)
    rgc=128;
    // rgc=0;
    // rgc=rgc | rgm;
    // rgc=rgc | rgm;
    
    rgc = rgc | ((rgc << 1) | (rgc >> 7)); // циклическое растискивание на 1 разряд влево
    rgc = rgc | ((rgc >> 1) | (rgc << 7)); // циклическое растискивание на 1 разряд вправо
    cout<<"(short)rgc="<<(short)rgc<<endl;
    
    // rgm=rg0 & 0xA5 & (~rgc);
    
    
    
    /**/
    //cout<<"d9="<<(short)d9<<" d2="<<(short)d2<<" d3="<<(short)d3<<" d8="<<(short)d8<<" d4="<<(short)d4<<" d7="<<(short)d7<<" d6="<<(short)d6<<" d5="<<(short)d5<<endl;
    
    /*
     int endPoint=w*10;
     rg_tab2=1;
     index=0;
     for ( index=0; rg_tab2!=0 & index<endPoint; index++ ) { if ( index==128 ) rg_tab2=0; } //| // 129
     //while( rg_tab2!=0 & index<endPoint ){ index++;  if ( index==128 ) rg_tab2=0; }
     cout<<"index="<<index<<endl;
     */
    
} // if (GrafT)
    
    
//--------------
    
    
// 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
/*
if (0) { cout<<endl<<"вывод отладочной информации 2"<<endl;
    
    short w=1024;   //ncolumns;  // ширина массива  IMAGE WIDTH   // int w,h;
    int index;
    //int n=0;        // переменная адресов
    unsigned char rg0;  // байтовый регистр для хранения отдельных 8 бит маски
    unsigned char d2,d3,d4,d5,d6,d7,d8,d9; // d1,  // переменные маски
    short dm9=-w-1,  dm2=-w,  dm3=1-w, dm8=-1, dm4=1, dm7=w-1, dm6=w, dm5=w+1;
    //        -w-1,      -w,      1-w,     -1,     1,     w-1,     w,     w+1
    unsigned char a01, a10, b; // переменные условий
    
    short dl_1=0, dl_2=0;
    short dl_3=0, dl_4=0;
    int rg_tab2=1;
    long rg_tab3=1;
    
    unsigned char table_1[256];  // предпросчитаная таблица особых точек //
    unsigned int table_2[256];   // предпросчитаная таблица адресов смещения точек вдоль фокальной линии //
    //unsigned int *pt=table_2;    //         pt++;
    
    if ( w>32766 ) w=32766;      // 32767
    short table_dl[8]={ -w-1, -w, 1-w, -1, 1, w-1, w, w+1 };   // таблица координат смещения маски //
    //                   d9;  d2;  d3; d8; d4; d7; d6; d5;     // порядок заполнения регистра
    //                   0    1    0    1  1   0    1   0      // ортогональная маска регистра
    //                   1    0    1    0  0   1    0   1      // диагональная маска регистра
    
    rg0=72+32; // 32+16+4
    
    //ортогональная маска  //диагональная маска  //адреса смещения     // пример
    // 0x5A             // 0xA5          // table_dl[n]        // rg0
    
    // d9   d2   d3            0    1   0           1    0   1       -w-1  -w   1-w        1   2   4
    
    // d8   d1   d4            1        1           0        0        -1         1         8       16
    
    // d7   d6   d5            0    1   0           1    0   1        w-1   w   w+1        32  64 128
    
    // разборка байтового регистра на отдельные 8 бит //
    d9=rg0 & 1;    d2=rg0>>1 & 1; d3=rg0>>2 & 1; d8=rg0>>3 & 1;
    d4=rg0>>4 & 1; d7=rg0>>5 & 1; d6=rg0>>6 & 1; d5=rg0>>7 & 1;
    
    // представление байтового регистра отдельными 8 битами //
    cout<<(short)d9<<"   "<<(short)d2<<"   "<<(short)d3<<"   "<<(short)d8<<"   "<<(short)d4<<"   "<<(short)d7<<"   "<<(short)d6<<"   "<<(short)d5<<endl;
    cout<<"d9"<<" d2"<<" d3"<<" d8"<<" d4"<<" d7"<<" d6"<<" d5"<<endl;
    
    // шаблон матрици
    cout<<"d9"<<"   d2"<<"   d3"<<endl<<"d8"<<"          d4"<<endl<<"d7"<<"   d6"<<"   d5"<<endl;
    // данные матрици
    cout<<(short)d9<<"     "<<(short)d2<<"     "<<(short)d3<<endl<<(short)d8<<"            "<<(short)d4<<endl<<(short)d7<<"     "<<(short)d6<<"     "<<(short)d5<<endl;
    
    // Сначала ищем самые "ближайшие" входящие и выходящие точки (они м.б. только слева или справа, снизу или сверху).
    // Координаты входящих и выходящих точек это и есть одна из координат смещения маски dl1 или dl2.
    if (d2==1) { if (dl_1==0) dl_1=dm2; }
    if (d4==1) { if (dl_1==0) dl_1=dm4; else if (dl_2==0) dl_2=dm4; }
    if (d6==1) { if (dl_1==0) dl_1=dm6; else if (dl_2==0) dl_2=dm6; }
    if (d8==1) { if (dl_1==0) dl_1=dm8; else if (dl_2==0) dl_2=dm8; }
    cout<<(short)rg0<<"   dl_1="<<dl_1<<"   dl_2="<<dl_2<<endl;
    
    // За тем ищем диаганальные "более дальние" входящие и выходящие точки (они м.б. только по диаганали)
    // и проверяем что бы были не заняты соседние точки
    if (d9==1 && d8==0 && d2==0) { if (dl_1==0) dl_1=dm9; else if (dl_2==0 ) dl_2=dm9; }
    if (d3==1 && d2==0 && d4==0) { if (dl_1==0) dl_1=dm3; else if (dl_2==0 ) dl_2=dm3; }
    if (d5==1 && d4==0 && d6==0) { if (dl_1==0) dl_1=dm5; else if (dl_2==0 ) dl_2=dm5; }
    if (d7==1 && d6==0 && d8==0) { if (dl_1==0) dl_1=dm7; else if (dl_2==0 ) dl_2=dm7; }
    cout<<(short)rg0<<"   dl_1="<<dl_1<<"   dl_2="<<dl_2<<endl;
    /**/
    
    //if (1) { short g9=0, g2=0, g3=0, g8=0, g4=0, g7=0, g6=0, g5=0; }
    short g9=0, g2=0, g3=0, g8=0, g4=0, g7=0, g6=0, g5=0;
    
    if (1) {  // (GrafT)
        //dm9=-w-1,  dm2=-w,  dm3=1-w, dm8=-1, dm4=1, dm7=w-1, dm6=w, dm5=w+1;
        g9=0, g2=0, g3=0, g8=0, g4=0, g7=0, g6=0, g5=0;
        if (dl_1==dm9 || dl_2==dm9) g9=1;  if (dl_1==dm2 || dl_2==dm2) g2=1;  if (dl_1==dm3 || dl_2==dm3) g3=1;
        if (dl_1==dm8 || dl_2==dm8) g8=1;  if (dl_1==dm4 || dl_2==dm4) g4=1;  if (dl_1==dm7 || dl_2==dm7) g7=1;
        if (dl_1==dm6 || dl_2==dm6) g6=1;  if (dl_1==dm5 || dl_2==dm5) g5=1;
        cout<<g9<<"     "<<g2<<"     "<<g3<<endl<<g8<<"            "<<g4<<endl<<g7<<"     "<<g6<<"     "<<g5<<endl;
    }
    
    
    
    /**/
    
    
    
    /*
     rgm=rg0 & 0x5A; // 01011010 применение ортогональной маски регистра |
     dl_1=dl_2=0;
     for (n=0; n < 8; n++){ // цикл перебора бит байтового регистра и сопоставления им адресов хранящихся в массиве table_dl[n]
     // Заполнение dl_2,  м.б. выполнено только на следующем такте, после заполнения dl_1 и только один раз.
     if ( (rgm & 1)==1 && dl_1!=0 && dl_2==0 ) { dl_2=table_dl[n]; rgc=rgc | rgm; }
     // Заполнение dl_1,  м.б. выполнено только один раз.
     if ( (rgm & 1)==1 && dl_1==0 ) { dl_1=table_dl[n]; rgc=rgc | rgm; }   // массив table_dl[n] всегда не равен нулю
     rgm>>=1; // >>1 деление на 2
     } // for
     cout<<"(short)rg0="<<(short)rg0<<"   dl_1="<<dl_1<<"   dl_2="<<dl_2<<"   (short)rgc="<<(short)rgc<<endl;
     
     // маскирование соседних бит сработавших
     // циклическое растискивание на 1 разряд влево и 1 разряд вправо (8 разрядный регистр замкнут в кольцо)
     //rgc=128;
     rgc = rgc | ((rgc << 1) | (rgc >> 7)); // циклическое растискивание на 1 разряд влево
     rgc = rgc | ((rgc >> 1) | (rgc << 7)); // циклическое растискивание на 1 разряд вправо
     cout<<"(short)rgc="<<(short)rgc<<endl;
     
     
     // За тем ищем диаганальные "более дальние" входящие и выходящие точки (они м.б. только по диаганали)
     //rgm=rg0 & 0xA5;   // 10100101 применение диагональной маска регистра (0xA5=~0x5A;)
     rgm=rg0 & 0xA5 & (~rgc); // 10100101 применение диагональной маска регистра (0xA5=~0x5A;)
     for (n=0; n < 8; n++){
     if ( (rgm & 1)==1 && dl_1!=0 && dl_2==0 ) dl_2=table_dl[n];
     if ( (rgm & 1)==1 && dl_1==0 ) dl_1=table_dl[n];
     rgm>>=1; // >>1 деление на 2
     } // for
     cout<<"(short)rg0="<<(short)rg0<<"   dl_1="<<dl_1<<"   dl_2="<<dl_2<<endl;
     */
    
    // Запаковка в int (table_2) двух знаковых short с двумя вариантами смещения маски на dl1 или dl2
    *(short*)&rg_tab2=dl_1;
    *((short*)&rg_tab2+1)=dl_2;
    ///table_2[index]=rg_tab2;
    
    // Роспаковка координат из table_2 (int) в два знаковых short с двумя вариантами смещения маски на dl1 или dl2
    dl_1=*(short*) & rg_tab2;
    dl_2=*((short*) & rg_tab2+1);
    cout<<"rg_tab2="<<rg_tab2<<"   распакованный dl_1="<<dl_1<<"   распакованный dl_2="<<dl_2<<endl;
    
    
    
    
    
    // Создание предпросчитанной адресов смещения точек вдоль фокальной линии table_2 //
    // Создание предпросчитанной таблицы table_1
    int mn=0;
	// НОВЫЙ цикл перебора всех возможных значений матрицы (3*3-1)
    for (index=0; index < 256; index++){
        rg0=index;
        table_1[index]=table_2[index]=0; // заполнение нулями таблиц
        
        // разборка байтового регистра на отдельные 8 бит //
        d9=rg0 & 1;    d2=rg0>>1 & 1; d3=rg0>>2 & 1; d8=rg0>>3 & 1;
        d4=rg0>>4 & 1; d7=rg0>>5 & 1; d6=rg0>>6 & 1; d5=rg0>>7 & 1;
        // Подготовка данных для алгоритма //
        a01=0; // "a01" это число паттернов "01" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)
        if(d3-d2>0)a01++; if(d4-d3>0)a01++; if(d5-d4>0)a01++; if(d6-d5>0)a01++;
        if(d7-d6>0)a01++; if(d8-d7>0)a01++; if(d9-d8>0)a01++; if(d2-d9>0)a01++;
        a10=0; // "a10" это число паттернов "10" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)
        if(d3-d2<0)a10++; if(d4-d3<0)a10++; if(d5-d4<0)a10++; if(d6-d5<0)a10++;
        if(d7-d6<0)a10++; if(d8-d7<0)a10++; if(d9-d8<0)a10++; if(d2-d9<0)a10++;
        // "b" это число ненулевых соседей центральной точки d1, т.е, она имеет по крайней мере, 3 ненулевых соседа, но не более 5.
        b=d2+d3+d4+d5+d6+d7+d8+d9;
        
	    // Заполнение таблицы //
        
        // АЛГОРИТМ подсчета особых точек. //
	    // Точно такой же как в GBitmapFocalPoint.cpp . При изменениях синхронизировать.
        // Ставит точки только в "Т" стыках (базовый вариант). //
        if ( b<6 && b>2 && a01==3 && a10==3 ) table_1[index]+=1;  // проверяется a01=3 && a10=3  // 56 (int mn=0; {mn++;})
        
        // Ставит точки не только в "Т" стыках, но и в "Х" стыках. //
        //if ( b<7 && b>2 && a01>2 && a01<5 && a10>2 && a10<5 ) table_1[index]+=2; // проверяются a01=3=4 && a10=3=4
        // Ставит точки только в "Х" стыках. //
        if ( b<7 && b>2 && a01>2 && a01<5 && a10>2 && a10<5 && table_1[index]!=1) table_1[index]+=2; // 2
        //cout<<" "<<(unsigned short)table_1[index];
        
        // Ставит точки в случае "Х" при наличии квадрата 2x2 pix с выходящими из всех углов ломаными линиями. //
        // Основное правило ("Т" или "Х" стыков) эту ситуацию не отрабатывает.
        if ( d8==1 && d9 && d2==1 && b==5 && a01==2 && a10==2 ) table_1[index]+=2;   // d8==d9==d2==1 описание квадрата 2x2 pix, // 6
        // центральная точка d1==1 проверяется в основном цикле ниже
        
        // Ставит точки на концах линий "L_End" и не забыть поставить в главном цикле if ( rg0>0 && table_1[rg0]==0 )
        if ( b<3 && b>0 && a01==1 && a10==1 ) table_1[index]+=4;  // 16
        
        // Ставит точки когда фокальная линия вырожденна в один пиксел "P_Point"
        if ( b==0 ) table_1[index]+=8; // также как и во всех предидущих случаях запаковываем этот бит в char // 1
        
        // (GrafT) // вывод на экран стыков типа "Т", "Х" и "L_End" по шаблону матрици (параметр соответственно ==1, ==2, ==4)
        if (0 && table_1[index]==1) {
            cout<<"index="<<index<<endl;
            cout<<(short)d9<<"     "<<(short)d2<<"     "<<(short)d3<<endl<<(short)d8<<"     "<<1<<"     "<<(short)d4<<endl<<(short)d7<<"     "<<(short)d6<<"     "<<(short)d5<<endl<<endl;
        }
        
        
        // АЛГОРИТМ вычисления адресов промежуточных точек. //
        // Вычисление координат входящей и выходящей точки. Одна из них станет координатой смещения маски.
        //          b>0
        if ( b<5 && b>1 && a01==2 && a10==2 && table_1[index]==0 ) { // и не особая точка // Условие заполнения таблици
            
            // Сначала ищем самые "ближайшие" входящие и выходящие точки (они м.б. только слева или справа, снизу или сверху).
            // Координаты входящих и выходящих точек это и есть одна из координат смещения маски dl1 или dl2.
            dl_1=0, dl_2=0;
            if (d2==1) { if (dl_1==0) dl_1=dm2; }
            if (d4==1) { if (dl_1==0) dl_1=dm4; else if (dl_2==0) dl_2=dm4; }
            if (d6==1) { if (dl_1==0) dl_1=dm6; else if (dl_2==0) dl_2=dm6; }
            if (d8==1) { if (dl_1==0) dl_1=dm8; else if (dl_2==0) dl_2=dm8; }
            //cout<<(short)rg0<<"   dl_1="<<dl_1<<"   dl_2="<<dl_2<<endl;
            
            // За тем ищем диаганальные "более дальние" входящие и выходящие точки (они м.б. только по диаганали)
            // и проверяем что бы были не заняты соседние точки
            if (d9==1 && d8==0 && d2==0) { if (dl_1==0) dl_1=dm9; else if (dl_2==0 ) dl_2=dm9; }
            if (d3==1 && d2==0 && d4==0) { if (dl_1==0) dl_1=dm3; else if (dl_2==0 ) dl_2=dm3; }
            if (d5==1 && d4==0 && d6==0) { if (dl_1==0) dl_1=dm5; else if (dl_2==0 ) dl_2=dm5; }
            if (d7==1 && d6==0 && d8==0) { if (dl_1==0) dl_1=dm7; else if (dl_2==0 ) dl_2=dm7; }
            //cout<<(short)rg0<<"   dl_1="<<dl_1<<"   dl_2="<<dl_2<<endl;
            /**/
            
            // (GrafT)
            if (0) {
                cout<<(short)rg0<<"   dl_1="<<dl_1<<"   dl_2="<<dl_2<<endl;
                // пересчет координат из линейных в декартовы
                ///int dl_1_x, dl_1_y, dl_2_x, dl_2_y;
                ///dl_1_y=dl_1/w;  dl_1_x=dl_1-w*dl_1_y;
                ///dl_2_y=dl_2/w;  dl_2_x=dl_2-w*dl_2_y;
                ///cout<<"декартовы координаты относительно центра матрици"<<endl;
                ///cout<<"   dl_1_x="<<dl_1_x<<"   dl_1_y="<<dl_1_y<<"        dl_2_x="<<dl_2_x<<"   dl_2_y="<<dl_2_y<<endl;
                
                //dm9=-w-1,  dm2=-w,  dm3=1-w, dm8=-1, dm4=1, dm7=w-1, dm6=w, dm5=w+1;
                g9=0, g2=0, g3=0, g8=0, g4=0, g7=0, g6=0, g5=0;
                if (dl_1==dm9 || dl_2==dm9) g9=1;  if (dl_1==dm2 || dl_2==dm2) g2=1;  if (dl_1==dm3 || dl_2==dm3) g3=1;
                if (dl_1==dm8 || dl_2==dm8) g8=1;  if (dl_1==dm4 || dl_2==dm4) g4=1;  if (dl_1==dm7 || dl_2==dm7) g7=1;
                if (dl_1==dm6 || dl_2==dm6) g6=1;  if (dl_1==dm5 || dl_2==dm5) g5=1;
                cout<<g9<<"     "<<g2<<"     "<<g3<<endl<<g8<<"     "<<1<<"     "<<g4<<endl<<g7<<"     "<<g6<<"     "<<g5<<endl<<endl;
            } // (GrafT)
            
            
            // Запаковка в int (table_2) двух знаковых short с двумя вариантами смещения маски на dl1 или dl2
            *(short*)&rg_tab2=dl_1;
            *((short*)&rg_tab2+1)=dl_2;
            table_2[index]=rg_tab2;
            ///cout<<"table_2[index]="<<table_2[index]<<"   распакованный dl_1="<<dl_1<<"   распакованный dl_2="<<dl_2<<endl;
            
            // тест
            // Роспаковка координат из table_2 (int) в два знаковых short с двумя вариантами смещения маски на dl1 или dl2
            dl_1=*(short*)&table_2[index];
            dl_2=*((short*)&table_2[index]+1);
            ///cout<<"table_2[index]="<<table_2[index]<<"   распакованный dl_1="<<dl_1<<"   распакованный dl_2="<<dl_2<<endl;
            /**/
        } // if
        
        
        
        
        
    } // for
    cout<<"mn="<<mn<<endl;
    /**/
    
    ///____________________________________
    
 
    
    int nl,np;
    // unsigned int sizeAdr=0; // количество особых точек по всему графическому тексту.
    unsigned long  table_3[256];   // предпросчитаная таблица адресов смещения точек начала фокальных линий (упаковано по 4 short) //
    //table_1[index]=table_2[index]=table_3[index]=0; // заполнение нулями таблиц
    //long rg_tab3=1;
    //short dl_nl;
    //short dl_3=0, dl_4=0;
    
    // АЛГОРИТМ вычисления координат начала фокальных линий, выходящих из особых точек. //
    // получение координат начала фокальных линий, выходящих из особых точек (их м.б. 3,4,1 максимум 4).
    
    // Сначала ищем диаганальные "более дальние" выходящие точки (они м.б. только по диаганали).
    // Координаты выходящих точек это и есть стартовые координаты dl1,dl2,dl3,dl4 начала движения маски по фокальной линии.
    dl_1=dl_2=dl_3=dl_4=0;
    if (d9==1) { dl_1=dm9; }
    if (d3==1) { if (dl_1==0) dl_1=dm3; if (dl_2==0 ) dl_2=dm3; }
    if (d5==1) { if (dl_1==0) dl_1=dm5; if (dl_2==0 ) dl_2=dm5; if (dl_3==0 ) dl_3=dm5; }
    if (d7==1) { if (dl_1==0) dl_1=dm7; if (dl_2==0 ) dl_2=dm7; if (dl_3==0 ) dl_3=dm7; if (dl_4==0 ) dl_4=dm7; }
    cout<<(short)rg0<<"   dl_1="<<dl_1<<"   dl_2="<<dl_2<<"   dl_3="<<dl_3<<"   dl_4="<<dl_4<<endl;
    
    // За тем ищем самые "ближайшие" выходящие точки (они м.б. только слева или справа, снизу или сверху).
    // Выходящие линии находятся на расстоянии друг от друга больше чем на  90 градусов, поэтому не проверяем соседние точки.
    if (d2==1) { if (dl_1==0) dl_1=dm2; if (dl_2==0 ) dl_2=dm2; if (dl_3==0 ) dl_3=dm2; if (dl_4==0 ) dl_4=dm2; }
    if (d4==1) { if (dl_1==0) dl_1=dm4; if (dl_2==0 ) dl_2=dm4; if (dl_3==0 ) dl_3=dm4; if (dl_4==0 ) dl_4=dm4; }
    if (d6==1) { if (dl_1==0) dl_1=dm6; if (dl_2==0 ) dl_2=dm6; if (dl_3==0 ) dl_3=dm6; if (dl_4==0 ) dl_4=dm6; }
    if (d8==1) { if (dl_1==0) dl_1=dm8; if (dl_2==0 ) dl_2=dm8; if (dl_3==0 ) dl_3=dm8; if (dl_4==0 ) dl_4=dm8; }
    cout<<"dl_1="<<dl_1<<"   dl_2="<<dl_2<<"   dl_3="<<dl_3<<"   dl_4="<<dl_4<<endl;
    
    
    // Запаковка в long (table_3) четырех знаковых short с координатами начала фокальных линий.
    // выходящих из особых точек, в виде смещения маски на dl1,dl2,dl3,dl4.
    *(short*)&rg_tab3=dl_1;
    *((short*)&rg_tab3+1)=dl_2;
    *((short*)&rg_tab3+2)=dl_3;
    *((short*)&rg_tab3+3)=dl_4;
    table_3[index]=rg_tab3;
    cout<<"запакованный table_3"<<table_3<<endl;
    
    
    // тест
    // Роспаковка координат из table_3 (long) в четыре знаковых short с координатами начала фокальных линий.
    rg_tab3=table_3[index];
    dl_1=*(short*)&rg_tab3;
    dl_2=*((short*)&rg_tab3+1);
    dl_3=*((short*)&rg_tab3+2);
    dl_4=*((short*)&rg_tab3+3);
    cout<<"распакованный table_3"<<table_3<<endl;
    cout<<"dl_1="<<dl_1<<"  dl_2="<<dl_2<<"  dl_3="<<dl_3<<"  dl_4="<<dl_4<<endl<<endl;
    /**/
    
} // if (GrafT)
*/
    
///____________________________________
    
if (0) { cout<<"вывод отладочной информации особая точка угла 3"<<endl;
    
    int x,y;
    int w,h;
    w=ncolumns;  // ширина массива  IMAGE WIDTH
    h=nrows;     // высота массива  IMAGE HEIGHT
    int w_h=w*h; // длинна массива  IMAGE
    
    unsigned char scaling=1; // Уменьшение изображения фокальной линии (графемы) букв в "scaling" раз (2,3,4,5,...) с
    // сохранением площади черного. Серая подложка не выводится. При scaling=1 выводится изображение 1:1 с серой подложкой.
    
    /// Массивы исходной битовой картинки фокальнах линий.///
    // указатели типа uchar
    unsigned char *p0=bytes_data, *pw;    // входной массив, 0-черный 255-белый ( с 0-черный 1-белый не работает)
    unsigned char *bytes_data_1, *p1;     // такой же как массив bytes_data. Оба массива работают по очереди.
    
    
    // Условие линии
    //if ( b<5 && b>1 && a01==2 && a10==2 && table_1[index]==0 ) { // и не особая точка // Условие заполнения таблици.
    
    
    
    // Уменьшение изображения в "scaling" раз с сохранением площади черного. Без серой подложки. // time=0.012  w*h=4 млн. пикселей
    // Изображение берем в bytes_data, сохраняем уменьшенное изображение в bytes_data_1 и копируем обратно в bytes_data.
    // В общепринятом стандарте, 0-черный 255-белый
    if (scaling>1) {
        memset(bytes_data_1, 255, w_h); // заливка bytes_data_1 белым
        scaling=2; // int y;
        for (y=0; y < h; y++){          // time=0.012  w*h=4 млн. пикселей
            p0=bytes_data + y*w;
            p1=bytes_data_1 + (y/scaling)*w;
            for (x=0; x < w; x++){
                if (*(p0+x)==0) *(p1+x/scaling)=0;  // 0-черный для общепринятого стандарта
            } // x                                  // 255-черный для внутреннего формата
        } // y
        memcpy(bytes_data, bytes_data_1, w_h);     // адрес буфера назначения, адрес источника, количество байт для копирования
    } // if
    /**/
    
     // Выполняется в том же цикле где находятся особые точки
     // Если срабатывает признак конца линии или признак возможного наличия острого угла (<90),
     // запускается функция для определения угла между линиями выходящими из этой точки.
    // focalLineRecDirect1(uint sl_1, uint sl_2, uint LengthLine45, uint LengthLine90, uint LengthLine)
    // которая вычисляет коэффициент корреляции линии с прямой и угол наклона линии в градусах.
    // Угол между линиями вычисляется как разность углов линий, выходящих из этой точки.
    // Абсолитное значение углов линий дает ориентацию особой точки "угол".
    // Длинна лучей берется одинаковой и фиксированной 8 pix.
    
    // Как включить коэффициенты корреляции двух линий с прямой в коэффициент корреляции особой точки "угол"?
    // Взять наименьший
    
    // усреднение углов лучей выходящих из особой точки угла
    
} // if (GrafT)
    
///____________________________________

if (0) { cout<<"вывод отладочной информации не распознанные линии, т.е. линии без особых точек 3"<<endl;
    
    // (x0-x1)+(x1-x2)+(x2-x3)+(x3-x4)=x0-xn
    // (x0-x1)-(x1-x2)-(x2-x3)-(x3-x4)=
    //  x0-2*x1-xn                       =
    
} // if (GrafT)
    
///____________________________________
    
    /// ЦИКЛИЧЕСКИЙ СДВИГ///
    
    // return (UInt32)(((x) << (n)) | ((x) >> (32 - (n)))); //----
    // return (value >> count) + ( ((value << (32 - count)) >> (32 - count)) << count ); // http://forum.vingrad.ru/forum/topic-292550/0.html
    
    // return a << offset | a >> (32 - offset); //http://www.cyberforum.ru/c-beginners/thread191363.html
    
    //var = (var << 1) | (var >> 7); // значение переменной циклически сдвигается влево на 1 разряд
    //var = (var >> 1) | (var << 7); // ЦИКЛИЧЕСКИЙ СДВИГ сдвиг вправо на 1 разряд // http://arv.radioliga.com/content/view/192/49/
    
    // 2.14. Циклический сдвиг стр 46  Уоррен. Генри, С. "Алгоритмические трюки для программистов."
    // Циклический сдвиг влево на "n" разрядов:
    // y=(x<<n)|x>>(32-n) // значение переменной "x" циклически сдвигается влево на "n" разрядов (32-длинна слова)
    // Циклическийсдвиг в право на "n" разрядов:
    // y=(x>>n)|x<<(32-n)
    
    
///____________________________________
 
    
    // Вычисление угла поворота, при движении вдоль окружности, в полярных кооординатах.
    //      при движении вдоль окружности

    if (1) { cout<<"вывод отладочной информации: Угол поворота при движении вдоль окружности"<<endl;
        
        int n,n1,n2,dn,nStart,nFinal,nMax,nMin;
        int rg0;
        int index=68;
        
        // регистр rg0 (8 бит) графически это круг (периметр матрицы обсчета), который пересекает фокальньная линия, поэтому в регистре
        // всегда находится две отдельно стоящие единици (точнее найденные входящией и выходящие точки.). Единици находятся в точке пересечения круга и фокальньной линии.
        // Угол поворота при движении вдоль окружности
        
        rg0=index; // rg0=40; 00101000
        cout<<"rg0="<<rg0<<endl;
        
        // Подсчет бинарным поиском ведущих нулевых битов (количества первых подряд идущих нулей). Например, rg0=34; 00100010 => nStart=2;
        // Уоррен. Генри, С. "Алгоритмические трюки для программистов."
        n=0;
        if((rg0 & 0xF0)==0) {n+=4; rg0<<=4;}
        if((rg0 & 0xC0)==0) {n+=2; rg0<<=2;}
        nStart=n+1-(rg0>>7);
        cout<<"количество ведущих нулевых битов  nStart="<<nStart<<endl;
        
        rg0=index; // rg0=40; 00101000
        // Подсчет бинарным поиском завершающих нулевых битов (количества последних подряд идущих нулей). Например, rg0=34; 00100010 => nFinal=1;
        n=1;
        if((rg0 & 0x0F)==0) {n+=4; rg0>>=4;}
        if((rg0 & 0x03)==0) {n+=2; rg0>>=2;}
        nFinal=n-(rg0 & 1);
        cout<<"количество завершающих нулевых битов nFinal="<<nFinal<<endl;
        
        rg0=index;
        n1=nStart+nFinal;   // расстояние в битах (pix) между единицами, при движении по часовой стрелке.
        n2=8-2-n1;          // расстояние в битах (pix) между единицами, при движении против часовой стрелки.
        dn=n2-n1;           //
        // Минимальное и максимальное расстояние в битах (pix) между единицами,
        nMin=n1; nMax=n2;
        if(nMin>nMax) {nMin=n2; nMax=n1;}
        //dn=nMax-nMin;
        cout<<"nMin="<<nMin<<"   nMax="<<nMax<<nMin<<"   dn="<<dn<<endl;
        
        // 1) Определить знак разности
        
        // 2) Передать в основную функцию:
        // - накапливаем в регистре  long long 64=8*8.
        // - накапливаем разность в переменной sum добавляя вход и вычитая выход регистра, получаем скользящее среднее.
        // - нормируем среднее (/8). Если круг, то забегаем на следующий виток на 8 pix, еси дуга то забегать не куда и
        // нормируем от 1 до 8.
        // Получили разность усредненную по 8 отсчетам. Дальше можно строить возрастающий ватерфал и
        // проверять на сколько он похож на прямую линию т.е. на сколько кривая похожа на круг.
        
        //GBitset.h
        //signed  char GrafT[32][16]; ///< массив управления графикой во всех подпрограммах
        //GrafT[15][0]=0;
        
        //--------------
        
        ///unsigned short GrafN[256][8] // адресов смещения точек вдоль фокальной линии упаковано по 2 short
        // адресов точек начала фокальных линий упаковано по 4 short
        // Угол поворота по 2 short
        //int floorsAndParkings[2][4]
        unsigned short GrafN[2][8]=
        {
            { 1, 2, 3, 4, 5, 6, 7, 8 },
            { 1, 2, 3, 4, 5, 6, 7, 8 }
        };
        //GrafN[256][7]=0;
        
        //--------------
        
        // Очередная формула распространяет вправо крайний правый единичный бит.
        int x=128; // 10000000 это основной слой  // x=88;  01011000
        // Выделяем бит самого старшего из 8 слоев графики
        // x=Buf&128;
        // Распространяем вправо крайний правый единичный бит, т.е. заполняем единицали весь байт.
        x=x|(x-1); // Например, 01011000 => 01011111, если исходное слово равно 0, все биты результата будут равны 1.
        cout<<"формула распространяет вправо крайний правый единичный бит x="<<x<<endl;
        // x=255; 11111111      // x=95; 01011111
        
        //--------------
        
        
        /// ДЕЙСТВУЕТ, но не понадобилось ///
        
        /*
        int rg0=34; // 00100010
        
        // Выделяем в байтовом  регистре rg0 крайний справа единичный бит.
        rg0=rg0 & (-rg0); // rg0=2; // 00000010
        cout<<" rg0="<<rg0<<endl;
        
        int x, y, n;
        // регистр rg0 графически это круг, т.е. конец регистра подсоединен к его началу. рассматриваем как к
        y=(x<<n)|x>>(32-n); // значение переменной "x" циклически сдвигается влево на "n" разрядов (32-длинна слова).
         */
        
        /*
         rg0=34;
         // Подсчет ведущих нулевых битов (первых подряд идущих битов). Например, rg0=34;  00100010 => n=2;
         n=0;
         if(rg0<=0x0F) {n=n+4; rg0=rg0<<4;}
         if(rg0<=0x3F) {n=n+2; rg0=rg0<<2;}
         if(rg0<=0x7F) n=n+1;
         cout<<"количество ведущих нулевых битов  n="<<n<<endl;
         */
        
        /*
         unsigned char byte = ...;
         
         byte = (byte & 0x55) + ((byte & 0xAA) >> 1);
         byte = (byte & 0x33) + ((byte & 0xCC) >> 2);
         byte = (byte & 0x0f) + ((byte & 0xf0) >> 4);
         
         считает нули в x:
         Код:
         int q = sizeof(x)*8;
         while (x) x &= x - 1, q--;
         */
        // Выделить в слове крайний справа единичный бит. Например,  01011000 => 00001000.
        // x&(-x);
        // Для того чтобы обнулить крайний справа единичный бит (например, 01011000 => 01010000
        // x&(x-1);
        
        // Выделяем в байтовом  регистре rg0 крайний справа единичный бит.
        ///rg0=rg0 & (-rg0); // rg0=2; // 00000010
        ///cout<<"запакованный rg0="<<rg0<<endl;

       // rg0=40;  00101000 => n=3;
    } // if (GrafT)
    
    
    
///____________________________________
    
    
       /// Деление на страници (развороты книги) ///
    
    // При запуске программы PageSegmentation вручную задаем число колонок (2), на которые надо разбить текст (это обычный режим).
    // Если полученное число колонок не равно двум или координата TurnX равно нулю (те получилась одна колонка).
    
    // УЖЕ РЕАЛИЗОВАННО
    /*
     int xf0,xf1;           // координаты прямоугольника вокруг колонок
     int nFrm,nFrame,widX,maXwx;    // ,nClm,nColumn ,TurnX
     int nFrameDefined=2;
     
     if( nFrame!=nFrameDefined || TurnX==0 ) {
     for ( nFrm=1; nFrm < nFrame; nFrm++ ){ // Цикл по количеству колонок nFrame, без первой колонки.
     xf0=frameArray[nFrm].xf0;  xf1=frameArray[nFrm-1].xf1;      //  [0]
     widX=xf0 - xf1;
     #ifdef DEBUGLVL
     if( GrafT[11][3] )LineVertical(xf0, 0xffff00);
     if( GrafT[11][3] )LineVertical(xf1, 0xffff00);
     #endif
     if( widX > maXwx ) { maXwx=widX; TurnX=(xf1 + xf0)/2; }
     DM("widX="<<widX<<" xf0="<<xf0<<" xf1="<<xf1<<" MeanCol="<<MeanCol<<" TurnX="<<TurnX<<"\n---\n");
     
     } // Цикл по количеству колонок nFrame
     } // if
     else  { TurnX=0; }
     */
    // TurnX - координата серидины разворота книги (по X), глобальная.
    // TurnXL=set->TurnX;
    
    // если нет строк (печа расположены вертикально) то MeanMax задаем вручную. При размере печа выше среднего (400дпи)  400
    // Максимально возможный коэффициент сглаживания равен 80.
    ///MeanMax=80;      // ручная установка MeanMax
    ///KHigAdapt=80;    // ручная установка KHigAdapt
    
    // —————————————————
    
    
    /// Перевод смещения в углы ///
    
    // d9   d2   d3            0    1   0           1    0   1       -w-1  -w   1-w        1   2   4
    
    // d8   d1   d4            1        1           0        0        -1         1         8       16
    
    // d7   d6   d5            0    1   0           1    0   1        w-1   w   w+1        32  64 128
    
    /*
     // координаты маски в следующей итерации в Декартовой системе координат (реализованно в абсолютной линейной системе координат).
     ///if ( sl+dl1==sl_old ) { sl+=dl2; p0+=dl2; dl0=dl2; }  // это следующая стартовая точка.
     ///if ( sl+dl2==sl_old ) { sl+=dl1; p0+=dl1; dl0=dl1; }  // или эта
     if ( sl+dl1==sl_old ) { sl+=dl0=dl2; p0+=dl2; }  // это следующая стартовая точка.
     if ( sl+dl2==sl_old ) { sl+=dl0=dl1; p0+=dl1; }  // или эта
     //cout<<"dl0="<<dl0<<"   x=dl0%w="<<dl0%w<<"   y=dl0/w="<<dl0/w<<endl; ///////////////
     
     int SAlpha=0;
     // в полярной системе координат Alpha
     // Относительный угол поворота вектора следующей стартовой точки
     //if ( dl0==1||dl0==-1||dl0==w||dl0==-w ) LengthLine90++; else LengthLine45++;
     if ( dl0 >-2 ) dlAlpha=dl0+dl0; else dlAlpha=dl0+w; // dlAlpha==2,1,0,-1,-2 , что соответствует +90°,+45°,0,-45°,-90° градусам.
     if ( dl0 >-2 ) dlAlpha=dl0+dl0; else dlAlpha=dl0+w; // dlAlpha==2,1,0,-1,-2 , что соответствует +90°,+45°,0,-45°,-90° градусам.
     // Для получения угла в градусах полученное значение dlAlpha от 2 до -2 можно умножить на 45°.
     
     SAlpha+=dlAlpha;
     LengthCircle45
     
     */
    
//________________________________________________________________________________________________________________________________________________

    exit(0);
}
    
    
    
    
    
    
//________________________________________________________________________________________________________________________________________________
    
                                                // Задачки //
    
    //—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
    
    //Разбор текста словарными фразами с использованием существующего сложного алгоритма.
    /*
     Пробегая словарем по тексту, все совпавшие части словарных фраз и текста отгребаем в структуру.
     Записываем в структуру координаты в тексте начала и конца совпавшей части словарных фраз и текста.
     После пробега всего словаря, существующим сложным алгоритмом разбираем текст на словарные фразы.
     */
    //—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
    
    //Быстрый конвертор кодировок Uni.
    /*
     Есть таблица соответствия каждой фразы состоящие из последовательности байт (< 45-64) каждому short.
     Фраз в таблице примерно 9000.
     Написать локап с битовым регистром в размер текста.
     Словарь состоит из этих фраз. Каждой фразе сопоставлен short.
     Текстом является произвольная последовательность фраз.
     */
    
    //—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
    
    //Хеш поиск
    /*
     Хеш поиск ключ - значение. Буквы open tape после распознавания по очереди поступают на вычисление хеш
     Хеш сработал проверяем результат если не совпал запускаем обычный медленный поиск.
     */
    //—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
    
    //Строки
    /*
     После выделения строк, вырезаем из графики строки по одной и запускаем еще раз выделение строки и получение масштаба
     В отдельно стоящей строке масштаб выделяется с достаточной точностью.  Совместо - сильно влияние соседних строк.
     В графически вырезанной строке можно удалить мелкие формы и осколки соседних строк с помощью функции выделения фокальных линий.
     Ей же можно удалить рамки (сравнивая расстояние между точками отрезка и длинну линии между теми же точками).
     */
    
    //—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
    
    
                                                // Алгоритмы //
    
    // Нахождение масштаба букв.
    
    // Проблема в том что мы хотим масштабировать каждый шрифт независимо до оптимального размера в (32 pix).
    
    /* Однократно выполняемый этап дополнения Б.Д. pix размерами шрифта.
     Берем несколько страниц качественного типографского текста Кангюр состоящие из букв одного шрифта и одного размера. Вручную масштабируем эти текст до оптимального размера в (32 pix). При оптимальном размере текста получается наименьшее количество ошибок.
     Масштабируем текст вверх на 8 pix и в низ 8 pix с шагов в 1 pix. Получаем 16 размеров текста каждый из которых нумерованн своим масштабом. Распознаем по очереди все 16 текстов. Буквы сработавшие с коэффициентом корреляции выше 96% отмечаем соответствующим масштабом. Это индивидуальный масштаб буквы, в итоге, в процессе распознавания, он будет ее предоставлен. Сохраняем в Б.Д. масштаб и коэффициент корреляции для каждой буквы. Одна буква может сработать более чем одном масштабе (т.е. ей может быть присвоено несколько масштабов, это не принципиально).

     
     Оптимальное распознование многошрифтовых текстов .
     - Предварительный прогон распозноваемого текста. Необходим для определения количества и размера шрифтов.
     Может выполняться сокращенной Б.Д. После прогона текста из букв с коэффициентом корреляции выше 96% (их пиксельных размеров) строится частотная гистограмма которая сглаживается и отределяются максимумы. Их в общем случае несколько, по количеству шрифтов встречающихся в тексте. Середине каждого пика соответствует свой pix размер шрифта.
     - Основные прогоны распозноваемого текста. Прогонов столько скалько разных шрифтов в распозноваемом тексте. Под каждый шрифт выполняем свое оптимальное масштабировае графики распозноваемого текста. Мы же хотим чтобы каждый шрифт хорошо распознавался в оптимуме размера. Обработку результатов всех прогонов выполняем совместно выбирая наилучшие значения коэффициентов корреляции. Прогоны могут выполняться по сокращенной Б.Д, состоящий только из букв шрифтов своего и близкого масштаба.
     
     В итоге получается 4 прогона графики распозноваемого текста (три трех шрифтах), но все они могут выполняться по сокращенной Б.Д. 
     Поэтому быстродействие ухудшается не в 4 раза, а меньше.
     
     По результатом первого прогона можно сегментировать области текста с разными шрифтами и прогонять не всю площадь текста, а только ту где есть данный шрифт.
     
     Очень крупные и очень мелкие шрифты - это свои эталоны, их масштабированием не получить.

         /Несколько самых подходящих букв в графике измеряем в ручную в pix и заносим этот результат Б.Д. Причем результат заносим не только в измеренные буквы, но и во все буквы у которых масштаб соответствует измеренным буквам. Теперь почти все буквы Б.Д. имеют свой pix масштаб. Это нужно чтобы померив букву линейкок м.б. оценить масштаб./
    */
     
     
    // ———————————
    
    // Компактное и более простое описание.
    /* 
     Берем качественный типографский текст (состоит из букв одного размера). Измеряем вручную высоту буквы (pix) в тексте на котором зто удобно делать. Заносим в Б.Д. в эту букву. И так измеряем несколько букв (одних и тех же или разных?). Распознаем страницу этого текста (лучше несколько страниц). Всем буквам с высокой корреляцией присваиваем эту высоту.
     Аналогичным образом прогоняем несколько текстов (разного размера), пока Б.Д. более менее не заполнится высотами букв.
     В процессе распознавания по первым же буквам ясно какой оптимальный размер букв.
    */
    
    /*
    // Однако реально по масштабу прыгают все буквы. Поэтому:
    Делаем 8 слойный исходный ч.б. массив. Каждый слой отличается масштабом на 1-2 pix.
    Из "гроздьев винограда" берем первые 16 букв. Каждую из них "львом в пустыне" помещаем в свой оптимум, улучшая ее коэффициент корреляции.
    Получаем улучшение "гроздьев винограда".
    Это очень быстро (<128) по сравнению со всей БД (16 тысяч эталонов).
    Следующий старт "льва в пустыне" начинаем с масштаба предидущей буквы, сокращая его количество тактов.
     Можно добавить поиск по форме буквы, перебирая из Б.Д. все конкретные начертания данной буквы, по всем масштабам.
     Если бы удалось первый поиск выполнить с помощью распознанных фокальных линий (не запуская в каждой точке перебор всей Б.Д.),
     то проблема быстродействия стала бы не актуальной.
     После распознования там где красное (плохо распозналось) можно поиграть масштабом и формой (начертанием) буквы
    */
    
    /*
     // Очередная формула распространяет вправо крайний правый единичный бит.
     int x=128; // 10000000 это основной слой  // x=88;  01011000
     // Выделяем бит самого старшего из 8 слоев графики
     // x=Buf&128;
     // Распространяем вправо крайний правый единичный бит, т.е. заполняем единицали весь байт.
     x=x|(x-1); // Например, 01011000 => 01011111, если исходное слово равно 0, все биты результата будут равны 1.
     cout<<"формула распространяет вправо крайний правый единичный бит x="<<x<<endl;
     // x=255; 11111111      // x=95; 01011111
    */
    

   
    
    
//________________________________________________________________________________________________________________________________________________
    
    
                                                // Новые алгоритмы //
    
                                // РЕАЛИЗОВЫВАТЬ НЕ СТАЛИ ПОЯВИЛИСЬ САМЫЕ НОВЫЕ АЛГОРИТМЫ //
    
    //// Реализация оптимального распознавания для каждого размера букв в тексте. ////
    // Ссыпаем в гроздъя винограда результаты нескольких прогонов с оптимальном масштабом, для каждого размера букв в тексте.
    
    // —————————————————
    
///// Поиск графических примитивов ////
    
    /// Нахождение углов не отмеченных особыми точками ///
    // Находим углы классической матрицей. Это эффективно для мелких форм. В больших формах углы часто склажены, поэтому масштабируем битовую картинку фокальных линий вниз ( в 2-3 раза ) с сохранением черного (код уже написан). Углы становятся более резкими (как в мелких формах). Находим углы классической матрицей добавляя их к уже найденным.
    // уточняем "качество" угла. Проводим лучи в обе стороны на несколько pix и считаем между ними угол. Значение угла считаем с полощью функции "Нахождение прямых линий" или как угол между двумя прямыми. Коэффициент корреляции угла считаем минимальный из коэффициенто корреляции линии.
    /*
    // Острый угол между двумя прямыми, которые заданы уравнения с угловыми коэффициентами y=k_1*x + b_1 и y=k_2*x + b_2 определяется из равенства
    // tg alpha = |(k_2 - k_1)/(1+k_1*k_2)|.
    // При k_1*k_2=-1 прямые перпендикулярны, а при k_1=k_2 прямые параллельны.
    
    /// Уравнение прямой, проходящей через две заданные точки M_1(x_1; y_1) и M_2(x_2; y_2) имеет вид: (y-y_1)/(y_2-y_1)=(x-x_1)/(x_2-x_1)
    
    // Угловой коэффициент этой прямой  k=(y_2-y_1)/(x_2-x_1). Если x_1=x_2, то прямая параллельна оси ординат, а ее уравнение x=x_1. Если y_1=y_2, то прямая параллельна оси абсцисс и ее уравнение y=y_1.
    // http://www.math.com.ua/mathdir/uravneniya_pryamoy_rasstoyanie.html
    // http://stu.sernam.ru/book_ehm.php?id=26
    */
    
    /// Нахождение прямых линий // Момент первого порядка ///
    // Матрицей  (по таблице) считаем углы вдоль фокальных линий. Берем среднее - это угол наклона линии. Реально считаем просто просто угол наклона прямой. Сравниваем длинну вдоль фокальной линии с расстоянием между начальной и конечной точкой - это коэффициент корреляции линии с прямой.
    
    
    /// Нахождение кругов и дуг // Момент второго порядка ///
    // 1й выриант:
    //Считаем разность углов вдоль фокальных линий. Берем среднее от разности - это угол определяет радиус круга. По этому углу между радиусами проведенными из центра круга и расстоянием между начальной и конечной точкой линии (хорде), находим радиус. Сравниваем длинну вдоль фокальной линии с расстоянием между начальной и конечной точкой вдоль дуги идеальной окружности вычисленного радиуса - это коэффициент корреляции линии с окружностью.
    // 2й вариант более реальный:
    // Создаем массив интегральных сумм углов вдоль фокальных линий. Проверяем является ли массив интегральных сумм линейно нарастающим, для этого с помощью функции "Нахождение прямых линий" определяем коэффициент корреляции линии с прямой. Это и есть коэффициент корреляции линии с окружностью.
    // "линия" это прямая проведенная из начала координат (ноль) к последнему значению в массиве.

    
    /// Нахождение спиралей // Момент третьего порядка ///
    
//// Обратный рендер найденных графических примитивов // Визуализация для оценки качества работы ////

    //________________________________________________________________________________________________________________________________________________
    
    
                                            // Самые новые алгоритмы  (конец мая 2015) //
    
                                                ///// Поиск графических примитивов ////
    
    /// Зачем это нужно ? ///
    
    // Каждая точка фокальной линии это точка графического примитива: линии, круга, дуги к тому же обладающая характеристиками.
    // Например линия обладает углом наклона и в битовой маске в области ON суммируются только точки фокальной линии принадлежашие:
    // первое - прямой, второе - прямая д.б. с данным углом наклона. Маски ON и OFF видят только свои графические примитивы.
    // Это дает другую избирательность. 
    
    // Фокальная линия обладает однопиксельной шириной и может быть достаточно вариабельной в маске ON.
    // Гладкость и осмысленность этой вариабельности обеспечивается принадлежностью фокальной линии к определенному типу примитива.
    // Это дает другой тип вариабельности.
    
    /// Общие принципы. Автомотический набор Б.Д. графических примитивов ///
    
    // При распозновании вначале проверяются особые точки, затем выполняется поиск графических примитивов.
    // Т.е. выясняется тип кривых между особыми точками и их характеристики. По типу кривой, координатам начала и конца из микро Б.Д.
    // выбираются маски ON и OFF всех графических примитивов: линия, круг, дуга. Происходит запрос к Б.Д. и выборка ОДНОЙ маски
    // на один графический примитив, а не перебор всей Б.Д. как обычно.
    // С помощью масок вычисляется коэффициенты корреляции кривой с этими графическими примитивами. Выбирается наилучший примитив (линия, круг, дуга).
    // При первом обращении к маске (ее еще нет в Б.Д.) она просчитывается и выполняется в лет и ее параметры (тип кривой, координаты начала и конца )
    // запоминаютя и потом все новые маски заносятся в Б.Д. масок одновременно. По относительным координатам (начало кривой) и ее типу проверяем
    // нет ли уже такого примитива в микро Б.Д. масок. Таким образом микро Б.Д. графических примитивов заполняется автоматически.
    
    
    /// Нахождение прямых линий // Момент первого порядка ///
    
    // Подсчитывается длинна фокальной линии LengthLineDirect по кратчайшему расстоянию от начала линии до конца линии,
    // по Теореме Пифагора. Подсчитывается реальная длинна фокальной линии LengthLine_, состоящая из pix. Предварительный коэффициент корреляции линии
    // с прямой показывает на сколько % реальная пиксельная линия длиннее прямой, проведенной между концами линии. Это реализованно.
    // Если этот коэффициент корреляции достаточно велик, то применям масочный алгоритм.
    // Из Б.Д. выбираем линию (ключ реальная длинна фокальной линии и ее угол наклона) и накладываем сверху битовую маску линии
    // с областями ON и OFF (можно без защитной области)
    // Поскольку координаты начала и конца линии известны, то поиск не нужен
    // (м.б. стоит взять соседние маски: чуть больше, чуть меньше и выбрать лучший вариант).
    // Получаем коэффициент корреляции линии с прямой.
    // Маски ON и OFF должны обладать толщиной в несколько pix. Быстодействие - просчет всего одной маски без поиска.
    

    /// Нахождение кругов и дуг // Момент второго порядка ///
    
    // Если начало и конец фокальной линии совпадает то ищем круг.
    // Подсчитывается реальная длинна фокальной линии  LengthLine_, состоящая из pix. Вычисляется диаметр круга D=L/π,
    // который может быть на этом месте. В вызывающей функции вычисляются координаты центра окружности centerX, centerY,
    // как среднее арифметическое координат текущих точек линии. Это реализованно.
    // Остается проверить, является ли полноценным кругом эта замкнутая кривая с известной длинной и центром.
    // Как и в предидущем случае, из Б.Д. выбираем круг (ключ реальная длинна фокальной линии) и накладываем сверху битовую маску круга
    // с областями ON и OFF (можно без защитной области). Поскольку диаметр круга и координаты центра окружности известны,
    // то поиск не нужен, также можно взять соседние маски: чуть больше, чуть меньше и выбрать лучший вариант.
    // Получаем коэффициент корреляции круга.
    // Если начало и конец фокальной линии не совпадает то аналогичным способом ищем дугу.
    // Подсчитывается реальная длинна фокальной линии  LengthLine_, состоящая из pix. Дуга однозначно определяется ее началом, концом и длинной.
    // Аналогично из Б.Д. выбираем дугу (ключ реальная длинна фокальной линии) и накладываем сверху битовую маску дуги с областями ON и OFF.
    // Поскольку начало дуги, конец дуги и ее длинна известны, то поиск не нужен, также можно взять соседние маски:
    // чуть больше, чуть меньше и выбрать лучший вариант.
    // Получаем коэффициент корреляции дуги.

    /// Компактное и упрощенное описание. ///
    // Подсчитывается реальная длинна фокальной линии  LengthLine_, состоящая из pix. По этой длинне, с помощью разных масок
    // подсчитывая коэффициент корреляции, проверяется к какому типу примитива принадлежит данная кривая и ее параметры.
    
    
    /// Нахождение углов не отмеченных особыми точками ///
    
    // на пока
    // Две скользящие по фокальной линии подряд идущие суммы углов по 4 pix. Между ними берется разность,
    // как оценка резкого изменения угла вдоль кривой. В точке максимальной разности подсчитывается величина угла. 
    
                        /// Замечания и дополнения. ///
    
    // Комплексная обработка трех вышерассмотренных графических примитивов. Линия, круг, дуга.
    // Запускаем все три обработки, по наибольшему коэффициенту корреляции принимаем решение о наличии графического примитива в данном месте.
    // Если позволит математика можно оставить не 1 коэффициент корреляции, а 2 или 3, отбросив заведомо слабый.
    
    // Из за применения масок не очень опасны склеивание и разрывы.
    
//________________________________________________________________________________________________________________________________________________
    
                            /////  Поиск по словарю ограниченным только размерами памяти ////
    
    /// Общие принципы. Четкий и не четкий поиск.
    
    // Как бы меняем местами словарь и текст. Предпологается что словарь большой, а запрос (текст) короткий
    // Словарем служит большая таблица. Запрос читается последовательно, по словам.
    // По этому размер словаря не ограничен временем последовательного чтения, а ограничен только размерами памяти.
    // В место пар букв с перекрытием "чешуйка" (пары встречаются гораздо реже чем буквы) выгодно использовать целое слово
    // закодированное одним плотно упакованным int, т.к. слова достаточно редки.
    
    // Строим таблицу по словарю фраз где каждому слову (в место пар букв используем целое слово) соответствует список фраз в котором оно есть.
    // ID номер слова есть адрес в массиве, где расположен список адресов (тоже в виде массива int) фраз словаря, где это слово присутствует.
    // Там же предусмотрен массив счетчиков по одному счетчику short на каждую фразу словаря. Каждое попадание слова из запросной фразы
    // в словарную фразу фиксируется приращением соответствующего счетчика на единицу. Перед каждым запросом массив счетчиков обнуляется.
    
    /// Четкий поиск.
    
    // Берем первое слово из запросной фразы и по его ID номер (это плотно упакованные int) обращаемся к массиву фраз словаря, получаем
    // список фраз словаря, где это слово присутствует. Счетчики соответствующим этим словарным фразам приращением на единицу.
    // Берем второе слово из запросной фразы, обращаемся к массивам и также приращением соответствующие счетчики на единицу и т.д, до конца запросной фразы.
    // В момент проверки последнего слова запросной фразы запоминаем ID номера словарных фраз счетчики которых соответствуют количеству слов
    // в запросной фразе. Получили список найденных словарных фраз обращаясь только к таблицам, без последовательного чтения всего словаря.
    
    /// Не четкий поиск.
    
    // Не четкий поиск выполняется аналогично. Только в конце поиска по запросной фразе запоминаем список фраз счетчики которых
    // соответствуют количеству слов в запросной фразе минус нечеткость (1,2). Надо запомнить максимальные положения счетчиков на
    // два такта назад (для нечеткости в 1), что бы линейно не читать весь словарь. Правда нечеткость имеет минимальную градацию в слово,
    // но если применять "чешуйки", то минимальной градацией будет буква.

    /// Замечания и дополнения. ///
    
    // Объем необходимой памяти для таблицы фраз словаря будет сответствовать обычному линейному словарю составленным из
    // последовательно расположенных словарных фраз. Плюс небольшой объем необходимый счетчикам, т.е. число short равных числу фраз словаря.

    
//________________________________________________________________________________________________________________________________________________
    
    /// уве­ли­че­ние изоб­ра­же­ния без по­яв­ле­ния пик­се­лов ///
    
    // Уве­ли­че­ние изоб­ра­же­ния сводится к масштабированию самым быстрым (поэтому простым) алгоритмом и последующему сглаживанию алгоритмом высокого порядка. В известных фильтрах обычно используют алгоритмы третьего порядка (B-Spline, Mitchel, Lancros-3) и дополнительно разные "окна".
    
    // Свертки (Convolution) //
    // - Ближайший сосед. Геометрически это прямоугольная импульсная характеристика.
    // - Билинейный фильтр (bilinear или triangle в ImageMagick). Геометрически это треугольная импульсная характеристика.
    // - Бикубический фильтр (bicubic, catrom в ImageMagick). Геометрически импульсная характеристика выглядит как Гауссиан (шляпа).
    // - Фильтр Ланцоша (Lanczos). Геометрически импульсная характеристика выглядит как sinc ( sin_x/x т.е. шляпа с волнистыми затухающими краями ).
    
    // Примечательно, что некоторые фильтры имеют зоны отрицательных коэффициентов (как например бикубический фильтр или фильтр Ланцоша). Это нужно для придания переходам на конечном изображении резкости, которая была на исходном.
    
    // Отношение обработанных пикселей к исходным целиком определяется размером окна фильтра и равно его квадрату.  Т.е. для ближайшего соседа это отношение будет 2, для билинейного фильтра 4, для бикубического 16, для Ланцоша 36.
    // При одномерной рекурсивной обработке для билинейного фильтра достаточно просчитать 3 точки (не зависимо от размера окна), для бикубического 6, для Ланцоша 9. При двухмерной рекурсивной обработке для билинейного фильтра достаточно просчитать 6 точек (не зависимо от размера окна), для бикубического 12, для Ланцоша 18.
    
    
    // В частности, Hermite, B-spline и Mitchell относятся к кубическим — то есть их весовая функция это кубический полином.
    
    // Другой большой класс функций — это sinc, умноженный на разные "окна".
    // Hanning использует функцию sinc умноженную на окно Хана.
    // Lanzos это sinc * растянутый sinc в качестве окна.
    // Для увеличения изображений рекомендуют Mitchell, для уменьшения подойдет любой их оконных (по умолчанию Lanzos), если есть много мелких «узоров». Если же «узоров» нет, зато есть прямы границы, то лучше Гаусс с повышением резкости либо Mitchell, чтобы избежать сильного звона.
    // В самом ImageMagick в по умолчанию для повышения разрешения используется Mithell, а во всех остальных случаях — Lanzos.
    
    // http://habrahabr.ru/post/243285/
    
//________________________________________________________________________________________________________________________________________________
    
    /// Выделение рамок ///
    // Находим 90 градусные углы, как особые точки по всей печа с длинными лучами ( днинна >10% от соответствующей стороны печа).
    // Просчитываем всю длинну лучей выходящие их них, с учетом разрывов и паразитных ответвлений.
    // Для этого находим последнею особую точку (длинный 90 градусный угл) на данном луче, причем сам луч м.б.наклонным. Между начальной и конечной
    // точкой луча выделяем тонкую область в которой подсчитываем все pix прямых линий с данным наклоном. Подсчитываем также длинну идеальной
    // прямой линии между начальной и конечной точкой луча. Повторяем эти действия для всех длинных 90 градусных углов.
    // Отношение реальной длинны всех лучей к идеальной длинне всех лучей, по всей печа и есть коэффициент корреляции рамки

    
    // —————————————————
    
    /// Датчик положения текста (+90, -90, 180 градусов) ///
    // В БД графических примитивов для наиболее употребимых простых букв храним эталоны повернутые на +90 -90 180 градусов и зеркальное отображение.
    // Для распознования положенния текста пробегаем всеми модификациями эталонов и выбираем из них тот у которого распозналось наибольшее число букв.
    // Точнее, у какой модификациии больший суммарный коэффициент корреляции для букв, если он превышает 50%. Эта модификация и есть положение текста.
    
    // —————————————————
    
    /// Организация массива линии ///
    // Суммарное количество промежуточных точек, вдоль фокальной линии, по всему графическому тексту  sizeLineAdr
    // равно площади черного состоящего из фокальных линий,  что легко подсчитывается по 64 разряда (8*8) popcnt или функцией.
    // Лучше написать отдельную функцию.
    // Координаты промежуточных точек, вдоль фокальной линии хранятся в одном большом непрерывном массиве выше подсчитанной длины sizeLineAdr.
    // В Б.Д. хранятся ссылки на начало отдельных линий и их длинны. Количество линий примерно равно количеству точек с точностью до нескольких процентов.
    // Такой массив серилизуется.
    
    // —————————————————
    
    // Не забыть очистиь от черного 2х pix бордюр //
    // вызовом функции img->eraseBorder(2, 2);
    // перед применением любой из функций focalLine(9), focalPointXTL(focalAdr); или focalLineRecognition(focalAdr,focalLine);
    /// занести комментарий в эти функции.
    
    // —————————————————
    
    // В lookupProcess4.cpp код начиная с фразы:
    // "/// подсчет вероятности разделителя (пробела) распознаваемого текста по четкому поиску ///"
    // можно спокойно ремачить, а это половина кода этой функции.
    
    // —————————————————
    
    // Динамический набор Б.Д. во время распознавания.
    // Сортируем Б.Д. букв по частотности срабатывания. Распознаем  
    
    // —————————————————
    
    //  Hilbert transform.Преобразование Гильберта c++
    //  https://translate.google.ru/translate?sl=en&tl=ru&js=y&prev=_t&hl=ru&ie=UTF-8&u=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FHilbert_transform&edit-text=
    //  http://www.bourabai.kz/signals/ts10.htm
    //  Преобразование Гильберта. Aналитический сигнал
    //  http://www.dsplib.ru/content/hilbert/hilbert.html
    //  Преобразование Гильберта
    //  http://chaos.ssu.runnet.ru/kafedra/edu_work/textbook/khovanovs-01/node24.html
    //  Простой SDR приёмник на ПЛИС
    //  http://habrahabr.ru/post/204310/
    
    // —————————————————
    
    // По gaussian(int amplitude)
   
    // 1) Сделать ограничения на размер области усреднения ss=1
    // int ss=amplitude;  // "ss" зто "ширина" области усредннения Гауссиана в пикселях.
    // Ограничения на размер области усреднения ss
    // if ( ss<=2 ) ss=2;   if ( ss>64 ) ss=64;
    
    // 2) для битового массива не нужно:
    //  "уменьнение динамического диапазона размытого серого до динамического диапазона байта (0-255)"
    //  т.е. ss_m4=1;
    //  int ss_m4=2*ss*ss*ss*ss; // для ss=2;  ss_m4=32;
    //  *p2=*d2/ss_m4;
    //  в обоих циклвх, иначе сразу получается бинаризация.
    
    
    // 3) // реально в gaussian это не поворот на -90°, а зеркальный flip.
    
    // Заменить на настоящее дискретное вpащение изображения на углы +90° или -90° взять в GBitmap::rotateFast
    /*
    // Дискретное вpащение изображения на углы +90° или -90°
    // Rotate one pixel at a time.
    // rotate by-90°, вращение против часовой стрелки,
    unsigned int index_=0;  int dlt=1; // было unsigned int dlt до 5 ноября 2010 года
    // rotate by+90°, вращение по часовой стрелки.
    if (rotation== 90) { index_=w_h, dlt=-1; }
    
    // переупаковка (транспонирование) всего  горизонтального
    // массива строк в массив вертикальные строк.
     
    /// НОВОЕ вpащение изображения на угол -90°
     
     // Дискретное вpащение изображения на угол -90°
     unsigned int index_=0;
     p2=bytes_data_2 + pr2_w;   p1=bytes_data_1 + pr2_w;  /// сдвигаем в начало массива p2 на + pr2_w  /// сдвигаем обратно в массиве p1 на + pr2_w
     for ( x=w_1; x >-1 ; x-- ) { // w_1=w-1;   // time=0.016
         for ( y=0; y < w_h; y+=w){
             *(p1 + index_)= *(p2 + x + y);
             index_+=1; // -90°
         } // y
     } // x
     
     // Дискретное вpащение изображения на угол +90°
     // Возвращаем в исходное положение и записываем в исходный массив bytes_data
     index_=w_h,
     w_=h; // меняем местами w и h по любому    // int w_=h;  int h_=w;
     w_1=w_-1;
     p0=bytes_data;   p2=bytes_data_2 + pr2_w;  //  + pr2_w  сдвигаем в начало массива
     for ( x=w_1; x >-1 ; x-- ) { // w_1=w-1;   // time=0.016
         for ( y=0; y < w_h; y+=w_){ // w_h
             // за одно выполняем инверсию "~" и записываем результат в исходный массив p0
             *(p0 + index_)=~(*(p2 + x + y));
             index_-=1; // +90°
         } // y
     } // x
    */
    
    /// ПРЕЖНИЙ зеркальный flip.
    
    /*
    // реально это не поворот на -90°, а зеркальный flip.
    // Поворот на -90°. Переупаковка (транспонирование) горизонтального массива строк в массив вертикальных строк.
    p2=bytes_data_2 + pr2_w;   p1=bytes_data_1 + pr2_w; /// сдвигаем в начало массива p2 на + pr2_w   /// сдвигаем обратно в массиве p1 на + pr2_w
    for ( x=0; x < w; x++ ) {    // time=0.37
        for ( y=0; y < w_h; y+=w ){ /// sizeBuf   w_
            //*(p1 + index_)=*(p2 + x + y);  index_++;  // index_+=dlt; int dlt=1;
            *p1=*(p2+y);  p1++; // p1++;  сквозной индекс в цикле переупаковки
            // *p1=*(p2+y); cout<<" "<<(unsigned short)*p1;  p1++;     // *p1=*p0;   p1++;  p0+=w;
        } // y
        p2++; // +x
    } // x
    */
    /*
    // Поворот на +90°. Возвращаем в исходное положение и записываем в исходный массив bytes_data
    w_=h; //int n=0;  // меняем местами w и h по любому    // int w_=h;  int h_=w;
    p0=bytes_data;   p2=bytes_data_2 + pr2_w;  // index_=0;  ///  + pr2_w  сдвигаем в начало массива
    for ( x=0; x < w_; x++ ) {    // time=0.25
        for ( y=0; y < w_h; y+=w_ ){ // w_h
            // *(p0 + index_)=*(p2 + x + y);  index_--; // index_+=dlt; int dlt=1;
            // за одно выполняем инверсию "~" и записываем результат в исходный массив p0
            *p0=~(*(p2+y));   p0++; // n++; // p0++;  сквозной индекс в цикле переупаковки
        } // y
        p2++; // +x
    } // x
    */
    
    
    // —————————————————
    
    
    /// часть алгоритмов находится в текстовом файле Алгоритмы.txt ///
    
   
    
    //————————————————————————————————————————————————————————————————————————————————————————
    
    // Линейная интерполяция цвета между двумя точками.
    // Возвращаем с интерполяцией цвета Y на расстоянии l.
    // http://tech-algorithm.com/articles/linear-interpolation/
    
    /**
     *
     * Linear interpolation between two points.
     * Return interpolated color Y at distance l.
     *
     * @param A ARGB for point A.
     * @param B ARGB for point B.
     * @param l Distance Y from A.
     * @param L Distance between A and B.
     * @return Interpolated color Y.
     */
    /*
    public int linearInterpolate(int A, int B, int l, int L) {
        // extract r, g, b information
        // A and B is a ARGB-packed int so we use bit operation to extract
        int Ar = (A >> 16) & 0xff ;
        int Ag = (A >> 8) & 0xff ;
        int Ab = A & 0xff ;
        int Br = (B >> 16) & 0xff ;
        int Bg = (B >> 8) & 0xff ;
        int Bb = B & 0xff ;
        // now calculate Y. convert float to avoid early rounding
        // There are better ways but this is for clarity's sake
        int Yr = (int)(Ar + l*(Br - Ar)/(float)L) ;
        int Yg = (int)(Ag + l*(Bg - Ag)/(float)L) ;
        int Yb = (int)(Ab + l*(Bb - Ab)/(float)L) ;
        // pack ARGB with hardcoded alpha
        return 0xff000000 | // alpha
        ((Yr << 16) & 0xff0000) |
        ((Yg << 8) & 0xff00) |
        (Yb & 0xff) ;
    }
    */
    
    //————————————————————————————————————————————————————————————————————————————————————————
    


};