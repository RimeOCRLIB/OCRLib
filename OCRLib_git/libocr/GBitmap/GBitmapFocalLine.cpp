//  OCRLib  2015 www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  Will Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .

#include "GBitmap.h"


namespace ocr{
    //*****************************************************************************
    
    // Функция стандартизации начертания текста путем определения фокальной линии (графемы) букв.
    // Удобно использовать в паре с функцией определения толщины штриха lineWidth().
    // Работает только с черно-белой картинкой. 
    
    // Матрица (3*3-1) перепрыгивает белые области и вычисляет матрицу только в черных областях, 
    // что в 2.0 раза быстрее, чем перебирать все пиксели подряд.    
    int  GBitmap::focalLine(int n_RemovLayers) {
        
        // n_RemovLayers это количество удаленных слоев (слой это периметр символов графического текста) 
        // Обычно n_RemovLayers=7. // лучше =9  // number of removed layers
        //  * Идея *  
        // Алгоритм, общая идеология и терминология взята из работ:
        // A Fast Parallel Algorithm for Thinning Digital Patterns. T. Y. ZHANG and C. Y. SUEN.
        // http://www-prima.inrialpes.fr/perso/Tran/Draft/gateway.cfm.pdf
        
        
        //  * Особенности *
        // Функция потенциально не быстрая т.к. 14 раз пробегает весь исходный байтовый массив (при n_RemovLayers=7)
        // Поэтому: 
        // - используются предпросчитанные таблицы, что улучшает общее быстродействие функции в 2 раза
        // - обрабатываются (подвергаются эррозии) только чернные пиксели в тексте (точки d1), перепрыгивая через белые области,
        // что улучшает общее быстродействие функции еще в 5-6 раз.
        // Можно пробегать сразу блоками по 64 pix, но это значительно более сложный код, примерно как в
        // функции "Полиграфическое растискивание dotGain()", зато на порядок быстрее.
        
        //  * Особенности применения *
        // Превышение количества удаленных слоев n_RemovLayers выше определенного значения не влияет на качество получаемой  
        // фокальной линии (графемы) букв, а приводит только к замедлению работы программы.
        // Первый подход - априорное определение минимального количества удаленных слоев. Один удаленный слой    
        // (слой это периметр символа т.е. 2 pix) и это 2 единици толщины штриха. Необходимое количество удаленных слоев  
        // равно половине средней толщины штриха плюс еще одна половина средней толщины штриха, как компромисный запас 
        // на особо толстые линии в изображении. Окончательное значение n_RemovLayers равно средней толщине штриха в pix. 
        // Среднею толщину штриха по всему графическому тексту (изм. в десятых долях pix) можно получить с помощью
        // функции "Определение толщины штриха lineWidth()". Поэтому n_RemovLayers=line_wd/10;  где int line_wd=lineWidth()
        // Проще задать вручную при вызове программы.
        // Обычно компромисное значение количества удаленных слоев n_RemovLayers=7 (скорее 9).
        // Второй подход - определение минимального количества удаленных слоев в самом процессе работы этой программы.
        // При снятии слоя пикселей за слоем с какой-то момент графическая картинка (текст) перестанет изменятся.
        // Как только массив станет равным предыдущему массиву, процесс останавливается.
        // Практически удобно комплексировать оба метода. А именно, задаем максимальное разумное количество слоев,
        // (например 9), но если графическая картинка перестанет изменятся при снятии слоев, программа закончит работу
        // и не будет снимать последовательно все 9*2 слоев. Сейчас так и реализованно.
        
        //printToScreen(); exit(0);
        
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if (GrafT) { cout<<"Функция определения фокальных линий букв (графем)   focalLine()   n_RemovLayers="<<n_RemovLayers<<endl; }
        
        //TIME_START 
        
        int x,y;      
        int w,h;            
        w=ncolumns;  // ширина массива  IMAGE WIDTH
        h=nrows;     // высота массива  IMAGE HEIGHT
        int w_h=w*h; // длинна массива  IMAGE
        
        if (GrafT) { cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
        // w*h=4 млн. пикселей time=0.26/2 // w*h=10 млн.  time=0.68/2  // 4.3/2  w*h=39 млн., n_RemovLayers=15
        
        /// управляющие переменные ///         
        int n_Lay=n_RemovLayers; // количество удаленных слоев (слой это периметр символа) n_Lay=7;
        int min_RemovLayers=n_RemovLayers; // возвращаемое функцией фактическое количество удаленных слоев.
        // Вполне м.б. min_RemovLayers < n_RemovLayers
        unsigned char scaling=1; // Уменьшение изображения фокальной линии (графемы) букв в "scaling" раз (2,3,4,5,...) с 
        // сохранением площади черного. Серая подложка не выводится. При scaling=1 выводится изображение 1:1 с серой подложкой. 
        
        if (GrafT) cout<<"количество удаленных слоев   n_Lay="<<n_Lay<<endl;
        
        /// вспомогательные переменные
        int n=0;     // переменная по количеству удаленных слоев со всех сторон
        //int m=0;
        int g, s, s_old; //, s_dlt
        unsigned char rg0;  // байтовый регистр для хранения отдельных 8 бит маски
        unsigned char d2,d3,d4,d5,d6,d7,d8,d9; // d1,  // переменные маски
        unsigned char a,b,c,d; // переменные условий
        int flag1, flag2; // флаги попиксельного равенства исходнного и подвергнутого эррозии массивов, 
        // if (flag1==0 && flag2==0) при этом условии все штрихи достигают пиксельной толщины. 
        int w_1=w+1; // смещение с угла в центр матрици (маски)
        
        // вспомогательные переменные для предотвращения выхода за пределы массива
        int w_h_=w*h-(w+w+4); // -(0)
        
        
        /// Массивы.///
        // указатели типа uchar
        unsigned char *p0=bytes_data, *pw;    // входной массив, 0-черный 255-белый ( с 0-черный 1-белый не работает)
        unsigned char *bytes_data_1, *p1;     // такой же как массив bytes_data. Оба массива работают по очереди.
        
        //////////////
        
        // указатели типа uint
        unsigned int *BufS; //,*d0 // массив адресов начала и конца слайсов (slice) и предназначен для перепрыгивания белых областей. 
        
        // размер массива bytes_data_1.
        unsigned int sizeBuf=w_h + 32 ;
        // размер массива BufS (д.б. четным).
        int k=16; // 160
        unsigned int sizeBufS=((sizeBuf/k)/2)*2;
        ///if (GrafT)cout<<"размер массива изображения   w_h="<<w_h<<",     размер int массива адресов слайсов   sizeBufS="<<sizeBufS<<endl;
        
        // выделение памяти под массивы. 
        bytes_data_1 = (unsigned char*)malloc(sizeBuf); // p1
        ///bytes_data_1 = (unsigned char*)calloc(sizeBuf,sizeof(unsigned char));         
        BufS = (unsigned int*)calloc(sizeBufS+32, sizeof(unsigned int)); // d0  // Каждый элемент инициализируется в 0.
        ///BufS = (unsigned int*)malloc(sizeBufS*sizeof(unsigned int)+32);  // d0
        unsigned char table_1[256];  // таблица для удаления граничных точек справа и внизу (снятие слоя точек справа и внизу) // 
        unsigned char table_2[256];  // таблица для удаления граничных точек слева и сверху (снятие слоя точек слева и сверху) //
        
        // указатели на те же массивы типа ulong для быстрых циклов
        unsigned long *bytes_data0_64=(unsigned long*)bytes_data;    // приведение к unsigned long
        unsigned long *bytes_data1_64=(unsigned long*)bytes_data_1;  // приведение к unsigned long        
        unsigned long *p0_64, *p1_64;
        
        ///unsigned long *p0_64=(unsigned long*)bytes_data;    // приведение к unsigned int
        ///unsigned long *p1_64=(unsigned long*)bytes_data_1;  // приведение к unsigned int
        
        // предварительные данные для циклов определяющих момент остановки процесса удаления слоев,
        // по достижения фокальной линии пиксельной толщины. 
        int sf_rg=sizeof(unsigned long);
        int w_h_64=w_h/sf_rg;  // sizeof(unsigned long)=8
        ///cout<<"w_h="<<w_h<<"  (w_h_32)*32="<<(w_h_32)*32<<endl;
        
        // отступы от краев (бордюр) x0, x1, y0, y1, блокируют влияние грязи с краев текста на процесс остановки эрозии 
        // графической картинки по достижении однопиксельной толщины штриха. Возможный захват бордюром не большой части 
        // текста в данном случае не критичен т.к.эрозия графической картинки происходит все равно по всей площади текста.
        // Но решение об остановке эрозии принемается только по центральной части картинки, без бордюров, поэтому лучше br=16
        int br=16;   // величина отступа от краев, как часть высоты и ширины изображения (1/8). Лучше 1/16
        int x0, x1, y0, y1; // отступы от краев (бордюр). 
        x0=(w/br)/sf_rg;  x1=(w-w/br-1)/sf_rg;  y0=h/br;  y1=h-h/br-1;    
        if (GrafT) cout<<"sf_rg="<<sf_rg<<"  x0="<<x0<<"  x1="<<x1<<"  y0="<<y0<<"  y1="<<y1<<endl;    
        /**/  
        
        
        
        ///TIME_START
        // Заполнение массива BufS адресами начала и конца черных слайсов (для перепрыгивания белых областей).         
        // Эррозия работает только с черным в тексте, а площадь черного на порядок меньше площади
        // белого (в 30 и более раз), что уменьшает полное время выполнения функции с time=0.66 до time=0.33.
        pw=bytes_data + w_1;  // w_1=(w+1); смещение с угла в центр матрици (маски)
        s_old=bytes_data[w_1];  g=0;   
        for ( x=0; x < w_h_; x++ ) {   // time=0.06  w*h=10 млн. пикселей 
            s=*(pw + x);      // s=bytes_data[x+w_1]; 
            // заполнение массива адресами начала и конца черных слайсов.
            if(s-s_old < 0) { BufS[g]=x; }  // неравенства работают до инверсии уровней входного массива
            if(s-s_old > 0) { BufS[g+1]=x;  g+=2;  if(g > sizeBufS){break;} } 
            //if(s-s_old < 0) { BufS[g+1]=x; cout<<"   "<<BufS[g]<<" "<<BufS[g+1]; g+=2; }
            s_old=s;              
            //if(g > sizeBufS) break;
        } // for
        int sizeBufSR=g;
        if (GrafT) cout<<"размер массива адресов слайсов   sizeBufS="<<sizeBufS<<",   реальное заполнение массива BufS адресами   g="<<g<<endl;
        // если массив BufS оказался слишком мал для размещения всех слайсов, то все что в него не поместилось 
        // превращаям в как бы в один большой слайс продолженный до конца массива и обрабатываем его обычным способом.
        BufS[sizeBufS-1]=w_h_;    
        ///if (GrafT) cout<<"последний адрес массива BufS     BufS[sizeBufS-1]="<<BufS[sizeBufS-1]<<endl;  
        ///TIME_PRINT_
        /**/
        
        //   n_Lay=14;  // test
        
        // матрица (маска) обсчета (3*3-1), где d1 центральной точка по которой принимается решение удалять - не удолять. 
        // d2, d3, d4, d5, d6, d7, d8, d9  точки окружения, по которым работает алгоритм принятия решения.
        /*   
         d9   d2   d3
         
         d8   d1   d4
         
         d7   d6   d5
         */
        
        // Создание предпросчитанных таблиц table_1 и table_2 по условию (a = 1) && (2 <= b <= 6) && (c = 0) && (d = 0)
        // В таблице table_2 по отношению к table_1 изменен только способ подсчета "c=d2*d4*d8" и "d=d2*d6*d8"    
        
        // цикл перебора всех возможных значений матрици (3*3-1) // time=0
        for (int index=0; index < 256; index++){ 
            rg0=index;
            table_1[index]=table_2[index]=255; // заполнение таблиц единицами // убрать 2 else { table_1[rg0]=255; }
            
            // разборка байтового регистра на отдельные 8 бит
            d9=rg0 & 1;    d2=rg0>>1 & 1; d3=rg0>>2 & 1; d8=rg0>>3 & 1; 
            d4=rg0>>4 & 1; d7=rg0>>5 & 1; d6=rg0>>6 & 1; d5=rg0>>7 & 1;            
            // АЛГОРИТМ //            
            a=0; // "a" это число паттернов "01" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)  
            if(d3-d2>0)a++; if(d4-d3>0)a++; if(d5-d4>0)a++; if(d6-d5>0)a++; 
            if(d7-d6>0)a++; if(d8-d7>0)a++; if(d9-d8>0)a++; if(d2-d9>0)a++;    //  a = 1 - условие N1 
            // "b" это число ненулевых соседей центральной точки d1, т.е, она имеет по крайней мере, 2 ненулевых соседа, но не более 6.            
            b=d2+d3+d4+d5+d6+d7+d8+d9; //  2 <= b <= 6 - условие N2 
            // По крайней мере, одна из точек d2, d4, d6 являются фоновой
            c=d2*d4*d6;  //  c = 0 - условие N3 
            // По крайней мере, одна из точек d4, d6, d8 являются фоновой
            d=d4*d6*d8;  //  d = 0 - условие N4            
            // заполнение таблицы первой половины итерации (subiteration)
            if ( b<=6 && b>=2 && a==1 && c==0 && d==0 ) table_1[index]=0;
            
            // По крайней мере, одна из точек d2, d4, d8 являются фоновой
            c=d2*d4*d8;  //  c = 0 - условие N3 
            // По крайней мере, одна из точек d2, d6, d8 являются фоновой
            d=d2*d6*d8;  //  d = 0 - условие N4
            // заполнение таблицы второй половины итерации (subiteration)
            if ( b<=6 && b>=2 && a==1 && c==0 && d==0 ) table_2[index]=0;
            
            //cout<<" "<<(unsigned short)table_2[index];
        } // for    
        if (GrafT) cout<<"значение байтового регистра для хранения отдельных 8 бит маски, в конце цикла   rg0="<<(unsigned short)rg0<<endl; 
        // cout<<endl;  
        
        
        // создание массива и его заполнение для хранения и визуализвции серой подложки букв из исходного изображения 
        unsigned char *bytes_data_2;
        if (GrafT) {                
            bytes_data_2 = (unsigned char*)malloc(sizeBuf); // p2            
            // копирование bytes_data в bytes_data_2
            memcpy(bytes_data_2, bytes_data, w_h);  // адрес буфера назначения, адрес источника, количество байт для копирования
        } // if
        
        
        // инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный 
        //for ( x=0; x < w_h; x++ ) { if (bytes_data[x]) bytes_data[x]=0;  else bytes_data[x]=255;} // по 1 байту  // else bytes_data[x]=1;
        for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data0_64[x]; } // по 8 байт одновременно
        
        // Для нормальной работы алгоритма перед началом цикла по "x" в массивах bytes_data и bytes_data_1 
        // должны быть одни и те же данные. В этом смысл всех memcpy() в данной программе.
        // копирование bytes_data в bytes_data_1  // time=0.003  w_h=w*h=10 млн. пикселей // time=0.003*14=0.042
        memcpy(bytes_data_1, bytes_data, w_h); 
        
        
        
        
        /// Цикл по количеству удаленных слоев со всех сторон. /// time=0.24  w*h=10 млн. пикселей  n=8
        pw=bytes_data + w_1;    // w_1=(w+1); смещение с угла в центр матрици (маски)
        p1=bytes_data_1 + w_1;
        //n_Lay=2;
        for ( n=0; n < n_Lay; n++ ) {
            
            
            // Удаление граничных точек справа и внизу (снятие одного слоя точек справа и внизу) //  
            // В первой половине итерации (subiteration), точка контура d1 удаляется из изображения,
            // если она удовлетворяет следующим условиям: (a = 1) && (2 <= b <= 6) && (c = 0) && (d = 0)
            // условие реализованно в виде предросчитанной таблицы table_1[]
            
            // цикл обеспечивает обработку (эррозию) только черных пикселей в тексте (точки d1), перепрыгивая через белые области.     
            for ( g=0; g < sizeBufSR; g+=2 ) { //  w_h_=w*h-(w+w+4);  // time=0.18/2  только цикл ( n_Lay=7, w*h=4 млн. пикселей )                    
                ///for ( x=0; x < w_h_; x++ ) { 
                // цикл обеспечивает удаление точки контура d1 с помощью таблицы.
                for ( x=BufS[g]; x < BufS[g+1]; x++ ) {
                    // если точка контура d1 равна нулю, то ее не зачем просчитывать и удалять.
                    if (*(pw + x)!=0) {  // pw=bytes_data + w_1;   // w_1=(w+1);
                        p0=bytes_data+x;
                        // сборка байтового регистра rg0 из отдельных 8 бит матрици с помощью единичных масок
                        rg0=(*(p0)&1) + (*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w+2)&16) + (*(p0+w+w)&32) + (*(p0+w+w+1)&64) + (*(p0+w+w+2)&128); 
                        if ( rg0>1 && table_1[rg0]==0 ) { *(p1+x)=0; } // p1=bytes_data_1 + w_1;  // time=0.66/2
                        //cout<<(unsigned short)*p0;
                    } // if
                } // x        
            } // g
            /**/
            
            // Как только удаление граничных точек справа и внизу перестанет изменять массив (все штрихи достигли пиксельной толщины), 
            // устанавливаем  флаг в ноль.
            flag1=0; 
            for (y=y0; y < y1; y++){  // time=0.0003 w*h=4 млн. пикселей
                s=(y*w)/sf_rg;
                p0_64=bytes_data0_64 + s; 
                p1_64=bytes_data1_64 + s;
                for (x=x0; x < x1; x++){ // х управляет указателем на 64 (sf_rg)  // int x
                    if ( p0_64[x]!=p1_64[x] ) { flag1++; goto break1; }  // goto break1;  break;
                } // x 
            } // y 
        break1:;
            if (GrafT) cout<<" flag1="<<flag1;
            /**/
            
            // в массивах bytes_data и bytes_data_1 должны быть одни и те же данные.        
            memcpy(bytes_data, bytes_data_1, w_h);  // адрес буфера назначения, адрес источника, количество байт для копирования
            
            // Как только удаление граничных точек слева и сверху, справа и внизу перестанет изменять массив, выходим из общего цикла по "n".
            if (flag1==0 && flag2==0) {break;}
            
            
            // Удаление граничных точек слева и сверху (снятие одного слоя точек слева и сверху) //
            // Во второй половине итерации (subiteration), точка контура d1 удаляется из изображения,
            // если она удовлетворяет следующим условиям: (a = 1) && (2 <= b <= 6) && (c = 0) && (d = 0)
            // условие реализованно в виде предросчитанной таблицы table_2[]
            // Во второй половине итерации (subiteration), изменились только следующии условия относящиеся к "c" и "d":    
            // d2 * d4 * d8 = 0     //  d2 * d6 * d8 = 0 
            
            // цикл обеспечивает обработку (эррозию) только чернных пикселей в тексте (точки d1), перепрыгивая через белые области.    
            for ( g=0; g < sizeBufSR; g+=2 ) {
                ///for ( x=0; x < w_h_; x++ ) {
                // цикл обеспечивает удаление точки контура d1 с помощью таблицы.
                for ( x=BufS[g]; x < BufS[g+1]; x++ ) {
                    // если точка контура d1 равна нулю, то ее не зачем удалять.
                    if (*(pw + x)!=0) {  // pw=bytes_data + w_1;   // w_1=(w+1);
                        p0=bytes_data+x;
                        /*
                         d9=*p0 & 1;         d2=*(p0+1) & 2;       d3=*(p0+2) & 4;
                         d8=*(p0+w) & 8;     d1=*(p0+w+1) & 1;     d4=*(p0+w+2) & 16;
                         d7=*(p0+w+w) & 32;  d6=*(p0+w+w+1) & 64;  d5=*(p0+w+w+2) & 128;   
                         */
                        // сборка байтового регистра rg0 из отдельных 8 бит матрици с помощью единичных масок
                        // rg0=d9 + d2 + d3 + d8 + d4 + d7 + d6 + d5;
                        rg0=(*(p0)&1) + (*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w+2)&16) + (*(p0+w+w)&32) + (*(p0+w+w+1)&64) + (*(p0+w+w+2)&128);                
                        if ( rg0>1 && table_2[rg0]==0 ) { *(p1+x)=0; } // time=0.66/2   // if ( table_2[rg0]==0 ) { *(p1+w+1)=0; } // time=0.7/2
                    } // if    
                } // x        
            } // g
            /**/
            
            // Как только удаление граничных точек слева и сверху перестанет изменять массив (все штрихи достигли пиксельной толщины), 
            // устанавливаем  флаг в в ноль.
            flag2=0; 
            for (y=y0; y < y1; y++){
                s=(y*w)/sf_rg;
                p0_64=bytes_data0_64 + s; 
                p1_64=bytes_data1_64 + s;
                for (x=x0; x < x1; x++){ // х управляет указателем на 64 (sf_rg)
                    if ( p0_64[x]!=p1_64[x] ) { flag2++; goto break2; } // goto break2; break;
                } // x 
            } // y 
        break2:;
            if (GrafT) cout<<" flag2="<<flag2;
            /**/
            
            // в массивах bytes_data и bytes_data_1 должны быть одни и те же данные.
            memcpy(bytes_data, bytes_data_1, w_h);  // адрес буфера назначения, адрес источника, количество байт для копирования
            
            // Как только удаление граничных точек слева и сверху, справа и внизу перестанет изменять массив, выходим из общего цикла по "n".
            if (flag1==0 && flag2==0) {break;}  
            
        } // n
        if (GrafT) { cout<<endl; cout<<"Окончание цикла по количеству удаленных слоев   n="<<n<<endl; }
        
        // фактическое количество удаленных слоев.
        min_RemovLayers=n;

        // визуализация серым фокальных линий (по 8 байт одновременно). ( внутренний формат программы 255-черный, 0-белый ).
        ///for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=(bytes_data0_64[x]>>1)&0x7F7F7F7F7F7F7F7F; } // деление на 2 и прим. 64 р маски.
        // Черное (255) становится серым (127), белое (0) остается белым.
        // 0x7F7F7F7F7F7F7F7F  64 р маска для деление на 2, маска убирает передвинувшиеся (при сдвиге) из соседних байт разряды.
        
        
        // приведение массива к общепринятому стандарту, 0-черный 255-белый ( внутренний формат программы 0-белый 255-черный ).
        // for ( x=0; x < w_h; x++ ) { if (bytes_data[x]>0) bytes_data[x]=0;  else bytes_data[x]=255; } // по 1 байту   //time=0.03  w_h=w*h=10 млн. пикселей
        for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data0_64[x]; } // по 8 байт одновременно  // time=0.005 w*h=10 млн. пикселей
        
        // создание серой подложки из исходного изображения для фокальной линии (графемы) букв. Не используем, переделано на 32
        //if (GrafT) {for ( x=0; x < w_h; x++ ){ bytes_data[x]=(bytes_data_2[x] + bytes_data[x])/2; }  }  // time=0.05 w*h=10 млн. пикселей
        
        // printToScreen(); exit(0);
        
        // Уменьшение изображения в "scaling" раз с сохранением площади черного. Если надо. Без серой подложки. // time=0.012  w*h=4 млн. пикселей
        // Изображение берем в bytes_data, сохраняем уменьшенное изображение в bytes_data_1 и копируем обратно в bytes_data.    
        if (scaling>1) {
            memset(bytes_data_1, 255, w_h); // заливка bytes_data_1 белым
            scaling=2; // int y;
            for (y=0; y < h; y++){          // time=0.012  w*h=4 млн. пикселей      
                p0=bytes_data + y*w;
                p1=bytes_data_1 + (y/scaling)*w;
                for (x=0; x < w; x++){ 
                    if (*(p0+x)==0) *(p1+x/scaling)=0; // 0-черный для общепринятого стандарта
                } // x                                 // 255-черный для внутреннего формата                
            } // y    
            memcpy(bytes_data, bytes_data_1, w_h);     // адрес буфера назначения, адрес источника, количество байт для копирования
        } // if 
        /**/
        
        /*    
         // тест области сравнения массивов bytes_data0_64 и bytes_data1_64
         for (y=y0; y < y1; y++){
         s=(y*w)/sf_rg;
         p0_64=bytes_data0_64 + s; 
         p1_64=bytes_data1_64 + s;
         for (int x=x0; x < x1; x++){
         p0_64[x]=0; 
         // *(p0_64+x)=0;
         } // x 
         } // y 
         */ 
        
        /*    
         // тест области работы алгоритма, эррозия работает только с черным в тексте.
         for ( g=0; g < sizeBufSR; g+=2 ) { 
         for ( x=BufS[g]; x < BufS[g+1]; x++ ) { bytes_data[x]*=0.5; } // 0-черный
         } // for
         */
        
        
        
        // освобождение массивов     
        if ( bytes_data_1 !=NULL ) free(bytes_data_1);
        if (GrafT) { if ( bytes_data_2 !=NULL ) free(bytes_data_2); }
        if ( BufS !=NULL ) free(BufS);
        
        
        // Возвращаемое функцией фактическое количество удаленных слоев. Вполне м.б. что функция вычислит фокальной линии (графемы) букв
        // за меньшее число тактов min_RemovLayers, чем ее было предложено на входе n_RemovLayers.
        return min_RemovLayers;
        
        
        //TIME_PRINT_   cout<<"TIME_PRINT_   фокальных линий   focalLine"<<endl;
        
        //---------------------------------------------------------------------------------------------------------
        
        //for ( x=0; x < w_h_ && g < sizeBufS; x++ ) {  // time=0.07  w*h=10 млн. пикселей 
        //////  int x0=(128*w)/sf_rg;     int x1=w_h_64-(128*w)/sf_rg-1;  // для цикла без отступов.
        ///     for ( x=x0; x < x1; x++ ) { if ( bytes_data0_64[x]!=bytes_data1_64[x] ) flag1++; }  cout<<" flag1="<<flag1;  // time=0.002  w*h=4 млн. pix
        ///     for ( x=x0; x < x1; x++ ) { if ( bytes_data0_64[x]!=bytes_data1_64[x] ) flag2++; }  cout<<" flag2="<<flag2;     
        
        //---------------------------------------------------------------------------------------------------------
        
        
        
    }//____________________________________________________________________________   
    
    
    /// TMP ///
    
    //*****************************************************************************
    
    // Функция стандартизации начертания текста путем определения фокальной линии (графемы) букв.
    // Удобно использовать в паре с функцией определения толщины штриха lineWidth().
    
    // Матрица (3*3-1) не вычисляется в белых пикселях, что в 2.8 раза быстрее, 
    // чем вычисляеть ее во всех пикселях подряд.    
    int  GBitmap::focalLineT(int n_RemovLayers) {
        
        // n_RemovLayers это количество удаленных слоев (слой это периметр символов графического текста) 
        // Обычно n_RemovLayers=7.  // number of removed layers
        
        // A Fast Parallel Algorithm for Thinning Digital Patterns. 
        // T. Y. ZHANG and C. Y. SUEN.
        // http://www-prima.inrialpes.fr/perso/Tran/Draft/gateway.cfm.pdf
        
        //  * Идея *
        // A Fast Parallel Algorithm for Thinning Digital Patterns. T. Y. ZHANG and C. Y. SUEN.
        
        //  * Особенности *
        // Функция потенциально не быстрая т.к. 14 раз пробегает весь исходный байтовый массив (при n_RemovLayers=7)
        // Можно пробегать сразу блоками по 64 pix, но это значительно более сложный код, примерно как в
        // функции "Полиграфическое растискивание dotGain()" за то на порядок быстрее.
        
        //  * Особенности применения *
        // Превышение количества удаленных слоев n_RemovLayers выше определенного значения не влияет на качество получаемой  
        // фокальной линии (графемы) букв, а приводит только к замедлению работы программы. Один удаленный слой    
        // (слой это периметр символа т.е. 2 pix) и это 2 единици толщины штриха. Необходимое количество удаленных слоев  
        // равно половине средней толщины штриха плюс еще одна половина средней толщины штриха, как компромисный запас 
        // на особо толстые линии в изображении. Окончательное значение n_RemovLayers равно средней толщине штриха в pix. 
        // Среднею толщину штриха по всему графическому тексту (изм. в десятых долях pix) можно получить с помощью
        // функции "Определение толщины штриха lineWidth()". Поэтому n_RemovLayers=line_wd/10;  где int line_wd=lineWidth()
        // Обычно компромисное значение количества удаленных слоев n_RemovLayers=7.
        
        
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if (GrafT) { cout<<"Функция определения фокальных линий букв (графем)   focalLineT() n_RemovLayers="<<n_RemovLayers<<endl; }
        
        //TIME_START
        
        int x,y;      
        int w,h;            
        w=ncolumns;  // ширина массива  IMAGE WIDTH
        h=nrows;     // высота массива  IMAGE HEIGHT
        int w_h=w*h; // длинна массива  IMAGE
        
        if (GrafT) { cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
        // w*h=4 млн. пикселей time=0.26 // w*h=10 млн.  time=0.68  // 4.3  w*h=39 млн., n_RemovLayers=15
        
        /// управляющие переменные ///                  
        int n_Lay=n_RemovLayers; // количество удаленных слоев (слой это периметр символа) n_Lay=7;
        int min_RemovLayers=n_RemovLayers; // возвращаемое функцией фактическое количество удаленных слоев.
        // Вполне м.б. min_RemovLayers < n_RemovLayers
        unsigned char scaling=1; // Уменьшение изображения фокальной линии (графемы) букв в "scaling" раз (2,3,4,5,...) с 
        // сохранением площади черного. Серая подложка не выводится. При scaling=1 выводится изображение 1:1 с серой подложкой. 
        //cout<<"n_Lay="<<(unsigned short)n_Lay<<endl;
        
        /// вспомогательные переменные
        int n=0;     // переменная по количеству удаленных слоев со всех сторон
        int m=0;
        int s;
        unsigned char rg0;  // байтовый регистр для хранения отдельных 8 бит маски
        unsigned char d2,d3,d4,d5,d6,d7,d8,d9; // d1,  // переменные маски
        unsigned char a,b,c,d; // переменные условий
        int flag1, flag2; // флаги попиксельного равенства исходнного и подвергнутого эррозии массивов, 
        // if (flag1==0 && flag2==0) при этом условии все штрихи достигают пиксельной толщины. 
        
        
        /// указатели
        unsigned char *p0=bytes_data;    // входной массив, 0-черный 255-белый ( с 0-черный 1-белый не работает)
        //unsigned char *pW;
        unsigned char *bytes_data_1, *p1;
        
        int sf_rg=sizeof(unsigned long);
        int w_h_64=w_h/sf_rg;  // sizeof(unsigned long)=8
        //cout<<"w_h="<<w_h<<"  (w_h_32)*32="<<(w_h_32)*32<<endl;
        
        // отступы от краев (бордюр) x0, x1, y0, y1, блокируют влияние грязи с краев текста на процесс остановки эрозии 
        // графической картинки по достижении однопиксельной толщины штриха. Возможный захват бордюром не большой части 
        // текста в данном случае не критичен т.к.эрозия графической картинки происходит все равно по всей площади текста.
        int br=8;   // величина отступа от краев, как часть высоты и ширины изображения (1/8).        
        int x0, x1, y0, y1; // отступы от краев (бордюр). 
        x0=(w/br)/sf_rg;  x1=(w-w/br-1)/sf_rg;  y0=h/br;  y1=h-h/br-1;
        
        if (GrafT) cout<<"sf_rg="<<sf_rg<<"  x0="<<x0<<"  x1="<<x1<<"  y0="<<y0<<"  y1="<<y1<<endl;    
        /**/  
        
        //   n_Lay=14;  // test
        
        
        unsigned int sizeBuf=w_h + 32 ;   
        // cout<<"w_h="<<w_h<<"  sizeBuf="<<sizeBuf<<endl;
        /// Массивы. 
        bytes_data_1 = (unsigned char*)malloc(sizeBuf); // p1
        //bytes_data_1 = (unsigned char*)calloc(sizeBuf,sizeof(unsigned char)); // Каждый элемент инициализируется в 0.
        unsigned char table_1[256];  // таблица для удаления граничных точек справа и внизу (снятие слоя точек справа и внизу) // 
        unsigned char table_2[256];  // таблица для удаления граничных точек слева и сверху (снятие слоя точек слева и сверху) //
        
        ///unsigned long *p0_64=(unsigned long*)bytes_data;    // приведение к unsigned int
        ///unsigned long *p1_64=(unsigned long*)bytes_data_1;  // приведение к unsigned int
        
        unsigned long *bytes_data0_64=(unsigned long*)bytes_data;    // приведение к unsigned long
        unsigned long *bytes_data1_64=(unsigned long*)bytes_data_1;  // приведение к unsigned long        
        unsigned long *p0_64, *p1_64;
        
        
        // матрица (маска) обсчета (3*3-1), где d1 центральной точка по которой принимается решение удалять - не удолять. 
        // d2, d3, d4, d5, d6, d7, d8, d9  точки окружения, по которым работает алгоритм принятия решения.
        /*   
         d9   d2   d3
         
         d8   d1   d4
         
         d7   d6   d5
         */
        
        // Создание предпросчитанных таблиц table_1 и table_2 по условию (a = 1) && (2 <= b <= 6) && (c = 0) && (d = 0)
        // В таблице table_2 по отношению к table_1 изменен только способ подсчета "c=d2*d4*d8" и "d=d2*d6*d8"    
        
        // цикл перебора всех возможных значений матрици (3*3-1)
        for (int index=0; index < 256; index++){ 
            rg0=index;
            
            // разборка байтового регистра на отдельные 8 бит
            d9=rg0 & 1;    d2=rg0>>1 & 1; d3=rg0>>2 & 1; d8=rg0>>3 & 1; 
            d4=rg0>>4 & 1; d7=rg0>>5 & 1; d6=rg0>>6 & 1; d5=rg0>>7 & 1;            
            // АЛГОРИТМ //            
            a=0; // "a" это число паттернов "01" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)  
            if(d3-d2>0)a++; if(d4-d3>0)a++; if(d5-d4>0)a++; if(d6-d5>0)a++; 
            if(d7-d6>0)a++; if(d8-d7>0)a++; if(d9-d8>0)a++; if(d2-d9>0)a++;    //  a = 1 - условие N1 
            // "b" это число ненулевых соседей центральной точки d1, т.е, она имеет по крайней мере, 2 ненулевых соседа, но не более 6.            
            b=d2+d3+d4+d5+d6+d7+d8+d9; //  2 <= b <= 6 - условие N2 
            // По крайней мере, одна из точек d2, d4, d6 являются фоновой
            c=d2*d4*d6;  //  c = 0 - условие N3 
            // По крайней мере, одна из точек d4, d6, d8 являются фоновой
            d=d4*d6*d8;  //  d = 0 - условие N4            
            // заполнение таблицы первой половины итерации (subiteration)
            if ( b<=6 && b>=2 && a==1 && c==0 && d==0 ) { table_1[rg0]=0; } else { table_1[rg0]=255; }
            
            // По крайней мере, одна из точек d2, d4, d8 являются фоновой
            c=d2*d4*d8;  //  c = 0 - условие N3 
            // По крайней мере, одна из точек d2, d6, d8 являются фоновой
            d=d2*d6*d8;  //  d = 0 - условие N4
            // заполнение таблицы второй половины итерации (subiteration)
            if ( b<=6 && b>=2 && a==1 && c==0 && d==0 ) { table_2[rg0]=0; } else { table_2[rg0]=255; }  
            
            //cout<<" "<<(unsigned short)table_2[index];
        } // for    
        if (GrafT) {cout<<endl;  cout<<"rg0="<<(unsigned short)rg0<<endl; }
        
        
        // создание массива и его заполнение для хранения серой подложки из исходного изображения для фокальной линии (графемы) букв
        unsigned char *bytes_data_2;
        if (GrafT) {                
            bytes_data_2 = (unsigned char*)malloc(sizeBuf); // p2            
            // копирование bytes_data в bytes_data_2
            memcpy(bytes_data_2, bytes_data, w_h);  // адрес буфера назначения, адрес источника, количество байт для копирования
        } // if
        
        // инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный 
        //for ( x=0; x < w_h; x++ ) { if (bytes_data[x]) bytes_data[x]=0;  else bytes_data[x]=255;} // по 1 байту  // else bytes_data[x]=1;
        for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data0_64[x]; } // по 8 байт одновременно
        
        // Для нормальной работы алгоритма перед началом цикла по "x" в массивах bytes_data и bytes_data_1 
        // должны быть одни и те же данные. В этом смысл всех memcpy() в данной программе.
        // копирование bytes_data в bytes_data_1  // time=0.003  w_h=w*h=10 млн. пикселей // time=0.003*14=0.042
        memcpy(bytes_data_1, bytes_data, w_h); 
        
        
        // вспомогательные переменные для предотвращения выхода за пределы массива
        int w_h_=w*h-(w+w+4)-(0);
        
        /// Цикл по количеству удаленных слоев со всех сторон. ///
        for ( n=0; n < n_Lay; n++ ) {
            
            // Удаление граничных точек справа и внизу (снятие одного слоя точек справа и внизу) //  
            // В первой половине итерации (subiteration), точка контура d1 удаляется из изображения,
            // если она удовлетворяет следующим условиям: (a = 1) && (2 <= b <= 6) && (c = 0) && (d = 0)
            // условие реализованно в виде предросчитанной таблицы table_1[]
            
            p0=bytes_data; p1=bytes_data_1; // m=0;  ///// p0=bytes_data+w+1;   p1=bytes_data_1+w+1;
            for ( x=0; x < w_h_; x++ ) {    // time=0.18/2  только цикл ( n_Lay=7, w*h=4 млн. пикселей ) 
                // если точка контура d1 равна нулю, то ее не зачем удалять.
                if (*(p0+w+1)==255) {       // d1=*(p0+w+1);    // в 2.8 быстрее  ///// p0=bytes_data-(w+1);
                    // сборка байтового регистра rg0 из отдельных 8 бит матрици с помощью единичных масок
                    rg0=(*(p0)&1) + (*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w+2)&16) + (*(p0+w+w)&32) + (*(p0+w+w+1)&64) + (*(p0+w+w+2)&128); // time=0.66/2
                    if ( rg0>1 && table_1[rg0]==0 ) { *(p1+w+1)=0; } // time=0.66/2               
                    //cout<<(unsigned short)*p0;
                } // if
                p0++;  p1++;  // m++;
            } // x
            /**/
            // Как только удаление граничных точек справа и внизу перестанет изменять массив (все штрихи достигли пиксельной толщины), устанавливаем  флаг в ноль.
            flag1=0; 
            for (y=y0; y < y1; y++){  // time=0.0003 w*h=4 млн. пикселей
                s=(y*w)/sf_rg;
                p0_64=bytes_data0_64 + s; 
                p1_64=bytes_data1_64 + s;
                for (int x=x0; x < x1; x++){ // x движется по 64
                    if ( p0_64[x]!=p1_64[x] ) { flag1++; goto break1; }  // goto break1;  break;
                } // x 
            } // y 
            break1:;
            if (GrafT) cout<<" flag1="<<flag1;
            /**/
            
            // в массивах bytes_data и bytes_data_1 должны быть одни и те же данные.        
            memcpy(bytes_data, bytes_data_1, w_h);  // адрес буфера назначения, адрес источника, количество байт для копирования
            
            // Как только удаление граничных точек слева и сверху, справа и внизу перестанет изменять массив, выходим из общего цикла по "n".
            if (flag1==0 && flag2==0) {break;}
            
            // Удаление граничных точек слева и сверху (снятие одного слоя точек слева и сверху) //
            // Во второй половине итерации (subiteration), точка контура d1 удаляется из изображения,
            // если она удовлетворяет следующим условиям: (a = 1) && (2 <= b <= 6) && (c = 0) && (d = 0)
            // условие реализованно в виде предросчитанной таблицы table_2[]
            // Во второй половине итерации (subiteration), изменились только следующии условия относящиеся к "c" и "d":    
            // d2 * d4 * d8 = 0     //  d2 * d6 * d8 = 0
            
            p0=bytes_data; p1=bytes_data_1;  // m=0; 
            for ( x=0; x < w_h_; x++ ) {
                // если точка контура d1 равна нулю, то ее не зачем удалять.
                if (*(p0+w+1)==255) {
                    /*
                     d9=*p0 & 1;         d2=*(p0+1) & 2;       d3=*(p0+2) & 4;
                     d8=*(p0+w) & 8;     d1=*(p0+w+1) & 1;     d4=*(p0+w+2) & 16;
                     d7=*(p0+w+w) & 32;  d6=*(p0+w+w+1) & 64;  d5=*(p0+w+w+2) & 128;   
                     */
                    // сборка байтового регистра rg0 из отдельных 8 бит матрици с помощью единичных масок
                    // rg0=d9 + d2 + d3 + d8 + d4 + d7 + d6 + d5;
                    rg0=(*(p0)&1) + (*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w+2)&16) + (*(p0+w+w)&32) + (*(p0+w+w+1)&64) + (*(p0+w+w+2)&128);
                    // if ( table_2[rg0]==0 ) { *(p1+w+1)=0; } // time=0.7/2
                    if ( rg0>1 && table_2[rg0]==0 ) { *(p1+w+1)=0; } // time=0.66/2
                } // if
                p0++;  p1++;  // m++;      
            } // x
            /**/
            // Как только удаление граничных точек слева и сверху перестанет изменять массив (все штрихи достигли пиксельной толщины), устанавливаем  флаг в в ноль.
            flag2=0; 
            for (y=y0; y < y1; y++){
                s=(y*w)/sf_rg;
                p0_64=bytes_data0_64 + s; 
                p1_64=bytes_data1_64 + s;
                for (int x=x0; x < x1; x++){
                    if ( p0_64[x]!=p1_64[x] ) { flag2++; goto break2; } // goto break2; break;
                } // x 
            } // y 
            break2:;
            if (GrafT) cout<<" flag2="<<flag2;
            /**/
            
            // в массивах bytes_data и bytes_data_1 должны быть одни и те же данные.
            memcpy(bytes_data, bytes_data_1, w_h);  // адрес буфера назначения, адрес источника, количество байт для копирования
            
            // Как только удаление граничных точек слева и сверху, справа и внизу перестанет изменять массив, выходим из общего цикла по "n".
            if (flag1==0 && flag2==0) {break;}  
            
        } // n
        cout<<endl;
        
        // фактическое количество удаленных слоев.
        min_RemovLayers=n;
        
        if (GrafT) {
            cout<<" flag1="<<flag1<<" flag2="<<flag2<<"  n="<<n<<endl;
            int m_max=w_h - m;
            cout<<"m_max="<<m_max<<"  w_h="<<w_h<<"  m="<<m<<endl;
            cout<<"x="<<x<<"  w_h_="<<w_h_<<"  m+(w+w+3)="<<m+(w+w+3)<<endl;
        }
        
        //TIME_START 
        // приведение массива к общепринятому стандарту, 0-черный 255-белый ( внутренний формат программы 0-белый 255-черный ). Переделать на 32
        //for ( x=0; x < w_h; x++ ) { if (bytes_data[x]>0) bytes_data[x]=0;  else bytes_data[x]=255; } // по 1 байту   //time=0.03  w_h=w*h=10 млн. пикселей
        for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data0_64[x]; } // по 8 байт одновременно
        
        // создание серой подложки из исходного изображения для фокальной линии (графемы) букв. Переделать на 32
        if (GrafT) {  for ( x=0; x < w_h; x++ ) {  bytes_data[x]=(bytes_data_2[x] + bytes_data[x])/2; }  } 
        
        
        // Уменьшение изображения в "scaling" раз с сохранением площади черного. Без серой подложки. // time=0.012  w*h=4 млн. пикселей
        // Изображение берем в bytes_data, сохраняем уменьшенное изображение в bytes_data_1 и копируем обратно в bytes_data.    
        if (scaling>1) {
            memset(bytes_data_1, 255, w_h); // заливка bytes_data_1 белым
            scaling=2; // int y;
            for (y=0; y < h; y++){          // time=0.012  w*h=4 млн. пикселей      
                p0=bytes_data + y*w;
                p1=bytes_data_1 + (y/scaling)*w;
                for (x=0; x < w; x++){ 
                    if (*(p0+x)==0) *(p1+x/scaling)=0; // 0-черный для общепринятого стандарта 
                } // x                                 // 255-черный для внутреннего формата                
            } // y    
            memcpy(bytes_data, bytes_data_1, w_h);     // адрес буфера назначения, адрес источника, количество байт для копирования
        } // if 
        /**/ 
        
        /*    
         // тест области применения  
         for (y=y0; y < y1; y++){
         s=(y*w)/sf_rg;
         p0_64=bytes_data0_64 + s; 
         p1_64=bytes_data1_64 + s;
         for (int x=x0; x < x1; x++){
         p0_64[x]=0; 
         // *(p0_64+x)=0;
         } // x 
         } // y 
         */ 
        
        //TIME_PRINT_
        
        // освобождение массивов     
        if ( bytes_data_1 !=NULL ) free(bytes_data_1);
        if (GrafT) { if ( bytes_data_2 !=NULL ) free(bytes_data_2); }
        
        // Возвращаемое функцией фактическое количество удаленных слоев. Вполне м.б. что функция вычислит фокальной линии (графемы) букв
        // за меньшее число тактов min_RemovLayers, чем ее было предложено на входе n_RemovLayers.
        return min_RemovLayers;
        
        
        //---------------------------------------------------------------------------------------------------------
        
        //////  int x0=(128*w)/sf_rg;     int x1=w_h_64-(128*w)/sf_rg-1;  // для цикла без отступов.
        ///     for ( x=x0; x < x1; x++ ) { if ( bytes_data0_64[x]!=bytes_data1_64[x] ) flag1++; }  cout<<" flag1="<<flag1;  // time=0.002  w*h=4 млн. pix
        ///     for ( x=x0; x < x1; x++ ) { if ( bytes_data0_64[x]!=bytes_data1_64[x] ) flag2++; }  cout<<" flag2="<<flag2;     
        
        
        // действующие тесты
        /*
         // d9  d2  d3
         // d8  d1  d4    
         // d7  d6  d5 
         
         ////d9=255; d2=255;
         ////rg0=(d9 & 1) + (d2 & 2) ;
         
         //rg0=d1 & 1; //rg0=d2 & 2 ;
         ///d9=1; d2=1; d3=1; d8=1; d4=1; d7=1; d6=1; d5=1;
         d9=255; d2=255; d3=255; d8=255; d4=255; d7=255; d6=255; d5=255;
         // сборка байтового регистра из отдельных 8 бит
         ///rg0=d9 + d2*2 + d3*4 + d8*8 + d4*16 + d7*32 + d6*64 + d5*128;  // 255
         rg0=(d9 & 1) + (d2 & 2) + (d3 & 4) + (d8 & 8) + (d4 & 16) + (d7 & 32) + (d6 & 64) + (d5 & 128);  // 255
         cout<<"rg0="<<(ushort)rg0<<endl;
         // разборка байтового регистра на отдельных 8 бит
         d9=rg0 & 1; d2=rg0>>1 & 1; d3=rg0>>2 & 1; d8=rg0>>3 & 1; d4=rg0>>4 & 1; d7=rg0>>5 & 1; d6=rg0>>6 & 1; d5=rg0>>7 & 1;
         
         cout<<"d9="<<(ushort)d9<<"  d2="<<(ushort)d2<<"  d3="<<(ushort)d3<<"  d8="<<(ushort)d8<<"  d4="<<(ushort)d4
         <<"  d7="<<(ushort)d7<<"  d6="<<(ushort)d6<<"  d5="<<(ushort)d5<<endl;
         // >>1==/2
         */
        
        //---------------------------------------------------------------------------------------------------------
        
        
        // bytes_data_32[d + x]=(0xFF000000*(s & 1) | s0) ^ invert;   s>>=1;
        
        ///int n01;
        ///n01=n-(n/2)*2;
        ///cout<<"n="<<n<<"   n-(n/2)*2="<<n-(n/2)*2<<endl;
        ///if(n01==0) { p0=bytes_data; p1=bytes_data_1; }  else { p1=bytes_data; p0=bytes_data_1; } 
        
        // if(s1!=s2) cout<<" s1="<<s1<<" s2="<<s2;;
        // cout<<" "<<s1<<"   "<<s2;  
        
        
    }//____________________________________________________________________________   
    
    
    
    
    //*****************************************************************************
    
    /// TMP ///
    // функция стандартизации начертания текста путем определения фокальной линии (графемы) букв.
    // Просчет матрицы происходит в теле цикла.
    
    int  GBitmap::focalLineT1(int n_RemovLayers) {
        
        
        // A Fast Parallel Algorithm for Thinning Digital Patterns. 
        // T. Y. ZHANG and C. Y. SUEN
        // http://www-prima.inrialpes.fr/perso/Tran/Draft/gateway.cfm.pdf
        
        
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if (GrafT) { cout<<"функция определения фокальных линий букв (графем)   focalLineT1()"<<endl; }
        
        ///TIME_START 
        
        int x;  //,y;   //
        int w,h;            
        w=ncolumns; // ширина массива  IMAGE WIDTH
        h=nrows;    // высота массива  IMAGE HEIGHT
        int w_h=w*h;
        
        if (GrafT) { cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
        
        /// управляющие переменные ///         
        int n_Lay=n_RemovLayers; // количество удаленных слоев (слой это периметр символа) n_Lay=7;
        int min_RemovLayers=n_RemovLayers; // возвращаемое функцией фактическое количество удаленных слоев.
        // Вполне м.б. min_RemovLayers < n_RemovLayers
        
        // вспомогательные переменные
        int n=0;     // переменная по количеству удаленных слоев со всех сторон
        int m=0;
        unsigned char d1,d2,d3,d4,d5,d6,d7,d8,d9; // переменные маски
        unsigned char a,b,c,d; // переменные условий
        
        /*
         d9   d2   d3
         
         d8   d1   d4
         
         d7   d6   d5
         */
        
        // вспомогательные переменные для увеличения быстродействия
        
        // указатели
        unsigned char *p0=bytes_data;    // входной массив, 0-черный 255-белый ( с 0-черный 1-белый не работает)
        //unsigned char *pW;
        unsigned char *bytes_data_1, *p1;
        
        unsigned int sizeBuf=w_h + 32 ;   // + 512
        cout<<"w_h="<<w_h<<"  sizeBuf="<<sizeBuf<<endl;
        /// Массивы. Каждый элемент инициализируется в 0.
        ///bytes_data_1 = (unsigned char*)calloc(sizeBuf,sizeof(unsigned char)); // p1
        
        
        bytes_data_1 = (unsigned char*)malloc(sizeBuf); // p1
        
        
        ///if (GrafT) {    
        unsigned char *bytes_data_2;
        bytes_data_2 = (unsigned char*)malloc(sizeBuf); // p2
        
        // копирование bytes_data в bytes_data_2
        memcpy(bytes_data_2, bytes_data, w_h);  // адрес буфера назначения, адрес источника, количество байт для копирования
        
        //    if ( bytes_data_2 !=NULL ) free(bytes_data_2);
        ///}
        
        for ( x=0; x < w_h; x++ ) { if (bytes_data[x]) bytes_data[x]=0;  else bytes_data[x]=1;} // x   
        
        // копирование bytes_data в bytes_data_1
        memcpy(bytes_data_1, bytes_data, w_h);  // адрес буфера назначения, адрес источника, количество байт для копирования
        // memset(bytes_data_1, 255, w_h);
        
        
        //TIME_START
        
        // вспомогательные переменные для предотвращения выхода за пределы массива
        int w_h_=w*h-(w+w+4)-(0);
        
        // цикл по количеству удаленных слоев со всех сторон
        for ( n=0; n < n_Lay; n++ ) {
            
            
            // Удаление граничных точек справа и внизу (снятие слоя точек справа и внизу) //  
            // В первой половине итерации (subiteration), точка контура d1 удаляется из изображения,
            // если она удовлетворяет следующим условиям:
            // (a = 1) && (2 <= b <= 6) && (c = 0) && (d = 0)
            
            p0=bytes_data; p1=bytes_data_1;   m=0;
            for ( x=0; x < w_h_; x++ ) {                
                //cout<<(unsigned short)*p0;            
                
                d9=*p0;        d2=*(p0+1);      d3=*(p0+2);
                d8=*(p0+w);    d1=*(p0+w+1);    d4=*(p0+w+2);
                d7=*(p0+w+w);  d6=*(p0+w+w+1);  d5=*(p0+w+w+2);   //p0++;
                /**/
                /*
                 d9=*p0;  d2=*(p0+1);  d3=*(p0+2);     pW=p0+w;  // d9=*p0;        d2=*(p0+1);      d3=*(p0+2);
                 d8=*pW;  d1=*(pW+1);  d4=*(pW+2);     pW+=w;    // d8=*(p0+w);    d1=*(p0+w+1);    d4=*(p0+w+2);
                 d7=*pW;  d6=*(pW+1);  d5=*(pW+2);   //p0++;     // d7=*(p0+w+w);  d6=*(p0+w+w+1);  d5=*(p0+w+w+2);   p0++;
                 */
                
                // "a" это число паттернов "01" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)
                a=0;   
                if(d3-d2>0)a++; if(d4-d3>0)a++; if(d5-d4>0)a++; if(d6-d5>0)a++; 
                if(d7-d6>0)a++; if(d8-d7>0)a++; if(d9-d8>0)a++; if(d2-d9>0)a++;    //  a = 1 - условие N1 
                // "b" это число ненулевых соседей центральной точки d1, то есть, она имеет по крайней мере, 2 ненулевых соседа, но не более 6.            
                b=d2+d3+d4+d5+d6+d7+d8+d9; //  2 <= b <= 6 - условие N2 
                // По крайней мере, одна из точек d2, d4, d6 являются фоновой
                c=d2*d4*d6;  //  c = 0 - условие N3 
                // По крайней мере, одна из точек d4, d6, d8 являются фоновой
                d=d4*d6*d8;  //  d = 0 - условие N4                        
                ///            if ( b<=6 && b>=2 && a==1 && c==0 && d==0 ) { *(p1+w+1)=255; }  // else { *(p1+w+1)=0; }  // 0-черный 255-белый // *(p0-1)=1;
                if ( b<=6 && b>=2 && a==1 && c==0 && d==0 ) { *(p1+w+1)=0; } // 0 - белый,  255 - черный
                
                p0++;  p1++;   m++;
                
                ///cout<<"a="<<a<<"  b="<<b<<"  c="<<c<<"  d="<<d<<endl;
            } // x
            /**/
            memcpy(bytes_data, bytes_data_1, w_h);  // адрес буфера назначения, адрес источника, количество байт для копирования
            
            // Удаление граничных точек слева и сверху (снятие слоя точек слева и сверху) //
            // Во второй половине итерации (subiteration), точка контура d1 удаляется из изображения,
            // если она удовлетворяет следующим условиям:
            // (a = 1) && (2 <= b <= 6) && (c = 0) && (d = 0)
            // Во второй половине итерации (subiteration), изменились только следующии условия относящиеся к "c" и "d":    
            //  d2 * d4 * d8 = 0     //  d2 * d6 * d8 = 0      
            
            p0=bytes_data; p1=bytes_data_1;   m=0;
            for ( x=0; x < w_h_; x++ ) {                           
                
                d9=*p0;        d2=*(p0+1);      d3=*(p0+2);
                d8=*(p0+w);    d1=*(p0+w+1);    d4=*(p0+w+2);
                d7=*(p0+w+w);  d6=*(p0+w+w+1);  d5=*(p0+w+w+2);   //p0++;
                /**/
                /*
                 d9=*p0;  d2=*(p0+1);  d3=*(p0+2);     pW=p0+w;  // d9=*p0;        d2=*(p0+1);      d3=*(p0+2);
                 d8=*pW;  d1=*(pW+1);  d4=*(pW+2);     pW+=w;    // d8=*(p0+w);    d1=*(p0+w+1);    d4=*(p0+w+2);
                 d7=*pW;  d6=*(pW+1);  d5=*(pW+2);   //p0++;     // d7=*(p0+w+w);  d6=*(p0+w+w+1);  d5=*(p0+w+w+2);   p0++;
                 */
                
                // "a" это число паттернов "01" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)
                a=0;   
                if(d3-d2>0)a++; if(d4-d3>0)a++; if(d5-d4>0)a++; if(d6-d5>0)a++; 
                if(d7-d6>0)a++; if(d8-d7>0)a++; if(d9-d8>0)a++; if(d2-d9>0)a++;    //  a = 1 - условие N1 
                // "b" это число ненулевых соседей центральной точки d1, то есть, она имеет по крайней мере, 2 ненулевых соседа, но не более 6           
                b=d2+d3+d4+d5+d6+d7+d8+d9; //  2 <= b <= 6 - условие N2 
                // По крайней мере, одна из точек d2, d4, d8 являются фоновой
                c=d2*d4*d8;  //  c = 0 - условие N3 
                // По крайней мере, одна из точек d2, d6, d8 являются фоновой
                d=d2*d6*d8;  //  d = 0 - условие N4
                ///cout<<"a="<<a<<"  b="<<b<<"  c="<<c<<"  d="<<d<<endl;            
                if ( b<=6 && b>=2 && a==1 && c==0 && d==0 ) { *(p1+w+1)=0; }  // else { *(p1+w+1)=0; } // 0 -белый  // 0-черный 255-белый // *(p0-1)=1;
                
                p0++;  p1++;   m++;
                
            } // x
            /**/ 
            memcpy(bytes_data, bytes_data_1, w_h);  // адрес буфера назначения, адрес источника, количество байт для копирования
            
        } // n
        
        
        int m_max=w_h - m;
        // m_max=*(bytes_data - p0);
        cout<<"m_max="<<m_max<<"  w_h="<<w_h<<"  m="<<m<<endl;
        cout<<"x="<<x<<"  w_h_="<<w_h_<<"  m+(w+w+3)="<<m+(w+w+3)<<endl;
        
        //TIME_START
        // копирование bytes_data в bytes_data_1 // time=0.003  w_h=w*h=10 млн. пикселей // time=0.003*14=0.042
        memcpy(bytes_data, bytes_data_1, w_h);   // адрес буфера назначения, адрес источника, количество байт для копирования  
        
        for ( x=0; x < w_h; x++ ) { if (bytes_data[x]) bytes_data[x]=0;  else bytes_data[x]=255; } // x   //time=0.03  w_h=w*h=10 млн. пикселей
        
        // создание серой подложки из исходного изображения для фокальной линии (графемы) букв
        if (GrafT) {  for ( x=0; x < w_h; x++ ) {  bytes_data[x]=(bytes_data_2[x] + bytes_data[x])/2; }  } 
        
        /*
         memset(bytes_data_1, 255, w_h);
         ////for ( x=0; x < w_h; x++ ) { if (bytes_data[x]==0) bytes_data_1[x/4]=0; } // bytes_data[x/2]=bytes_data[x];
         // уменьшение изображения в "m" раз с сохранением площади черного
         m=2;
         for (y=0; y < h; y++){       // 16224 × 2464 // time=0.00      
         p0=bytes_data + y*w;
         p1=bytes_data_1 + (y/m)*w;
         for (x=0; x < w; x++){ 
         if (*(p0+x)==0) *(p1+x/m)=0;
         } // x 
         } // y    
         memcpy(bytes_data, bytes_data_1, w_h);   // адрес буфера назначения, адрес источника, количество байт для копирования
         */ 
        
        //TIME_PRINT_
        
        
        // освобождение массивов     
        if ( bytes_data_1 !=NULL ) free(bytes_data_1);
        //if (GrafT) { if ( bytes_data_2 !=NULL ) free(bytes_data_2); }
        
        // Возвращаемое функцией фактическое количество удаленных слоев. Вполне м.б. что функция вычислит фокальной линии (графемы) букв
        // за меньшее число тактов min_RemovLayers, чем ее было предложено на входе n_RemovLayers.
        return min_RemovLayers;
        
        
        //d9   d2   d3
        //d8   d1   d4    
        //d7   d6   d5 
        
        d9=1; d2=1; d3=1; d8=1; d4=1; d7=1; d6=1; d5=1; 
        int rg0=d9 + d2*2 + d3*4 + d8*8 + d4*16 + d7*32 + d6*64 + d5*128;  // 255
        cout<<"rg0="<<rg0<<endl;
        d9=rg0 & 1; d2=rg0>>1 & 1; d3=rg0>>2 & 1; d8=rg0>>3 & 1; d4=rg0>>4 & 1; d7=rg0>>5 & 1; d6=rg0>>6 & 1; d5=rg0>>7 & 1;
        cout<<"d9="<<d9<<"  d2="<<d2<<"  d3="<<d3<<"  d8="<<d8<<"  d4="<<d4<<"  d7="<<d7<<"  d6="<<d6<<"  d5="<<d5<<endl;
        // >>1==/2
        
        //unsigned char c1,c2,d1,d2;
        unsigned char table_1[255];  // таблица для удаления граничных точек справа и внизу (снятие слоя точек справа и внизу) // 
        unsigned char table_2[255];  // таблица для удаления граничных точек слева и сверху (снятие слоя точек слева и сверху) //
        
        for (int index=0; index < 256; index++){ 
            rg0=index;
            d9=rg0 & 1;    d2=rg0>>1 & 1; d3=rg0>>2 & 1; d8=rg0>>3 & 1; 
            d4=rg0>>4 & 1; d7=rg0>>5 & 1; d6=rg0>>6 & 1; d5=rg0>>7 & 1;
            // "a" это число паттернов "01" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)
            a=0;   
            if(d3-d2>0)a++; if(d4-d3>0)a++; if(d5-d4>0)a++; if(d6-d5>0)a++; 
            if(d7-d6>0)a++; if(d8-d7>0)a++; if(d9-d8>0)a++; if(d2-d9>0)a++;    //  a = 1 - условие N1 
            // "b" это число ненулевых соседей центральной точки d1, то есть, она имеет по крайней мере, 2 ненулевых соседа, но не более 6.            
            b=d2+d3+d4+d5+d6+d7+d8+d9; //  2 <= b <= 6 - условие N2 
            // По крайней мере, одна из точек d2, d4, d6 являются фоновой
            c=d2*d4*d6;  //  c = 0 - условие N3 
            // По крайней мере, одна из точек d4, d6, d8 являются фоновой
            d=d4*d6*d8;  //  d = 0 - условие N4                        
            if ( b<=6 && b>=2 && a==1 && c==0 && d==0 ) { table_1[index]=1; } else { table_1[index]=0; }
            // По крайней мере, одна из точек d2, d4, d8 являются фоновой
            c=d2*d4*d8;  //  c = 0 - условие N3 
            // По крайней мере, одна из точек d2, d6, d8 являются фоновой
            d=d2*d6*d8;  //  d = 0 - условие N4 
            if ( b<=6 && b>=2 && a==1 && c==0 && d==0 ) { table_2[index]=1; } else { table_2[index]=0; }
            
            cout<<(unsigned short)table_2[index];
        } //
        cout<<endl;
        
        
        //int d1=0,d2=0,d3=0,d4=0,d5=0,d6=0,d7=0,d8=0,d9=0;
        //int a=0,b=0,c=0,d=0;
        
        /// int n01;
        ///n01=n-(n/2)*2;
        ///cout<<"n="<<n<<"   n-(n/2)*2="<<n-(n/2)*2<<endl;
        ///if(n01==0) { p0=bytes_data; p1=bytes_data_1; }  else { p1=bytes_data; p0=bytes_data_1; } 
        ///if(n01==0) { p0=bytes_data; p1=bytes_data_1; }  else { p1=bytes_data; p0=bytes_data_1; }
        
        
        
        //TIME_PRINT_
        
    }//____________________________________________________________________________  
    
    
    
    
    
    
    
    
}