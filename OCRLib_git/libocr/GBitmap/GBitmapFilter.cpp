//  OCRLib  2015 www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  Will Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .

#include "GBitmap.h"
//#include <smmintrin.h> // для =_mm_popcnt_u64(ss);


namespace ocr{
    
    
    // действующая версия // (вторая, основная)
    
    /// ГОТОВАЯ fast version Gaussian (blur) ///
    
//*****************************************************************************
    
// функция размытия (blur) массива bytes_data двухмерным Гауссианом ( Gaussian ).
    
void  GBitmap::gaussian(int amplitude) {
        
        // ss "ширина" (amplitude) Гауссиана в пикселях. Физический смысл, "ss" это область усреднения с весами близкими к Гауссиану. 
        // Входной массив bytes_data может быть: как серым от 0-черного до 255-белого, так и черно-белым: 0-черный 255-белый.
        // На выходе bytes_data всегда серый. 
        // bytes_data это unsigned char
        
        //  * Идея 1 *  пока не реализовано
        // Адаптивное сглаживание.
        // Идея состоит в том, что степень сглаживания графического текста обратно пропорциональна степени
        // "курчавости" текста (числу Мадельброта) вычесленному в небольшой области вокруг каждой точки графического текста.
        //  * Реализация *
        // Скользящия квадратная область S*S пробегает по всему исходному битовому массиву.
        // Для каждой точки этого массива в квадратной области S*S вычисляется две величины:
        // - площадь ( суммарное количество черных пикселей попавших в область S*S )
        // - длинна периметра или контура ( суммарное количество переходов из черного в белое и из белого в черное,
        // попавших в область S*S, по вертикали и по горизонтали ). Вычисляется сдвигом битового регистра длинной в w*h
        // Отношение длинны периметра (контура) к площади называется числом Мадельброта
        // Адаптивно сглаживаем картинку с управлением от вычисленного числа Мадельброта.
        // Для увеличения быстродействия величины площади и длинны периметра вычисляются по предпросчитанному интегрольному массиву.
        // В этой функции эта идея не реализованна.
        
        //  * Идея 2 * реализована в этой фунции
        /// Теория размытия (blur) битового массива (изображения) двухмерным Гауссианом. Реализованна функция. ///
        // Двухмерный Гауссиан использует фиксированную область усредннения в пикселях, где ss ее "ширина"
        // Одномерные фильтры с прямоугольной и треугольной импульсной характеристикой (где k это ss):
        // -прямоугольная рекурсивная весовая функция. Соответствует одномерному фильтру с прямоугольной импульсной характеристикой
        // y(n)=y(n-1)+x(n)-x(n-2k-1)
        // -треугольная рекурсивная весовая функция. Соответствует одномерному фильтру с треугольной импульсной характеристикой
        // y(n)=-y(n-2)+2y(n-1)+x(n-2k-2)-2x(n-k-1)+x(n)
        // Импульсная характеристика фильтра это его реакция на еденичный импульс. Ее удобно применять для отладки фильтра.
        // Рекурсивная весовая функция это удобная форма для дискретной (програмной) реализации соответствующего фильтра.
        // Если к одному и тому же массиву данных применить два раза подряд фильтр с треугольной импульсной характеристикой,
        // то это эквивалентно применению фильтра с гладкий импульсной характеристикой практически точно совпадающий
        // по форме с одномерным Гауссианом ( Gaussian ).
         
        // Если к двухмерному массиву данных применить одномерный Гауссианом сначала по горизонтали, а затем по вертикали,
        // то это эквивалентно применению двухмерного Гауссиана.
        // Для увеличения быстродействия, удобнее сначала выполнять горизонтальный прогон Гауссом, затем транспонировать массив,
        // опять горизонтальный прогон Гауссом и снова транспонирование массива ( транспонировать, т.е. поворачивать на +90°).
        
        
///     TIME_START
        // time=2.14 сек   w=16224 × h=2464  w*h=40 млн пикселей  //  (w=2698 h=4000)
        // time=0.63 сек   w=2621  × h=3979  w*h=10 млн пикселей
        // time=0.22 сек   w=3491  × h=1017  w*h=3.5 млн пикселей
        // первые "ss" и последние "ss" пикселей изображения в этой версии защищены от краевых эффектов
        // за счет создания защитных областей pr2_w в начале и в конце всех массивов.
        
        if(amplitude==0)return;
        
        int x,y;
        int w,h;
        w=ncolumns; // ширина массива  IMAGE WIDTH в пикселях
        h=nrows;    // высота массива  IMAGE HEIGHT в пикселях
        int w_h=w*h;
        unsigned char *p0=bytes_data; // входной и выходной массив, для черно белых изображений p0=0,255 или серых p0=0-255;
        int ss=amplitude;  // "ss" зто "ширина" области усредннения Гауссиана в пикселях.
        int w_;
        // вспомогательные переменные для увеличения быстродействия
        int wh_ss2, wh_ss4;
    
        // Ограничения на размер области усреднения ss
        if ( ss<=2 ) ss=2;   if ( ss>64 ) ss=64;    
        //ss=4;  // test // 
    
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    
        if (GrafT) {
            cout<<"Сглаживание (blur) Гауссианом gaussian()    amplitude="<<amplitude<<endl;
            cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; 
        }

    
        // Вычисление величины защитной области pr2_w в начале и в конце всех массивов. 
        int pr1=ss*2+8;  // protection area // после отладки сделать ss*2+8; (во время отладки ss*1+2;)
        int pr2=pr1*2;
        int pr2_w=(pr2/w)*w + w; // защитная область должна быть кратна "w" и не может быть меньше "w".
        ///int pr2_w4=pr2_w*sizeof(unsigned int); // для массивов ReBuf и ImBuf
        if (GrafT) cout<<"ширина области усредннения  ss="<<ss<<",  защитная область  pr2="<<pr2<<",  защитная область кратная w   pr2_w="<<pr2_w<<endl;    
        
        // размер массивов в байтах sizeBuf, это размер исходного массива плюс  
        // две защитные области pr2_w в начале и в конце массива.
        unsigned int sizeBuf=w_h + pr2_w + pr2_w; // sizeBuf количество элементов в массиве
        ///unsigned int sizeBuf4=sizeBuf*sizeof(unsigned int); // длинна массива в байтах
        if (GrafT) cout<<"размер исходного массива в байтах   w_h="<<w_h<<",   размер массивов с защитными областями sizeBuf="<<sizeBuf<<endl;
    
        // масштабирующие коэффициенты необходимы для уменьнения динамического диапазона размытого серого
        // до динамического диапазона байта (0-255) после применения Гауссиана.
        int ss_2=ss*2;
        int ss_m2=ss*ss;
        int ss_m3=ss_m2*ss;
        int ss_m4=ss_m3*ss; // реально использыется только этот, остальные ныщны для отладки.
        if (GrafT)cout<<"масштабирующий коэффициент для уменьнения динамического диапазона серого  ss_m4="<<ss_m4<<endl;
        
        // указатели
        unsigned char* bytes_data_1, *p1;
        unsigned char* bytes_data_2, *p2;
        unsigned int* ReBuf, *d1;
        unsigned int* ImBuf, *d2;
        
        // Массивы. Каждый элемент инициализируется в 0.
        bytes_data_1 = (unsigned char*)calloc(sizeBuf,sizeof(unsigned char)); // p1
        bytes_data_2 = (unsigned char*)calloc(sizeBuf,sizeof(unsigned char)); // p2
        ReBuf = (unsigned int*)calloc(sizeBuf,sizeof(unsigned int)); // d1
        ImBuf = (unsigned int*)calloc(sizeBuf,sizeof(unsigned int)); // d2        
        // calloc(n,size); unsigned n; 
        // количество элементов unsigned size; длина каждого элемента в байтах // lalloc=(long*)calloc(40, sizeof(long));
    
        ///ImBuf = (unsigned short*)malloc(sizeBuf); // d1
        ///ReBuf = (unsigned short*)malloc(sizeBuf); // d2
    
    // test memset //                   
    ///memset(ReBuf, 0, 4*sizeBuf);   /// d1==ReBuf; ImBuf==d2  // sizeBuf количество элементов    //////////////////////////////////////
    ///memset(ReBuf, 0, 4*pr2_w);     memset(ReBuf + pr2_w + w_h, 0, 4*pr2_w); 
    // начало (указатель), значение одного байта, количество символов в байтах (длинна) unsigned
    // for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<ReBuf[x]; if ((x+1)%32==0)cout<<endl; } // x

        /*
        int sf_rg=sizeof(unsigned long);
        int w_h_64=w_h/sf_rg;  // sizeof(unsigned long)=8
        unsigned long *bytes_data0_64=(unsigned long*)bytes_data;    // приведение к unsigned long
        unsigned long *bytes_data1_64=(unsigned long*)bytes_data_1;  // приведение к unsigned long 
        unsigned long *bytes_data2_64=(unsigned long*)bytes_data_2;  // приведение к unsigned long
        //unsigned long *p0_64, *p1_64;
        */
    
        // тест //       
        ////memset(bytes_data, 0, w_h);    // тест черная плашка 
        //  memset(bytes_data, 255, w_h);  // тест белая  плашка
    
        // инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный
        for ( x=0; x < w_h; x++ ){ bytes_data_1[x+pr2_w]=~bytes_data[x]; }
        ///for ( x=0; x < w_h_64; x++ ) { bytes_data1_64[x+pr2]=~bytes_data0_64[x]; } // инвертируем по 8 байт одновременно 
        // инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 1-черный
        ///for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data0_64[x] & 0x1010101010101010; } // обрабатываем по 8 байт одновременно 
    
    

        /// Горизонтальное размытие (blur) одномерным Гауссианом двухмерного массива данных (изображения) ///

        // Горизонтальное применение прямой треугольной весовой функции        
        p1=bytes_data_1 + pr2_w;   d1=ReBuf + pr2_w;  // pr1=ss*1+2;
        wh_ss2=w_h + ss_2;
        for ( x=0; x < wh_ss2; x++ ) {    // time=0.41 16224 × 2464  // ss_2=ss*2;            
            // треугольная весовая функция, прямая фильтрация
            // ReBuf[x]=-ReBuf[x-2]+2*ReBuf[x-1+ImBuf[x-2*s ]-2*ImBuf[x-ss]+ImBuf[x];
            *d1=-*(d1-2)+(*(d1-1)<<1)+*(p1-ss_2)-(*(p1-ss)<<1)+*p1;       // <<1=2*
            //cout<<" "<<(unsigned short)*d1;
            p1++;   d1++;  // p0=bytes_data_1+x;   d1=ReBuf+x;               
        } // x    
///        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<ReBuf[x]/ss_m2; if ((x+1)%32==0)cout<<endl; } // x

                
        // Горизонтальное применение инверсной треугольной весовой функции     
        p2=bytes_data_2 + w_h + pr2_w + ss_2;   d1=ReBuf + w_h + pr2_w + ss_2;   d2=ImBuf + w_h + pr2_w + ss_2;
        wh_ss4=w_h + ss_2 + ss_2;
        for ( x=wh_ss4; x > 0; x-- ) { // time=0.53 16224 × 2464   // ss_2=ss*2;                        
            // треугольная весовая функция, инверсная фильтрация
            // ImBuf[x]=-ImBuf[x+2]+2*ImBuf[x+1]+ReBuf[x+ss_2]-2*ReBuf[x+ss]+ReBuf[x];
            *d2=-*(d2+2)+(*(d2+1)<<1)+*(d1+ss_2)-(*(d1+ss)<<1)+*d1;          // <<1=2*
            // уменьнение динамического диапазона размытого серого до динамического диапазона байта (0-255)
            *p2=*d2/ss_m4;   
            //cout<<" "<<(unsigned short)*p2;
            p2--;  d1--;  d2--; // p2=bytes_data+x;   d1=ReBuf+x;   d2=ImBuf+x;            
        } // x
///        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<(unsigned short)bytes_data_2[x]; if ((x+1)%32==0)cout<<endl; } // x
        ///TIME_PRINT_
        /**/

                
        
        ///TIME_START 
        // реально это не поворот на -90°, а зеркальный flip.
        // Поворот на -90°. Переупаковка (транспонирование) горизонтального массива строк в массив вертикальных строк.
        p2=bytes_data_2 + pr2_w;   p1=bytes_data_1 + pr2_w; /// сдвигаем в начало массива p2 на + pr2_w   /// сдвигаем обратно в массиве p1 на + pr2_w 
        for ( x=0; x < w; x++ ) {    // time=0.37  
            for ( y=0; y < w_h; y+=w ){ /// sizeBuf   w_
                //*(p1 + index_)=*(p2 + x + y);  index_++;  // index_+=dlt; int dlt=1; 
                *p1=*(p2+y);  p1++; // p1++;  сквозной индекс в цикле переупаковки    
                // *p1=*(p2+y); cout<<" "<<(unsigned short)*p1;  p1++;     // *p1=*p0;   p1++;  p0+=w;
            } // y 
          p2++; // +x
        } // x
///        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<(unsigned short)bytes_data_1[x]; if ((x+1)%32==0)cout<<endl; } // x // sizeBuf  w_h    
        ///TIME_PRINT_
        /**/   
        
        
         /*
         // ТЕСТ, поворот еще на +90° до +180°
         int w_=h;   // int h_=w;    // меняем местами w и h по любому
         //p2=bytes_data_2;   d1=ReBuf;       // возвращение в исходное положение
         p2=bytes_data_2;   p1=bytes_data_1;  // поворот еще на +90° до +180°, тест
         unsigned int index_=w_h; // сквозной индекс в цикле переупаковки
         for ( x=0; x < w_; x++ ) {    // time=0.45=0.25
             p1++; // +x
             for ( y=0; y < w_h; y+=w_ ){
                 // *(p2 + index_)=*(d1 + x + y);  index_--; // index_+=dlt; int dlt=1;
                 // *p2=*(d1+y) ;   p2++; // d1++;  // возвращение в исходное положение
             *p2=*(p1+y) ;   p2--; // d1++;    // поворот еще на +90°, до +180°, тест
            } // y
         } // x             
        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<(unsigned short)bytes_data_2[x]; if ((x+1)%32==0)cout<<endl; } // x
        */
    
        
        //*******************************************************************************************
        
        
        /// Вертикальное размытие (blur) одномерным Гауссианом двухмерного массива данных (изображения) ///
        
        ///TIME_START
    
        // обязательное обнуление // d1    
        memset(ReBuf, 0, sizeBuf*4);   /// d1==ReBuf; ImBuf==d2  // sizeBuf количество элементов   /////////////////////////////////////////
        ///memset(ReBuf, 0, pr2_w*4);     memset(ReBuf + pr2_w + w_h, 0, pr2_w*4);
        // начало (указатель), значение одного байта, количество символов в байтах (длинна) unsigned
///        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<ReBuf[x]/ss_m2; if ((x+1)%32==0)cout<<endl; }
        
        
        // обязательное обнуление начального участка массива bytes_data_1 от 0 до pr2_w, для чистого старта рекурсивного фильтра    
        memset(bytes_data_1, 0, pr2_w);    // p1    
        // обязательное обнуление конечного участка массива bytes_data_1 от pr2_w + w_h до sizeBuf, для чистого старта рекурсивного фильтра
        memset(bytes_data_1 + pr2_w + w_h, 0, pr2_w);     
///        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<(unsigned short)bytes_data_1[x]; if ((x+1)%32==0)cout<<endl; } // x // sizeBuf  w_h

    
        // Вертикальное применение прямой треугольной весовой функции

        p1=bytes_data_1 + pr2_w;   d1=ReBuf + pr2_w;
        wh_ss2=w_h + ss_2;
        for ( x=0; x < wh_ss2; x++ ) {    // time=0.26  16224 × 2464
            // треугольная весовая функция, прямая фильтрация
            // ReBuf[x]=-ReBuf[x-2]+2*ReBuf[x-1+ImBuf[x-2*s ]-2*ImBuf[x-ss]+ImBuf[x];
            *d1=-*(d1-2)+(*(d1-1)<<1)+*(p1-ss_2)-(*(p1-ss)<<1)+*p1;       // <<1=2*
            ///cout<<" "<<(unsigned short)*d1;
            p1++;   d1++;  // p0=bytes_data_1+x;   d1=ReBuf+x;               
        } // x
///        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<ReBuf[x]/ss_m2; if ((x+1)%32==0)cout<<endl; } // x
        ///TIME_PRINT_

        ///TIME_START
        // Не обязательное обнуление начального и конечного участка массива  bytes_data_2  // p2
        memset(bytes_data_2, 0, pr2_w);     memset(bytes_data_2 + pr2_w + w_h, 0, pr2_w);        
        // Не обязательное обнуление начального и конечного участка массива ImBuf  /// ImBuf=d2;  d1=ReBuf; 
        memset(ImBuf, 0, pr2_w*4);     memset(ImBuf + pr2_w + w_h, 0, pr2_w*4);       

            
        // Вертикальное применение инверсной треугольной весовой функции
    
        p2=bytes_data_2 + w_h + pr2_w + ss_2;   d1=ReBuf + w_h + pr2_w + ss_2;   d2=ImBuf + w_h + pr2_w + ss_2;
        wh_ss4=w_h + ss_2 + ss_2;
        for ( x=wh_ss4; x > 0; x-- ) { // time=0.32  16224 × 2464        
            // треугольная весовая функция, инверсная фильтрация
            // ImBuf[x]=-ImBuf[x+2]+2*ImBuf[x+1]+ReBuf[x+ss_2]-2*ReBuf[x+ss]+ReBuf[x];
            *d2=-*(d2+2)+(*(d2+1)<<1)+*(d1+ss_2)-(*(d1+ss)<<1)+*d1;          // <<1=2*
            // уменьнение динамического диапазона размытого серого до динамического диапазона байта (0-255)
            *p2=*d2/ss_m4; // для внутреннего формата программы 0-белый 255-черный   // *p0=(d*255)/ss_m3;            
            p2--;  d1--;  d2--; // p2=bytes_data+x;   d1=ReBuf+x;   d2=ImBuf+x;        
        } // x
///        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<(unsigned short)bytes_data_2[x]; if ((x+1)%32==0)cout<<endl; } // x
    
        
        // *******************************************************************************************
        /**/
    
        
        ///TIME_START
        // Поворот на +90°. Возвращаем в исходное положение и записываем в исходный массив bytes_data
        w_=h; //int n=0;  // меняем местами w и h по любому    // int w_=h;  int h_=w;
        p0=bytes_data;   p2=bytes_data_2 + pr2_w;  // index_=0;  ///  + pr2_w  сдвигаем в начало массива
        for ( x=0; x < w_; x++ ) {    // time=0.25
            for ( y=0; y < w_h; y+=w_ ){ // w_h
                // *(p0 + index_)=*(p2 + x + y);  index_--; // index_+=dlt; int dlt=1;
                // за одно выполняем инверсию "~" и записываем результат в исходный массив p0
                *p0=~(*(p2+y));   p0++; // n++; // p0++;  сквозной индекс в цикле переупаковки 
            } // y
            p2++; // +x
        } // x 
        ///        for ( x=0; x < w_h; x++ ) { cout<<" "<<(unsigned short)bytes_data[x]; if ((x+1)%32==0)cout<<endl; } // x
        //cout<<"n="<<n<<endl;
        /**/
    
        // инверсия уровней "~" необходима для преобразования внутреннего формата программы 0-белый (1-255)-серый в 
        // общепринятый стандарт 0-черный (1-255)-серый для выходного массива bytes_data
    
        // заполняем нулями технологический бордюр в 2 пиксела внизу изображения
        memset(bytes_data+ncolumns*nrows-ncolumns*2, 255, ncolumns*2);
    
    
        // освобождение массивов bytes_data_1, bytes_data_2, ImBuf,  ReBuf
        if ( bytes_data_1 !=NULL ) free(bytes_data_1);
        if ( bytes_data_2 !=NULL ) free(bytes_data_2);
        if ( ImBuf !=NULL ) free(ImBuf);
        if ( ReBuf !=NULL ) free(ReBuf);
        /**/
    
///    TIME_PRINT_
    
    
    
        // вспомогательные переменные для предотвращения выхода за пределы массива    
        // вспомогательные переменные для увеличения быстродействия
    
        /*
        ///TIME_START
        // Поворот на +90°. Возвращаем в исходное положение
        ///w_=sizeBuf/w;   // int w_=h;  int h_=w;   // меняем местами w и h по любому
        w_=h; // меняем местами w и h по любому // int w_=h;  int h_=w;
        p1=bytes_data_1;   p2=bytes_data_2 + pr2_w;  // index_=0;  ///  + pr2_w  сдвигаем в начало массива
        //p2=bytes_data_2 + pr2_w;   p1=bytes_data_1 + pr2_w;   // index_=0;  /////p2=bytes_data_2;--p0=bytes_data; ///  + pr2_w  сдвигаем в начало массива
        for ( x=0; x < w_; x++ ) {    // time=0.25
       /////     p2++; // +x
            for ( y=0; y < w_h; y+=w_ ){ // w_h
                // *(p1 + index_)=*(d1 + x + y);  index_--; // index_+=dlt; int dlt=1;
                // за одно выполняем инверсию
                *p1=*(p2+y);   p1++; // d1++;  сквозной индекс в цикле переупаковки // возвращение в исходное положение
            } // y
            p2++; // +x
        } // x 
        for ( x=0; x < sizeBuf; x++ ) { cout<<" "<<(unsigned short)bytes_data_1[x]; if ((x+1)%32==0)cout<<endl; } // x
        
    
 //   for ( x=0; x < w_h; x++ ){ bytes_data[x]=~bytes_data_2[x+pr2_w]; }
        
        // инверсия уровней выходного массива внутреннего формата программы 0-белый (1-255)-серый в общепринятый стандарт 0-черный (1-255)-серый
        for ( x=0; x < w_h; x++ ){ bytes_data[x]=~bytes_data_1[x+pr2_w]; }
        ///for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data1_64[x+pr2]; } // инвертируем по 8 байт одновременно
        */
    
  
    
        ///TIME_PRINT_
        ///if (GrafT) { cout<<"n0_min="<<n0_min<<"    n0_max="<<n0_max<<endl; } ////////
        ///int n0=0; int n0_max=0;   int mx=w_h*h;   int n0_min=mx; ////////
        ///if( n0 <= n0_min ) { n0_min=n0; } ////////
        ///if( n0 > n0_max ) { n0_max=n0; } ////////
        ///n0++; ////////
    
        ///int w_=sizeBuf/h;   // int w_=w;
        ///w_=sizeBuf/w;   // int w_=h;  int h_=w;   // меняем местами w и h по любому
    
         /*
         // приведение уровней bytes_data из 0 и 255 к 0 и 1       // ~
         //for ( y=0; y < w_h; y++ ){ bytes_data[y]=(bytes_data[y]>>7); }
         for ( y=0; y < w_h; y++ ){ *(p0+y)>>=7; }    /// *p0=(d*255)/ss_m3;
         */
        // инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный 
        //for ( x=0; x < w_h; x++ ) { if (bytes_data[x]) bytes_data[x]=0;  // else bytes_data[x]=1; } // по 1 байту //else bytes_data[x]=255;        
        
    ///unsigned char a,b=255; a=~b; cout<<"  a="<<(unsigned short)a; a=~b&1;  cout<<"  a="<<(unsigned short)a; cout<<endl;
    //unsigned int c=0x1010101; cout<<"  c="<<c; cout<<endl; // 0x10101010 // 16843009  //0b01011110 двоичный
    //    unsigned int a,b=0xFFFFFFFFFFFFFFFF;
    ////unsigned long a,b=0; // 0x101010101010101==72340172838076673
    ////a=~b; cout<<"  a="<<a; a=~b & 0x1010101010101010;  cout<<"  a="<<a; cout<<endl;
    
//-----------------------------------------------------------------------------------------------------------
        
        
}//____________________________________________________________________________
    
    
        // работающая версия // (первая запасная)
    
    /// ГОТОВАЯ fast version Gaussian (blur) ///
    
//*****************************************************************************
    
// функция размытия (blur) массива bytes_data двухмерным Гауссианом ( Gaussian ).
    
void  GBitmap::gaussianT(int amplitude) {
        
        // ss "ширина" (amplitude) Гауссиана в пикселях.
        // входной массив bytes_data может быть как серым: от 0-черного до 255-белого, так и черно-белым: 0-черный 255-белый.
        // bytes_data это unsigned char
        
        //  * Идея 1 *
        // Адаптивное сглаживание.
        // Идея состоит в том, что степень сглаживания графического текста обратно пропорциональна степени
        // "курчавости" текста (числу Мадельброта) вычесленному в небольшой области вокруг каждой точки графического текста.
        //  * Реализация *
        // Скользящия квадратная область S*S пробегает по всему исходному битовому массиву.
        // Для каждой точки этого массива в квадратной области S*S вычисляется две величины:
        // - площадь ( суммарное количество черных пикселей попавших в область S*S )
        // - длинна периметра или контура ( суммарное количество переходов из черного в белое и из белого в черное,
        // попавших в область S*S, по вертикали и по горизонтали ). Вычисляется сдвигом битового регистра длинной в w*h
        // Отношение длинны периметра (контура) к площади называется числом Мадельброта
        // Адаптивно сглаживаем картинку с управлением от вычисленного числа Мадельброта.
        // Для увеличения быстродействия величины площади и длинны периметра вычисляются по предпросчитанному интегрольному массиву.
        // В этой функции эта идея не реализованна.
        
        /*
         /// Теория размытия (blur) битового массива (изображения) двухмерным Гауссианом. Реализованна функция. ///
         // Двухмерный Гауссиан использует фиксированную область усредннения в пикселях, где ss ее "ширина"
         // Одномерные фильтры с прямоугольной и треугольной импульсной характеристикой (где k это ss):
         // -прямоугольная рекурсивная весовая функция. Соответствует одномерному фильтру с прямоугольной импульсной характеристикой
         // y(n)=y(n-1)+x(n)-x(n-2k-1)
         // -треугольная рекурсивная весовая функция. Соответствует одномерному фильтру с треугольной импульсной характеристикой
         // y(n)=-y(n-2)+2y(n-1)+x(n-2k-2)-2x(n-k-1)+x(n)
         // Импульсная характеристика фильтра это его реакция на еденичный импульс. Удобно применять для отладки фильтра.
         // Рекурсивная весовая функция это удобная форма для дискретной (програмной) реализации соответствующего фильтра.
         // Если к одному и тому же массиву данных применить два раза подряд фильтр с треугольной импульсной характеристикой,
         // то это эквивалентно применению фильтра с гладкий импульсной характеристикой практически точно совпадающий
         // по форме с одномерным Гауссианом ( Gaussian ).
         
         // Если к двухмерному массиву данных применить одномерный Гауссианом сначала по горизонтали, а затем по вертикали,
         // то это эквивалентно применению двухмерного Гауссиана.
         // Для увеличения быстродействия, удобнее сначала выполнять горизонтальный прогон Гауссом, затем транспонировать массив,
         // опять горизонтальный прогон Гауссом и снова транспонирование массива ( транспонирование, т.е. поворот на +90°).
         */
        
        ///        TIME_START
        // time=2.14 сек   w=16224 × h=2464  w*h=40 млн пикселей  //  (w=2698 h=4000)
        // time=0.63 сек   w=2621  × h=3979  w*h=10 млн пикселей
        // time=0.22 сек   w=3491  × h=1017  w*h=3.5 млн пикселей
        // первые "ss+ss" и последние "ss" пикселей изображения не защищены от краевых эффектов
        
        if(amplitude==0)return;
        
        int x,y;
        int w,h;
        w=ncolumns; // ширина массива  IMAGE WIDTH в пикселях
        h=nrows;    // высота массива  IMAGE HEIGHT в пикселях
        int w_h=w*h;
        unsigned char *p0=bytes_data;      // входной и выходной массивы, 0-черный 255-белый
        int ss=amplitude;  // ss "ширина" (амплитуда) Гауссиана в пикселях.
        
        // размеры массивов в байтах
        unsigned int sizeBuf=w_h*sizeof(unsigned int) + 512;   // + ss*2 // + 64; //   ЗАВЫШЕНО В 4 РАЗА
        unsigned int sizeBufInt=sizeBuf/sizeof(unsigned int);
        //sizeBuf=sizeBuf/4;
        cout<<"w_h="<<w_h<<"  sizeBuf="<<sizeBuf<<"  sizeBufInt="<<sizeBufInt<<endl;
        
        /*
         // размеры массивов в байтах
         unsigned int sizeBuf_bd1=w_h + 512; 
         unsigned int sizeBuf=w_h + 512;
         unsigned int sizeBufT=w_h*sizeof(unsigned int) + 512;   // + ss*2  //   ЗАВЫШЕНО В 4 РАЗА
         unsigned int sizeBufInt=sizeBufT/sizeof(unsigned int);
         //        unsigned int sizeBufInt=w_h + 512;
         cout<<"w_h="<<w_h<<"  sizeBuf="<<sizeBuf<<endl;
         cout<<"sizeBufInt="<<sizeBufInt<<"  sizeBufInt="<<sizeBufInt<<endl;
         // calloc(n,size); unsigned n; количество элементов unsigned size; длина каждого элемента в байтах // lalloc=(long*)calloc(40, sizeof(long));
         
         */
        
        // указатели
        unsigned char* bytes_data_1, *p1;
        unsigned int* ReBuf, *d1;
        unsigned int* ImBuf, *d2;
        
        // Массивы. Каждый элемент инициализируется в 0.
        bytes_data_1 = (unsigned char*)calloc(sizeBuf,sizeof(unsigned char)); // p1  /// ПРОВЕРИТЬ РАЗМЕР sizeBuf
        ImBuf = (unsigned int*)calloc(sizeBuf,sizeof(unsigned int)); // d1
        ReBuf = (unsigned int*)calloc(sizeBuf,sizeof(unsigned int)); // d2
        // calloc(n,size); unsigned n; количество элементов unsigned size; длина каждого элемента в байтах // lalloc=(long*)calloc(40, sizeof(long));
        ///ImBuf = (unsigned short*)malloc(sizeBuf); // d1
        ///ReBuf = (unsigned short*)malloc(sizeBuf); // d2
        
        
        //ss=4;  // "ширина" Гауссиана в пикселях
        
        // ss "ширина" Гауссиана в пикселях. Размер области усредннения ss=2-64,
        // для черно белых p0=0,255 или серых изображений p0=0-255;
        if ( ss<3 ) ss=2;   if ( ss>64 ) ss=64;
        // max ss=255 p0=0,1; при массивах типа int и *(d1-3)=*(d1-3)/ss;
        // max ss=40  p0=0,1; при массивах типа short
        // max ss=214 p0=0,1; при массивах типа int без *(d1-3)=*(d1-3)/ss;
        // max ss=214 p0=0,255; при массивах типа int и *(d1-3)=*(d1-3)/ss;
        // max ss=64  p0=0,255; при массивах типа int без *(d1-3)=*(d1-3)/ss;
        
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        
        if (GrafT) {
            cout<<"Сглаживание (blur) Гауссианом gaussian()    amplitude="<<amplitude<<endl;
            cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
        
        // вспомогательные переменные для предотвращения выхода за пределы массива
        int  s2=ss*2+1,  s4=ss*4;
        // вспомогательные переменные для увеличения быстродействия
        int wh_s2=w_h+s2;
        int wh_s4=w_h+s4;
        int ss_2=ss*2;
        int ss_m2=ss*ss;
        int ss_m3=ss_m2*ss;
        int ss_m4=ss_m3*ss;
        
        
        
        // обнуление ImBuf,ReBuf ( где ImBuf, ReBuf глобальные )
        ///memset(ImBuf,0,sizeBuf);      memset(ReBuf,0,sizeBuf);  // time=0.24 16224 × 2464
        
        //memset(bytes_data, 255, w_h);  // тест белая плашка
        //memset(bytes_data, 0, w_h);    // тест черная плашка // char 1, short 2, int 4.
         /*
         // приведение уровней bytes_data из 0 и 255 к 0 и 1       // ~
         //for ( y=0; y < w_h; y++ ){ bytes_data[y]=(bytes_data[y]>>7); }
         for ( y=0; y < w_h; y++ ){ *(p0+y)>>=7; }    /// *p0=(d*255)/ss_m3;
         */
        
        
        /// Горизонтальное размытие (blur) одномерным Гауссианом двухмерного массива данных (изображения) ///
        
        ///TIME_START
        // обязательно обнуление начального участка массива bytes_data от 0 до s2+1 для чистого старта рекурсивного фильтра
        memset(bytes_data, 0, s2+1); // начало, значение, начало+конец в байтах
        
        //bytes_data[s2+1]=255;
        //cout<<endl;  for ( y=0; y < s2*4; y++ ){cout<<"  "<<(unsigned short)bytes_data[y];}  cout<<endl;
        //cout<<endl;  for ( y=w_h-ss; y < sizeBufInt; y++ ){cout<<"  "<<(unsigned short)bytes_data[y];}  cout<<endl;
        
        // первое прямое применение треугольной весовой функции
        int n0=0; int n0_max=0;   int mx=w_h*h;  //int n1=mx;
        int n0_min=mx; ////////
        p0=bytes_data+s2;   d1=ReBuf+s2;
        ////        for ( y=s2; y < wh_s4; y++ ) { // s2=ss*2+1  // wh_s4=w_h+s4;   // time=0.41 16224 × 2464
        for ( y=s2; y < w_h-s2; y++ ) {
            
            
            if( n0 <= n0_min ) { n0_min=n0; } ////////
            if( n0 > n0_max ) { n0_max=n0; } ////////
            n0++; ////////
            
            // p0=bytes_data+y;   d1=ReBuf+y;
            p0++;   d1++;
            // треугольная весовая функция, прямая фильтрация
            // ReBuf[y]=-ReBuf[y-2]+2*ReBuf[y-1+ImBuf[y-2*s ]-2*ImBuf[y-ss]+ImBuf[y];
            *d1=-*(d1-2)+(*(d1-1)<<1)+*(p0-ss_2)-(*(p0-ss)<<1)+*p0;       // <<1=2*
        } // y
        ///TIME_PRINT_
        if (GrafT) { cout<<"n0_min="<<n0_min<<"    n0_max="<<n0_max<<endl; } ////////
        
        
        //cout<<endl;  for ( y=0; y < s2*4; y++ ){cout<<"  "<<ReBuf[y];}  cout<<endl;
        //cout<<endl;  for ( y=w_h-ss; y < sizeBufInt; y++ ){cout<<"  "<<ReBuf[y];}  cout<<endl;
        
        ///TIME_START
        // обязательно обнуление конечного участка массива ReBuf для чистого старта обратного рекурсивного фильтра
        ///d1=ReBuf;
        ///for ( y=wh_s2; y < sizeBufInt; y++ ) { *(d1+y)=0; }  // wh_s2=wh+s2;   // time=0
        memset(ReBuf+4*wh_s2, 0, 4*(sizeBufInt-wh_s2));  // начало (указатель), значение, количество символов в байтах (длинна) unsigned 
        
        // второе инверсное применение треугольной весовой функции
        /////        p0=bytes_data+wh_s4;   d1=ReBuf+wh_s4;   d2=ImBuf+wh_s4;
        p0=bytes_data+w_h;   d1=ReBuf+wh_s4;   d2=ImBuf+wh_s4;
        /////        for ( y=wh_s4; y > 0; y-- ) {  // wh_s4=w_h+s4;  // time=0.53 16224 × 2464  
        for ( y=w_h-s4; y > 0; y-- ) {
            //p0=bytes_data+y;   d1=ReBuf+y;   d2=ImBuf+y;
            p0--;  d1--;  d2--;
            // треугольная весовая функция, инверсная фильтрация
            // ImBuf[y]=-ImBuf[y+2]+2*ImBuf[y+1]+ReBuf[y+ss_2]-2*ReBuf[y+ss]+ReBuf[y];
            *d2=-*(d2+2)+(*(d2+1)<<1)+*(d1+ss_2)-(*(d1+ss)<<1)+*d1;          // <<1=2*
            // уменьнение динамического диапазона размытого серого до динамического диапазона байта (0-255)
            // bytes_data[y]=(ImBuf[y]*255)/ss_m4;  // >>12
            *p0=*d2/ss_m4;    //*p0=(d*255)/ss_m3;
        } // y
        ///TIME_PRINT_
        /**/
        
        //cout<<endl;  for ( y=0; y < s2*4; y++ ){cout<<"  "<<(unsigned short)bytes_data[y];}  cout<<endl;
        //cout<<endl;  for ( y=w_h-ss; y < sizeBufInt; y++ ){cout<<"  "<<(unsigned short)bytes_data[y];}  cout<<endl;
        
        //memset(ReBuf,0,sizeBuf);
        
        
        ///TIME_START
        // Поворот на -90°. Переупаковка (транспонирование) горизонтального массива строк в массив вертикальных строк.
        p0=bytes_data;   p1=bytes_data_1;   // index_=0;
        for ( x=0; x < w; x++ ) {    // time=0.37
            /////      p0++; // +x
            for ( y=0; y < w_h; y+=w ){
                //*(p1 + index_)=*(p0 + x + y);  index_++;  // index_+=dlt; int dlt=1; // for ( y=0; y < h; y++ ){
                *p1=*(p0+y);   p1++; // p1++;  сквозной индекс в цикле переупаковки    // *p1=*p0;   p1++;  p0+=w;
            } // y 
            p0++; // +x
        } // x
        ///TIME_PRINT_
        
        /*
         // ТЕСТ, поворот еще на +90° до +180°
         int w_=h;   // int h_=w;    // меняем местами w и h по любому
         //p0=bytes_data;   d1=ReBuf;       // возвращение в исходное положение
         p0=bytes_data;   p1=bytes_data_1;  // поворот еще на +90° до +180°, тест
         unsigned int index_=w_h; // сквозной индекс в цикле переупаковки
         for ( x=0; x < w_; x++ ) {    // time=0.45=0.25
         p1++; // +x
         for ( y=0; y < w_h; y+=w_ ){
         // *(p0 + index_)=*(d1 + x + y);  index_--; // index_+=dlt; int dlt=1;
         // *p0=*(d1+y) ;   p0++; // d1++;  // возвращение в исходное положение
         *p0=*(p1+y) ;   p0--; // d1++;    // поворот еще на +90°, до +180°, тест
         } // y
         } // x
         */
        
        //*******************************************************************************************
        
        // обнуление ImBuf-d2,  ReBuf-d1
        //memset(ImBuf,0,sizeBuf);      memset(ReBuf,0,sizeBuf);  // time=0.24 16224 × 2464
        
        
        /// Вертикальное размытие (blur) одномерным Гауссианом двухмерного массива данных (изображения) ///
        
        ///TIME_START
        // обязательно обнуление начального участка массива bytes_data_1 от 0 до s2+1 для чистого старта рекурсивного фильтра
        memset(bytes_data_1, 0, s2+1);
        
        // первое прямое применение треугольной весовой функции
        p1=bytes_data_1+s2;   d1=ReBuf+s2;
        for ( y=s2; y < wh_s4; y++ ) { // s2=ss*2+1  // wh_s4=w_h+s4;   // time=0.26  16224 × 2464
            //p0=bytes_data+y;   d1=ReBuf+y;
            p1++;   d1++;
            // треугольная весовая функция, прямая фильтрация
            // ReBuf[y]=-ReBuf[y-2]+2*ReBuf[y-1+ImBuf[y-2*s ]-2*ImBuf[y-ss]+ImBuf[y];
            *d1=-*(d1-2)+(*(d1-1)<<1)+*(p1-ss_2)-(*(p1-ss)<<1)+*p1;       // <<1=2*
            //*p1=*d1/ss_m2;
        } // y
        ///TIME_PRINT_
        
        ///for ( y=0; y < sizeBuf; y++ ) { bytes_data_1[y]=ReBuf[y]/ss_m2; }
        
        ///TIME_START
        // обязательно обнуление конечного участка массива ReBuf для чистого старта обратного рекурсивного фильтра
        ///d1=ReBuf;
        ///for ( y=wh_s2; y < sizeBufInt; y++ ) { *(d1+y)=0; }  // wh_s2=w_h+s2;  // time=0
        memset(ReBuf+4*wh_s2, 0, 4*(sizeBufInt-wh_s2));  // начало (указатель), значение, количество символов в байтах (длинна) unsigned
        
        // второе инверсное применение треугольной весовой функции
        ///////      p1=bytes_data_1+wh_s4;   d1=ReBuf+wh_s4;   d2=ImBuf+wh_s4;
        p1=bytes_data_1+wh_s4;   d1=ReBuf+wh_s4;   d2=ImBuf+wh_s4;
        /////        for ( y=wh_s4; y > 0; y-- ) {
        for ( y=w_h-s4; y > 0; y-- ) { // wh_s4=w_h+s4;   // time=0.32  16224 × 2464
            //p0=bytes_data+y;   d1=ReBuf+y;   d2=ImBuf+y;
            p1--;  d1--;  d2--;
            // треугольная весовая функция, инверсная фильтрация
            // ImBuf[y]=-ImBuf[y+2]+2*ImBuf[y+1]+ReBuf[y+ss_2]-2*ReBuf[y+ss]+ReBuf[y];
            *d2=-*(d2+2)+(*(d2+1)<<1)+*(d1+ss_2)-(*(d1+ss)<<1)+*d1;          // <<1=2*
            // уменьнение динамического диапазона размытого серого до динамического диапазона байта (0-255)
            // bytes_data_1[y]=ImBuf[y]*255/ss_m4;  // >>12
            *p1=*d2/ss_m4;  // *(d2-3)=*(d2-3)/ss_m4;            
        }
        ///TIME_PRINT_
        
        
        
        //*******************************************************************************************
        /**/
        
        //for ( y=6; y < sizeBuf; y++ ) { bytes_data_1[y-6]=bytes_data_1[y]; }
        
        
        ///TIME_START
        // Поворот на +90°. Возвращаем в исходное положение
        int w_=h;   // int h_=w;   // меняем местами w и h по любому
        p0=bytes_data;   p1=bytes_data_1;  // index_=0;
        for ( x=0; x < w_; x++ ) {    // time=0.25
            /////     p1++; // +x
            for ( y=0; y < w_h; y+=w_ ){
                //*(p0 + index_)=*(d1 + x + y);  index_--; // index_+=dlt; int dlt=1;
                *p0=*(p1+y);   p0++; // d1++;  сквозной индекс в цикле переупаковки // возвращение в исходное положение
                ///*p0=*(d2+y)/ss_m4;   p0++; // d1++;  сквозной индекс в цикле переупаковки // возвращение в исходное положение
            } // y
            p1++; // +x
        } // x
        /**/
        
        
        // освобождение массивов bytes_data_1, ImBuf,  ReBuf
        if ( bytes_data_1 !=NULL ) free(bytes_data_1);
        if ( ImBuf !=NULL ) free(ImBuf);
        if ( ReBuf !=NULL ) free(ReBuf);
        /**/
        
        ///        TIME_PRINT_
        
        
//-----------------------------------------------------------------------------------------------------------
        
        
}//____________________________________________________________________________
    
    
    
    
    
//*****************************************************************************
    
// функция определения толщины штриха в буквах графического текста ( lineWidth ).
    
int  GBitmap::lineWidth() {
        
        // Возвращает среднее значение толщины штриха line_w в буквах по всему графическому тексту (в пикселях).
        // Входной массив bytes_data должен быть черно-белым: 0-черный 255-белый или черно-белым: 0-черный 1-белый.
        // bytes_data это unsigned char.
        
        //  * Идея *
        // Определения толщины штриха для черо-белого графического текста.
        // Идея состоит в том, что подсчитывается длинна всех непрерывных вертикальных и горизонтальных "черных" слайсов.
        // толщиной в один пиксель по всему графическоу тексту. Отбрасываются все длинные слайсы, уменьшаются веса коротких   
        // слайсов и подсчитывается количество оставшихся "черных" слайсов каждой длинны.
        // Длинна слайса, встречающегося по всему графическому тексту, наибольшее число раз и есть толщина штриха в буквах.
        
        //  * Особенности *
        // Для серого графического текста, для пределения толщины штриха, предварительно применяют
        // функцию адаптивного порога binarisation(int Tr, int BASE) получая необходимый черо-белый графическй текст
        
        
        
        
        /**/
///        TIME_START
        // горизонтальное сканирование слайсов (быстрое) //
        // time=0.1   сек  w=16224 × h=2464  w*h=40 млн.pix  line_wd=98   line_w=10pix  // 137  line_w=14pix   //  (w=2698 h=4000)
        // time=0.033 сек  w=2621  × h=3979  w*h=10 млн.pix  line_wd=79   line_w=8 pix  // 87   line_w=9 pix
        // time=0.016 сек  w=2112  × h=3008  w*h=6  млн.pix  line_wd=37   line_w=4 pix
        
        // вертикальное сканирование слайсов (медленное) //
        // time=0.45  сек  w=16224 × h=2464  w*h=40 млн.pix  line_wd=100  line_w=10pix    //  (w=2698 h=4000)
        // time=0.1   сек  w=2621  × h=3979  w*h=10 млн.pix  line_wd=105  line_w=11pix    //  x+=3 // time=0.04
        // time=0.045 сек  w=2112  × h=3008  w*h=6  млн.pix  line_wd=44   line_w=4 pix
        
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        
        if (GrafT) { 
            cout<<"Определение толщины штриха lineWidth()"<<endl;
            cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; 
        }
        
        
        int x,y; 
        int w,h;
        w=ncolumns; // ширина массива  IMAGE WIDTH
        h=nrows;    // высота массива  IMAGE HEIGHT
        int w_h=w*h;
        
        // управляющие переменные
        unsigned char lineWH=2;   
        // lineWH=0 вычисляется толщина штриха по горизонтали (быстрое)
        // lineWH=1 вычисляется толщина штриха по вертикали (медленние)
        // lineWH=2 вычисляется среднее значение толщины штриха по вертикали и горизонтали (время выполнения сумма предид.)
        unsigned char n=1;        // уменьшения площади сканирования текста в "n" раз при вертикальное (медленным) поиске слайсов
        unsigned int lw_Max=32;   // максимально возможная толщина штриха
        // вспомогательные переменные
        unsigned int line_w=0;    // среднее значение толщины штриха по всему графическому тексту.
        unsigned int line_wd=0;   // то же что и line_w но в десятых долях пикселя
        unsigned int lw=0;        // текущая толщина штриха в буквах графического текста
        unsigned int lw_Sum=0;    // суммарное количество разных "черных" слайсов по всему графическому тексту.
        unsigned int md_Max=0;    // максимальное количество "черных" слайсов одной длинны во всем тексте
        unsigned int x_Max=0;     // длинна "черного" слайса наиболее часто встречающегося по всему тексту
        // вспомогательные переменные для увеличения быстродействия
        unsigned int s;
        // вспомогательные переменные для предотвращения выхода за пределы массива
        int w_h_1=w_h-1;
        int w_h_w=w_h-w;
        
        // указатели
        unsigned char *p0=bytes_data;    // входной массив, 0-черный 255-белый или 0-черный 1-белый
        uint *middle_data, *d1;  // массив распределения длинн "черных" слайсов, где
        // длинна слайса является адресом массива, а содержимое это количество слайсов данной длинны
        
        // Массивы. Каждый элемент инициализируется в 0.
        middle_data = (unsigned int*)calloc(lw_Max+8,sizeof(unsigned int)); // d1
        

        // ввести old_p0
        
        // уменьшения площади сканирования графического текста при вертикальное (медленным) поиске слайсов
        // если пдощать графического текста больше 1 млн.pix то обсчитываем только каждую третью колонку
        n=1;
        if ( w_h >1000000 ) n=3;
        
        //lineWH=0; // тест
        ///TIME_START
        
        /// горизонтальное сканирование слайсов (быстрое)  ///
        if (lineWH==0 || lineWH==2) {
            
            // подсчет количество "черных" слайсов каждой длинны (длинной от 1 до lw_Max).
            // заполение массива распределения длинн "черных" слайсов
            p0=bytes_data;  d1=middle_data; lw=0;
            for ( x=0; x < w_h_1; x++ ) {   // w_h_1=w_h-1;   // time=0.017 16224 × 2464
                // подсчет длинны "черного" слайса
                if (*p0==0) {  // если встретился "черный" пиксел
                    lw++;
                    // запись в массив middle_data колличества "черных" слайсов, где длинна слайса является адресом массива
                    if (*(p0+1)>0) { // если следующий пиксел "белый"
                        if (lw<lw_Max) { *(d1+lw)=*(d1+lw)+1; }  // если "черный" слайс не длинный  // *(d1+lw)++;
                        //if (lw<lw_Max) { *(d1+lw)++; }  // если "черный" слайс не длинный
                        lw=0;
                    } // (*(p0+1)>0)
                } // if (*p0==0)
                p0++; // p0=bytes_data+x;
            } // y
            
        } // if (lineWH
        ///TIME_PRINT_
        /**/
        
        
        /// вертикальное сканирование слайсов (медленние в 3 раза, при n=1) ///
        if (lineWH==1 || lineWH==2) {
            
            // подсчет количество "черных" слайсов каждой длинны (длинной от 1 до lw_Max).
            // заполение массива распределения длинн "черных" слайсов
            d1=middle_data; lw=0;      // x+=3 быстрее раза в 2.5 чем x++
            for ( x=0; x < w; x+=n ) { // x++, time=0.45 16224 × 2464 то же что и вращение time=0.37 (0.25) и обычный подсчет time=0.1
                p0=bytes_data+x;
                for ( y=0; y < w_h_w; y+=w ){    // w_h_w=w*h-w;
                    // подсчет длинны "черного" слайса
                    if (*p0==0) {  // если встретился "черный" пиксел
                        lw++;
                        // запись в массив middle_data колличества "черных" слайсов, где длинна слайса является адресом массива
                        if (*(p0+w)>0) { // если следующий пиксел "белый"
                            if (lw<lw_Max) { *(d1+lw)=*(d1+lw)+n; }  // если "черных" слайс не длинный, "n"- вес одного пикселя // +n; //////////
                            //if (lw<lw_Max) { *(d1+lw)++; }  // если "черных" слайс не длинный
                            lw=0;
                        } // (*(p0+1)>0)
                    } // if (*p0==0)
                    p0+=w;  // p0=bytes_data+w;
                } // y
            } // x
            
        } // if (lineWH
        ///TIME_PRINT_
        /**/
        
        
        if (GrafT) { cout<<endl;  for ( x=0; x < lw_Max; x++ ){cout<<"  "<<middle_data[x];}  cout<<endl; }
        
        // Таблица весов количества "черных" слайсов всему графическому тексту.
        // С помощью таблицы уменьшается влияние очень коротких слайсов длинной в 1,2... пикселя.
        d1=middle_data;  // d1[1]*=0.1; // (float)4.1
        
        /*
        *(d1+1)=*(d1+1)*(float)0.1;   *(d1+2)=*(d1+2)*(float)0.3;    *(d1+3)=*(d1+3)*(float)0.4;    *(d1+4)=*(d1+4)*(float)0.5;
        *(d1+5)=*(d1+5)*(float)0.6;   *(d1+6)=*(d1+6)*(float)0.7;    *(d1+7)=*(d1+7)*(float)0.7;    *(d1+8)=*(d1+8)*(float)0.7;
        *(d1+9)=*(d1+9)*(float)0.8;   *(d1+10)=*(d1+10)*(float)0.8;  *(d1+11)=*(d1+11)*(float)0.8;  *(d1+12)=*(d1+12)*(float)0.9;
        */
        
        
        // вычисление длинны x_Max и количества md_Max "черныхо" слайсов, самых встречающихся по всему тексту
        md_Max=0;
        for ( x=1; x < lw_Max; x++ ) {  // x=2 не учитываем пиксели нулевого и единичного размера
            if (md_Max < middle_data[x]) { md_Max=middle_data[x];  x_Max=x; }
        } // x
        if (GrafT) { cout<<"md_Max="<<md_Max<<"   x_Max="<<x_Max<<endl; }
        /**/
        
        if (GrafT) { cout<<endl;  for ( x=0; x < lw_Max; x++ ){cout<<"  "<<middle_data[x];}  cout<<endl; }
        
        
        // подсчет среднего по "черных" слайсом площадь которых лежит от максимума до половины максимума суммарной площади
        line_wd=0;  lw_Sum=0;
        for ( x=1; x < lw_Max; x++ ) {
            if (middle_data[x] > md_Max/2) {  // md_Max*2/3
                line_wd+=middle_data[x]*x;
                lw_Sum+=middle_data[x];
                ///cout<<"x="<<x<<endl;
            } // if
        } // y
        if (GrafT) { cout<<"lw_Sum="<<lw_Sum<<endl; }
        
        
        // значение толщина штриха в десятых долях пикселя: 38 это 3,8 pix
        if (lw_Sum == 0 ) { lw_Sum=1; }
        line_wd=line_wd*10/lw_Sum;
        
        
        // точное округление толщины штриха до целых пикселей
        //line_w=46; // тест
        // "s" порог между пикселями: 5,15,25,35,45,,,,. Пиксели могут принимать значения от 1 ло 320 (в десятых долях)
        s=(line_wd/10)*10+5;
        if (line_wd >= s ) { line_w=line_wd/10+1; }
        else line_w=line_wd/10;
        
        if ( line_wd<20 ) line_wd=10;   if ( line_wd>lw_Max*10 ) line_wd=lw_Max*10;
        if (GrafT) { cout<<"*толщина* штриха в десятых долях пикселя line_wd="<<line_wd<<endl; }
        // line_w толщина штриха в пикселях. Максимально возможная толщина штриха lw_Max=32,
        if ( line_w<2 ) line_w=1;   if ( line_w>lw_Max ) line_w=lw_Max;
        if (GrafT) { cout<<"*толщина* штриха в пикселях line_w="<<line_w<<endl; }
        /**/
        
        if (GrafT) { cout<<endl;  for ( x=0; x < 20; x++ ){cout<<"  "<<(unsigned short)bytes_data[x];}  cout<<endl; }        
        
        if (GrafT) {
            cout<<"оптимальное значение *толщины* штриха для данного текста   line_wd="<<80/10<<"."<<80%10<<" pix"<<endl; 
            cout<<"фактическое значение *толщины* штриха в пикселях                     line_wd="<<line_wd/10<<"."<<line_wd%10<<" pix"<<endl; }
        
        
        // освобождение массивов bytes_data_1
        if ( middle_data !=NULL ) free(middle_data);
        /**/
        
///        TIME_PRINT_
        
        // возвращение толщины штриха в пикселях.
        ///return line_w;
        // возвращение толщины штриха в десятых долях пикселя.
        return line_wd;
        
        
        //----------------------------------------------------------------------------------------------------------------                
         /*
         middle_data[1]*=(float)0.1;    middle_data[2]*=(float)0.3;    middle_data[3]*=(float)0.4;
         middle_data[4]*=(float)0.5;    middle_data[5]*=(float)0.6;    middle_data[6]*=(float)0.7;
         middle_data[7]*=(float)0.7;    middle_data[8]*=(float)0.7;    middle_data[9]*=(float)0.8;
         middle_data[10]*=(float)0.8;   middle_data[11]*=(float)0.8;   middle_data[12]*=(float)0.9;
         */
        /*
         *(d1+1)=*(d1+1)/10;     *(d1+2)=*(d1+2)*3/10;    *(d1+3)=*(d1+3)*4/10;    *(d1+4)=*(d1+4)*5/10;
         *(d1+5)=*(d1+5)*6/10;   *(d1+6)=*(d1+6)*7/10;    *(d1+7)=*(d1+7)*7/10;    *(d1+8)=*(d1+8)*7/10;
         *(d1+9)=*(d1+9)*8/10;   *(d1+10)=*(d1+10)*8/10;  *(d1+11)=*(d1+11)*8/10;  *(d1+12)=*(d1+12)*9/10;
        */
        
}//____________________________________________________________________________
    
    
    
    
    

}