//
//  GBitmapTEST_CodeStorage.cpp
//  OCRLib
//
//  Created by dharmabook on 08/08/15.
//
//



// -----------------------------------------------------------------------------

// в файле стpоки хpанились в обpатном поpядке, их необходимо пеpеставить
//for (y=0; y<200; y++) memcpy(picture[y],buffer[199-y],320); // 320x200

/*
 +++++Встроенные функции потокового SIMD расширения.doc
 Например, начало массива элементов типа __m64 выравнивается по 8 байтам,
 а массив элементов __m128 – по 16 байтам
 Для выделения памяти с выравниванием используется функция:
 void *_mm_malloc(int size, int align)
 size	– объем выделяемой памяти в байтах (как в malloc),
 align	– выравнивание в байтах.
 Для освобождения памяти, выделенной таким образом, используется функция:
 void _mm_free(void *p);
 Например:
 float *x;	// массив для обработки с помощью инструкций SSE
 x=(float)_mm_malloc(N*sizeof(float),16);
 // … здесь обработка …
 _mm_free(x);
 */

//----------------

// формирование центральной  области  "On"  без переходной области
// формирование перефирийной области  "Off" без переходной области
/*
 for (int y=0; y < h; y++ ) {
 s=~BufOff[y];
 Sb=On[y];
 ///Off[y]=Off[y] & s;
 if (maskType==1) {On[y]=Sb=Sb & s; }
 // подсчет площади центральной маски "On"
 // Регистровые суммы маски mask32 по  X    //0xFFFFFFFF
 Sb-=(Sb >> 1) & 0x55555555;                // 2-битовые ячейки
 Sb=(Sb & 0x33333333) + ((Sb >> 2) & 0x33333333); // 4-битовые
 Sb=(Sb + (Sb >> 4)) & 0x0F0F0F0F;                // 8-битоовые
 Sb+=Sb >> 8;                               // 16-битовые
 Sb+=Sb >> 16;                              // 32-битовая ячейка
 NMask+=Sb & 0x3F;  // 31 Обнуляем старшие разряды, содержащие "мусор"
 }
 //DM(END<<" x0st "<<x0st<<" x0st "<<x1st<<" x1st "<<y0st<<" y0st "<<y1st<<" y1st "<<END);
 */

/*
 Регистровые суммы. На примере 8-битного числа:
 
 v = (v & 0x55) + ((v >> 1) & 0x55);
 v = (v & 0x33) + ((v >> 2) & 0x33);
 return (v & 0x0f) + ((v >> 4) & 0x0f);    //0x0000003F;
 
 */

/*
 str 80
 // The following works only for 8-bit quantities.
 int pop7(unsigned x) {
 x = x*0x08040201;    // Make 4 copies.
 x = x >> 3;          // So next step hits proper bits.
 x = x & 0x11111111;  // Every 4th bit.
 x = x*0x11111111;    // Sum the digits (each 0 or 1).
 x = x >> 28;         // Position the result.
 return x;
 }
 */
/**/
//-----------------------------------------

/*
 Количество бит
 Здесь изюминка в следующем. Как известно, отнимая от числа единицу мы обнуляем
 крайний справа бит числа, например для числа 10011000 мы получим 10010xxx.
 Применив полученное число как маску к исходному, операцией &, мы обнулим крайний
 справа бит числа. Таким образом цикл будет выполняться столько раз, сколько
 единичных бит находится в числе
 
 int get_num_bit(unsigned char ch)
 {
 for(int n=0; x!=0; ++n)
 x &=x-1;              //x &= ~(-x);
 return n;
 }
 
 алгоритм для чисел с большим количеством нулевых бит
 int t = 0;
 while (x != 0) {
 t += 1;
 x &= x-1; // сбрасываем крайний справа бит
 }
 return t;
 алгоритм для чисел с большим количеством единичных бит
 int t=16
 while (x != 0xffff) {
 t--;
 x |= x+1;
 }
 return t;
 */

//-----------------------------------------
/**/
/*
 http://www.xserver.ru/computer/langprogr/c_c2p/7/
 5.3.
 Подсчитать номер младшего единичного бита (n должен быть ненулевым):
 Пример для 32-битного числа n.
 k = 0;
 if((n & 0xFFFF) == 0)   k = 16, n >>= 16;
 if((n & 0x00FF) == 0)   k += 8, n >>= 8;
 if((n & 0x000F) == 0)   k += 4, n >>= 4;
 if((n & 0x0003) == 0)   k += 2, n >>= 2;
 if((n & 0x0001) == 0)   k += 1;
 
 Подсчитать номер старшего единичного бита (если n=0, то k=32):
 Пример для 32-битного числа n.
 k = 0;
 if(n & 0xFFFF0000)      k = 16, n >>= 16;
 if(n & 0x0000FF00)      k += 8, n >>= 8;
 if(n & 0x000000F0)      k += 4, n >>= 4;
 if(n & 0x0000000С)      k += 2, n >>= 2;
 if(n & 0x00000002)      k += 1;
 */      //return k
//-----------------------------------------
/**/
/* как перевернуть число 8 бит наоборот
 / / Реверсивные правый 8 бит в слове.
 / / То же самое, но более эффективным, 15 Brisc ОПС.
 неподписанных rev8 (неподписанные х) {
 без знака U, M, S, T;
 
 U = X * 0x00020202;
 м = 0x01044010;
 S = U & M;
 T = (U <<2) и (M <1);
 возвращение 0x01001001 * (S + T)>> 24;
 / / Возврат (S + T)% 4095 / / Альтернативная, что эквивалентно выше.
 */
/*
 u = x*0x00020202
 m = 0x01044010
 s = u&m
 t = (u<<2)&(m<<1)
 x = (0x01001001*(s+t))>>24
 */
/*
 http://www.rsdn.ru/forum/cpp/1849986.flat.aspx
 uint8_t binvert8(uint8_t value) // see Warren H.S. Hacker's Delight - p. 109
 {
 uint32_t const u = value * 0x00020202;
 uint32_t const m = 0x01044010;
 return (uint8_t)((0x01001001 * ((u & m) + ((u << 2) & (m << 1)))) >> 24);
 
 //    return (uint8_t)((value * 0x0202020202ULL & 0x010884422010ULL) % 1023);
 }
 */

//------------------------------------------------------------------------------

/*                     // СТАТИЧЕСКИЕ  массивы  //
 ImBuf=(int*)farcalloc(ncnr+512, 4);    // запрос памяти с очисткой 0
 if (ImBuf==NULL) exit (1);             // 4 длина каждого элемента в байтах
 // ncnr+512 количество элементов в массиве
 
 //       вычисления        //
 
 if ( ImBuf !=NULL ) farfree(ImBuf);  //  освобождение памяти
 */
//q=(тип_q *)farmalloc(n_byte);     // запрос памяти без очистки 0
//q_new=farrealloc(q_old,n_byte);;  // изменение размера блока

//int *p;
// p = (int *) malloc(100 * sizeof(int)); /* Выделение памяти для 100 целых чисел */


// -----------------------------------------------------------------------------




//******************************************************************************

//   ТЕСТЫ ДЛЯ ФУНКЦИИ dotGain(int gainRate,int noiseRate)
//   Имитация полиграфического растискивания и зашумленности

/*
 int x,y,p,p0,p1;
 int d=dlt;          // dlt толщина стенок перефирийной области  "Off"
 unsigned int Sb;
 
 int w_32=ncolumns/32; int h=nrows;
 //unsigned int mWH=data_size/32;
 int mWH_32=ncolumns*nrows/32;
 
 unsigned int s=0;
 
 //		unsigned char* input=bites_data;  // исходный упакованный массив черно-белого скана  ///////////////
 // приведенный к unsigned int исходный упакованный массив черно-белого скана
 //////		unsigned int* input=(unsigned int*)bites_data;
 //
 //		unsigned char *d0,  // ссылка на на исходный упакованный массив черно-белого скана bites_data
 ///		unsigned int *BufOn=On;
 unsigned int BufOff[128];   memset(BufOff,0,128);    // обнуление
 
 
 DM(" TIME_START dotGain /GGG/ d="<<d<<END);
 ///		DM("/@@2@@@/маска пересечений"<<"x0="<<x0<<" x1="<<x1<<" y0="<<y0<<" y1="<<y1<<END);
 
 //------------------------------------------------------------------------------
 */
/*
 //-----------------------------------
 // Алгоритмические трюки для программистов стр47 сложение и вычитание двойных слов
 // тест  // s0=~0;
 ///unsigned int s0=1+2+4+(1<<31)+(1<<30);  unsigned int s1=8+16+(1<<30); // +(1<<29)
 unsigned int s0=~0-1-(1<<31);  unsigned int s1=~0-1-(1<<31); // +(1<<29)
 
 DM(END<<END<<" s1 "<<s1<<" s0 "<<s0<<END);
 // РАСПАКОВКА на экран, представления одного целого числа int
 // вход значение input
 // int radix  - где radix = 2 для двоичного представления целого числа (binary number);
 // radix = 8 для восьмеричного... и т.д.
 binaryPrint(s1, 2);  DM(" ");  binaryPrint(s0, 2); DM(" ");
 binaryPrint(s1, 2);  DM(" ");  binaryPrint(s0, 2); DM(" ");
 DM(END); DM(END);
 
 int dl=2;      // dlt сдвиг изображения влево, вправо, в верх, в низ.
 //if(!dl||dl==32) return;
 if(dl<1 || dl>31) return;
 unsigned int y0; unsigned int y1;
 int dm=32-dl;
 unsigned int Buf[8+1];   memset(Buf,0,(8+1)*4);    // обнуление
 Buf[0]=s0;  Buf[1]=s1;
 Buf[2]=s0;  Buf[3]=s1;
 Buf[4]=s0;  Buf[5]=s1;
 Buf[6]=s0;  Buf[7]=s1;
 //-----------------------------------
 */
/*
 // сдвиг всего массива Buf влево на величину dl, как одного многоразрядного регистра
 s0=Buf[0];
 for ( x=0;  x < 8;  x++  ) {
 
 s1=Buf[x+1];
 // беззнаковый сдвиг двух 32 разрядных регистров s0 и s1 влево, как одного 64 разрядного
 y1=s1<<dl|s0>>dm;    // y0=s0<<dl;
 s0=s1;
 
 // на псевдографике левый сдвиг отображается смещением цифр влево
 // последнее слово заполнено нолями, кроме перенесеного из соседнего регистра хвоста
 // DM(END<<END<<" y1 "<<y1<<" y0 "<<y0<<END);
 binaryPrint(y1, 2);  DM(" "); // DM(END);
 
 } // x
 */

/*
 //-----------------------------------
 // сдвиг всего массива вправо на величину dl, как одного многоразрядного регистра
 s0=Buf[7];
 for ( x=7;  x > 0 ;  x--  ) {  // ( x=7;  x > -1 ;  x--  )  (x=size-ds; x>ds; x--)
 
 s1=Buf[x-1];
 // беззнаковый сдвиг двух 32 разрядных регистров s0 и s1 вправо, как одного 64 разрядного
 y0=s0>>dl|s1<<dm;  // y1=s1>>dl;
 s0=s1;
 
 // на псевдографике правый сдвиг отображается смещением цифр вправо
 // начало последнего слова не корректно
 // DM(END<<END<<" y1 "<<y1<<" y0 "<<y0<<END);
 binaryPrint(y0, 2);  DM(" "); // DM(END);
 
 } // x
 //-----------------------------------
 */

//------------------------------------------------------------------------------

/*
 // сдвиг влево всего массива data_size_p32, как единого регистра
 // на величину dl, для прямого порядока пикселей
 unsigned int s2,s3,z0,z1,z2;   // s0,s1
 s0=bites_data_32[0];  // input
 //z0=bites_data_32[data_size_p32-1];
 for ( x=1;  x < data_size_p32-1;  x++ ) { // x=0;  // ncolumns*nrows/32;
 
 s1=bites_data_32[x+1];   //s2=bites_data_32[x];
 // беззнаковый сдвиг двух 32 разрядных регистров s0 и s1 влево,
 // как одного 64 разрядного регистра, для прямого порядока пикселей
 ///				bites_data_32[x]=s0>>dl|s1<<dm;          // y0=s0<<dl;   // ^ |
 bites_data_32[x]=s0&(s0>>dl|s1<<dm);     // z3=   // bites_data_32[x]=s2&(s0>>dl|s1<<dm);
 // добавление пикселей (пикселя) слева
 ///s3=s2&s0;// bites_data_32[x]=s2&s0;  //s2|s0;   s2 |(s2^s0);  input[x+p] | (input[x+p] ^ input[x+p+d]);
 s0=s1;  // z1=s2=
 
 ///z1=s1;  // z1=bites_data_32[x-1];
 // беззнаковый сдвиг двух 32 разрядных регистров s0 и s1 вправо,
 // как одного 64 разрядного регистра, для прямого порядока пикселей
 ////				bites_data_32[x]=s3&(z0<<dl|z1>>dm);    z0=z1;
 //z0=s1;
 
 } // x                     // уровни в битмапе  0-чёрный и 1-белый
 */

//------------------------------------------------------------------------------
/*
 tmp-------
 //unsigned int s;
 for ( y=0;  y < nrows;  y++ ) {   //  (h-d)
 p=y*ncolumns_p32;
 for (x=0; x<ncolumns_p32; x++) {
 s=bites_data_32[x+p];
 //bites_data_32[x+p]=s | (s ^ bites_data_32[x+p+d]); //p1=x+p0;
 //p1=x+p+d; if( p1>data_size_p32 ) { p1=data_size_p32; }
 bites_data_32[x+p]=s & bites_data_32[x+p+d]; // p1  x+p+d
 } // x
 } // y
 */
/*
 //------------------------------------------------------------------------------
 tmp-------
 d=10;
 d=d*ncolumns/32;
 for ( y=0;  y < nrows;  y++ ) {   //  (h-d)
 p=y*ncolumns/32;
 for (x=0; x<ncolumns/32; x++) {
 //BufOff[y]=BufOff[y] | (BufOn[y+d] ^ BufOn[y]);
 s=input[x+p];    input[x+p]=s | (s ^ input[x+p+d]); //p1=x+p0;
 ///input[x+p]=input[x+p] | (input[x+p] ^ input[x+p+d]);
 //input[y+p]=input[y+p+d];
 } // x
 } // y
 //------------------------------------------------------------------------------
 */

//------------------------------------------------------------------------------

/*
 // Алгоритмические трюки для программистов стр47 сложение и вычитание двойных слов
 // тест  // s0=~0;
 ///unsigned int s0=1+2+4+(1<<31)+(1<<30);  unsigned int s1=8+16+(1<<30); // +(1<<29)
 s0=~0-1-(1<<31);  s1=~0-1-(1<<31); // +(1<<29)
 
 DM(END<<END<<" s1 "<<s1<<" s0 "<<s0<<END);
 // РАСПАКОВКА на экран, представления одного целого числа int
 // вход значение input
 // int radix  - где radix = 2 для двоичного представления целого числа (binary number);
 // radix = 8 для восьмеричного... и т.д.
 binaryPrint(s1, 2);  DM(" ");  binaryPrint(s0, 2); DM(" ");
 binaryPrint(s1, 2);  DM(" ");  binaryPrint(s0, 2); DM(" ");
 DM(END); DM(END);
 
 dlt=2;      // int dlt сдвиг изображения влево, вправо, в верх, в низ.
 //if(!dlt||dlt==32) return;
 if(dlt<1 || dlt>31) return;
 unsigned int y0; unsigned int y1;
 int dm=32-dlt;
 unsigned int Buf[8+1];   memset(Buf,0,(8+1)*4);    // обнуление
 Buf[0]=s0;  Buf[1]=s1;
 Buf[2]=s0;  Buf[3]=s1;
 Buf[4]=s0;  Buf[5]=s1;
 Buf[6]=s0;  Buf[7]=s1;
 */

//------------------------------------------------------------------------------
// ТЕСТЫ ДЛЯ ФУНКЦИИ УПАКОВКА  PACKING 32 //

/*
 bytes_data[0+ncolumns]=0;
 bytes_data[1+ncolumns]=bytes_data[2+ncolumns]=bytes_data[3+ncolumns]=0;
 bytes_data[4+ncolumns]=bytes_data[5+ncolumns]=bytes_data[6+ncolumns]=0;
 bytes_data[7+ncolumns]=0;       bytes_data[1+ncolumns]=1;
 
 bytes_data[8+2*ncolumns]=0;
 bytes_data[9+2*ncolumns]=bytes_data[10+2*ncolumns]=bytes_data[11+2*ncolumns]=0;
 bytes_data[12+2*ncolumns]=bytes_data[13+2*ncolumns]=bytes_data[14+2*ncolumns]=0;
 bytes_data[15+2*ncolumns]=0;    bytes_data[9+2*ncolumns]=1;
 */
/*
 int y0;
 y0=bites_data_32[0+ncolumns/8]; //y0=255;
 DM(END); DM(END);  binaryPrint(y0, 2);  DM(" ");  DM(END);
 y0=bites_data_32[1+2*ncolumns/8];
 DM(END); DM(END);  binaryPrint(y0, 2);  DM(" ");  DM(END);
 */

//------------------------------------------------------------------------------

// ТЕСТЫ ДЛЯ ФУНКЦИИ РАСПАКОВКА UNPACKING 32 //

/*
 int v0=bytes_data[0+ncolumns];  int v1=bytes_data[1+ncolumns];
 int v2=bytes_data[2+ncolumns];  int v3=bytes_data[3+ncolumns];
 int v4=bytes_data[4+ncolumns];  int v5=bytes_data[5+ncolumns];
 int v6=bytes_data[6+ncolumns];  int v7=bytes_data[7+ncolumns];
 DM(END<<END<<"  0 "<<v0<<"  1 "<<v1<<"  2 "<<v2<<"  3 "<<v3<<"  4 "<<v4<<"  5 "<<v4
 <<"  6 "<<v6<<"  7 "<<v7<<END);
 
 v0=bytes_data[8+2*ncolumns];   v1=bytes_data[9+2*ncolumns];
 v2=bytes_data[10+2*ncolumns];  v3=bytes_data[11+2*ncolumns];
 v4=bytes_data[12+2*ncolumns];  v5=bytes_data[13+2*ncolumns];
 v6=bytes_data[14+2*ncolumns];  v7=bytes_data[15+2*ncolumns];
 DM(END<<END<<"  8 "<<v0<<"  9 "<<v1<<"  10 "<<v2<<"  11 "<<v3<<"  12 "<<v4<<"  13 "<<v4
 <<"  14 "<<v6<<"  15 "<<v7<<END);
 */

//******************************************************************************

//-----------------------------------*******************************************
/*                   // почти работающея версия
 //	binaryPrint(254, 2);  DM(" "); DM(END);
 unsigned int bytes_data_p32=data_size/32;
 unsigned int bytes_data_p4=data_size/4;
 unsigned int Mask=~(1 + (1<<8) + (1<<16) + (1<<24)); // 16843009  ~4278124286
 Mask=4278124286;
 binaryPrint(Mask, 2);  DM(" "); DM(END);
 //	Sb=16843009+(16843009>>2);
 //	binaryPrint(Sb, 2);  DM(" "); DM(END);
 //	Sb&=Mask;
 //	binaryPrint(Sb, 2);  DM(" "); DM(END);
 
 for ( x=8; x < bytes_data_p4-8; x++ ) { //s<5 && x<data_size_p_3;   data_size_p32
 Sb=bytes_data_32[x];
 ////Sb=16843009+(16843009>>2)+(1<<11);
 ///Sb=bytes_data_32[bytes_data_p4/2+32];
 ///binaryPrint(Sb, 2);  DM(" "); DM(END);
 ///DM(" Mask "<<Mask<<" Sb "<<Sb<<END);
 Sb=~(Sb | (~Mask));  // Sb=~Sb & Mask;
 ///binaryPrint(Sb, 2);  DM(" "); DM(END);
 ///DM(" Mask "<<Mask<<" Sb "<<Sb<<END);
 // Сумма единиц в регистре Sb    //0xFFFFFFFF
 Sb-=(Sb >> 1) & 0x55555555;                // 2-битовые ячейки
 Sb=(Sb & 0x33333333) + ((Sb >> 2) & 0x33333333); // 4-битовые
 Sb=(Sb + (Sb >> 4)) & 0x0F0F0F0F;                // 8-битоовые
 Sb+=Sb >> 8;                               // 16-битовые
 Sb+=Sb >> 16;                              // 32-битовая ячейка
 //NMask+=Sb & 0x3F;  // 31 Обнуляем старшие разряды, содержащие "мусор"
 Sb=Sb & 0x3F;  // 31 Обнуляем старшие разряды, содержащие "мусор"
 if( Sb>4 ) { break; } //  s>0;
 } // x    // 255 белый   //  Sb=0; tiff
 
 
 DM(" Mask "<<Mask<<" Sb "<<Sb<<END);
 */

//------------

/*
 // работающея версия
 // бинаризация входного массива битмап (изменино 20 октября 2010)
 int data_size_3=data_size-3;
 if(s>0 && invert==0) {
 for ( x=0; x < data_size_3; x+=4 ) {  // x=0; x < data_size; x++
 ///for ( x=0; x < data_size; x++ ) {
 ///if (bytes_data[x]>127){bytes_data[x]=1;}  else {bytes_data[x]=0;}
 // деление на 128 с присваиванием
 bytes_data[x]>>=7;    bytes_data[x+1]>>=7;
 bytes_data[x+2]>>=7;  bytes_data[x+3]>>=7;
 } // x
 } // if   // уровни в битмапе 0 и 255, уровни в битовом массиве 1 и 0   // 255 белый
 */

//------------

/*
 // работающея версия но не быстрее обычной  (изменино 20 октября 2010)
 
 // приведенный к unsigned int исходный распакованный массив черно-белого скана
 unsigned int* bytes_data_32=(unsigned int*)bytes_data;
 
 unsigned int bytes_data_p32=data_size/32;
 unsigned int bytes_data_p4=data_size/4;
 
 for ( x=8; x < bytes_data_p4-8; x++ ) { //s<5 && x<data_size_p_3;   data_size_p32
 ////Sb=16843009+(16843009>>2)+(1<<11);
 ///Sb=s0=bytes_data_32[bytes_data_p4/2+32];
 s0=s=bytes_data_32[x];
 // Sb сумма 4х бит 32х разрядного слова
 Sb =s0 & 255;
 s0=s>>8;  Sb+=s0 & 255;
 s0=s>>8;  Sb+=s0 & 255;
 s0=s>>8;  Sb+=s0 & 255;
 
 ///binaryPrint(s0, 2);  DM(" "); DM(END);        DM(" s0 "<<s0<<END);
 ///binaryPrint(Sb, 2);  DM(" "); DM(END);        DM(" Sb "<<Sb<<END);
 if( Sb>49999 ) { break; } //  s>0;
 } // x    // 255 белый   //  Sb=0; tiff
 
 DM(" Sb "<<Sb<<END);
 
 //DM(" Mask "<<Mask<<" Sb "<<Sb<<END);
 */

//------------

/*
 // работающея версия   (изменино 30 октября 2010)
 
 // Автоопределение количества градаций в битмапе
 // (изменино 20 октября 2010, в 3,0 раза быстрее классической).
 // Если в массиве встречается серое (или чб) больше едиици, то немедленно
 // выходим из цикла и далее выполняем бинаризацию битмапа.
 int data_size_8=data_size-8;
 for ( x=8; x < data_size_8; x+=4 ) { //s<5 && x<data_size_p_3;
 s=bytes_data[x]+ bytes_data[x+1]+ bytes_data[x+2]+ bytes_data[x+3];
 if( s>4 ) { break; } //  s=4;
 } // x
 
 //		 DM(END<<" x "<<x<<" s "<<s<<" data_size_8 "<<data_size_8<<END);
 
 
 // бинаризация входного массива битмап (изменино 20 октября 2010)
 int data_size_3=data_size-3;
 if(s>4){ // max>1
 for ( x=0; x < data_size_3; x+=4 ) {  // x=0; x < data_size; x++
 ///for ( x=0; x < data_size; x++ ) {
 ///if (bytes_data[x]>127){bytes_data[x]=1;}  else {bytes_data[x]=0;}
 // деление на 128 с присваиванием
 bytes_data[x]>>=7;    bytes_data[x+1]>>=7;
 bytes_data[x+2]>>=7;  bytes_data[x+3]>>=7;
 } // x
 }     // уровни в битмапе 0 и 255, уровни в битовом массиве 1 и 0
 */
//------------

//------------------------------------------------------------------------------
/*
 // работающея версия    (изменино 31 октября 2010)
 
 //автоопределение количества градаций в битмапе.
 // Если в массиве встречается серое (или чб) больше едиици (1+1+1+1=4),
 // то немедленно выходим из цикла и далее выполняем бинаризацию битмапа.
 int data_size_32=data_size-32;   s=0;
 for ( x=32; s<5 && x < data_size_32; x+=4 ) { // эквивалентно if(s>4) {break;}
 s=bytes_data[x]+ bytes_data[x+1]+ bytes_data[x+2]+ bytes_data[x+3];
 } // x  // в бинаризации д.б. s>4
 //*/
/*
 //invert=1;
 unsigned int inv;
 if(invert<1) { inv=0;} //  invert=0;  без инверсия (обычно белый фон)
 if(invert>0) { inv=1;} //  invert=1;  инверсия (обычно черный фон)
 
 // бинаризация входного массива битмап с управляемой инверсией
 b_data=data_size-3;
 if(s>0) { // s>0 // s>4
 for ( x=0; x < b_data; x+=4 ) {
 // деление на 128 с управляемой инверсией
 bytes_data[x]  =(bytes_data[x]>>7)   - inv;
 bytes_data[x+1]=(bytes_data[x+1]>>7) - inv;
 bytes_data[x+2]=(bytes_data[x+2]>>7) - inv;
 bytes_data[x+3]=(bytes_data[x+3]>>7) - inv;
 } // x
 } // if   Выходной битмап:   0-черный    1-белый
 //*/
/**/
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
/**/
/*
 // СДВИГ ВНИЗ всего массива bites_data_32, как единого регистра на d0 строк
 
 // Добавление пикселей с нижней стороны символа.
 if(gRateLower>0 && m<dltLower) { // количество добавленных однопиксельных слоёв с нижней стороны символа
 for ( x=data_size_p32;  x > d0;  x-- ) {
 bites_data_32[x]=bites_data_32[x] & bites_data_32[x-d0];
 } // x
 } // if
 
 // Убавление пикселей с нижней стороны символа.
 if(gRateLower<0 && m<dltLower) { // количество убавленных однопиксельных слоёв с нижней стороны символа
 for ( x=data_size_p32;  x > d0;  x-- ) {   // d0
 bites_data_32[x]=bites_data_32[x] | bites_data_32[x-d0];
 } // x
 } // if
 
 
 } // m
 */
//------------------------------------------------------------------------------

/**/
//-----------------------------------*******************************************
