//  OCRLib  2015 www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  Will Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .

#include "GBitmap.h"


namespace ocr{
 
    
       
//*****************************************************************************
    
// функция определения пространственной ориентации Тибетского графического текста.
    
void  GBitmap::textOrientation(int *lineOrient, int *lineHeight) {

        // Определяет пространственную ориентацию Тибетского графического текста и возвращает.
        // orientation=1;  текст нормально ориентирован.
        // orientation=-1; текст повернут на 180.
        // orientation=0;  ориентация текста определена не достоверно.
        // Возвращает среднею высоту строки lineHeight  (без влияния рамок вокруг текста)
        // Входной массив bytes_data это unsigned char и может быть любым черно-белым или серым.
        
        //  * Идея *
        // Буквы Тибетского текста часто в верхней части имеют ярко выраженную горизонтальную полку.
        // Нижняя часть букв не имеет характерных графических особенностей.
        // По этому суммарная яркость строки по горизонтали имеет выраженную ассимерию между нижней и верхней половиными строк.
        // Вычисляя эту ассиметрию можно определить верхнею и нижнею часть строки. 
        
        //  * Реализация *
        // оптимальное число колонок 3-4, если разбивать текст на большее число колонок, то внутри колонки может не хватить
        // статистики для определения ориентации текста. Меньшее число колонок так же не позволяет правильно определить 
        // ориентацию текста, из встречающихся вертикальных деформаций по длинных печа.
        
        //  * Особенности применения *
        // Перед применением функции не забыть повернуть графическй текст.
        // Функция возвращает среднею высоту строки lineHeight без влияния рамок вокруг текста.
        // Среднея высота это все таки скорее оценка высоты строки чем ее истинное значение.
        


        
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        
///TIME_START 

        if (GrafT) { cout<<"Определение пространственной ориентации Тибетского текста   textOrientation()"<<endl; } 
                
        int x,y; 
        int w,h;    //int w_h=w*h;
        w=ncolumns; // ширина массива  IMAGE WIDTH
        h=nrows;    // высота массива  IMAGE HEIGHT
        if (GrafT) { cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
                
        // управляющие переменные
        int m=3; // количество вертикальных колонок в которых производится  независимый анализ ориентации текста 
        int thresholdAsm1=2;      // порог, выше которого коэффициент ассиметрии считается легитимным 
        int thresholdAsm2=50;     // порог, ниже которого коэффициент ассиметрии считается легитимным 
        int orientM=0;            // параметр ориентации Тибетского графического текста в одной колонке
        int orientMean=0;         // возвращаемый параметр ориентации Тибетского графического текста по всем колонкам.
        
        // вспомогательные переменные
        int n=0;             // переменная строк
        int md;              // суммарный горизонтальный размер "m" колонок
        int w_n;             // переменная используемая для приведение уровней графического текста к уровню белого=0  // w_n=w/ns+1;
        int max_s1, max_s2;  // значение максимума (амплитуды) горизонтальных сумм внутри первой, второй половины строки                
        int lineHgM=0;       // вычисленная средняя высота строки по одной колонки
        int lineHgMean=0;    // вычисленная средняя высота строки по всем колонкам
        int NLine=0;         // вычисленное количество легитимных строк в печа
        int MLine;           // вычисленное количество легитимных колонок в печа (количество колонок, где есть хотя бы одна строка)
        int asymetr;         // вычисленный средний коэффициент ассиметрии строки приведенный к 100 процентам
        int asymetrM=0;      // средний коэффициент ассиметрии asymmetry строки приведенный к 100 процентам: 
        // в полностью симметричной строке коэффициент ассиметрии asymmetry стремится к 0 (обычно -2 до 2), 
        // в ассиметричной строке стремится к 100 процентам (обычно 5-15),
        // в ассиметричной строке повернутой на 180 градусов стремится к -100 процентам (обычно те же 5-15, но отрицательные)
        
        // вспомогательные переменные для увеличения быстродействия
        int s;        // ,sum,snorm                
        int n1,n3;
        int n00,n11;
        int b1,b2,b3;
        
        // вспомогательные переменные для предотвращения выхода за пределы массива
                
        // указатели
        unsigned char *p0=bytes_data;    // входной массив, 0-черный 255-белый ( с 0-черный 1-белый не работает)
        int *BufS1, *d1;  // массив //
        int *BufS2;       // массив // *d2
        int *BufS3, *d3;  // массив //
        int sizeBufS=h;
        int sizeBufS_bytes=sizeBufS*sizeof(int);
        
        // Массивы. Каждый элемент инициализируется в 0.
        BufS1 = (int*)calloc(sizeBufS+32,sizeof(int)); // d1
        BufS2 = (int*)calloc(sizeBufS+32,sizeof(int)); // d2
        BufS3 = (int*)calloc(sizeBufS+32,sizeof(int)); // d3
        
        OCRFilter *SP=OCRFilter::create(nrows);  // необходима для filterHigh()
        
        // Увеличение шага сканирования графического текста (по ширине w). Для увеличения быстродействия.
        // Если ширина графического текста больше 5000 pix то суммируем пиксели через n 
        int ns=w/5000+1;         // if(ns>10) ns=10;
        //ns=1; //ns=500;   
        if (GrafT) { cout<<"шаг сканирования графического текста    ns="<<ns<<endl; }
        
        // Увеличение степени сглаживания горизонтальных сумм для сверхбольших печа. Если горизонтальная длинна     
        // графического текста больше 10000 pix, то коэффициенты сглаживания увеличиваются вдвое и т.д. 
        int mf=w/10000 + 1;         
        int KHigS1=3*mf;    // 4 min     // KHig1=(8-24) // KHigS=KFStrok*4+8;filter
        int KHigS2=12*mf;       
        int KHigS3=128*mf;  // пока 80 зто максимум, надо 160*m
        if (GrafT) { cout<<"величина увеличения сглаживания горизонтальных сумм   mf="<<mf<<endl; } 
         
        
        // отступы от краев (бордюр) x0, x1, y0, y1, блокируют влияние грязи с краев текста.
        // Возможный захват бордюром не большой части текста в данном случае не критичен.
        int br=8;   // 6
        int x0, x1, y0, y1;
        y0=h/br;  y1=h-h/br; // x0=w/br
        
        //переменные для визуализации гистограмми
        int M=6; static short delta=10; int ss;
        
        //int index=0;     // 2   // test

     
//************************************************************************************************************ 
      
   // цикл по числу вертикальных колонок в которых производится  независимый анализ ориентации текста 
   MLine=m;
   for (int index=0; index < m; index++){ 
        
        md=(w-w*2/br)/m; // суммарный горизонтальный размер "m" колонок
        // динамический бордюр
        x0=w/br + index*md;   x1=x0 + md;  if(x1 > w) x1=w;
        ///cout<<"index="<<index<<"   md="<<md<<"   x0="<<x0<<"   x1="<<x1<<endl;
        // int x0=w/br;  int x1=w-w/br;  // классический вариант статического бордюра
       
        // обнуление массива BufS1
        memset(BufS1, 0, sizeBufS_bytes);  // начало (указатель), значение, количество символов в байтах (длинна) unsigned.        
               
        if (GrafT) { 
            // горизонтальные линии, паказывающая область работы колонок.
            for(y=y0; y < y0+5; y++) { for (x=x0; x<x1; x++) { bytes_data[y*w+x]*=0.1; } }
            for(y=y1; y < y1+5; y++) { for (x=x0; x<x1; x++) { bytes_data[y*w+x]*=0.1; } }
            // вертикальные линии, паказывающая область работы колонок.
            for(y=y0; y < y1; y++) { for (x=x0; x<x0+5; x++) { bytes_data[y*w+x]*=0.5; } }
        }        
        
        // подсчет горизонтальных (horizontal_sum) сумм  //        
        w_n=(x1-x0)/ns+1;   // переменная используемая для приведение уровней графического текста к уровню белого=0// w_n=w/ns+1;
        d1=BufS1;  
        for (y=y0; y < y1; y++){       // 16224 × 2464 // time=0.13      // time=0.031
            s=0;
            p0=bytes_data + y*w;
            for (int x=x0; x < x1; x+=ns){            
                if ( *(p0+x)>0 ) { s++; }  //s+=*(p0+x);  // time=0.11                
            } // x 
            // приведение уровней графического текста к уровню белого 0 и уровню черного 1 
            *(d1+y)=(w_n-s)*ns;
        } // y
        //cout<<endl;        
        /**/ 
        
        
        // слабая фильтрация  KHigS1=3*mf;
        // начало BufS1 так же используется для хранения координат координат верха и низа строк        
        // для графического текста с горизонтальной длинной меньше 7000 pix (mf=1) сглаживание не используем
        if ( mf >= 1 ) { SP->filterHigh( (int*)BufS1, h, KHigS1); }               
        // визуализация BufS1
        if (GrafT) {    if (GrafT ) {  }
            M=6; delta=10;   // uint
            for(y=0; y<h; y++) { ss=(BufS1[y]/M)+delta; if (ss>w)ss=w; for (x=delta; x<ss; x++) { bytes_data[y*w+x]*=0.6; } } 
        } 
       
        
        // копирование BufS1 в BufS2
        memcpy(BufS2, BufS1, sizeBufS_bytes);  // адрес буфера назначения, адрес источника, количество байт для копирования
        // средняя фильтрация KHigS2=12*mf; 
        SP->filterHigh( (int*)BufS2, h, KHigS2) ;        
        // визуализация BufS2
        if (GrafT) {  
            M=6; delta=10;   
            for(y=0; y<h; y++) { ss=(BufS2[y]/M)+delta; if (ss>w)ss=w; for (x=delta; x<ss; x++) { bytes_data[y*w+x]*=0.6; } }                
        } 
        
       
        // копирование BufS2 в BufS3
        memcpy(BufS3, BufS2, sizeBufS_bytes); // адрес буфера назначения, адрес источника, количество байт для копирования                        
        // сильная фильтрация KHigS3=128*mf;  // пока 80 - зто максимум того, что позволяет filterHigh(), поэтому сглаживаем 3 раза              
        SP->filterHigh( (int*)BufS3, h, KHigS3 );
        SP->filterHigh( (int*)BufS3, h, KHigS3 );
        SP->filterHigh( (int*)BufS3, h, KHigS3 );
        /**/    
        // визуализация BufS3
        if (GrafT) { 
            M=6; delta=10;     // uint
            for(y=0; y<h; y++) { ss=(BufS3[y]/M)+delta; if (ss>w)ss=w; for (x=delta; x<ss; x++) { bytes_data[y*w+x]*=0.6; } }
        } 
       
        
        // бинаризация BufS2 // 
        // здесь BufS3 становится меандром, который используется для вычисления координат верха и низа строк 
        for (y=0; y < h; y++) { if ( BufS2[y] > BufS3[y] + 8 ) { BufS3[y]=1024; } else { BufS3[y]=0; } } // y
        // обнуление хвостов
        memset(BufS3, 0, 4*y0);   memset(BufS3+y1, 0, 4*(h-y1));   // начало (указатель), значение, количество символов в байтах (длинна) unsigned
        //for (y=y1; y < h; y++) { BufS3[y]=0; }
        // визуализация границ строк (гистограмма)
        if (GrafT) {
            M=1; delta=w/8; 
            for(y=0; y<h; y++) { ss=(BufS3[y]/M)+delta; if (ss>w)ss=w; for (x=delta; x<ss; x++) { bytes_data[y*w+x]*=0.6; } } 
        }
       
        
        // подсчет числа строк и их координат //
        n1=0;  n3=0;                  
        //for (y=y0-1; y < y1; y++){ // y=y0-1;
        for (y=0; y < h; y++){ 
            d3=BufS3+y; 
            // вычисление координаты верха строки
            if ( *d3<*(d3+1) ) { n1+=4; BufS1[n1]=y; }   
            // вычисление координаты низа строки
            if ( *d3>*(d3+1) ) { n3+=4; BufS1[n1+2]=y; BufS1[n1+3]=0; }           
        } // y        
        if (GrafT) { cout<<"число строк  (n1)/4="<<n1/4<<"  (n3)/4="<<n3/4<<endl; }
        
       
        asymetrM=0;      // вычисленный средний коэффициент ассиметрии      
        lineHgM=0;       // вычисленная средняя высота строки
        NLine=0;         // вычисленное количество легитимных строк в печа
       
        // Отбрасывание рамок. Убираем по 1 строке (или по 2) сверху и по 1 строке (или по 2) снизу
        n00=4; n11=n1+4; // одна строка это 4    // for (n=4; n < n1+4; n+=4)
        if ( n1 > 5*4 && n1 <= 7*4) { n00=4+4; n11=n1+4-4; }    if ( n1 > 7*4 ) { n00=4+8; n11=n1+4-8; } 
       
        // вычисление коэффициента ассиметрии и средней высоты строки графического текста  // 
        for (n=n00; n < n11; n+=4){  // цикл по числу строк 
            max_s1=0;   max_s2=0;  
            b1=BufS1[n];  b2=BufS1[n+2];  b3=(b1+b2)/2;            
            // вычисление максимума (амплитуды) горизонтальных сумм внутри первой половины строки            
            for ( y=b1; y < b3; y++){ if ( BufS1[y] > max_s1 ) { max_s1=BufS1[y]; } }  
            // вычисление максимума (амплитуды) горизонтальных сумм внутри второй половины строки            
            for ( y=b3; y < b2; y++){ if ( BufS1[y] > max_s2 ) { max_s2=BufS1[y]; } }    
            // маленькие амплитуды не обсчитываем
            if ( max_s1<16 || max_s2<16) { max_s1=0; max_s2=0; }    
            // вычисление коэффициента ассиметрии , как разности амплитуд горизонтальных сумм выше и ниже 
            // середины строки (в пределах строки), приведенной к 100 процентам            
            asymetr=(max_s1 - max_s2)*100/(max_s1 + max_s2 + 1);  
            ////cout<<"asymetr="<<asymetr<<"   b1="<<b1<<"   b3="<<b3<<"   b2="<<b2<<endl;
            if (GrafT) { cout<<"asymetr="<<asymetr<<endl; }
            // вычисление суммарного коэффициента ассиметрии и суммарной высоты строки графического текста, только если
            // коэффициент ассиметрии лежит между значениями порогов thresholdAsm1=2 и thresholdAsm2=50 т.е. от 3 до 49.
            if ( (asymetr>thresholdAsm1 && asymetr<thresholdAsm2 )||( asymetr<-thresholdAsm1 && asymetr>-thresholdAsm2)) 
            { asymetrM+=asymetr;  lineHgM+=(b2-b1);  NLine++; }
        } // n
        // cout<<endl;
        
        // нормировка средней высоты строки графического текста по одной колонке.
        if ( NLine==0 ) { lineHgM=0; MLine--; }  else { lineHgM/=NLine;  lineHgMean+=lineHgM; }        
        if (GrafT) { cout<<"средняя высота строки   lineHgM="<<lineHgM<<endl;
                     cout<<"число легитимных строк  NLine="<<NLine<<endl; }
        
        // нормировка среднего коэффициента ассиметрии.
        if ( NLine==0 ) { asymetrM=0; }  else { asymetrM/=NLine; } 
        if (GrafT) { cout<<"средний коэффициент ассиметрии   asymetrM="<<asymetrM<<endl; }
        
        // установка параметра ориентации Тибетского графического текста по каждой колонке.
        orientM=0;
        if ( asymetrM >  thresholdAsm1 ) orientM=1; 
        if ( asymetrM < -thresholdAsm1 ) orientM=-1;
        orientMean+=orientM;
        if (GrafT) { cout<<"параметр ориентации Тибетского графического текста     orientM="<<orientM<<endl; }
        /**/  
        
       
   } // index 
        
        // последняя (крайне правая) вертикальная линия, паказывающая область работы колонок.
        if (GrafT) { for(y=y0; y < y1; y++) { for (x=x1; x<x1+5; x++) { bytes_data[y*w+x]*=0.5; } }  }       
        
//************************************************************************************************************
        
        // вычисление средней высоты строки графического текста по всем колонкам. 
        // MLine это количество колонок, где есть хотя бы одна строка
        if ( MLine > 0 ) { lineHgMean/=MLine; }  else { lineHgMean=0; }        
        ///cout<<endl<<"средняя высота строки по всем колонкам   lineHgMean="<<lineHgMean<<endl;
        if (GrafT) { cout<<"число легитимных колонок в печа   MLine="<<MLine<<endl; }        
        //*lineHeight=(float)lineHgMean*0.8;
        *lineHeight=lineHgMean*(float)0.8; // (float)0.8;
        
        // окончательная установка параметра ориентации Тибетского графического текста по всем колонкам.
        if ( orientMean >=  1 ) orientMean=1;    if ( orientMean <= -1 ) orientMean=-1;
        //if (GrafT) { cout<<"orientMean="<<orientMean<<endl; }
        *lineOrient=orientMean;
        
        // освобождение массивов 
        if ( BufS1 !=NULL ) free(BufS1);
        if ( BufS2 !=NULL ) free(BufS2);
        if ( BufS3 !=NULL ) free(BufS3);
        
        
///TIME_PRINT_
        
}//____________________________________________________________________________   
    
    
    
        
        //---------------------------------------------------------------------------
        /// TMP ///
        
        // memset(horizontal_sum, 255, 4*h);  // начало (указатель), значение, количество символов в байтах (длинна) unsigned
        
        // граници выделяем механизмом растискивания
        
        // общая переменная (9999) - оценка средней высота строки, для всего батча, нужна для textOrientation() и textClean()
        // если не подсчитана, то программы запускают свой подсчет
        
        // сглаживание KHig1=8(8-24) и KHig10 как порог, как в binarisation или Лапласиане. Меандр как нахождение максимума продольных сумм строк, фактическое  
        // нахождение мах, деление площади на две части, вычисление ассиметрии, простая статистическая обработка результатов по строкам. 
        //  сильная фильтрация (80, надо 128-256) исходных горизонтальных сумм
        // вычисление максимума maxF сильно фильтрованных исходных сумм
        
        
        //KHigS=0;       // оптимальный параметр фильтрации строк
        //DeltaNstr=0;   // вычисленная высота строки
        //NStrok=0;      // вычисленное колличество строк в печа
        
        // if ( w>1000 ) { то подсчет horizontal_sum выполняем 3 не зависимыми вертикальными блоками}
        //  else { то выполняем обычный подсчет horizontal_sum по всей площади }
        
        //---------------------------------------------------------------------------
        
/*        
        int dot_gain=7;
        int g1, g2, g3, g4;
        cout<<"dot_gain="<<dot_gain<<endl;

        int dg=dot_gain/2;        // cout<<"dg="<<dg<<endl;   // division
        g1=dg;  g2=dg;  g3=dg;  g4=dg;
        dg=dot_gain%2;            // cout<<"dg="<<dg<<endl;   // modulo
        g1+=dg;  g3+=dg; 
        cout<<"g1="<<g1<<"   g2="<<g2<<"    g3="<<g3<<"   g4="<<g4<<endl;         
*/
        
        
        ///*(d1+y)=snorm=(w_n-s)*ns;   
        // подсчет вертикальных интегральных сумм (лесенка)
        ///sum+=snorm; *(d4+y)=sum;  
        // cout<<"_"<<(short)*(d1+y);
        // int max_y=0;       // координаты максимума горизонтальных сумм в строке
        // int max_s=0;         // максимальное значение горизонтальных сумм в строке 
        // d2=BufS2+y; d3=BufS3+y;   if ( *d2 >*d3 ) { *d3=1024; } else { *d3=0; }
        
         /*
         asymetr=49; ///  3-49
         // только если коэффициент ассиметрии лежит между значениями порогов thresholdAsm1=2 и thresholdAsm2=50 т.е. от 3 до 49
         if ( (asymetr>thresholdAsm1 && asymetr<thresholdAsm2 )||( asymetr<-thresholdAsm1 && asymetr>-thresholdAsm2)) 
         { cout<<"параметр     asymetr="<<asymetr<<endl; }
         */
        
        // вычисление средней высоты строки графического текста.
        ///if ( asymetr>thresholdAsm1 || asymetr<-thresholdAsm1 ) { lineHgM+=(b2-b1); NLine++; }
        // вычисление среднего коэффициента ассиметрии.
        ///asymetrM+=asymetr;
        /*
        max_s1=44; max_s2=24;
        if ( max_s1<16 || max_s2<16) { max_s1=0; max_s2=0; }
        cout<<"параметр     max_s1="<<max_s1<<"            параметр     max_s2="<<max_s2<<endl;
        */
        // обнуление массива BufS3
        ///memset(BufS3, 0, 4*y0);     memset(BufS3+y1, 0, sizeBufS_bytes);  // начало (указатель), значение, количество символов в байтах (длинна) unsigned
        //for (y=y1; y < h; y++) { BufS3[y]=0; }
        
        
        /*
        // Отбрасывание рамок. Убираем по 1 строке (или по 2) сверху и по 1 строке (или по 2) снизу
        n00=4; n11=n1+4; // одна строка это 4    // for (n=4; n < n1+4; n+=4)
        if ( n1 > 5*4 && n1 <= 7*4) { n00=4+4; n11=n1+4-4; }    if ( n1 > 7*4 ) { n00=4+8; n11=n1+4-8; } 
        ///int max_y1;  int max_y2; int max_dy;  int asm_y;
        
        // вычисление коэффициента ассиметрии и средней высоты строки графического текста  // 
        for (n=n00; n < n11; n+=4){  // цикл по числу строк 
            max_s1=0;   max_s2=0;  
            b1=BufS1[n];  b2=BufS1[n+2];  b3=(b1+b2)/2;            
            // вычисление максимума (амплитуды) горизонтальных сумм внутри первой половины строки            
            for ( y=b1; y < b3; y++){ if ( BufS1[y] > max_s1 ) { max_s1=BufS1[y]; } }  // max_y1=y;
            // вычисление максимума (амплитуды) горизонтальных сумм внутри второй половины строки            
            for ( y=b3; y < b2; y++){ if ( BufS1[y] > max_s2 ) { max_s2=BufS1[y]; } }  // max_y2=y;  
            ///max_dy=max_y2-max_y1;    asm_y=max_dy*100/48; // (b2-b1+1)
            ///max_dy=max_y2-max_y1;    asm_y=((b3-max_y1)-(max_y2-b3))*100/(max_y2 - max_y1 + 1); // (b2-b1+1)
            // маленькие амплитуды не обсчитываем
            if ( max_s1<16 || max_s2<16) { max_s1=0; max_s2=0; }    
            // вычисление коэффициента ассиметрии , как разности амплитуд горизонтальных сумм выше и ниже 
            // середины строки (в пределах строки), приведенной к 100 процентам            
            asymetr=(max_s1 - max_s2)*100/(max_s1 + max_s2 + 1);  
            ///cout<<"asymetr="<<asymetr<<"   b1="<<b1<<"   max_y1="<<max_y1<<"   b3="<<b3<<"   max_y2="<<max_y2<<"   b2="<<b2<<endl;
            ////cout<<"asymetr="<<asymetr<<"   b1="<<b1<<"   b3="<<b3<<"   b2="<<b2<<endl;
            ////cout<<"asymetr="<<asymetr<<"   max_dy="<<max_dy<<"   asm_y="<<asm_y<<endl;
            if (GrafT) { cout<<"asymetr="<<asymetr<<endl; }
            // вычисление суммарного коэффициента ассиметрии и суммарной высоты строки графического текста, только если
            // коэффициент ассиметрии лежит между значениями порогов thresholdAsm1=2 и thresholdAsm2=50 т.е. от 3 до 49.
            if ( (asymetr>thresholdAsm1 && asymetr<thresholdAsm2 )||( asymetr<-thresholdAsm1 && asymetr>-thresholdAsm2)) 
            { asymetrM+=asymetr;  lineHgM+=(b2-b1);  NLine++; }
        } // n
        // cout<<endl;
        */

        

    
    
//--------------------------------------------------------------------------------------------------------------------------------------------------------
    
    

    
    
}