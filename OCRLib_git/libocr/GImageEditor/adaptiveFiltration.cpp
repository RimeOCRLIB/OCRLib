#include "GImageEditor.h"
//#include <math.h>

void GImageEditor::adaptiveFiltration1(GBitmap *img_pecha,float *p,int mode){
    int line_width=44;
    int line_wd0=0, line_wd1=0, line_wd2=0;
    int line_wd; 
    //общие управляющие переменные
    int Tr1=85, BASE1=24;
    int amplitude0=0;
    int textOrientation=0;
    int g1=0, g2=0, g3=0, g4=0, dot_gain=0;
    int amplitude1=0;
    int n_RemovLayers=0;
    int graduation;
    int g=12; // по умолчанию g=8, параметр задающий максимально возможный определяемый угол наклона текста,
    float rotation=0;
    float scale=p[0];
    if(scale<0.25)scale=1;
    //cout<<"scale="<<scale<<endl;
    if(mode==2) {
        /*
         p[0] - scale
         p[1] - Tr1=85;
         p[2] - BASE1=24; ///70 светлее 90 темнее BASE1=32 для Калачакры с равной толщиной штриха, было 4
         p[3] - amplitude0=0;     /// 2 для Калачакры с равной толщиной штриха, было 0
         p[4] - amplitude1=2;  // amplitude=4  // 0 без изменений.
         p[5] - textOrientation=0;
         p[6] - line_wd1=47;  //line_wd1=51;  // если line_wd1=0  то оно вычисляется функцией измерения толщины штриха 47
         p[7] - n_RemovLayers=1;
         p[8] - dot_gain=1;
         p[9] - g; //диапазон угола детектора поворота
         p[10]- //нормализация ориентации
         */
        Tr1=p[1];
        BASE1=p[2]; ///70 светлее 90 темнее BASE1=32 для Калачакры с равной толщиной штриха, было 4
        amplitude0=p[3];     /// 2 для Калачакры с равной толщиной штриха, было 0
        amplitude1=p[4];  // amplitude=4  // 0 без изменений.
        textOrientation=p[5];
        line_wd1=p[6];  //line_wd1=51;  // если line_wd1=0  то оно вычисляется функцией измерения толщины штриха 47
        n_RemovLayers=p[7];
        dot_gain=p[8];
        g=p[9];
        if(p[10]!=0)img_pecha->rotateFast(p[10]);
        
        img_pecha->bilinearScale(scale);
        img_pecha->crop32();
        graduation=img_pecha->DetectGradations();
        img_pecha->gaussian(amplitude0);
        img_pecha->binarisation(Tr1, BASE1);
        img_pecha->focalLine(n_RemovLayers); // одна единица в параметре функции удаляет по одному пикселю с каждой стороны т.е. два пикселя.
        img_pecha->dotGain(g1, g2, g3, g4, dot_gain);     // необходим либо ncolumns кратности 32 или (g, g, 0, 0, dot_gain)
        img_pecha->gaussian(amplitude1);
        img_pecha->binarisation(Tr1, BASE1);
        if(g)rotation=img_pecha->detectPageAngle(g); // угол поворота в градусах
        img_pecha->rotateFast(rotation);

    }else{
        img_pecha->bilinearScale(scale);
        img_pecha->crop32();
        img_pecha->binarisation(Tr1, BASE1);
        if(g)rotation=img_pecha->detectPageAngle(g); // угол поворота в градусах
        img_pecha->rotateFast(rotation);
    }


}


void GImageEditor::adaptiveFiltration(GBitmap *img_pecha,float scale,int mode){
    
    // если line_width не равно нолю, то это главное значение (главнее line_wd1=47;)
    int line_width=44;   // 60 // измеряется в десятых долях пикселя. Шаг 25   // 100
    // Если за ранее не известно рекомендованное значение *толщины* штриха для всех страниц графического текста, то данную функцию 
    // можно запустить при параметре line_width=0 и в комментариях (выводятся при GrafT=1;) получить такое сообщение:
    // "рекомендованное значение *толщины* штриха для всех страниц,        line_wd=59 pix"
    // Если результат удовлетволительный (определяется визуально по графической картинке 2.tif), то это значение line_width=59 можно использовать 
    // при следующих запусках для стандартизации *толщины* штриха всех страниц графического текста данной книги.
    // Если результат не удовлетволительный, то можно рекомендованное значение line_width=59 подкорректировать в ручную, помня  
    // что line_width измеряется в десятых долях пикселя, а реальная толщина штриха может состоять только из целого числа пикселей. 
    
    //mode=0;     // - нормализация страницы простая (Калачакра - книга с разворотами) 
    //int mode=1;   // - нормализация страницы с восстановлением толщины штриха. Пока mode=1 настроена под Калачакру - книгу с разворотами 
                    //   равной толщины и блоки помечены 3 ремарками
    //int mode=5;   // - нормализация буквы в базе данных (состоящей из букв эталонов) с восстановлением толщины штриха
    //int mode=3;   // - нормализация поворота
    
    //cout<<"Запуск блока функций, осуществляющих адаптивную фильтрацию графического текста  adaptiveFiltration()  mode="<<mode<<endl;
    
    int line_wd0=0, line_wd1=0, line_wd2=0;
    int line_wd;
    //общие управляющие переменные
    int Tr1=87, BASE1=4;          
    int amplitude0=0;
    int textOrientation=0;
    int rotation=0;
    int g1=0, g2=0, g3=0, g4=0, dot_gain=0;
    int amplitude1=0;
    int Tr2=87, BASE2=4;    
    int n_RemovLayers=2;
    int amplitude2=4;
    int GrafT=1;
    //scale=0.7;
    //int deltaDotGain=1;  // для худых текстов =1  для плотных текстов =0
    
    //mode=1;
    //cout<<" mode="<<mode<<" scale="<<scale<<endl;
    
    // нормализация страницы простая - управляющие переменные //
    if(mode==0) {
        // Преобразование серого массива в битовый массив (адаптивный порог)  
        Tr1=80; BASE1=32;
        
        amplitude0=0;
        /// Билинейное масштабирование изображения серого массива. ///
        
        GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    }
 
    
    // нормализация страницы - управляющие переменные //
    if(mode==1) {
        
        // Преобразование серого массива в битовый массив (адаптивный порог)   // time=0.089
        Tr1=85; BASE1=32; /// BASE1=32 для Калачакры с равной толщиной штриха, было 4
        
        amplitude0=0;     /// 2 для Калачакры с равной толщиной штриха, было 0
                          /// 2 для шрифта TCRC, было 0. Фактически перенесли фильтрацию Гауссианом с конца функции
                          /// в ее начало, для подавления шумовых пикселей контура, остальные режимы mode не проверяли.
        
        /// Определение пространственной ориентации Тибетского графического текста и средней высоты строки ///
        //textOrientation=1;
        
        /// Билинейное масштабирование изображения серого массива. ///
        //scale=(float)0.58; /// 2.0 для Калачакры с равной толщиной штриха, было 1
        
        //img_pecha->rotateFast(-90);
        /// Определение пространственной ориентации Тибетского графического текста и средней высоты строки ///
        textOrientation=0;
        
        /// Имитация полиграфического растискивания dot_gain. ///
        dot_gain=0;  // =2; // записи  g1=0, g2=0, g3=0, g4=0, dot_gain=2;  и  g1=1, g2=1, g3=1, g4=1, dot_gain=0; эквивалентны
        //g1=0; g2=0; g3=1; g4=0;  dot_gain=0;
        // Количество добавленных однопиксельных слоёв вокруг символа от 1 до 31, убавленных от -1 до -31, без изменений 0. 
        
        
        /// Степень сглаживание (blur) Гауссианом графического текста amplitude. ///
        amplitude1=0;  // amplitude=4  // 0 без изменений.
        
        // Задание среднего значения толщины штриха line_wd1 без измерения 
        line_wd1=47;  //line_wd1=51;  // если line_wd1=0  то оно вычисляется функцией измерения толщины штриха 47
        
        img_pecha->eraseBorder(50,0);
        
        /// Здесь полностью повторяется блок mode==5. ///
        //  n_RemovLayers==F(line_wd1);
        //  dot_gain==F(line_wd1);
        //  amplitude2==F(line_wd1);
        
        
        GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    }
    /**/
    
    // нормализация буквы в базе данных с восстановлением толщины штриха - управляющие переменные //
    if(mode==5) { 
        
        // весь блок автоматизированн и заводится от толщины штриха line_wd1
        
        /// Функция стандартизации начертания текста путем определения фокальной линии (графемы) букв. ///
        //  n_RemovLayers==F(line_wd1);  // n_RemovLayers=2; // 0 без изменений. 
        line_wd1=47;
        /// Имитация полиграфического растискивания dot_gain. ///
        //  dot_gain==F(line_wd1);       //  dot_gain=4;     // 0 без изменений.       
        
        /// Степень сглаживание (blur) Гауссианом графического текста amplitude. ///
        //  amplitude2==F(line_wd1);     //  amplitude2=4;   // 0 без изменений.
        
        GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }        
    }
    /**/
    
     // нормализация буквы в базе данных - управляющие переменные //
     if(mode==3) {
         img_pecha->rotateFast(-90);
         /// Определение пространственной ориентации Тибетского графического текста и средней высоты строки ///
         textOrientation=1;
         
         GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  } 
     }
     /**/    
        
    /* 
    // Полный список всех функций, удобный для их обзора. Полный доступ ко всем параметрам // 
    int Manual=1; 
    // если задаваемая пользователем толщина штриха Manual=0; то все коэффициенты задаем в ручную    
    // если Manual не равна нулю, то коэффициенты (BASE2, dot_gain) считаем от толщины штриха.
    if (Manual==0) {
        // DetectGradations(). Автоопределение наличие серого или черно-белого в битмапе. // time=0.006 // w=16224 × h=2464
        scale=(float)1.0;      // bilinearScale(scale). Билинейное масштабирование серого изображения. // time=1.00  
        Tr1=87, BASE1=4;       // binarisation(). Преобразование серого массива в битовый массив (адаптивный порог) // time=0.089 
        // detectPageAngle(g). Функция определения угла наклона текста
        // rotateFast(rotation). Вращение битовой картинки
        // lineWidth(). Измерение среднего значения толщины штриха line_w в буквах  (изм. в десятых долях pix) // time=0.022
        // textOrientation( &lineOrient, &lineHeight ). Определение пространственной ориентации Тибетского текста и ср. высоты строки.// time=0.049  
        
        // crop32(). Нормализация массива bytes_data по размеру ncolumns кратным 32 // time=0.17 // необходима для работы функции dotGain 
        g1=0, g2=0, g3=0, g4=0, dot_gain=2; // g1=1, g2=1, g3=1, g4=1, dot_gain=0;  // dotGain(). Имитация полиграфического растискивания.
        amplitude1=5; // 2, 5   // gaussian(amplitude). Сглаживание (blur) массива bytes_data двухмерным Гауссианом  // time=0.25
        Tr2=87, BASE2=4; // если  amplitude1>0 // binarisation(). Преобразование серого массива в битовый массив (адаптивный порог) // time=0.089
        
        // Функция определения параметров для не полной стандартизации начертания текста (фокальная линия получается переменной толщины): //
        // n_RemovLayers==F(line_wd1);   dot_gain==F(line_wd1);   amplitude2==F(line_wd1); //
        n_RemovLayers=2; // focalLine(). Не полная стандартизации начертания текста (фокальная линия получается переменной толщины)   
        // w*h=4 млн. пикселей time=0.26  // w*h=10 млн.  time=0.68  // 4.3  w*h=39 млн., n_RemovLayers=15
        g1=0, g2=0, g3=0, g4=0, dot_gain=4; // g1=1, g2=1, g3=1, g4=1, dot_gain=0;  // dotGain(). Имитация полиграфического растискивания.
        amplitude2=4; // 2, 5  // gaussian(amplitude). Сглаживание (blur) массива bytes_data двухмерным Гауссианом  // time=0.25
        Tr2=87, BASE2=4;       // binarisation(). Преобразование серого массива в битовый массив (адаптивный порог) // time=0.089 // 46 
        // lineWidth(). Измерение среднего значения толщины штриха line_w в буквах  (изм. в десятых долях pix). // time=0.022  
    }
    */
    
    TIME_START
    
    //-------------------------------------------------------------------------------------------------------------------------------------------    
    
    // Автоопределение наличие серого или черно-белого в битмапе. // time=0.006 
    int graduation=0;
    if(mode==0 || mode==1 || mode==2 || mode==5) {   // || mode==5 на время отладки
        graduation=img_pecha->DetectGradations();
        // graduation=1; в битмапе встречается серое и надо применять адаптивный порог, graduation=0; битмап уже бинаризован.
        if (GrafT) { cout<<"Автоопределение наличие серого (1) или ч/б (0) в битмапе DetectGradations()   graduation="
            <<graduation<<endl; }
    }
    
    // Билинейное масштабирование серого изображения. // time=1.00  scale=1.055  w=16224 × h=2464
    if(mode==0 || mode==1 || mode==2){
        img_pecha->bilinearScale(scale);
        if (GrafT) { cout<<"Билинейное масштабирование серого изображения     bilinearScale()   scale="<<scale<<endl; }
    }

    // Сглаживание (blur) массива bytes_data двухмерным Гауссианом   // time=0.68  w*h=10 млн пикселей    /////////////////////  для Калачакры с равной толщиной штриха 
    if(mode==0 || mode==1 || mode==2){ 
        img_pecha->gaussian(amplitude0);
        if (GrafT) { cout<<"Сглаживание (blur) Гауссианом   gaussian()  amplitude0="<<amplitude0<<endl; }
    }
    // Преобразование серого массива в битовый массив (адаптивный порог)   // time=0.089
    if (graduation==1 || amplitude0 !=0) {
        // Tr меньше - более тонкие линии (штрихи), Tr больше - более толстые линии.
        img_pecha->binarisation(Tr1, BASE1);  if (GrafT) { cout<<"Адаптивный порог binarisation()   Tr1="<<Tr1<<"  BASE1="<<BASE1<<endl; }       
    } // if
    
    // Функция определения угла наклона текста
    /*if(mode==0 || mode==1){        
        int g=8; // по умолчанию g=8, параметр задающий максимально возможный определяемый угол наклона текста,
        // с увеличением максимального угола наклона текста g, пропорционально падает быстродействие t.
        float rotation=img_pecha->detectPageAngle(g); // угол поворота в градусах
        if (GrafT) { 
            cout<<"Функция определения угла наклона текста    detectPageAngle(rotation)  rotation="<<rotation<<endl; 
            cout<<"возвращает угол наклона текста   rotation="<<rotation<<endl; }
        // Вращение битовой картинки
        img_pecha->rotateFast(rotation);
        if (GrafT) { cout<<"Вращение битовой картинки   rotateFast(rotation)  rotation="<<rotation<<endl; }
    }
    */
    // Измерение среднего значения толщины штриха line_w в буквах  (изм. в десятых долях pix). // time=0.022
    if(mode==10) {
        line_wd0=img_pecha->lineWidth();
        if (GrafT) { cout<<"Определение толщины штриха lineWidth()  line_wd0="<<line_wd0<<endl; }
    }

    
    // функция определения пространственной ориентации Тибетского графического текста и средней высоты строки // time=0.049
    if(textOrientation){
        int lineOrient=0;    int lineHeight=36;
        img_pecha->textOrientation( &lineOrient, &lineHeight );
        // lineOrient==1 текст нормально ориентирован, -1 текст повернут на 180, 0 ориентация текста определена не достоверно.
        // Возвращает среднею высоту строки lineHeight (без влияния рамок вокруг текста) и завышает высоту маленьких строк
        if (GrafT) { cout<<"Определение пространственной ориентации Тибетского графического текста   textOrientation()"<<endl;
            cout<<"и возвращает параметр пространственной ориентации   lineOrient ="<<lineOrient<<endl; 
            cout<<"и возвращает среднею высоту строки   lineHeight="<<lineHeight<<endl; }         
        
        // функция поворота изображения на произвольный угол и дискретные углы  +180°, +90°, -90° // time=0.11 w=16224 × h=2464 rotation== +180°
        if(lineOrient==-1){ 
            rotation=180; 
            cout_<<"@+@"<<inputData.data["inputFile"]<<endl;
        }
        if(lineOrient==0){ 
            cout_<<"@+@!!!!"<<inputData.data["inputFile"]<<endl;
        }
        //rotation=180;
        img_pecha->rotateFast(rotation);
        if (GrafT) { cout<<"Поворот изображения на произвольный угол и дискретные углы  +180°, +90°, -90°     rotateFast()   rotation="<<rotation<<endl; }
    }
    /**/
    
    //-//-//
    // Нормализация массива bytes_data по размеру ncolumns кратным 32  // w=16224 × h=2464  time=0.17 (пересчитано т.к. 16224/32=507 )
    if(mode==1){  // нужна обоим функциям полиграфического растискивания
        // необходима для работы функции "Имитация полиграфического растискивания".     
        ///    if (g3>0 || g4>0) { // dot_gain       // если то нормализация нужна     // можно не делать     
        img_pecha->crop32();    if (GrafT) { cout<<"Нормализация ncolumns/32*32 массива bytes_data   crop32()"<<endl; }          
        // возвращает новый массив bytes_data с новым размером по горизонтали ncolumns кратным 32 и новым data_size=ncolumns*nrows;
    }
    
    // Имитация полиграфического растискивания. // time=0.034    
    if(mode==1||mode==2){
        if (GrafT) { cout<<"Полиграфическое растискивание dotGain()  g1, g2, g3, g4,  dot_gain="<<g1<<g2<<g3<<g4<<dot_gain<<endl; }
        img_pecha->dotGain(g1, g2, g3, g4, dot_gain);     // необходим либо ncolumns кратности 32 или (g, g, 0, 0, dot_gain)
    }

    
    // Сглаживание (blur) массива bytes_data двухмерным Гауссианом   // time=0.68  w*h=10 млн пикселей       
    if(mode==1||mode==2){
        img_pecha->gaussian(amplitude1);
        if (GrafT) { cout<<"Сглаживание (blur) Гауссианом   gaussian()  amplitude1="<<amplitude1<<endl; }
    }
    
    // Преобразование серого массива в битовый массив (адаптивный порог)  // time=0.089 
    if(amplitude1>0){
        // Конечную толщину штриха выставляем с помощью Tr. // 46
        // Tr меньше - более тонкие линии (штрихи), Tr больше - более толстые линии.    
        img_pecha->binarisation(Tr2, BASE2);
        if (GrafT) { cout<<"Адаптивный порог binarisation()   Tr2="<<Tr2<<"  BASE2="<<BASE2<<endl; }
        // при line_wd2=10 pix binarisation отъедает 1 pix до line_wd2=9.0 pix, при line_wd2=5 pix это не заметно
    }
    
    
    // Измерение среднего значения толщины штриха line_w в буквах по всему графическому тексту (изм. в десятых долях pix). // time=0.022
    if(line_wd1==0 && (mode==1 || mode==5)){
        line_wd1=img_pecha->lineWidth();     if (GrafT) { cout<<"Определение толщины штриха  lineWidth()  line_wd1="<<line_wd1<<endl; }
    }
    //return;
     
    // Функция определения параметров для не полной стандартизации начертания текста (фокальная линия получается не много переменной толщины)
    if(mode==10 || mode==5){
        // рекомендованное значении line_width (ручное) // полученное из среднего значения толщины штриха line_w при первом запуске этой функции
        line_wd=line_wd1;  // line_wd=(float)line_wd1*1.0
        // использование рекомендованного значения line_width, полученное при первом (предидущем) запуске этой функции
        ///if(line_width>0) line_wd=line_width;  // май
        if(line_width>0) line_wd1=line_width;
        //cout<<"рррррррррр значение *толщины* штриха,         line_wd1="<<line_wd1/10<<"."<<line_wd1/10<<" pix"<<endl;
        // эмпирические формулы 
        //if(line_wd1<=50) line_wd=line_wd1*2-50;
        if(line_wd1<=50) line_wd=line_wd1*2-50;
        if(line_wd<=10) line_wd=10; // рекомендованное значение *толщины* штриха не м.б. меньше 1 pix.
        ///line_wd=30; // 60 - Rinpoche   // 30 - Kannada
        if (GrafT) { 
            //cout<<"*толщина* штриха, эмпирическая формула      if(line_wd1<=50) line_wd=line_wd1*2-50;    line_wd="<<line_wd/10<<"."<<line_wd%10<<" pix"<<endl;
            cout<<"рекомендованное значение *толщины* штриха*10 для всех страниц ,        line_wd="<<line_wd<<" pix"<<endl;
        }
        // частичное выделение фокальной линии (графемы) букв. Удаляется примерно половина пикселей от полной толщины штриха line_wd. 
        ////n_RemovLayers=line_wd/25; // 30 // (line_wd измеряется в десятых долях pix)
        n_RemovLayers=1;  ////////////////////////////////////////// для плотных текстов задаем принудительно
        // растискиванием восстанавливаем ровно столько пикселей, сколько удалили частичной скелетизацией т.е. в два раза больше.
///        dot_gain=n_RemovLayers*2;
        // растискиванием восстанавливаем пикселей меньше чем удалили частичной скелетизацией.
        ////dot_gain=(3*n_RemovLayers)/2+deltaDotGain;  // значение dot_gain не обязательно кратно двойке и может меняться на единицу.
        dot_gain=1;       ////////////////////////////////////////// для плотных текстов задаем принудительно
        ///g1=(3*n_RemovLayers)/2;  g2=0;  g3=(3*n_RemovLayers)/2;  g4=0;
        // Сглаживание (blur) массива bytes_data двухмерным Гауссианом. Разные вариалты зависимости степени сглаживания от толщины штриха.
        ///amplitude1=line_wd/16;
        amplitude2=(int)sqrt((double)line_wd)/2;       // степень 1/2 и деленная на 2   // #include <math.h>
        //amplitude2=3;
        ///amplitude1=(int)exp(0.5*log((double)line_wd))/2; // степень 0.5  // если степень 0.333 то на 2 не делим   // log==ln
        
    }
    
    // Функция стандартизации начертания текста путем определения фокальной линии (графемы) букв.
    if(mode==10 || mode==5|| mode==2){    // w*h=10 млн.  time=0.33  n_RemovLayers=8
        img_pecha->focalLine(n_RemovLayers); // одна единица в параметре функции удаляет по одному пикселю с каждой стороны т.е. два пикселя.
        if(GrafT)cout<<"Функция определения фокальных линий букв (графем)   focalLine()    n_RemovLayers="<<n_RemovLayers<<endl;
    }

    // Имитация полиграфического растискивания. Время выполнения функции time=0.034
    if(mode==10 || mode==5){
        // растискиванием восстанавливаем ровно столько пикселей, сколько удалили частичной скелетизацией т.е. в два раза больше.        
        if (GrafT) { cout<<"Полиграфическое растискивание dotGain()  g1, g2, g3, g4,  dot_gain="<<g1<<g2<<g3<<g4<<dot_gain<<endl; }
        img_pecha->dotGain(g1, g2, g3, g4, dot_gain);     // необходим либо ncolumns кратности 32 или (g, g, 0, 0, dot_gain)
    }
    
    
     // Билинейное масштабирование серого изображения. // time=1.00  scale=1.055  w=16224 × h=2464   ////////////////// для Калачакры с равной толщиной штриха
   // if(mode==1 && scale!=0){
   //     img_pecha->bilinearScale(1/scale);
   //     if (GrafT) { cout<<"Билинейное масштабирование серого изображения     bilinearScale()   1/scale="<<1/scale<<endl; }
  //  }
    
    
    // Преобразование серого массива в битовый массив (адаптивный порог)  // time=0.089  
    if(amplitude2>0){
        // Конечную толщину штриха выставляем с помощью Tr. // 46
        // Tr меньше - более тонкие линии (штрихи), Tr больше - более толстые линии.    
        img_pecha->binarisation(Tr2, BASE2);    //  img_pecha->binarisation(80,24);
        if (GrafT) { cout<<"Адаптивный порог binarisation()   Tr2="<<Tr2<<"  BASE2="<<BASE2<<endl; }
    }
    /**/
    
    // Измерение среднего значения толщины штриха line_w в буквах по всему графическому тексту (изм. в десятых долях pix). // time=0.022
    if(mode==1 || mode==5){
        line_wd2=img_pecha->lineWidth();     if (GrafT) { cout<<"Определение толщины штриха  lineWidth()  line_wd2="<<line_wd2<<endl; }
    }
    
    // Функция определения угла наклона текста
    if(mode==0 || mode==1){        
        int g=20; // по умолчанию g=8, параметр задающий максимально возможный определяемый угол наклона текста,
        // с увеличением максимального угола наклона текста g, пропорционально падает быстродействие t.
        float rotation=img_pecha->detectPageAngle(g); // угол поворота в градусах
        if (GrafT) {
            cout<<"Функция определения угла наклона текста    detectPageAngle(rotation)  rotation="<<rotation<<endl;
            cout<<"возвращает угол наклона текста   rotation="<<rotation<<endl;
        }
        // Вращение битовой картинки
        img_pecha->rotateFast(rotation);
        if (GrafT) { cout<<"Вращение битовой картинки   rotateFast(rotation)  rotation="<<rotation<<endl; }
    }
/**/
    
    if (GrafT) { 
        cout<<endl;
        cout<<"измеренное значение *толщины* штриха в пикселях, до обработки                  line_wd0="<<line_wd0/10<<"."<<line_wd0%10<<" pix"<<endl;
        cout<<"измеренное значение *толщины* штриха, после предварительной фильтрации         line_wd1="<<line_wd1/10<<"."<<line_wd1%10<<" pix"<<endl;
        cout<<"измеренное значение *толщины* штриха, после стандартизации *толщины* штриха   line_wd2="<<line_wd2/10<<"."<<line_wd2%10<<" pix"<<endl;
        cout<<endl<<"полное время выполнения пакета обработки графического текста  ";
        
        //------------------------------------------------------------------------------------------------------------------------------------------- 
        TIME_PRINT

    }
    
    
    ////////////////////////////////////////
    
    /// тоже что и 1B (2112 × 3008), только увеличен в 2 раза (4224 × 6016). Блеклый, не равномерный и с малым разрешением
    /// float scale=2;    dotGain(1, 1, 1, 1,),  gaussian(5),  binarisation(87, 4)
    
    /// _RINPOCHE_200.jpg    бикубиком делаем scale=2; 
    /// DetectGradations(),   binarisation(87, 4),  crop32();   dotGain(1, 1, 1, 1,),   gaussian(5);   binarisation(87, 4)        time=0.51
    
    
    // _bon.jpg    DetectGradations(),   binarisation(87, 4),  crop32(),  dotGain(1, 1, 1, 1,) gaussian(3); binarisation(87, 4),
    
    
    // оптимальное значение *толщины* штриха, как часть высоты строки.
    ///int line_wd1=lineHeight*10/(float)4.1;  // (float)2.439;  // line_wd1 измеряется в десятых долях pix.
    
    
    /*
     //---------------
     // Сглаживание (blur) массива bytes_data двухмерным Гауссианом. Разные вариалты зависимости степени сглаживания от толщины штриха.
     ///amplitude1=line_wd/16;
     ///amplitude2=(int)sqrt((double)line_wd)/2;       // степень 1/2 и деленная на 2   // #include <math.h>
     ///amplitude1=(int)exp(0.5 * log((double)line_wd))/2; // степень 0.5  // если степень 0.333 то на 2 не делим   // log==ln
     ///amplitude2=(int)pow((double)line_wd2, 1.0/3); // степень 1/3
     //--------------- 
     /// отлаженный блок, пока обходимся без автоматизации
     /// Первый параметр ручного ввода - толщина штриха (pix) в графическом тексте line_width. ///
     dot_gain=2;
     int line_width=60;  // line_width измеряется в десятых долях pix
     // если задаваемая пользователем толщина штриха line_width=0; то все коэффициенты задаем в ручную    
     // если line_width не равна нулю, то коэффициенты (BASE2, dot_gain) считаем от толщины штриха.
     
     //line_width=80;               // line_width измеряется в десятых долях pix.
     //line_width=line_wd1;  // автомат //автоматически считаем от высоты строки 
     
     // пересчет толщины штриха в высоту строки.
     // если задаваемая пользователем толщина штриха line_width!=0, то высоту строки берем как толщину штриха умноженную на *33/8, 
     // если задаваемая пользователем толщина штриха line_width=0, то все коэффициенты задаются таблицей ручного ввода.
     if (line_width!=0) {                
     if (line_width<40) line_width=40;   if (line_width>160) line_width=160; // line_width измеряется в десятых долях pix.  
     int lineHeightM=line_width*33/8;               
     // Все необходимые коэффициенты (BASE2, amplitude, dot_gain) по любому считаем от высоты строки lineHeightM.
     BASE2=lineHeightM/80;                 if (BASE2<4) BASE2=4;   if (BASE2>32) BASE2=32;      
     ////amplitude=lineHeightM*(float)0.0131;  if (amplitude<2) amplitude=2;  if (amplitude>12) amplitude=12; // 0.0151;
     amplitude=amplitudeG;                 if (amplitude<2) amplitude=2;  if (amplitude>12) amplitude=12;
     int line_width10=lineHeightM*10/41;   // int line_width10=line_width;
     int dg=line_width10 - line_wd0;       if (dg>=0) dot_gain=(dg+15)/10;   else dot_gain=(dg-15)/10; // int dg=line_width - line_wd0;
     //cout<<"lineHeightM="<<lineHeightM<<endl;
     }
     //---------------
     */    
    
    /*
     //------------------------------------------------------------------------------
     /// отлаженный блок, но влияние Tr слишком дискретно, т.е. не кому выполнить точную доводку толщины штриха .///
     // Единственный параметр ручного ввода толщина штриха в буквах текста line_width.
     int line_width10=84;
     // точное округление толщины штриха до целых пикселей
     // "s" порог между пикселями: 5,15,25,35,45,,,,. Пиксели могут принимать значения от 1 ло 320 (в десятых долях)
     int s=(line_width10/10)*10+5;
     if (line_width10 >= s) {line_width=line_width10/10+1;}   else {line_width=line_width10/10;}
     cout<<"line_width="<<line_width<<endl;
     
     int dg=line_width10 - line_width*10;           cout<<"    dg="<<dg<<endl;
     Tr2=Tr2 + dg; // Tr2=87; // test: 97-87=0.9 pix,  74-87=-1.0 pix // Tr2 позволяет делать прыжки не меньше 0.4 pix
     //------------------------------------------------------------------------------
     */
    
    
    
}