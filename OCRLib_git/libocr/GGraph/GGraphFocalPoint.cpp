//  OCRLib  2015 www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  Will Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .

#include "GGraph.h"

 
namespace ocr{
    
    //*****************************************************************************
    
    /// Базовая версия - focalPointXTL ///
    
    // Функция выделения фокальных точек на фокальных линиях (графемах) букв. Ставит точки в "Т" стыках, в "Х" стыках и концах линий "L_End".
    // Определяет тип точки и записывает его в статус
    // Используется после применения функцией стандартизации начертания текста путем определения фокальной линии (графемы) букв.
    // Работает только с черно-белой картинкой.
    
    int  GGraph::focalPointXTL(vector<OCRPoint>&focalAdr) {
        
        // Адреса фокальных точек в виде int расположенны в массиве векторов focalAdr, где int это расстояние
        // от начала координат до фокальной точки. Количество адресов равно sizeAdr.
        // Функция возвращает суммарное количество особых точек (адресов) sizeAdr по всему графическому тексту.
        
        // Общая идеология и терминология взята из работ:
        // A Fast Parallel Algorithm for Thinning Digital Patterns. T. Y. ZHANG and C. Y. SUEN.
        // http://www-prima.inrialpes.fr/perso/Tran/Draft/gateway.cfm.pdf
        // Каждая точка графическомуго текста просчитывается матрицей (маской) обсчета (3*3-1), где d1 центральной точка по которой
        // принимается решение является ли она точкой пересечения трех (и более) линий.
        // d2, d3, d4, d5, d6, d7, d8, d9  точки окружения, по которым работает алгоритм принятия решения. Точки окружения последовательно
        // записываются в байтовый регистр rg0. Подсчитывается число паттернов "01" и число паттернов "10" в упорядоченном множестве
        // d2, d3, d4, d5, d6, d7, d8, d9,(d2). Число паттернов "01" и число паттернов "10" должно быть три и более, т.к. каждая линия,
        // пересекая периметр маски, дает в регистре по одному паттерну "01" и "10". Дополнительно проверяется количество ненулевых соседей
        // центральной точки d1, т.е. она имеет по крайней мере, 3 ненулевых соседа, но не более 5. Все эти алгоритмы реализуются в виде
        // предпросчитанной таблицы table_1 по условию  b<6 && b>2 && a01>2 && a10>2 (для "Т" стыков). Отдельно, уже в цикле вычисления координат
        // особых (фокальных) точек проверяется центральная точка d1, и если она черная, то только тогда запускастся проверка по таблице,
        // что сильно уменьшает общее количество обращений к таблице. При положительном ответе таблицы данная точка считается особой точкой
        // и ее декартовы координаты "x", "y" заносятся в массив переменной длинны focalAdr в виде short количеством sizeAdr.
        // Сама функция возвращает количество особых точек sizeAdr по всему графическому тексту.
        // При необходимости, может ставить точки не только в "Т" стыках и "Х" стыках, но и на концах линий.
        // Условия (примерно) для разных типов особых точек:
        // Точки только в "Т" стыках (базовый вариант).  b<6 && b>2 && a01==3 && a10==3
        // Точки не только в "Т" стыках, но и в "Х" стыках.  b<7 && b>2 && a01>2 && a01<5 && a10>2 && a10<5
        // Точки на концах линий "L_End".  b==1 && a01==1 && a10==1  и не забыть в главном цикле if ( rg0>0 && table_1[rg0]==0 )
        
        //  * Особенности *
        // Вычисление матрицы (3*3-1) выполняется по предпросчитанным таблицам, что быстрее
        // чем просчитывать матрицу в теле цикла (более чем в 2 раза).
        
        //  * Особенности применения *
        // Используется после применения функцией стандартизации начертания текста путем определения фокальной линии (графемы) букв.
        
        ///printToScreen(); exit(0);
        
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if (GrafT) { cout<<"Функция выделения фокальных точек на фокальных линиях букв   focalPointXTL() "<<endl; }
        
        /*
        // На сером данная функция focalPoint() вешается в трудно отлавливаемом варианте. Лучше проверить с помрщью функции
        // автоопределение наличие серого или черно-белого в битмапе int graduation=img_pecha->DetectGradations();. // time=0.006
        */
        
        //TIME_START_ASM
        //TIME_START
        
        int x;
        int w,h;
        w=ncolumns;  // ширина массива  IMAGE WIDTH
        h=nrows;     // высота массива  IMAGE HEIGHT
        int w_h=w*h; // длинна массива  IMAGE
        
        if (GrafT) { cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
        // w*h=10 млн.  time=0.033
        
        /// вспомогательные переменные
        int n=0;     // переменная адресов
        unsigned char rg0;  // байтовый регистр для хранения отдельных 8 бит маски
        unsigned char d2,d3,d4,d5,d6,d7,d8,d9; // d1,  // переменные маски
        unsigned char a01, a10, b; // переменные условий
        unsigned int sizeAdr; // возвращаемое количество особых точек по всему графическому тексту.
        //short nPoint; // накопительная переменная, имеет смысл при многократном вызове данной функции
        // и обозначает сколько раз по данному адресу была найдена особая точека.
        
        int w_1=w+1; // смещение с угла в центр матрицы (маски)
        int w_h_=w*h-(w+w+4);   // -(0)
        int sf_rg=sizeof(unsigned long);  // размер unsigned long в байтах // sizeof(unsigned long)=8
        int w_h_64=w_h/sf_rg;   // размер массива bytes_data в unsigned long
        ///cout<<"w_h="<<w_h<<"  sf_rg="<<sf_rg<<"  w_h_64="<<w_h_64<<endl;
        
        
        /// Массивы ///
        // указатели типа uchar
        unsigned char *p0=bytes_data, *pw;   // входной массив, 0-черный 255-белый ( с 0-черный 1-белый не работает)
        //unsigned int *bytes_data0_32=(unsigned int*)bytes_data;    // приведение к unsigned int
        
        // выделение памяти под массивы.
        unsigned char table_1[256];  // таблица наличия особой точки.
        // содержимое байтов таблици, если особая точка;
        // типа "Т" то в байте находится 1, если типа "Х" то 2, если окончание линии "L_end" то 4, если точка перегиба то 8 и
        // т.д. по степени 2. Во время отладки на одном месте могут оказаться точки разного типа.
        
        // указатели типа ulong на те же массивы для быстрых циклов.
        unsigned long *bytes_data0_64=(unsigned long*)bytes_data;    // приведение к unsigned long
        
        
        // матрица (маска) обсчета (3*3-1), где d1 центральной точка по которой принимается решение является ли она точкой пересечения трех линий.
        // d2, d3, d4, d5, d6, d7, d8, d9  точки окружения, по которым работает алгоритм принятия решения.
         /*
         d9   d2   d3
         
         d8   d1   d4
         
         d7   d6   d5
         */
        
        // Создание предпросчитанной таблицы table_1, например по условию (a01 = 3) && (a10 = 3) && (2 < b < 6)
        
        // цикл перебора всех возможных значений матрицы (3*3-1) без центральной точки d1 // time=0
        for (int index=0; index < 256; index++){
            rg0=index;
            table_1[index]=0; // заполнение нулями таблици
             
            // разборка байтового регистра на отдельные 8 бит //
            d9=rg0 & 1;    d2=rg0>>1 & 1; d3=rg0>>2 & 1; d8=rg0>>3 & 1;
            d4=rg0>>4 & 1; d7=rg0>>5 & 1; d6=rg0>>6 & 1; d5=rg0>>7 & 1;
            // Подготовка данных для алгоритма //
            a01=0; // "a01" это число паттернов "01" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)
            if(d3-d2>0)a01++; if(d4-d3>0)a01++; if(d5-d4>0)a01++; if(d6-d5>0)a01++;
            if(d7-d6>0)a01++; if(d8-d7>0)a01++; if(d9-d8>0)a01++; if(d2-d9>0)a01++;
            a10=0; // "a10" это число паттернов "10" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)
            if(d3-d2<0)a10++; if(d4-d3<0)a10++; if(d5-d4<0)a10++; if(d6-d5<0)a10++;
            if(d7-d6<0)a10++; if(d8-d7<0)a10++; if(d9-d8<0)a10++; if(d2-d9<0)a10++;
            // "b" это число ненулевых соседей центральной точки d1, т.е, она имеет по крайней мере, 3 ненулевых соседа, но не более 5.
            b=d2+d3+d4+d5+d6+d7+d8+d9;
            
            // АЛГОРИТМ (заполнение таблицы) //
            
            // Ставит точки только в "Т" стыках (базовый вариант). //
            if ( b<6 && b>2 && a01==3 && a10==3 ) table_1[index]+=1;  // проверяется a01=3 && a10=3
            
            // Ставит точки не только в "Т" стыках, но и в "Х" стыках. //
            //if ( b<7 && b>2 && a01>2 && a01<5 && a10>2 && a10<5 ) table_1[index]+=2; // проверяются a01=3=4 && a10=3=4
            // Ставит точки только в "Х" стыках. Основное правило  //
            if ( b<7 && b>2 && a01>2 && a01<5 && a10>2 && a10<5 && table_1[index]!=1) table_1[index]+=2; // 2
            //cout<<" "<<(unsigned short)table_1[index];
            
            // Основное правило ("Т" или "Х" стыков) ситуацию с квадратом из четырех точек не отрабатывает.
            // Варианты отработки ситуации, если на месте Х образной точки квадрат из четырех точек,
            // с выходящими из всех углов ломаными линиями. //
            // отрабатывает не все ситуации
            ///if ( d8==1 && d9 && d2==1 && b==5 && a01==2 && a10==2 ) table_1[index]+=2; // d8==d9==d2==1 описание квадрата 2x2 pix, // 6
            
            // Ставит точки в случае, если на месте Х образной точки квадрат из четырех точек.
            // В этом варианте мы ставим одну фокальную точку в правый нижний угол квадрата
            ///if ( d8==1 && d9 && d2==1 && a01==2 && a10==2 ) table_1[index]+=2;
            
            // Ставит точки в случае, если на месте Х образной точки квадрат из четырех точек.
            // В этом варианте мы ставим четыре фокальных точеки в каждом уголу квадрата
            if ( ((d8==1 && d9==1 && d2==1) || (d2==1 && d3==1 && d4==1) ||
                  (d4==1 && d5==1 && d6==1) || (d6==1 && d7==1 && d8==1)) && b<7 && a01==2 && a10==2 ) table_1[index]+=2;
            // центральная точка d1==1 проверяется в основном цикле ниже
            
            // Ставит точки на концах линий "L_End" и не забыть в главном цикле if ( rg0>0 && table_1[rg0]==0 )
            if ( b<3 && b>0 && a01==1 && a10==1 ) table_1[index]+=4;
            
            // Ставит точки когда фокальная линия вырожденна в один пиксел "P_Point"
            if ( b==0 ) table_1[index]+=8;
            
            // Ставит точки не только в "Т" стыках, но и в "произвольном числе" стыков.
            ///if ( b<6 && b>2 && a01>2 && a10>2 ) table_1[index]=0;    // проверяются a01>2 && a10>2
        } // for
        
        if (GrafT) cout<<"значение байтового регистра для хранения отдельных 8 бит маски, в конце цикла   rg0="<<(unsigned short)rg0<<endl;
        // cout<<endl;
        
        
        
        // инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный
        //for ( x=0; x < w_h; x++ ) { if (bytes_data[x]) bytes_data[x]=0;  else bytes_data[x]=255;} // по 1 байту
        for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data0_64[x]; } // по 8 байт одновременно // time=0.005 w*h=10 млн. пикселей
        
        // Вычисление координат особых (фокальных) точек //
        
        // цикл обеспечивает принятие решения с помощью таблицы, является ли точка фокальной линии букв особой.
        OCRPoint pt; // обьявление локальной переменной
        pw=bytes_data + w_1;  // w_1=(w+1); смещение с угла в центр матрицы (маски)
        for ( x=0; x < w_h_; x++ ) {
            
            //if(x%w<650||x%w>700){  p0=bytes_data + x;    *p0=0;  continue;} // отладка. проверка области поиска
            
            // если точка контура d1 белая, то ее не зачем просчитывать по таблице (белых больше чем черных в 30 и более раз).
            if (*(pw + x)!=0) {  // d1=*(p0+w+1);    // в 2.8 быстрее
                p0=bytes_data + x;
                // сборка байтового регистра rg0 из отдельных 8 бит матрицы с помощью единичных масок
                rg0=(*(p0)&1) + (*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w+2)&16) + (*(p0+w+w)&32) + (*(p0+w+w+1)&64) + (*(p0+w+w+2)&128);
                
                // запись координат и статуса особых точек типа "Т", "Х", "L_end" в массив
                ///if ( rg0>2 && table_1[rg0]==0 ) { bytes_data0_32[n]=x + (w+1);  n++; } // сохраняем в исходный графический массив
                if ( table_1[rg0]>0 ){ // (rg0>0 && table_1[rg0]==4) смотрим только "L_end"      ///if ( rg0>2 && table_1[rg0]>0 ){
                    // Пересчет координат из линейных в декартовы (снижакт общее быстродействие на 20 процентрв).
                    pt.y=(x+w_1)/w;   // w_1=w+1;
                    pt.x=(x+w_1)%w;   // pt.status=0; // компактный вариант
                    // Сохранение в структуру статуса особых точек
                    pt.type=table_1[rg0];      // точки типа "Т", "Х", "L_end", P_Point кодируются соответственно 1, 2, 4, 8
                    // Сохранение в структуру адресов особых точек в декартовых координатах "x", "y".
                    focalAdr.push_back(pt);
                 }
                /**/
                //cout<<(unsigned short)*p0;
                //cout<<" "<<(unsigned short)rg0;
            } // if
        } // x
        
        ///sizeAdr=n;
        sizeAdr=(uint)focalAdr.size();
        if (GrafT) cout<<"значение    sizeAdr="<<sizeAdr<<endl;
        /**/
       
        if (GrafT) {
            // визуализация серым фокальных линий (графем) по 8 байт одновременно. ( внутренний формат программы 255-черный, 0-белый ).
            for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=(bytes_data0_64[x]>>1)&0x7F7F7F7F7F7F7F7F; } // деление на 2 и прим. 64 р маски.
            // Черное (255) становится серым (127), белое (0) остается белым.
            // 0x7F7F7F7F7F7F7F7F  64 р маска для деление на 2, маска убирает передвинувшиеся (при сдвиге) из соседних байт разряды.
            
            // визуализация черным особых точек (фокальных точек)
            for ( n=0; n < sizeAdr; n++ ) { bytes_data[(int)(focalAdr[n].y*w+focalAdr[n].x)]=255; } // читаем из массива векторов
        }
        
        // приведение массива к общепринятому стандарту, 0-черный 255-белый ( внутренний формат программы 0-белый 255-черный ).
        // по 1 байту,  time=0.03  w_h=w*h=10 млн. пикселей
        ///for ( x=0; x < w_h; x++ ) { if (bytes_data[x]>0) bytes_data[x]=0;  else bytes_data[x]=255; }
        // по 8 байт одновременно,  time=0.005  w*h=10 млн. пикселей
        for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data0_64[x]; }
        
        /*
        if (GrafT) {
            // визуализация серым фокальных линий (графем)
            for ( x=0; x < w_h; x++ ) { bytes_data[x]=(255+bytes_data[x])/2; } // для серого, =255 для чб
            // визуализация черным особых точек (фокальных точек)
            for ( n=0; n < sizeAdr; n++ ) { bytes_data[focalAdr[0][n]->y*w+focalAdr[0][n]->x]=0; } // читаем из массива векторов
        }
        */
        
        //TIME_PRINT_ASM
        ///TIME_PRINT_   cout<<"TIME_PRINT_   фокальных точек   focalLine"<<endl;
        
        
        
        // Возвращаем количество особых точек sizeAdr по всему графическому тексту.
        return sizeAdr;
        // Адреса фокальных точек в декартовых координат "x", "y" (short) расположенны в массиве переменной длинны focalAdr.
        // Количество адресов равно sizeAdr=focalAdr->size();.
        
        
        ///int y_;
        // пересчет координат из линейных в декартовы (снижает общее быстродействие на 20 процентрв).
        ///y_=(w_1+x)/w;  // w_1=w+1;
        ///pt.x=(w_1+x)-w*y_; pt.y=y_;  // pt.type=0;  // x+w_1
        
        /// int w_2=w+2;  int w_w=w+w;  int w_w_1=w+w+1;  int w_w_2=w+w+2;
        /// rg0=(*(p0)&1) + (*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w_2)&16) + (*(p0+w_w)&32) + (*(p0+w_w_1)&64) + (*(p0+w_w_2)&128);
        
    }//____________________________________________________________________________
    

    
    
    // Функция выделения фокальных точек на фокальных линиях (графемах) букв. Ставит точки не только в "Т" стыках, но и в "Х" стыках.
    // Используется после применения функцией стандартизации начертания текста путем определения фокальной линии(графемы) букв.
    // Работает только с черно-белой картинкой.
    
    int  GGraph::focalPoint(vector<OCRPoint>&focalAdr) {

        // Адреса фокальных точек в виде int расположенны в массиве векторов focalAdr, где int это расстояние 
        // от начала координат до фокальной точки. Количество адресов равно sizeAdr. 
        // Функция возвращает количество особых точек (адресов) sizeAdr по всему графическому тексту.
        
        // Общая идеология и терминология взята из работ:
        // A Fast Parallel Algorithm for Thinning Digital Patterns. T. Y. ZHANG and C. Y. SUEN.
        // http://www-prima.inrialpes.fr/perso/Tran/Draft/gateway.cfm.pdf
        // Каждая точка графическомуго текста просчитывается матрицей (маской) обсчета (3*3-1), где d1 центральной точка по которой 
        // принимается решение является ли она точкой пересечения трех (и более) линий. 
        // d2, d3, d4, d5, d6, d7, d8, d9  точки окружения, по которым работает алгоритм принятия решения. Точки окружения последовательно 
        // записываются в байтовый регистр rg0. Подсчитывается число паттернов "01" и число паттернов "10" в упорядоченном множестве 
        // d2, d3, d4, d5, d6, d7, d8, d9,(d2). Число паттернов "01" и число паттернов "10" должно быть три и более, т.к. каждая линия, 
        // пересекая периметр маски, дает в регистре по одному паттерну "01" и "10". Дополнительно проверяется количество ненулевых соседей 
        // центральной точки d1, т.е. она имеет по крайней мере, 3 ненулевых соседа, но не более 5. Все эти алгоритмы реализуются в виде 
        // предпросчитанной таблицы table_1 по условию  b<6 && b>2 && a01>2 && a10>2 (для "Т" стыков). Отдельно, уже в цикле вычисления координат 
        // особых (фокальных) точек проверяется центральная точка d1, и если она черная, то только тогда запускастся проверка по таблице, 
        // что сильно уменьшает общее количество обращений к таблице. При положительном ответе таблицы данная точка считается особой точкой
        // и ее декартовы координаты "x", "y" заносятся в массив переменной длинны focalAdr в виде short количеством sizeAdr.  
        // Сама функция возвращает количество особых точек sizeAdr по всему графическому тексту.
        // При необходимости, может ставить точки не только в "Т" стыках и "Х" стыках, но и на концах линий.
        // Условия для разных типов особых точек:
        // Точки только в "Т" стыках (базовый вариант).  b<6 && b>2 && a01==3 && a10==3
        // Точки не только в "Т" стыках, но и в "Х" стыках.  b<7 && b>2 && a01>2 && a01<5 && a10>2 && a10<5 
        // Точки на концах линий.  b==1 && a01==1 && a10==1  и в главном цикле if ( rg0>0 && table_1[rg0]==0 )  
        
        //  * Особенности *
        // Вычисление матрицы (3*3-1) выполняется по предпросчитанным таблицам, что быстрее больше чем в 2 раза,  
        // чем просчитывать матрицу в теле цикла.
        
        //  * Особенности применения *
        // Используется после применения функцией стандартизации начертания текста путем определения фокальной линии(графемы) букв.
        
        
        
        
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if (GrafT) { cout<<"Функция выделения фокальных точек на фокальных линиях букв   focalPoint() "<<endl; }
        
        /*
         // На сером данная функция focalPoint() вешается в трудно отлавливаемом варианте. Лучше проверить с помрщью функции
         // автоопределение наличие серого или черно-белого в битмапе int graduation=img_pecha->DetectGradations();. // time=0.006   
         */
        
        //TIME_START_ASM    
        //TIME_START 
        
        int x;    
        int w,h;            
        w=ncolumns;  // ширина массива  IMAGE WIDTH
        h=nrows;     // высота массива  IMAGE HEIGHT
        int w_h=w*h; // длинна массива  IMAGE
        
        if (GrafT) { cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
        // w*h=10 млн.  time=0.033  
        
        /// вспомогательные переменные
        int n=0;     // переменная адресов
        unsigned char rg0;  // байтовый регистр для хранения отдельных 8 бит маски
        unsigned char d2,d3,d4,d5,d6,d7,d8,d9; // d1,  // переменные маски
        unsigned char a01, a10, b; // переменные условий 
        unsigned int sizeAdr; // возвращаемое количество особых точек по всему графическому тексту.
        //short nPoint; // накопительная переменная, имеет смысл при многократном вызове данной функции
        // и обозначает сколько раз по данному адресу была найдена особая точека.
        
        int w_1=w+1; // смещение с угла в центр матрицы (маски)
        int w_h_=w*h-(w+w+4);   // -(0)    
        int sf_rg=sizeof(unsigned long);  // размер unsigned long в байтах // sizeof(unsigned long)=8
        int w_h_64=w_h/sf_rg;   // размер массива bytes_data в unsigned long  
        ///cout<<"w_h="<<w_h<<"  sf_rg="<<sf_rg<<"  w_h_64="<<w_h_64<<endl;
        
        
        /// Массивы ///
        // указатели типа uchar
        unsigned char *p0=bytes_data, *pw;   // входной массив, 0-черный 255-белый ( с 0-черный 1-белый не работает)
        //unsigned int *bytes_data0_32=(unsigned int*)bytes_data;    // приведение к unsigned int
        
        // выделение памяти под массивы.
        unsigned char table_1[256];  //
        
        // указатели типа ulong на те же массивы для быстрых циклов
        unsigned long *bytes_data0_64=(unsigned long*)bytes_data;    // приведение к unsigned long
        
        
        // матрица (маска) обсчета (3*3-1), где d1 центральной точка по которой принимается решение является ли она точкой пересечения трех линий. 
        // d2, d3, d4, d5, d6, d7, d8, d9  точки окружения, по которым работает алгоритм принятия решения.
        /*   
         d9   d2   d3
         
         d8   d1   d4
         
         d7   d6   d5
         */
        
        // Создание предпросчитанной таблицы table_1, например по условию (a01 = 3) && (a10 = 3) && (2 < b < 6)  
        
        // цикл перебора всех возможных значений матрицы (3*3-1) без центральной точки d1 // time=0
        for (int index=0; index < 256; index++){ 
            rg0=index;
            table_1[index]=255; // заполнение единицами всех байт и бит таблици
            // разборка байтового регистра на отдельные 8 бит
            d9=rg0 & 1;    d2=rg0>>1 & 1; d3=rg0>>2 & 1; d8=rg0>>3 & 1; 
            d4=rg0>>4 & 1; d7=rg0>>5 & 1; d6=rg0>>6 & 1; d5=rg0>>7 & 1;            
            // АЛГОРИТМ //                    
            a01=0; // "a01" это число паттернов "01" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)  
            if(d3-d2>0)a01++; if(d4-d3>0)a01++; if(d5-d4>0)a01++; if(d6-d5>0)a01++; 
            if(d7-d6>0)a01++; if(d8-d7>0)a01++; if(d9-d8>0)a01++; if(d2-d9>0)a01++;    //  a01 = 3 - условие N1        
            a10=0; // "a10" это число паттернов "10" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)  
            if(d3-d2<0)a10++; if(d4-d3<0)a10++; if(d5-d4<0)a10++; if(d6-d5<0)a10++; 
            if(d7-d6<0)a10++; if(d8-d7<0)a10++; if(d9-d8<0)a10++; if(d2-d9<0)a10++;    //  a01 = 3 - условие N2                
            //  2 <= b <= 6 - условие N2 было        
            // "b" это число ненулевых соседей центральной точки d1, т.е, она имеет по крайней мере, 3 ненулевых соседа, но не более 5.            
            b=d2+d3+d4+d5+d6+d7+d8+d9; //  2 < b < 6 - условие N3                 
            // заполнение таблицы //
            // Ставит точки только в "Т" стыках (базовый вариант).      // { table_1[rg0]=0; } else { table_1[rg0]=255; }
            ///if ( b<6 && b>2 && a01==3 && a10==3 ) table_1[index]=0;  // проверяется a01=3 && a10=3
            // Ставит точки не только в "Т" стыках, но и в "Х" стыках.
            if ( b<7 && b>2 && a01>2 && a01<5 && a10>2 && a10<5 ) table_1[index]=0; // проверяются a01=3=4 && a10=3=4
            // Ставит точки не только в "Т" стыках, но и в "произвольном числе" стыков.
            ///if ( b<6 && b>2 && a01>2 && a10>2 ) table_1[index]=0;    // проверяются a01>2 && a10>2
            //cout<<" "<<(unsigned short)table_1[index];
            // Ставит точки в случае квадрата 2x2 pix с выходящими из всех углов ломаными линиями.
            // Основное правило ("Т" или "Х" стыков) эту ситуацию не отрабатывает.
            if ( d8==1 && d9 && d2==1 && b==5 && a01==2 && a10==2 ) table_1[index]=0;   // d8==d9==d2==1 описание квадрата 2x2 pix,
                                                                                        // d1==1 проверяется в основном цикле ниже
        } // for
        
        if (GrafT) cout<<"значение байтового регистра для хранения отдельных 8 бит маски, в конце цикла   rg0="<<(unsigned short)rg0<<endl; 
        // cout<<endl;
        
        
        
        // инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный 
        //for ( x=0; x < w_h; x++ ) { if (bytes_data[x]) bytes_data[x]=0;  else bytes_data[x]=255;} // по 1 байту  
        for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data0_64[x]; } // по 8 байт одновременно // time=0.005 w*h=10 млн. пикселей
        
        // Вычисление координат особых (фокальных) точек //  
        
        // цикл обеспечивает принятие решения с помощью таблицы, является ли точка контура d1 особой.
        int y_;
        OCRPoint pt; // обьявление локальной переменной
        pw=bytes_data + w_1;  // w_1=(w+1); смещение с угла в центр матрицы (маски)     
        for ( x=0; x < w_h_; x++ ) {
            
            //if(x%w<650||x%w>700){  p0=bytes_data + x;    *p0=0;  continue;} //отладка. проверка области поиска

            // если точка контура d1 белая, то ее не зачем просчитывать по таблице (белых больше чем черных в 30 и более раз).
            if (*(pw + x)!=0) {  // d1=*(p0+w+1);    // в 2.8 быстрее 
                p0=bytes_data + x;
                // сборка байтового регистра rg0 из отдельных 8 бит матрицы с помощью единичных масок
                rg0=(*(p0)&1) + (*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w+2)&16) + (*(p0+w+w)&32) + (*(p0+w+w+1)&64) + (*(p0+w+w+2)&128);
                // странное лекарство
                // В этой строке нет проверки левого верхнего цикла матрици что разрушает квадрат из четырех пикселей и тогда алгоритм ставит точку
                ////rg0=(*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w+2)&16) + (*(p0+w+w)&32) + (*(p0+w+w+1)&64) + (*(p0+w+w+2)&128);
                // запись координат особых точек в массив
                ///f ( rg0>2 && table_1[rg0]==0 ) { bytes_data0_32[n]=x + (w+1);  n++; } // сохраняем в исходный графический массив
                if ( rg0>2 && table_1[rg0]==0 ){
                    // пересчет координат из линейных в декартовы (сажает общее быстродействие на 20 процентрв).
                    y_=(w_1+x)/w;  // w_1=w+1;
                    pt.x=(w_1+x)-w*y_; pt.y=y_;  // pt.type=0;  // x+w_1
                    focalAdr.push_back(pt);     // сохраняем в вектор
                }   
                //cout<<(unsigned short)*p0;
                //cout<<" "<<(unsigned short)rg0;
            } // if  
        } // x 
        
        ///sizeAdr=n;
        sizeAdr=(uint)focalAdr.size();
        if (GrafT) cout<<"значение    sizeAdr="<<sizeAdr<<endl;
        /**/
        
        
        // приведение массива к общепринятому стандарту, 0-черный 255-белый ( внутренний формат программы 0-белый 255-черный ).
        // по 1 байту,  time=0.03  w_h=w*h=10 млн. пикселей
        ///for ( x=0; x < w_h; x++ ) { if (bytes_data[x]>0) bytes_data[x]=0;  else bytes_data[x]=255; } 
        // по 8 байт одновременно,  time=0.005  w*h=10 млн. пикселей
        for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data0_64[x]; } 
        
        
        if (GrafT) {        
            // визуализация серым фокальных линий (графем)
            for ( x=0; x < w_h; x++ ) { bytes_data[x]=(255+bytes_data[x])/2; }
            // визуализация черным особых точек (фокальных точек)
            for ( n=0; n < sizeAdr; n++ ) { bytes_data[(int)(focalAdr[n].y*w+focalAdr[n].x)]=0; } // читаем из массива векторов
        }
        
        //TIME_PRINT_ASM
       ///TIME_PRINT_   cout<<"TIME_PRINT_   фокальных точек   focalLine"<<endl;
        
        
        
        // Возвращаем количество особых точек sizeAdr по всему графическому тексту.
        return sizeAdr;
        // Адреса фокальных точек в декартовых координат "x", "y" (short) расположенны в массиве переменной длинны focalAdr. 
        // Количество адресов равно sizeAdr=focalAdr->size();.
        
        
        /// int w_2=w+2;  int w_w=w+w;  int w_w_1=w+w+1;  int w_w_2=w+w+2; 
        /// rg0=(*(p0)&1) + (*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w_2)&16) + (*(p0+w_w)&32) + (*(p0+w_w_1)&64) + (*(p0+w_w_2)&128);
        
    }//____________________________________________________________________________   
    
    
    /// Более быстрая версия с предпросчетом адресов начала и конца черных слайсов (для перепрыгивания белых областей) ///
    // По факту не более быстрая версия
    
    // Функция выделения фокальных точек на фокальных линиях (графемах) букв.
    // Используется после применения функцией стандартизации начертания текста путем определения фокальной линии(графемы) букв.
    // Работает только с черно-белой картинкой      
    
    int  GGraph::focalPointT1() {
        
        // Функция возвращает количество особых точек по всему графическому тексту. Адреса в виде int количеством sizeAdr,  
        // расположенны в начале массива bytes_data и c точки зрения графики, занимают 1-2 пиксельные линии.      
        // Используется после применения функцией стандартизации начертания текста путем определения фокальной линии(графемы) букв.
        
        //  * Идея *
        // Общая идеология взята из работ
        // A Fast Parallel Algorithm for Thinning Digital Patterns. T. Y. ZHANG and C. Y. SUEN.
        // http://www-prima.inrialpes.fr/perso/Tran/Draft/gateway.cfm.pdf
        // Каждая точка графическомуго текста просчитывается матрицей (маской) обсчета (3*3-1), где d1 центральной точка по которой 
        // принимается решение является ли она точкой пересечения трех (и более) линий. 
        // d2, d3, d4, d5, d6, d7, d8, d9  точки окружения, по которым работает алгоритм принятия решения. Точки окружения последовательно 
        // записываются в байтовый регистр rg0. Подсчитывается число паттернов "01" и число паттернов "10" в упорядоченном множестве 
        // d2, d3, d4, d5, d6, d7, d8, d9,(d2). Число паттернов "01" и число паттернов "10" должно быть три и более, т.к. каждая линия, 
        // пересекая периметр маски, дает в регистре по одному паттерну "01" и "10". Дополнительно проверяется количество ненулевых соседей 
        // центральной точки d1, т.е. она имеет по крайней мере, 3 ненулевых соседа, но не более 5. Все эти алгоритмы реализуются в виде 
        // предпросчитанной таблицы table_1 по условию  b<6 && b>2 && a01>2 && a10>2. Отдельно, уже в цикле вычисления координат 
        // особых (фокальных) точек проверяется центральная точка d1, и если она черная, то только тогда запускастся проверка по таблице, 
        // что сильно уменьшает общее количество обращений к таблице. При положительном ответе таблицы данная точка считается особой точкой
        // и ее координаты заносятся в начало графического массива bytes_data в виде int количеством sizeAdr и c точки зрения графики, 
        // занимают всего 1-2 пиксельные линии. Сама функция возвращает количество особых точек sizeAdr по всему графическому тексту.
        
        //  * Особенности *
        // Вычисление матрицы (3*3-1) выполняется по предпросчитанным таблицам, что в 2 раза быстрее 
        // чем просчитывать матрицу в теле цикла.
        
        //  * Особенности применения *
        // Используется после применения функцией стандартизации начертания текста путем определения фокальной линии(графемы) букв.
        
        
        
        
        
        
        
        int GrafT=1;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if (GrafT) { cout<<"Функция выделения фокальных точек на фокальных линиях букв   focalPoint() "<<endl; }
        
        /*
         // На сером данная функция focalPoint() вешается в трудно отлавливаемом варианте. Лучше проверить.
         // Автоопределение наличие серого или черно-белого в битмапе. // time=0.006 
         int graduation=img_pecha->DetectGradations();
         // graduation=1; в битмапе встречается серое и надо применять адаптивный порог, graduation=0; битмап уже бинаризован.
         if (graduation=1) { 
         cout<<"В битмапе встречается серое (1) и функция focalPoint() работать не будет   graduation="<<graduation<<endl;
         return; // return=0;
         }    
         */
        
        
        //TIME_START
        
        int x;   // ,y   
        int w,h;            
        w=ncolumns;  // ширина массива  IMAGE WIDTH
        h=nrows;     // высота массива  IMAGE HEIGHT
        int w_h=w*h; // длинна массива  IMAGE
        
        if (GrafT) { cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
        // w*h=4 млн. пикселей time=0.26/2 // w*h=10 млн.  time=0.68/2  // 4.3/2  w*h=39 млн., n_RemovLayers=15
        
        /// управляющие переменные /// 
        
        
        
        
        /// вспомогательные переменные
        int n=0;     // переменная адресов
        //int m=0;
        int s, s_old, g; 
        unsigned char rg0;  // байтовый регистр для хранения отдельных 8 бит маски
        unsigned char d2,d3,d4,d5,d6,d7,d8,d9; // d1,  // переменные маски
        unsigned char a01, a10, b; // переменные условий 
        unsigned int sizeAdr; // возвращаемое количество особых точек по всему графическому тексту
        
        int w_h_=w*h-(w+w+4); // -(0)
        
        int sf_rg=sizeof(unsigned long);
        int w_h_64=w_h/sf_rg;  // sizeof(unsigned long)=8
        ///cout<<"w_h="<<w_h<<"  sf_rg="<<sf_rg<<"  w_h_64="<<w_h_64<<endl;
        
        
        /// Массивы.///
        // указатели типа uchar
        unsigned char *p0=bytes_data;    // входной массив, 0-черный 255-белый ( с 0-черный 1-белый не работает)
        unsigned int *bytes_data0_32=(unsigned int*)bytes_data;    // приведение к unsigned int
        //unsigned char *pW;
        //    unsigned char *bytes_data_1, *p1;
        
        // указатели типа uint
        unsigned int *BufS; //,*d0 // массив адресов начала и конца слайсов (slice) и предназначен для перепрыгивания белых областей.
        
        // размер массива bytes_data_1.
        // массив для хранения и визуализвции серой подложки букв из исходного изображения
        unsigned int sizeBuf=w_h + 32 ;
        // размер массива BufS (д.б. четным).
        int k=16; //160 // коэффициент равный отношению полного количества пикселей к количеству черных слайсовпо всему  
        // графическому тексту. Поскольку заранее не известен то выбирается эмпирический с запасом. 
        unsigned int sizeBufS=((sizeBuf/k)/2)*2;
        if (GrafT)cout<<"размер массива изображения   w_h="<<w_h<<",     размер int массива адресов слайсов   sizeBufS="<<sizeBufS<<endl;
        
        // выделение памяти под массивы. 
        ///bytes_data_1 = (unsigned char*)malloc(sizeBuf); // p1
        //    bytes_data_1 = (unsigned char*)calloc(sizeBuf,sizeof(unsigned char));         
        BufS = (unsigned int*)calloc(sizeBufS+32, sizeof(unsigned int)); // d0  // Каждый элемент инициализируется в 0.
        ///BufS = (unsigned int*)malloc(sizeBufS*sizeof(unsigned int)+32);  // d0
        unsigned char table_1[256];  // таблица для  // 
        
        // указатели типа ulong на те же массивы для быстрых циклов
        unsigned long *bytes_data0_64=(unsigned long*)bytes_data;    // приведение к unsigned long
        ///unsigned long *bytes_data1_64=(unsigned long*)bytes_data_1;  // приведение к unsigned long        
        ///unsigned long *p0_64, *p1_64;
        
        
        
        //TIME_START
        // Заполнение массива BufS адресами начала и конца черных слайсов (для перепрыгивания белых областей).         
        // Алгоритм работает только с черным в тексте, а площадь черного на порядок меньше площади
        // белого (в 30 и более раз), что уменьшает полное время выполнения функции с time=0.66 до time=0.33 .
        g=0;   s_old=bytes_data[w+1];
        for ( x=0; x < w_h_; x++ ) {  // time=0.07  w*h=10 млн. пикселей
            s=bytes_data[x+(w+1)];    // (w+1) смещение центральной точки матрицы
            // заполнение массива адресами начала и конца черных слайсов.
            if(s-s_old < 0) { BufS[g]=x; }  // неравенства работают до инверсии уровней входного массива
            if(s-s_old > 0) { BufS[g+1]=x;  g+=2; } 
            //if(s-s_old < 0) { BufS[g+1]=x; cout<<"   "<<BufS[g]<<" "<<BufS[g+1]; g+=2; }
            s_old=s;              
            if(g > sizeBufS) break;
        } // for
        
        int sizeBufSR=g;
        if (GrafT) cout<<"размер массива адресов слайсов   sizeBufS="<<sizeBufS<<",   реальное заполнение массива BufS адресами   g="<<g<<endl;
        // если массив BufS оказался слишком мал для размещения всех слайсов, то все что в него не поместилось 
        // превращаям в как бы в один большой слайс продолженный до конца массива и обрабатываем его обычным способом.
        BufS[sizeBufS-1]=w_h_;    
        ///if (GrafT) cout<<"последний адрес массива BufS     BufS[sizeBufS-1]="<<BufS[sizeBufS-1]<<endl;  
        //TIME_PRINT_
        /**/
        
        
        // матрица (маска) обсчета (3*3-1), где d1 центральной точка по которой принимается решение является ли она точкой пересечения трех линий. 
        // d2, d3, d4, d5, d6, d7, d8, d9  точки окружения, по которым работает алгоритм принятия решения.
        /*   
         d9   d2   d3
         
         d8   d1   d4
         
         d7   d6   d5
         */
        
        // Создание предпросчитанной таблицы table_1 по условию (a01 = 3) && (a10 = 3) && (2 < b < 6) //  
        
        // цикл перебора всех возможных значений матрицы (3*3-1) // time=0
        for (int index=0; index < 256; index++){ 
            rg0=index;        
            // разборка байтового регистра на отдельные 8 бит
            d9=rg0 & 1;    d2=rg0>>1 & 1; d3=rg0>>2 & 1; d8=rg0>>3 & 1; 
            d4=rg0>>4 & 1; d7=rg0>>5 & 1; d6=rg0>>6 & 1; d5=rg0>>7 & 1;            
            // АЛГОРИТМ //                    
            a01=0; // "a01" это число паттернов "01" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)  
            if(d3-d2>0)a01++; if(d4-d3>0)a01++; if(d5-d4>0)a01++; if(d6-d5>0)a01++; 
            if(d7-d6>0)a01++; if(d8-d7>0)a01++; if(d9-d8>0)a01++; if(d2-d9>0)a01++;    //  a01 = 3 - условие N1        
            a10=0; // "a10" это число паттернов "10" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)  
            if(d3-d2<0)a10++; if(d4-d3<0)a10++; if(d5-d4<0)a10++; if(d6-d5<0)a10++; 
            if(d7-d6<0)a10++; if(d8-d7<0)a10++; if(d9-d8<0)a10++; if(d2-d9<0)a10++;    //  a01 = 3 - условие N2                
            //  2 <= b <= 6 - условие N2 было        
            // "b" это число ненулевых соседей центральной точки d1, т.е, она имеет по крайней мере, 3 ненулевых соседа, но не более 5.            
            b=d2+d3+d4+d5+d6+d7+d8+d9; //  2 < b < 6 - условие N3                 
            // заполнение таблицы 
            //if ( b<6 && b>2 && a01>2 && a10>2 ) { table_1[rg0]=0; } else { table_1[rg0]=255; }
            if ( b<6 && b>2 && a01==3 && a10==3 ) { table_1[rg0]=0; } else { table_1[rg0]=255; }        
            //cout<<" "<<(unsigned short)table_1[index];
        } // for    
        if (GrafT) cout<<"значение байтового регистра для хранения отдельных 8 бит маски, в конце цикла   rg0="<<(unsigned short)rg0<<endl; 
        // cout<<endl;
        
        
        // создание массива и его заполнение для хранения и визуализвции серой подложки букв из исходного изображения 
        unsigned char *bytes_data_1, *p1;
        if (GrafT) {                
            //bytes_data_1 = (unsigned char*)malloc(sizeBuf); // p2
            bytes_data_1 = (unsigned char*)calloc(sizeBuf,sizeof(unsigned char));
            // копирование bytes_data в bytes_data_1
            ///memcpy(bytes_data_1, bytes_data, w_h);  // адрес буфера назначения, адрес источника, количество байт для копирования
        } // if    
        
        
        
        // инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный 
        //for ( x=0; x < w_h; x++ ) { if (bytes_data[x]) bytes_data[x]=0;  else bytes_data[x]=255;} // по 1 байту  
        for ( x=0; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data0_64[x]; } // по 8 байт одновременно // time=0.005 w*h=10 млн. пикселей
        
        
        // Вычисление координат особых (фокальных) точек //  
        
        // цикл обеспечивает работу только с черными точками d1, перепрыгивая через белые области.
        p1=bytes_data_1;  n=0; // p0=bytes_data;  
        for ( g=0; g < sizeBufSR; g+=2 ) {                     
            /// for ( x=0; x < w_h_; x++ ) { 
            // цикл обеспечивает принятие решения с помощью таблицы, является ли точка контура d1 особой.
            for ( x=BufS[g]; x < BufS[g+1]; x++ ) {
                p0=bytes_data+x;
                // если точка контура d1 белая, то ее не зачем просчитывать по таблице.
                ///if (*(p0+w+1)==255) {       // d1=*(p0+w+1);    // в 2.8 быстрее
                // сборка байтового регистра rg0 из отдельных 8 бит матрицы с помощью единичных масок
                rg0=(*(p0)&1) + (*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w+2)&16) + (*(p0+w+w)&32) + (*(p0+w+w+1)&64) + (*(p0+w+w+2)&128); 
                // запись координат особых точек в массив
                ///if ( rg0>2 && table_1[rg0]==0 ) { *(p1+x+w+1)=255;  bytes_data0_32[n]=x+(w+1);  n++; }                 
                if ( rg0>2 && table_1[rg0]==0 ) { bytes_data0_32[n]=x+(w+1);  n++; }
                //cout<<(unsigned short)*p0;
                ///} // if
            } // x        
        } // g
        sizeAdr=n;
        if (GrafT) cout<<"значение    sizeAdr="<<sizeAdr<<endl;
        /**/
        
        
        // приведение массива к общепринятому стандарту, 0-черный 255-белый ( внутренний формат программы 0-белый 255-черный ). 
        //for ( x=0; x < w_h; x++ ) { if (bytes_data[x]>0) bytes_data[x]=0;  else bytes_data[x]=255; } // по 1 байту  // time=0.03  w_h=w*h=10 млн. пикселей
        int sizeAdr64_x=sizeAdr/2+2;  // sizeof(unsigned long)/sizeof(unsigned int);
        for ( x=sizeAdr64_x; x < w_h_64; x++ ) { bytes_data0_64[x]=~bytes_data0_64[x]; } // по 8 байт одновременно  // time=0.005 w*h=10 млн. пикселей
        
        
        if (GrafT) {
            // визуализация особых точек (фокальных точек) на подложке из серых фокальных линий (графем). 
            ///if (GrafT) {  for ( x=0; x < w_h; x++ ) {  bytes_data[x]=(bytes_data_2[x] + bytes_data[x])/2; }  }  // time=0.05 w*h=10 млн. пикселей
            ////for ( x=0; x < w_h; x++ ) { if ( bytes_data_1[x]==255 ) {bytes_data[x]=0;}  else  {bytes_data[x]=~(bytes_data[x]/2);}  }
            
            int sizeAdr8_x=sizeAdr*sizeof(unsigned int)+4;
            for ( x=sizeAdr8_x; x < w_h; x++ ) { bytes_data[x]=(255+bytes_data[x])/2; }
            for ( n=0; n < sizeAdr; n++ ) { bytes_data[bytes_data0_32[n]]=0; }
            
            // визуализация особых точек (фокальных точек) серым на подложке из черных фокальных линий (графем) с помощью массива координат.
            ////for ( n=0; n < sizeAdr; n++ ) { bytes_data[bytes_data0_32[n]]=128; }
        }
        
        
        /*    
         // тест области работы алгоритма, эррозия работает только с черным в тексте.
         for ( g=0; g < sizeBufSR; g+=2 ) { 
         for ( x=BufS[g]; x < BufS[g+1]; x++ ) { bytes_data[x]*=0.5; } // 0-черный
         } // for
         */
        
        //TIME_PRINT_
        
        // освобождение массивов 
        if (GrafT) { if ( bytes_data_1 !=NULL ) free(bytes_data_1); }
        //    if ( bytes_data_1 !=NULL ) free(bytes_data_1);
        if ( BufS !=NULL ) free(BufS);
        
        
        // возвращаемое количество особых точек по всему графическому тексту 
        // Адреса в виде int количеством sizeAdr расположенны в начале массива bytes_data и занимают 1-2 пиксельные линии.
        return sizeAdr;
        
        
        
        
    }//____________________________________________________________________________   
    
    
    
    
    
    
}
