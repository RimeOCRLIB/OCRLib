//  OCRLib  2015 www.buddism.ru.
//****************************************************************************
//  NAMO TASSA BHAGAVATO ARAHATO SAMMA SAMBUDDHASSA
//  Will Buddha Dharma bring benefit and peace in all the world.
//****************************************************************************
//
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .

#include "GGraph.h"
#include <math.h> 


namespace ocr{
    
    
    //*****************************************************************************
    
    /// Базовая версия - focalLineRecognition ///
    
    // Функция распознования фокальных линий (графемы) букв
    // Функция вычисляет координаты точек, из которых состоят фокальные линии букв.
    // Используется после применения функцией определения фокальной линии(графемы) букв и функции выделения фокальных точек.
    // сответственно GGraphFocalLine.cpp  и  GGraphfocalPointXTL.cpp . Не забыть очистиь от черного 2х pix бордюр
    // вызовом функции img->eraseBorder(2, 2);
    
    int  GGraph::focalLineRecognition(vector<OCRPoint>&focalAdr, vector<OCRFocalLine> &focalLine) {
        
        /// Комментарии к функции ///
        
        // Адреса начальных и конечных фокальных точек функция получает в виде int расположенны в массиве векторов focalAdr,
        // где int это расстояние от начала координат до фокальной точки. Количество адресов равно sizeAdr.
        // Функция возвращает координаты промежуточных точек фокальных линий в массиве focalLine и 
        // суммарную длинну фокальных линий по всему графическому тексту SumLengthLine (заремачили).
        
        //  * Идея *
        // По сути дела производит упорядочение адресов точек вдоль фокальной линии.
        // Функция получает координаты стартовой особой точки и запускает движение маски вдоль фокальной линии от
        // начальной до конечной фокальной точки. Промежуточные координаты точек фокальной линии записываются в массив.
        // За тем следующая стартовая точка и т.д.
        
        //  * Описание алгоритма движения маски по точкам фокальной линии.*
        // Помещаем центр маски 3*3 на стартовую особую точку. Маской, с помощью таблици rg_tab2,
        // проверяем сначало ближайшие точки, они м.б. только слева или справа, снизу или сверху и их 4.
        // И они плотнее соприкасаются с центральной точкой, чем диагональные. Если среди этих 4 точек черной нет,
        // то проверяем диагональные ближайшие точки. Таким способом находим две черные точки фокальной линии,
        // среди них одна точка от предидущей итерации и ее не рассматриваем. Остается только одна точка.
        // Это центральная точка следующей итерации.
        // Записываем в массив (Б.Д.) адрес соответствующей этой точке, в абсолютной системе координат.
        // Запоминаем также ее координату в переменную (например w+1), чтобы исключить ее из рассмотрения на следующей
        // итерации (начальные условия переменных это координаты стартовой особой точки). Переставляем на нее центр маски.
        // Маска оказалась в новом положении соответствующему началу следующей итерации и т.д...
        // За одну итерацию находим не более одной точки.
        // Если встречаем конечную фокальную точку или другую особую точку, то считаем что линия закончилась.
        // Пример из которого видно, зачем сначало рассматриваются ближайшие точки только слева или справа, снизу или сверху,
        // а затем диагональные ближайшие точки.
        //  1  0  0
        //  1  1  0
        //  0  1  1
        // Аналогично работает алгоритм выбора стартовах точек линии (их max 4), только используется таблица rg_tab3 и
        // с помощью нее проверяются все возможные стартовые точки.
        // Принцип и конкретная реализация работы матрицей (маской) обсчета (3*3-1) по таблице описана в функции GGraphFocalPoint.cpp
        
        //  * Особенности применения *
        // Перед запуском функции необходимо предварительно очистить от черного 2х pix бордюр с помощью вызова
        // функции img->eraseBorder(2, 2);
        
        
        int GrafT=0 ;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if (GrafT) { cout<<endl<<"Функция распознования фокальных линий букв   focalLineRecognition() "<<endl; }

        
TIME_START
        
        // Вызов функция построения таблиц (массивов) распознавания фокальных линий.
        buildOCRLineTable();
        // Функция заполняет глобальные массивы table_1[256], table_2[256] и table_3[256].

        // Вызов функция построения таблиц (массивов) для вычисления коэффициента корреляции уголов векторов.
        buildOCRAlphaTable();  // использается функциями сравнения (корреляции) двух кривых Безье CorrelationBezierA,B.
        // Функция заполняет глобальные массивы tabAlpha_1[361].
        
        int i;
        int w,h;
        w=ncolumns;  // ширина массива  IMAGE WIDTH
        h=nrows;     // высота массива  IMAGE HEIGHT
        int w_h=w*h; // длинна массива  IMAGE
        unsigned int sizeBuf=w_h + 32;  // размер массива bytes_data_1.
        if ( w>32766 ) w=32766;         // 32767
        if (GrafT) { cout<<"w="<<w<<",  h="<<h<<"    w*h="<<w*h/1000000<<" млн. пикселей"<<endl; }
        // w*h=10 млн. пикселей time=0.033  // w*h=14 млн. пикселей time=0.057
        register1=0;

        /// вспомогательные переменные
        int nl;         // Переменная цикла по количеству фокальных линий выходящих из особой точки.
        int np;         // Переменная цикла по количеству особых точек по всему графическому тексту.
        short dl_nl;    // Координата точек начала фокальных линий (переменная таблици rg_tab3), “nl” номер стартовой точки.
        int index;      // Переменная цикла по количеству точек фокальной линий.
        // int w_1=w+1; // смещение с угла в центр матрицы (
        //short g9=0, g2=0, g3=0, g8=0, g4=0, g7=0, g6=0, g5=0; // переменные для вывода графики
        //short dm9=-w-1, dm2=-w, dm3=1-w, dm8=-1, dm4=1, dm7=w-1, dm6=w, dm5=w+1; // переменные координат смещения маски //
        //          -w-1,     -w,     1-w,     -1,     1,     w-1,     w,     w+1  // величины смещения маски //

        // вспомогательный регистры (переменные таблиц)
        unsigned char rg0;  // байтовый регистр для хранения отдельных 8 бит маски.
        int rg_tab1=1;
        int rg_tab2=1;
        long rg_tab3=1;
        
        // обьявление локальных переменной для сохранения объекта "линия".
        OCRPoint p_line;  // для промежуточных точек вдоль фокальной линии. point of the line
        OCRPoint p_start; // для особых точек как начало фокальной линии.
                
        int sf_rg=sizeof(unsigned long);  // размер unsigned long в байтах // sizeof(unsigned long)=8
        int w_h_64=w_h/sf_rg;   // размер массива bytes_data в unsigned long
        ///cout<<"w_h="<<w_h<<"  sf_rg="<<sf_rg<<"  w_h_64="<<w_h_64<<endl;
        
        /// Массивы исходной битовой картинки фокальнах линий ///
        // указатели типа uchar
        unsigned char *p0=bytes_data, *p1;  // входной массив строго: 0-черный 255-белый (11111111), ( с 0-черный 1-белый не работает)
        unsigned char *bytes_data_1;        // массив занятости адресов промежуточных точек фокальной линии (0,1).
        // указатели типа ulong на массивы для быстрых циклов.
        unsigned long *bytes_data0_64=(unsigned long*)bytes_data;    // приведение к unsigned long
       
        // выделение памяти под массивы.
        // Таблица (массив) занятости адресов промежуточных точек фокальной линии.
        bytes_data_1 = (unsigned char*)calloc(sizeBuf+64, sizeof(unsigned char)); // с заполнением нулями
        
        // Массивы для хранения таблиц глобальные и объявлены в GBitmap.h
        
        uint sizeAdr=(uint)focalAdr.size(); // количество особых точек по всему графическому тексту. SumSpecialPoints
        uint SumLengthLine; // суммарная длинна всех фокальных линий (суммарное количество всех промежуточных точек)
        uint LengthLine;    // длинна фокальной линии (количество промежуточных точек вдоль фокальной линии)
        uint nLine;         // количество фокальных линий по всему графическому тексту.
        
        // максимально возможная длина фокальной линии равна w+h, что позволяет использовать массивы фиксированного размера.
        int MaxLengthLine=w+h; // 256 //  endPoint
        // максимальное количество фокальных линий выходящих из особой точки фиксированно и равно 4.
        int nLinePoint=4;
        
        // Координаты смещения маски по входящим или выходящим точкам пересечения фокальные линии с маской.
        // Реализуется один из двух вариантов смещения (на величину dl1 или dl2) и записывается в dl0.
        short dl0,dl1,dl2; // [-32768, 32768]
        // текущие координаты положения маски в абсолютной линейно строчной системе координат (отсчитываются от начала скана).
        int sl,sl1,sl_;
        // координаты предыдущего положения маски в абсолютной линейно строчной системе координат (отсчитываются от начала скана).
        int sl_old;
        // текущие координаты положения маски в абсолютной декартовой системе координат (отсчитываются от начала скана).
        short x0,y0; // по факту координаты "x" и "y" особой точки.

        
        // инверсия уровней входного массива общепринятого стандарта 0-черный 255-белый, во внутренний формат программы 0-белый 255-черный.
        //for ( i=0; i < w_h; i++ ) { if (bytes_data[i]) bytes_data[i]=0;  else bytes_data[i]=255;} // по 1 байту.
        for ( int i=0; i < w_h_64; i++ ) { bytes_data0_64[i]=~bytes_data0_64[i]; } // по 8 байт одновременно // time=0.005 w*h=10 млн. пикселей.
        
        // подготовка массива для поиска еще не оцифрованных линий, копирование в bytes_data_1
        // исходной битовой картинки фокальнах линий (0-белый 255-черный).
        memcpy(bytes_data_1, bytes_data, w_h);  // адрес буфера назначения, адрес источника, количество байт для копирования.
        /**/
        ////int w2=w+2; int ww=w+w; int ww1=w+w+1; int ww2=w+w+2;
        
/// Цикл перебора особых точек по всему графическому тексту. ///
nLine=0;  SumLengthLine=0;
        
for (np=0; np<sizeAdr; np++){

    // координаты начальной особой (фокальной) точки в Декартовой системе координат.
    x0=focalAdr[np].x;  // [-32768, 32768]
    y0=focalAdr[np].y;
    
    ///if (GrafT) { cout<<endl<<"стартовая точка линии   x0="<<x0<<"   y0="<<y0<<endl; }
    // координаты особой фокальной точки в линейно строчной системе координат для центральной точки маски d1.
    sl=y0*w + x0;
    
    // координаты особой фокальной точки в линейно строчной системе координат для байтового регистра rg0.
    p0=bytes_data+sl-w-1; // координаты смещены в левый верхний угол маски на 1 pix относительно ее центральной точки d1
    // (y0-1)*w + x0-1.
        
    // сборка байтового регистра rg0 из отдельных 8 бит матрицы с помощью единичных масок (единица д.б.- строго 255 (11111111)).
    // координаты отсчитываются с левого верхнего угла матрицы.
    rg0=(*(p0)&1) + (*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w+2)&16) + (*(p0+w+w)&32) + (*(p0+w+w+1)&64) + (*(p0+w+w+2)&128);
    ////rg0=(*(p0)&1) + (*(p0+1)&2) + (*(p0+2)&4) + (*(p0+w)&8) + (*(p0+w2)&16) + (*(p0+ww)&32) + (*(p0+ww1)&64) + (*(p0+ww2)&128);
    // получение количества фокальных линий выходящих из особых точек (соответственно 3,4,1).
    rg_tab1=table_1[rg0];
    //if ((rg_tab1 & 1)==1) nLinePoint=3;  if ((rg_tab1>>1 & 1)==1) nLinePoint=4;  if ((rg_tab1>>2 & 1)==1) nLinePoint=1;
    if (rg_tab1==1) nLinePoint=3;      if (rg_tab1==2) nLinePoint=4;           if (rg_tab1==4) nLinePoint=1;
    ///if (GrafT) { cout<<"количество фокальных линий особой точки nLinePoint="<<nLinePoint<<endl; }
    // ответ таблици table_3 (long) с координатами начала фокальных линий.
    rg_tab3=table_3[rg0];
    ///cout<<"распакованный table_3="<<table_3<<endl;

    /// Сохранение адресов первой точки фокальной линии (особой точки) в структуру ///
    p_start.x=x0; // адрес первой точки фокальной линии в декартовых координатах "x" (short).
    p_start.y=y0; // адрес первой точки фокальной линии в декартовых координатах "y" (short).
    
    // Заполнение массива занятости только особыми точками линий.
    bytes_data_1[sl]=127; // +++
    
    /// Цикл перебора фокальных линий выходящих из особой точки. ///
    p1=p0;   sl1=sl; // сохраняем значения p0 и sl т.к. в следующим цикле они необратимо модифицируются.
    for (nl=0; nl<nLinePoint; nl++){
        
        // точка перед стартовой точкой линии. Соответствует координатам особой точки.
        sl_old=sl1; // по смыслу sl_old=sl; но в этом цикле sl модифицируется // прошлая точка
        
        // Роспаковка координат из table_3 (long) в "nl" знаковых short с координатами начала фокальных линий.
        dl_nl=*((short*)&rg_tab3+nl); // “nl” номер стартовой точки.
        
        // Следующая точка линии после особой точки, т.е. стартовая точка линии. //
        p0=p1+dl_nl;  // координаты стартовой точки для байтового регистра rg0 (маски).
        sl=sl1+dl_nl; // координаты стартовой точки для центральной точки маски d1.
        
        // Проверка стартовой точки линии. Если эта линия уже просчитана (=127), то выходим из цикла (continue). // break;
        if ( bytes_data_1[sl]==127) continue;

        /// Сохранение адресов второй точки фокальной линии (стартовой точки) в структуру ///
        p_line.x=sl%w; // адрес второй точки фокальной линии, в декартовых координатах "x"(short).
        p_line.y=sl/w; // адрес второй точки фокальной линии, в декартовых координатах "y"(short).
        
        OCRFocalLine lineP;     // создаем новый объект "линия".
        lineP.data.push_back(p_start);   // сохраняем первую точку линии (особую точку).
        lineP.data.push_back(p_line);    // сохраняем вторую точку линии (стартовую точку).

        // Длинна фокальной линии состоящая из всех pix. Начальное значение содержит стартовую и вторую точку.
        LengthLine=2;
    
        
        /// Цикл перебора точек фокальных линий и вычисление их координат ///
        //  Цикл обеспечивает движение маски вдоль фокальной линии и принятие решения с помощью таблицы о направлении движения.
        rg_tab2=1;
        // остановка цикла по условию особой точки rg_tab2==0 или по max длинне линии MaxLengthLine=w+h // 256
        for ( index=0; rg_tab2!=0 && index<MaxLengthLine; index++ ) {

            // Сборка байтового регистра rg0 из отдельных 8 бит матрицы с помощью единичной маски.
            // Координаты отсчитываются с левого верхнего угла матрицы. Байты из памяти читаются почти подряд.
            // d9=rg0 & 1;     d2=rg0>>1 & 1; d3=rg0>>2 & 1; d8=rg0>>3 & 1; d4=rg0>>4 & 1;   d7=rg0>>5 & 1;  d6=rg0>>6 & 1;      d5=rg0>>7 & 1;
            rg0=(*(p0)&1) + (*(p0+1)&2) +  (*(p0+2)&4) +  (*(p0+w)&8) +  (*(p0+w+2)&16) + (*(p0+w+w)&32) + (*(p0+w+w+1)&64) + (*(p0+w+w+2)&128);
            // После распаковки в основном цикле получаем тот же регистр rg0 с той-же последовательностью битов.
            //cout<<"   sl="<<sl<<"   x=sl%w="<<sl%w<<"   y=sl/w="<<sl/w<<endl;

            // Ответ таблици int table_2 с двумя вариантами смещения маски на dl1 или dl2.
            rg_tab2=table_2[rg0];
            ///cout<<"   (short)rg0="<<(short)rg0<<"   rg_tab2="<<rg_tab2<<endl;
            
            // Если текущая точка - это обычная точка фокальной линии (не является особой точкой фокальной линии).
            if ( rg_tab2!=0) { // условие особой точки rg_tab2==0.
                
                // Роспаковка координат из table_2 (int) в два знаковых short с двумя вариантами смещения маски на dl1 или dl2.
                dl1=*(short*) & rg_tab2;
                dl2=*((short*) & rg_tab2+1);
                // После распаковки  координат получаем два short dl1 и dl2 (16р).
                
                // Вывод графики и пояснения
                
                // d9   d2   d3            0    1   0           1    0   1         -w-1  -w   1-w         1   2   4
                
                // d8   d1   d4            1        1           0        0          -1         1          8       16
                
                // d7   d6   d5            0    1   0           1    0   1          w-1   w   w+1         32  64 128
                
                // распакованная координата входящей и выходящей точки по шаблону матрици (центральная точка забита 1)
                /*
                if (GrafT){  // if (1) {
                    // текущая координата точки по шаблону матрици (центральная точка d1 = 0 или 2)
                    cout<<endl<<"------------"<<"index="<<index<<"------------"<<endl;
                    cout<<"текущая координата точки"<<endl;
                    //dm9=-w-1,  dm2=-w,  dm3=1-w, dm8=-1, dm4=1, dm7=w-1, dm6=w, dm5=w+1;
                    g9=rg0 & 1;  g2=rg0>>1 & 1;  g3=rg0>>2 & 1;  g8=rg0>>3 & 1;  g4=rg0>>4 & 1;  g7=rg0>>5 & 1;  g6=rg0>>6 & 1;  g5=rg0>>7 & 1;
                    cout<<g9<<"     "<<g2<<"     "<<g3<<endl<<g8<<"     "<<(short)bytes_data[sl]/127<<"     "<<g4<<endl<<g7<<"     "<<g6<<"     "<<g5<<endl; // 2 в центре маски это черное
                    cout<<"dl1="<<dl1<<"   dl2="<<dl2<<endl;
                    
                    //  распакованная координата входящей и выходящей точки по шаблону матрици (центральная точка забита 0)
                    g9=0, g2=0, g3=0, g8=0, g4=0, g7=0, g6=0, g5=0;
                    if (dl1==dm9 || dl2==dm9) g9=1;  if (dl1==dm2 || dl2==dm2) g2=1;  if (dl1==dm3 || dl2==dm3) g3=1;
                    if (dl1==dm8 || dl2==dm8) g8=1;  if (dl1==dm4 || dl2==dm4) g4=1;  if (dl1==dm7 || dl2==dm7) g7=1;
                    if (dl1==dm6 || dl2==dm6) g6=1;  if (dl1==dm5 || dl2==dm5) g5=1;
                    cout<<"входящая и выходящая точки"<<endl;
                    cout<<g9<<"     "<<g2<<"     "<<g3<<endl<<g8<<"           "<<g4<<endl<<g7<<"     "<<g6<<"     "<<g5<<endl<<endl;
 
                    cout<<"   sl="<<sl<<"   x=sl%w="<<sl%w<<"   y=sl/w="<<sl/w<<endl;
                    cout<<"   sl_old="<<sl_old<<"   x=sl_old%w="<<sl_old%w<<"   y=sl_old/w="<<sl_old/w<<endl;
                    cout<<"   sl+dl1="<<sl+dl1<<"   x=(sl+dl1)%w="<<(sl+dl1)%w<<"   y=(sl+dl1)/w="<<(sl+dl1)/w<<endl;
                    cout<<"   sl+dl2="<<sl+dl2<<"   x=(sl+dl2)%w="<<(sl+dl2)%w<<"   y=(sl+dl2)/w="<<(sl+dl2)/w<<endl;
                
                    //if ( index==1 ) { bytes_data[sl+dl2]=255; bytes_data[sl+dl1]=255;} // только sl+dl2
                } // (GrafT)
                */

                // Заполнение таблици (массива) занятости адресов промежуточных точек фокальной линии.
                bytes_data_1[sl]=127; //++++  // заполняем всю линию 127 от начальной стартовой до конечной стартовой точки включительно
                
                // Запоминаем адрес sl до изменения, т.к. адрес sl+dl1 или sl+dl2 будет относится уже к следующей итерации.
                // Запоминаем текущее положение маски, до модификации sl с помощью dl1 или dl2
                sl_=sl;
                                
                // координаты маски в следующей итерации в абсолютной линейной системе координат.
                if ( sl+dl1==sl_old ) { sl+=dl2; p0+=dl2; dl0=dl2; }  // это следующая стартовая точка.
                if ( sl+dl2==sl_old ) { sl+=dl1; p0+=dl1; dl0=dl1; }  // или эта
                ///if ( sl+dl1==sl_old ) { sl+=dl0=dl2; p0+=dl2; }    // это следующая стартовая точка.
                ///if ( sl+dl2==sl_old ) { sl+=dl0=dl1; p0+=dl1; }    // или эта
                //cout<<"dl0="<<dl0<<"   x=dl0%w="<<dl0%w<<"   y=dl0/w="<<dl0/w<<endl; ///////////////
                
                // запоминаем текущее положение маски, которое для следующей итерации будет стартовым,
                // не мешая установки начальных условий  sl_old=y0*w+x0; .
                sl_old=sl_;
                /// Координаты точек линии от следующий после стартовой до конечной особой точки, т.е. все сдвинуто вперед на pix. ///
                
                /// Сохранение координат промежуточных точек в структуру (стартовая и первая точка сохранены раньше) ///
                p_line.x=sl%w;  // координата текущей точки фокальной линии, в декартовых координатах по "x"(short).
                p_line.y=sl/w;  // координата текущей точки фокальной линии, в декартовых координатах по "y"(short).
                // оч. быстро, добавляет меньше чем time=0.001
                
                // сохраняем характеристики промежуточных точек в объект lineP.
                lineP.data.push_back(p_line);    // для массивов адресов от следующий после стартовой точки до конца.
                
                //if(GrafT){cout<<index<<"_index="<<lineP.data[index+2].x<<" y="<<lineP.data[index+2].y<<endl;}
                
                LengthLine++;       // Длина фокальной линии в pix.


            } // if
            

        } // index

        if(GrafT){
            //for(int t=0;t<lineP.data.size();t++){cout<<t<<"_x="<<lineP.data[t].x<<" y="<<lineP.data[t].y<<endl;}
        }
        
        // Запись в объект класса OCRFocalLine
        lineP.start=lineP.data[0];
        lineP.end=lineP.data[lineP.data.size()-1];
        lineP.index=(int)focalLine.size();
        if(GrafT){
            lineP.start.type=C_POINT;
            lineP.end.type=C_POINT;
        }

        GStr<int> *newPoints=GStr<int>::create();

        // Сохранение типа стартовой особой точки в объект линия.
        lineP.start.type=rg_tab1;
        // Сохранение типа конечной особой точки в объект линия.
        lineP.end.type=table_1[rg0];
        

        // Функция для распознования углов и подсчета его величины alpha. + 0.01 сек
        uint deltaAngle=7; // 7 // Расстояние между началом (концом) и вершиной угла в pix.
        focalLineRecAngle(lineP.data, newPoints, deltaAngle); //////
        
        // Функция для выполнения деления ломанной фокальной линии на составляющие линии (деления по углам). + 0.03 сек
        // Функция focalLineSplit выходит за границы массивов и теребует отладки
        //newPoints->resize(0);
        focalLineSplit(newPoints,focalLine,focalAdr,lineP);
        
        //focalLineNorm(lineP);
        // focalLineNorm выполняется в функции GGraphFocalLineRecognition1.
        //focalLine.push_back(lineP);  // записываем готовую линию в вектор.
        
        //newPoints->destroy();
  /**/
       
    } // for (nl=0;
    
} // for (np=0;

        // Вывод графики
        /*
        if (GrafT) {   // внутренний формат программы 0-белый 255-черный
            cout<<"количество особых точек по всему графическому тексту  sizeAdr="<<sizeAdr<<endl;
            cout<<"количество фокальных линий по всему графическому тексту  nLine="<<nLine<<endl;
            cout<<"суммарная длинна фокальных линий, по всему графическому тексту  SumLengthLine="<<SumLengthLine<<endl;
            // визуализация серым особых точек (фокальных точек)
            ////for ( n=0; n < sizeAdr; n++ ) { bytes_data[focalAdr[0][n]->y*w+focalAdr[0][n]->x]=128; } // читаем из массива массивов векторов
            
            // визуализация серым распознанных фокальных линий
            int focalLine_size; // длинна фокальной линии
            int SumLengthLine_s=0; // суммарная длинна фокальной линии
            for ( nl=0; nl < nLine; nl++ ) { // nl номер линии //nLine
                focalLine_size=(int)focalLine[0][nl]->size();
                SumLengthLine_s+=focalLine_size;
                for ( n=0; n < focalLine_size; n++ ) // n номер точки в линии
                    { bytes_data[focalLine[0][nl]->point[n].y*w+focalLine[0][nl]->point[n].x]=128; }  // читаем из массива массивов векторов
            } // for (nl=0;
            //cout<<"focalLine_size=(int)focalLine[0][nl]->size();="<<focalLine_size<<endl;
            cout<<"суммарная длинна фокальных линий (из массива БД), по всему графическому тексту  SumLengthLine_s="<<SumLengthLine_s<<endl;
           
            // визуализация серым распознанных фокальных линий из массива bytes_data_1
            ////memcpy(bytes_data, bytes_data_1, w_h);     // адрес буфера назначения, адрес источника, количество байт для копирования.
        }
       */
       
        /*
        // Для поиска не оцифрованных линий. Выделение не распознанных линий.
        if (GrafT) {   // работает во внутренним формате программы:  255-черный линия не распознанна, 127-серый линия распознанна, 0-белый.
            // визуализация серым не распознанных фокальных линий (по 8 байт одновременно).
            for ( i=0; i < w_h_64; i++ ) { bytes_data0_64[i]=(bytes_data0_64[i]>>7 & 0x0101010101010101)<<7; } // деление на 128 и прим. 64 р маски.
            // 0x0101010101010101  64 р маска для деление на 128, маска убирает передвинувшиеся при сдвиге разряды (7) из соседних байт.
            // Не распознанные фокальные линии становятся серыми (128), распознанные линии становятся белыми, белое остается белым (0).
        }
        */
        
        // приведение массива к общепринятому стандарту, 0-черный 255-белый ( внутренний формат программы 0-белый 255-черный ).
        ///for ( i=0; i < w_h; i++ ) { if (bytes_data[i]>0) bytes_data[i]=0;  else bytes_data[i]=255; } // по 1 байту,  time=0.03  w_h=w*h=10 млн. пикселей
        for ( i=0; i < w_h_64; i++ ) { bytes_data0_64[i]=~bytes_data0_64[i]; } // по 8 байт одновременно, time=0.005  w*h=10 млн. пикселей
        
        // освобождение массивов
        if ( bytes_data_1 !=NULL ) free(bytes_data_1);
        
        
//---------------------------------------------------------------------------------------------------------------------------------------------
        
        /// ВРЕМЕННЫЙ вызов функции для сравнения (корреляции) двух кривых Безье. ///
        
        // Линия line2 более длинная чем line1
        //int id1=881;   int id2=1697;       // line1, line2 // 1689, 1697 // 1045, 1697 // 1737; 1741; линии б/м // id1=2975;2976; инверсия точек
        ///OCRFocalLine line1=focalLine[id1], line2=focalLine[id2];
        
        // Функция с возможностью вычисления параметров кривой Безье по части фокальной линии.
        //int strL=0; int endL=focalLine[1689].lenM-3; // 0,0 по полной длине. // 25 //  focalLine[1689].lenM-3;
/////        focalLineBezierP(focalLine[1689], strL, endL);
        // Функция с возможностью вычисления параметров кривой Безье по части фокальной линии.
/////        focalLineBezierP(focalLine[1697], 0, 25);
 
        

//OCRFocalLine line1=focalLine[id1], line2=focalLine[id2];

int NumberLine=(int)focalLine.size(); // Количество линий на странице. number of lines // number of lines
//cout<<"Количество линий на странице     NumberLine="<<NumberLine<<endl;
 /*
register1=0; // временная переменная для подсчета чего-нибудь. Для тестов.
int m=0;
int size_Line=5000; // 5097
for (int n1=0; n1<size_Line; n1++){  // 1.5 сек 5000*5000
    for (int n2=0; n2<size_Line; n2++){
        
        // Функция для сравнения (корреляции) двух кривых Безье.
        //if(CorrelationBezierA(focalLine[n1], focalLine[n2], 0)>85) m++; //1689 1697 85.8477%
        if(CorrelationBezierT(focalLine[n1], focalLine[n2])>85) m++; // Используется таблица для ранней отсечки.
        // 0 коэффициент корреляции не зависит от масштаба (зависит от поворота кривых Безье). 93.3694%
        // 1 коэффициент корреляции не зависит от масштаба и от поворота кривых Безье.  93.5196%
        
        // Функция для сравнения (корреляции) двух кривых Безье. С параметрами.
////       CorrelationBezierB(focalLine[id1], focalLine[id2], 1,  0, 1, 1, 1); //////
        
    }
}
cout<<"    CorrelationBezierA(focalLine[n1], focalLine[n2], 0)>85    m="<<m<<endl;
///cout<<"nn1="<<nn1<<endl;
*/
//cout<<"    register1="<<register1<<endl;

/**/
        
        // Функция для сравнения (корреляции) одной кривой Безье с частью другой кривой Безье.
       // OCRFocalLine line3;
///        CorrelationBezierPart(focalLine[id1], focalLine[id2], line3);  /////
   
        
        // Функция для быстрой растеризации кривой Безье (Рекурсивная функция).
        //int id=id2; // 1697  // 1689
        //focalLine[id].mData.resize(0); // заполнение нулями
        //BezierRasterisation(focalLine[id], focalLine[id].mData);
        
        // Функция для тестирования алгоритмов обработки кривых Безье.
        //Test(focalLine[id1], focalLine[id2]);
        
//---------------------------------------------------------------------------------------------------------------------------------------------
        
        if(GrafT){TIME_PRINT_
cout<<endl<<"<<<<Время выполнения  focalLineRecognition>>>>"<<endl;
        }
//TIME_PRINT_

        
        // Возвращаем суммарную длину фокальных линий по всему графическому тексту (не подсчитанна).
        return SumLengthLine;

        
//---------------------------
        
        // код работает, но не понадобился.
        /*
         // нельзя давать серый, регистру rg0 надо строго 255 (11111111)
         // Быстрый перевод в серое, т.е. деление на 2.
       //if (GrafT) {   // внутренний формат программы 0-белый 255-черный
         // визуализация серым фокальных линий (по 8 байт одновременно). ( внутренний формат программы 255-черный, 0-белый ).
       //for ( i=0; i < w_h_64; i++ ) { bytes_data0_64[i]=(bytes_data0_64[i]>>1)&0x7F7F7F7F7F7F7F7F; } // деление на 2 и прим. 64 р маски.
         // Черное (255) становится серым (127), белое (0) остается белым.
         // 0x7F7F7F7F7F7F7F7F  64 р маска для деление на 2, маска убирает передвинувшиеся при сдвиге разряды из соседних байт.
       //}
    
        
        // Распаковка координат входящей и выходящей точки. Варианты координат смещения маски dl1, dl2 находятся в двух знаковых
        // short (16р+16р) запакованных в один int rg_tab (32р).
        /////////////////////////////signed short dl1;  // signed для распаковки сдвигом обязательно.
        ///dl1=rg_tab2;    // выбираем младший short, т.к. dl1 это signed short, а rg_tab это int. /// dl1 =(signed short)(rg_tab);
        ///dl2=rg_tab2>>8; // сдвигаем старший short в младший short  // >> дел  // << умн
        // После распаковки  координат получаем два short dl1 и dl2 (16р).

//g9=*(p0)&1, g2=*(p0+1)&2, g3=*(p0+2)&4, g8=*(p0+w)&8, g4=*(p0+w+2)&16, g7=*(p0+w+w)&32, g6=*(p0+w+w+1)&64, g5=*(p0+w+w+2);
        
        
        ///short table_dl[8]={ -w-1, -w, 1-w, -1, 1, w-1, w, w+1 };   // таблица координат смещения маски //
        /////                   d9;  d2;  d3; d8; d4; d7; d6; d5;     // порядок заполнения регистра
        /////                   0    1    0    1  1   0    1   0      // ортогональная маска регистра
        /////                   1    0    1    0  0   1    0   1      // диагональная маска регистра
        
        
        ///if ( sl+dl1==sl_old ) { sl+=dl2; p0+=dl2; cout<<"   slА="<<sl<<"   x=sl%w="<<sl%w<<"   y=sl/w="<<sl/w<<endl; }
        ///if ( sl+dl2==sl_old ) { sl+=dl1; p0+=dl1; cout<<"   slБ="<<sl<<"   x=sl%w="<<sl%w<<"   y=sl/w="<<sl/w<<endl; }
        
        /// if ( (focalLine[0][np+nl]->point[0].y + focalLine[0][np+nl]->point[0].x)!=0 )  continue; // point[0] нулевая точка
        
        
        //if ( maxCor<25 )  { correlation=1; goto maxCorEND; }
        //maxCorEND:; // переход
        
        //if ( MaxCorY==MaxCorX ) break;
        
        
        // Проверка центральной точки маски d1 (d1 д.б. всегда черная) происходит самим фактом движения по черной фокальной линии.
        */
    
    }//____________________________________________________________________________
 
    

        //*****************************************************************************
        
                                /// УГОЛ ///
    // Функция для распознования углов и подсчета его величины alpha.
        
    void GGraph::focalLineRecAngle(vector<OCRPoint>&dataVector, GStr<int>*newPoints, uint deltaAngle){
        
        
        // deltaAngle - Расстояние между началом (концом) и вершиной угла в pix, задается вручную ==7.
        // Углов на фокальной линии может быть несколько.
        // Функция потенциально масштабозависимая т.к. b_pix=7; (расстояние между началом <концом> и вершиной угла) задается в pix.
        // грубо можно взять от высоты строки Hs=32,   b_pix=Hs*7/32;

        int index, index_min;
        int x0,y0,x1,y1,x2,y2;  // Декартовы координаты начала и конца линии.
        int dx,dy;
        // a,b,c стороны треугольника, "alpha" угол напротив стороны "a". Точка угола сканирует фокальную линию.
        float a, aa;   // расстояние между началом и концом угла и его квадрат.
        float b, bb;   // расстояние между началом и вершиной угла и его квадрат.
        float c, cc;   // расстояние между концом и вершиной угла и его квадрат.
        float a_bc;    // отношение расстояния между концами угла и суммы длинны лучей угла и его копия
        float alpha, alpha_min;   // текущий угол в градусах вычесленый по теорема косинусов и его минимальное значение.
        int m=0;       // счетчик количества подряд идущих не срабатываний угла.
        
    
        // длинна фокальной линии (количество промежуточных точек вдоль фокальной линии).
        uint LengthLine=(uint)dataVector.size();
        OCRPoint *data=(OCRPoint*)&dataVector[0];
        
        int b_pix=deltaAngle;   // расстояние между началом (концом) и вершиной угла в pix. deltaAngle=7;
        int bc_pix=2*b_pix;  // расстояние между началом и концом угла, через его вершину, в pix.
        
        // Выходим из функции, если линия короткая.
        // Линии короче LINE_SIZE=12 или bc_pix+1=14+1 является прямыми линиями и в них углы не ищем.
        // "LINE_SIZE=12" в pix задаем в GGraph.h
        if (LengthLine<bc_pix+1 || LengthLine<LINE_SIZE) return; 
        //cout<<"LengthLine"<<LengthLine<<endl;
    
        int spaceLim=4;  // количества подряд идущих не срабатываний угла, в pix, перед срабатыванием следующего угла.
        // cout<<"b_pix="<<b_pix<<endl;
        
        float abcLim=0.8267;     // предварительный коэффициент срабатывания алгоритма. alpha=111  a_bc=0.8267
        // Позволяет вычислять угол в каждой точки фокальной линии по теореме косинусов в 10-40 раз реже.
        
        float alphaLim=110;   // максимальный угол срабатывания алгоритма в градусах.
        // Таблица соответствия предварительного коэффициента "abcLim" срабатывания алгоритма и угла "alphaLim"
        // index=11   alpha=128.664  a_bc=0.90151
        // index=36   alpha=120.533  a_bc=0.868675
        // index=23   alpha=119.058  a_bc=0.861903
        // index=34   alpha=119.058  a_bc=0.861903
        // index=45   alpha=111.505  a_bc=0.826682
        // index=37   alpha=90.0027  a_bc=0.707107
        // index=35   alpha=65.2268  a_bc=0.53931
        // alphaLim=57.29747*2*a_bc; // alphaLim=114,6*a_bc; // формула для оценки alphaLim по a_bc для малых углов
        
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if (GrafT) {
            cout<<endl<<"Функция для выделения углов   focalLineRecAngle() "<<endl;
            cout<<"Расстояние между началом (концом) и вершиной угла в pix deltaAngle="<<deltaAngle<<endl;
            cout<<"Максимальный угол срабатывания алгоритма в градусах alphaLim="<<alphaLim<<endl;
            cout<<"Предварительный коэффициент срабатывания алгоритма abcLim="<<abcLim<<endl;
            /**/
        }
        
        // Начальные условия для вычисления минимального угла.
        alpha=alpha_min=32768;  index_min=0;  m=0;
        
        // Нахождение углов при движении по координатам фокальной линии.
        uint LengthLine_=LengthLine-b_pix;
        for ( index=b_pix; index<LengthLine_; index++ ) {//-1
            
            x0=data[index].x;        y0=data[index].y;
            x1=data[index-b_pix].x;  y1=data[index-b_pix].y;
            x2=data[index+b_pix].x;  y2=data[index+b_pix].y; //+1
            
            dx=x2-x1;  dy=y2-y1;
            // Вычисление кратчайшего расстояния между началом и концом угла по Теореме Пифагора.
            aa=(float)(dx*dx+dy*dy);
            a=sqrt(aa);
            
            dx=x1-x0;  dy=y1-y0;
            // Вычисление кратчайшего расстояния между началом и вершиной угла.
            bb=(float)(dx*dx+dy*dy);
            b=sqrt(bb);
            
            dx=x2-x0;  dy=y2-y0;
            // Вычисление кратчайшего расстояния между концом и вершиной угла.
            cc=(float)(dx*dx+dy*dy);
            c=sqrt(cc);
            
            
            // если отношение расстояния между концами угла и суммы длинны лучей угла меньше
            // порогового значения, то вычисляем угол по теорема косинусов.
            a_bc=a/(b+c);
            if (a_bc<abcLim){
                
                // вычисление угола по теорема косинусов.
                //￼￼￼ a*a=b*b + c*c - 2bc*cosA // A угол между bc.
                // alpha=arccos((b*b + c*c - a*a)/2bc);
                alpha=57.29747*acos((bb + cc - aa)/(2*b*c));
                
                if (alpha<alphaLim){
                    // если текущий угол меньше порогового значения,
                    // то вычисляем наилучшую точку по критерию минимального угла.
                    if (alpha_min>alpha){ // критерий минимального угла.
                        alpha_min=alpha;  // Запоминаем минимальный угол.
                        index_min=index;  // Сохраняем индех.
                        m=0;              // Обнуляем счетчик не срабатываний.
                    }
                }else{
                    m++; // подсчитываем количество не срабатываний.
                } // if (alpha<alphaLim
                
            }else{
                m++; // подсчитываем количество не срабатываний.
            }// if (a_bc
            
            
            // детектор нескольких (spaceLim) не срабатываний угла.
            if ((m>spaceLim || index==LengthLine-b_pix-1) && index_min>0) {
            //             "||" отработка конца линии     // index_min>0 если что то есть в коробке
            
                // Запоминаем индекс и минимальный угол, если прошло несколько (b_pix) подряд идущих не срабатываний угла.
                newPoints->push_back(index_min); // index_min, alpha_min
                // Восстанавливаем начальные условия для вычисления минимальный угла (опустошаем коробку = index_min).
                alpha_min=32768; index_min=0;
                if (GrafT) {
                    cout<<"index="<<index<<"   index_min="<<index_min<<"   m="<<m<<endl;
                    cout<<"Запомнили минимальный угол"<<endl; }
            }
            //cout<<"index="<<index<<"   index_min="<<index_min<<"   m="<<m<<endl;
        } // for ( index
/**/

        
        // Вспомогательные формулы
        // float sinAlpha=sin(alpha/57.29747/2);
        // Теорема косинусов
        //￼￼￼ a*a=b*b + c*c - 2bc*cosA // A угол между bc
        //￼￼￼ b*b=a*a + c*c - 2ac*cosB // B угол между ac
        //￼￼￼ c*c=a*a + b*b - 2ab*cosC // C угол между ab
        // Теорема синусов
        // a/sinA=b/sinB=c/sinC

        
    }//__________________________________________________________________________
/**/

    
    //*****************************************************************************
    
    // Функция для деления ломанной фокальной линии на составляющие линии.
    
    void GGraph::focalLineSplit(GStr<int>*newPoints, vector<OCRFocalLine> &focalLine,vector<OCRPoint>&focalAdr,OCRFocalLine &lineP){
        
        // В случае если в линия ломанная (найден один или несколько углов), делим линию на
        // составляющие линиии производим их нормализацию.
        
        int count=newPoints->size();
        if(count){
            
            for (int i=0; i<count; i++ ) {
                OCRFocalLine line;
                if(i==0){
                    line.start=lineP.start;
                    int d=newPoints[0][i];
                    //cout<<"d="<<d<<endl;
                    line.end=lineP.data[d];
                    line.index=lineP.index;
                    line.data.resize(d);
                    memcpy((char*)&line.data[0],(char*)&lineP.data[0],d*sizeof(OCRPoint));
                    
                    //DR("i="<<d<<" s="<<count<<" line.index="<<line.index<<endl);
                    //if(print){
                    //    line.reloadPtr();
                    //    for(int j=0;j<line.data.size();j++){
                    //        cout<<j<<" x="<<line.data[j].x<<" y="<<line.data[j].y<<" x1="<<lineP.data[j].x<<" y="<<lineP.data[j].y<<endl;
                    //    }
                    //}
                }else{
                    int d=newPoints[0][i];
                    int d1=newPoints[0][i-1];
                    line.start=lineP.data[d1];
                    line.end=lineP.data[d];
                    line.index=(int)focalLine.size();
                    int l=d-d1;
                    line.data.resize(l);
                    memcpy(&line.data[0],(char*)&lineP.data[0]+sizeof(OCRPoint)*d1,l*sizeof(OCRPoint));
                    
                    line.start.type=C_POINT;
                    focalAdr.push_back(line.start);
                }
                
                // Функция для нормализации данных фокальной линии.
                focalLineNorm(line);
                
                focalLine.push_back(line);  // записываем готовую линию в вектор.
                
            }
            OCRFocalLine line;
            int d=newPoints[0][newPoints->size()-1];
            line.start=lineP.data[d];
            line.end=lineP.end;
            line.index=(int)focalLine.size(); ///cout<<" line.index="<<line.index<<endl;
            int l=(int)lineP.data.size()-d;
            int start=(int)lineP.data.size()-l;
            //cout<<"newPoints[newPoints.size()-1]="<<newPoints[newPoints.size()-1]<<" l="<<l<<endl;
            line.data.resize (l);
            //cout<<"l="<<l<<" start="<<start<<" size()="<<lineP.data.size()<<endl;
            memcpy((char*)&line.data[0],(char*)&lineP.data[0]+sizeof(OCRPoint)*start,l*sizeof(OCRPoint));
            line.start.type=C_POINT;
            focalAdr.push_back(line.start);
            
            ///cout<<" s="<<lineP.data.size()<<" line.index="<<line.index<<endl;
            //for(int j=0;j<line.data.size();j++){
            //    cout<<j<<" x="<<line.data[j].x<<" y="<<line.data[j].y<<" x1="
            //    <<lineP.data[j+start].x<<" y="<<lineP.data[j+start].y<<endl;
            //}
            
            focalLineNorm(line);
            focalLine.push_back(line);  // записываем готовую линию в вектор.
            
        }else{
            
            // Вызов функции для нормализации данных фокальной линии.
            focalLineNorm(lineP);
            // focalLineNorm выполняется в функции GGraphFocalLineRecognition1.
            focalLine.push_back(lineP);  // записываем готовую линию в вектор.
            
            
        }
        

        
    } //____________________________________________________________________________


 
    //*****************************************************************************

    /// Базовая версия - buildOCRLineTable ///
    
    // Функция построения таблиц распознавания фокальных линий.
    // Предназначена для построения таблиц, необходимых для функции распознования фокальных линий focalLineRecognition.
    
void GGraph::buildOCRLineTable(){
    
    // Функция создает 3 предпросчитанные таблици (заполняет 3 глобальных массива, объявленые в GBitmap.h):
    // - таблицу для вычисления особых точек table_1. //
    // - таблицу для вычисления адресов смещения точек при движении вдоль фокальной линии table_2 //
    // - таблицу для вычисления адресов точек начала фокальных линий table_3. Из каждой точки может выходить до 4 линий. //
    
    // Вычисление матрицы (3*3-1) по предпросчитанным таблицам быстрее в несколько раз чем просчитывать матрицу в теле основного цикла.
    // Принцип и конкретная реализация работы матрицей (маской) обсчета (3*3-1) по таблице описана в функции GGraphFocalPoint.cpp

    
    int GrafT=0 ;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
    if (GrafT) { cout<<"Функция построения таблиц распознавания фокальных линий   buildOCRLineTable() "<<endl; }

    
    /// вспомогательные переменные.
    unsigned char d2,d3,d4,d5,d6,d7,d8,d9; // d1,  // переменные маски.
    short dm9=-w-1, dm2=-w, dm3=1-w, dm8=-1, dm4=1, dm7=w-1, dm6=w, dm5=w+1; // переменные координат смещения маски //
    //        -w-1,     -w,     1-w,     -1,     1,     w-1,     w,     w+1  // величины смещения маски //
    unsigned char a01, a10, b; // переменные условий.
    short dl_1=0, dl_2=0, dl_3=0, dl_4=0;  // Координаты точек (например dl_1, dl_2 координаты входящих и выходящих точек).

    // вспомогательный регистры (переменные таблиц), где table_1[256], table_2[256], table_3[256] и table_4[256] глобальные массивы.
    unsigned char rg0;  // байтовый регистр для хранения отдельных 8 бит маски.
    int rg_tab2=1;
    long rg_tab3=1;
    
    
    
    // переменные для вывода графики
    short g9=0, g2=0, g3=0, g8=0, g4=0, g7=0, g6=0, g5=0;
    GrafT=0;
    if (GrafT) {
        // вывод на экран шаблона матрици
        cout<<"d9"<<"   d2"<<"   d3"<<endl<<"d8"<<"          d4"<<endl<<"d7"<<"   d6"<<"   d5"<<endl;
        // вывод на экран бит регистра rg0 по шаблону матрици
        ///cout<<(short)d9<<"     "<<(short)d2<<"     "<<(short)d3<<endl<<(short)d8<<"            "<<(short)d4<<endl<<(short)d7<<"     "<<(short)d6<<"     "<<(short)d5<<endl;
    }
    
    
    //rg0=1+64+16;  // тест
    
    //матрица обсчета    //ортогональная маска  //диагональная маска   //адреса смещения     //сокращение     // пример rg0
    
    // d9   d2   d3            0    1   0           1    0   1         -w-1  -w   1-w         dm9 dm2 dm3        1   2   4
    
    // d8   d1   d4            1        1           0        0          -1         1          dm8     dm4        8       16
    
    // d7   d6   d5            0    1   0           1    0   1          w-1   w   w+1         dm7 dm6 dm5        32  64 128
    
    // матрица (маска) обсчета (3*3-1), где d1 центральной точка по которой принимается решение.
    // d2, d3, d4, d5, d6, d7, d8, d9  точки окружения, по которым работает алгоритм принятия решения.
    
    
    /////
    
    // Создание предпросчитанной таблицы особых точек table_1. //
    // Создание предпросчитанных адресов смещения точек при движении вдоль фокальной линии table_2 //
    // Создание предпросчитанной таблицы адресов точек начала фокальных линий table_3. //
    // Цикл перебора всех возможных значений матрицы (3*3-1 без центральной точки).
    for (int index=0; index < 256; index++){
        rg0=index;
        table_1[index]=table_2[index]=table_3[index]=0; // заполнение таблиц нулями
        dl_1=dl_2=dl_3=dl_4=0;
        
        // разборка байтового регистра на отдельные 8 бит //
        d9=rg0 & 1;    d2=rg0>>1 & 1; d3=rg0>>2 & 1; d8=rg0>>3 & 1;
        d4=rg0>>4 & 1; d7=rg0>>5 & 1; d6=rg0>>6 & 1; d5=rg0>>7 & 1;
        // Подготовка данных для алгоритма //
        a01=0; // "a01" это число паттернов "01" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)
        if(d3-d2>0)a01++; if(d4-d3>0)a01++; if(d5-d4>0)a01++; if(d6-d5>0)a01++;
        if(d7-d6>0)a01++; if(d8-d7>0)a01++; if(d9-d8>0)a01++; if(d2-d9>0)a01++;
        a10=0; // "a10" это число паттернов "10" в упорядоченном множестве d2, d3, d4, d5, d6, d7, d8, d9,(d2)
        if(d3-d2<0)a10++; if(d4-d3<0)a10++; if(d5-d4<0)a10++; if(d6-d5<0)a10++;
        if(d7-d6<0)a10++; if(d8-d7<0)a10++; if(d9-d8<0)a10++; if(d2-d9<0)a10++;
        // "b" это число ненулевых соседей центральной точки d1, например, она имеет по крайней мере, 3 ненулевых соседа, но не более 5.
        b=d2+d3+d4+d5+d6+d7+d8+d9;
        
        // Заполнение таблиц //
        
        // АЛГОРИТМ подсчета особых точек. Заполнение таблици table_1 //
        // Точно такой же как в GGraphFocalPoint.cpp . При изменениях синхронизировать.
        // Ставит точки только в "Т" стыках (базовый вариант). //
        if ( b<6 && b>2 && a01==3 && a10==3 ) table_1[index]+=1;  // проверяется a01=3 && a10=3  // 56 (int mn=0; {mn++;})
        
        // Ставит точки не только в "Т" стыках, но и в "Х" стыках. //
        //if ( b<7 && b>2 && a01>2 && a01<5 && a10>2 && a10<5 ) table_1[index]+=2; // проверяются a01=3=4 && a10=3=4
        // Ставит точки только в "Х" стыках. Основное правило  //
        if ( b<7 && b>2 && a01>2 && a01<5 && a10>2 && a10<5 && table_1[index]!=1) table_1[index]+=2; // 2
        //cout<<" "<<(unsigned short)table_1[index];
        
        // Основное правило ("Т" или "Х" стыков) ситуацию с квадратом из четырех точек не отрабатывает.
        // Варианты отработки ситуации, если на месте Х образной точки квадрат из четырех точек,
        // с выходящими из всех углов ломаными линиями. //
        // отрабатывает не все ситуации
        ///if ( d8==1 && d9 && d2==1 && b==5 && a01==2 && a10==2 ) table_1[index]+=2; // d8==d9==d2==1 описание квадрата 2x2 pix, // 6
        
        // Ставит точки в случае, если на месте Х образной точки квадрат из четырех точек.
        // В этом варианте мы ставим одну фокальную точку в правый нижний угол квадрата
        ///if ( d8==1 && d9 && d2==1 && a01==2 && a10==2 ) table_1[index]+=2;
        
        // Ставит точки в случае, если на месте Х образной точки квадрат из четырех точек.
        // В этом варианте мы ставим четыре фокальных точеки в каждом уголу квадрата
        if ( ((d8==1 && d9==1 && d2==1) || (d2==1 && d3==1 && d4==1) ||
              (d4==1 && d5==1 && d6==1) || (d6==1 && d7==1 && d8==1)) && b<7 && a01==2 && a10==2 ) table_1[index]+=2;
        // центральная точка d1==1 проверяется в основном цикле ниже

        // Ставит точки на концах линий "L_End" и не забыть поставить в главном цикле if ( rg0>0 && table_1[rg0]==0 )
        if ( b<3 && b>0 && a01==1 && a10==1 ) table_1[index]+=4;  // 16
        
        // Ставит точки когда фокальная линия вырожденна в один пиксел "P_Point"
        if ( b==0 ) table_1[index]+=8; // также как и во всех предидущих случаях запаковываем этот бит в char. // 1
        
        // (GrafT) // вывод на экран стыков типа "Т", "Х" и "L_End" по шаблону матрици (параметр соответственно ==1, ==2, ==4)
        if (GrafT && table_1[index]==4) {
            cout<<"index="<<index<<endl;
            cout<<(short)d9<<"     "<<(short)d2<<"     "<<(short)d3<<endl<<(short)d8<<"     "<<1<<"     "<<(short)d4<<endl<<(short)d7<<"     "<<(short)d6<<"     "<<(short)d5<<endl<<endl;
        }
        if (GrafT){
            cout<<"table_1[188]="<<(short)table_1[188]<<endl;
            cout<<"b="<<(short)b<<" a01="<<(short)a01<<" a10="<<(short)a10<<endl;
        }
    
        // АЛГОРИТМ вычисления адресов промежуточных точек.  Заполнение таблици table_2  //
        // Вычисление координат входящей и выходящей точки. Одна из них станет координатой смещения маски.
        //          b>0
        if ( b<7 && b>1 && a01==2 && a10==2 && table_1[index]==0 ) { // и не особая точка // Условие заполнения таблицы. 5
            
            // Сначала ищем самые "ближайшие" входящие и выходящие точки (они м.б. только слева или справа, снизу или сверху).
            // Координаты входящих и выходящих точек это и есть одна из координат смещения маски dl1 или dl2.
            dl_1=0, dl_2=0;
            if (d2==1) { if (dl_1==0) dl_1=dm2; }
            if (d4==1) { if (dl_1==0) dl_1=dm4; else if (dl_2==0) dl_2=dm4; }
            if (d6==1) { if (dl_1==0) dl_1=dm6; else if (dl_2==0) dl_2=dm6; }
            if (d8==1) { if (dl_1==0) dl_1=dm8; else if (dl_2==0) dl_2=dm8; }
            //cout<<(short)rg0<<"   dl_1="<<dl_1<<"   dl_2="<<dl_2<<endl;
            
            // За тем ищем диаганальные "более дальние" входящие и выходящие точки (они м.б. только по диаганали)
            // и проверяем только те у которых не заняты соседние точки.
            if (d9==1 && d8==0 && d2==0) { if (dl_1==0) dl_1=dm9; else if (dl_2==0 ) dl_2=dm9; }
            if (d3==1 && d2==0 && d4==0) { if (dl_1==0) dl_1=dm3; else if (dl_2==0 ) dl_2=dm3; }
            if (d5==1 && d4==0 && d6==0) { if (dl_1==0) dl_1=dm5; else if (dl_2==0 ) dl_2=dm5; }
            if (d7==1 && d6==0 && d8==0) { if (dl_1==0) dl_1=dm7; else if (dl_2==0 ) dl_2=dm7; }
            //cout<<(short)rg0<<"   dl_1="<<dl_1<<"   dl_2="<<dl_2<<endl;
            /**/
            
            // Запаковка в int (table_2) двух знаковых short с двумя вариантами смещения маски на dl1 или dl2.
            *(short*)&rg_tab2=dl_1;   *((short*)&rg_tab2+1)=dl_2;
            table_2[index]=rg_tab2;
            
            // (GrafT) // распакованная координата входящей и выходящей точки по шаблону матрици (центральная точка забита 1)
            if (GrafT) {
                // тест
                // Роспаковка координат из table_2 (int) в два знаковых short с двумя вариантами смещения маски на dl1 или dl2.
                dl_1=*(short*)&table_2[index];   dl_2=*((short*)&table_2[index]+1);
                cout<<"index="<<index<<"  table_2[index]="<<table_2[index]<<"   распакованные  dl_1="<<dl_1<<",   dl_2="<<dl_2<<endl;
                //dm9=-w-1,  dm2=-w,  dm3=1-w, dm8=-1, dm4=1, dm7=w-1, dm6=w, dm5=w+1;
                g9=0, g2=0, g3=0, g8=0, g4=0, g7=0, g6=0, g5=0;
                if (dl_1==dm9 || dl_2==dm9) g9=1;  if (dl_1==dm2 || dl_2==dm2) g2=1;  if (dl_1==dm3 || dl_2==dm3) g3=1;
                if (dl_1==dm8 || dl_2==dm8) g8=1;  if (dl_1==dm4 || dl_2==dm4) g4=1;  if (dl_1==dm7 || dl_2==dm7) g7=1;
                if (dl_1==dm6 || dl_2==dm6) g6=1;  if (dl_1==dm5 || dl_2==dm5) g5=1;
                cout<<g9<<"     "<<g2<<"     "<<g3<<endl<<g8<<"     "<<1<<"     "<<g4<<endl<<g7<<"     "<<g6<<"     "<<g5<<endl<<endl;
            } // (GrafT)
            
        } // if ( b<5
        
        
        
        // АЛГОРИТМ вычисления координат начала фокальных линий, выходящих из особых точек. //
        // получение координат начала фокальных линий, выходящих из особых точек (их м.б. 3,4,1 максимум 4).
        if ( table_1[index]!=0 ) { // если особая точка, то заполняем таблицу.
            
            // Сначала ищем самые "ближайшие" входящие и выходящие точки (они м.б. только слева или справа, снизу или сверху).
            // Координаты выходящих точек это и есть стартовые координаты dl1, dl2, dl3, dl4 начала движения маски по фокальной линии.
            dl_1=dl_2=dl_3=dl_4=0;
            //dl_1=0, dl_2=0, dl_3=0, dl_4=0;
            if (d2==1) { dl_1=dm2; }
            if (d4==1) { if (dl_1==0) dl_1=dm4; else if (dl_2==0) dl_2=dm4; }
            if (d6==1) { if (dl_1==0) dl_1=dm6; else if (dl_2==0) dl_2=dm6; else if (dl_3==0) dl_3=dm6; }
            if (d8==1) { if (dl_1==0) dl_1=dm8; else if (dl_2==0) dl_2=dm8; else if (dl_3==0) dl_3=dm8; else if (dl_4==0) dl_4=dm8; }
            ///cout<<(short)rg0<<"   dl_1="<<dl_1<<"   dl_2="<<dl_2<<"   dl_3="<<dl_3<<"   dl_4="<<dl_4<<endl;
            
            // За тем ищем диаганальные "более дальние" входящие и выходящие точки (они м.б. только по диаганали)
            // и проверяем только те у которых не заняты соседние точки.
            if (d9==1&&d8==0&&d2==0) {if (dl_1==0)dl_1=dm9; else if (dl_2==0 )dl_2=dm9; else if (dl_3==0 )dl_3=dm9; else if (dl_4==0 )dl_4=dm9;}
            if (d3==1&&d2==0&&d4==0) {if (dl_1==0)dl_1=dm3; else if (dl_2==0 )dl_2=dm3; else if (dl_3==0 )dl_3=dm3; else if (dl_4==0 )dl_4=dm3;}
            if (d5==1&&d4==0&&d6==0) {if (dl_1==0)dl_1=dm5; else if (dl_2==0 )dl_2=dm5; else if (dl_3==0 )dl_3=dm5; else if (dl_4==0 )dl_4=dm5;}
            if (d7==1&&d6==0&&d8==0) {if (dl_1==0)dl_1=dm7; else if (dl_2==0 )dl_2=dm7; else if (dl_3==0 )dl_3=dm7; else if (dl_4==0 )dl_4=dm7;}
            ///cout<<(short)rg0<<"+++   dl_1="<<dl_1<<"   dl_2="<<dl_2<<"   dl_3="<<dl_3<<"   dl_4="<<dl_4<<endl;
            /**/
            
            // Запаковка в long (table_3) четырех знаковых short с координатами начала фокальных линий,
            // выходящих из особых точек, в виде смещения маски на dl1, dl2, dl3, dl4.
            *(short*)&rg_tab3=dl_1;   *((short*)&rg_tab3+1)=dl_2;   *((short*)&rg_tab3+2)=dl_3;   *((short*)&rg_tab3+3)=dl_4;
            table_3[index]=rg_tab3;
            ///cout<<"запакованный table_3"<<table_3<<endl;
            
            // (GrafT)
            // распакованные координаты начала фокальных линий, выходящих из особых точек, по шаблону матрици (центральная точка забита 1)
            /*
            if (0) {
                // Роспаковка координат из table_3 (long) в четыре знаковых short с координатами начала фокальных линий.
                rg_tab3=table_3[index];
                dl_1=*(short*)&rg_tab3;   dl_2=*((short*)&rg_tab3+1);   dl_3=*((short*)&rg_tab3+2);   dl_4=*((short*)&rg_tab3+3);
                cout<<"dl_1="<<dl_1<<"  dl_2="<<dl_2<<"  dl_3="<<dl_3<<"  dl_4="<<dl_4<<endl<<endl;
                // заполнение шаблона матрици
                cout<<"распакованные координаты начала фокальных линий"<<endl;
                //dm9=-w-1,  dm2=-w,  dm3=1-w, dm8=-1, dm4=1, dm7=w-1, dm6=w, dm5=w+1;
                g9=0, g2=0, g3=0, g8=0, g4=0, g7=0, g6=0, g5=0;
                if (dl_1==dm9||dl_2==dm9||dl_3==dm9||dl_4==dm9) g9=1;    if (dl_1==dm2||dl_2==dm2||dl_3==dm2||dl_4==dm2) g2=1;
                if (dl_1==dm3||dl_2==dm3||dl_3==dm3||dl_4==dm3) g3=1;    if (dl_1==dm8||dl_2==dm8||dl_3==dm8||dl_4==dm8) g8=1;
                if (dl_1==dm4||dl_2==dm4||dl_3==dm4||dl_4==dm4) g4=1;    if (dl_1==dm7||dl_2==dm7||dl_3==dm7||dl_4==dm7) g7=1;
                if (dl_1==dm6||dl_2==dm6||dl_3==dm6||dl_4==dm6) g6=1;    if (dl_1==dm5||dl_2==dm5||dl_3==dm5||dl_4==dm5) g5=1;
                cout<<g9<<"     "<<g2<<"     "<<g3<<endl<<g8<<"     "<<0<<"     "<<g4<<endl<<g7<<"     "<<g6<<"     "<<g5<<endl<<endl;
            } // (GrafT)
            */
        } // if ( table_1
        
    } // for (index
    
    /////
    
    /**/
    if (GrafT) {
        cout<<"значение байтового регистра для хранения отдельных 8 бит маски, в конце цикла   rg0="<<(unsigned short)rg0<<endl;
        // вывод на экран бит регистра rg0 по шаблону матрици
        cout<<(short)d9<<"     "<<(short)d2<<"     "<<(short)d3<<endl<<(short)d8<<"            "<<(short)d4<<endl<<(short)d7<<"     "<<(short)d6<<"     "<<(short)d5<<endl;
    }
    // cout<<endl;
    /**/

    // Глобальные массивы table_1[256], table_2[256] и table_3[256] заполнены и готовы к использованию в
    
    
    //--------------------------------------------------------------------------------------------------------------------------
    /*           // таблица работает, но не понадобилась. Углы слишком грубые 45, 90 градусов и еще скачут.
    // предпросчитаная таблица вычисления тангенциальных углов при движении вдоль фокальной линии.
    char table_4[256];   // глобольный, заявленв GGraph.
    =table_4[index]=0;
    char rg4;
    // АЛГОРИТМ вычисления тангенциальных углов промежуточных точек.  Заполнение таблици table_4  //
    // Вычисление разности углов между вектором центральной и входящей точкой и вектором между центральной и выходящей точкой.
    // Т.е. вычисление тангенциальных углов при движении вдоль фокальной линии.
    // Получает данные dl_1 и dl_2 от алгоритма вычисления адресов промежуточных точек.
    
    // d9   d2   d3            0    1   0           1    0   1         -w-1  -w   1-w         dm9 dm2 dm3        1   2   4
    
    // d8   d1   d4            1        1           0        0          -1         1          dm8     dm4        8       16
    
    // d7   d6   d5            0    1   0           1    0   1          w-1   w   w+1         dm7 dm6 dm5        32  64 128
    
    //dm9=-w-1,  dm2=-w,  dm3=1-w, dm8=-1, dm4=1, dm7=w-1, dm6=w, dm5=w+1;
 
     // Знак угла определяется в основной функции
     //if (dl_1==dm2) { if(dl_2==dm4)rg4=90; if(dl_2==dm5)rg4=45; if(dl_2==dm6)rg4=0; }
     //else if (dl_1==dm3) { if(dl_2==dm5)rg4=90; if(dl_2==dm6)rg4=45; if(dl_2==dm7)rg4=0; }
     //else if (dl_1==dm4) { if(dl_2==dm6)rg4=90; if(dl_2==dm7)rg4=45; if(dl_2==dm8)rg4=0; }
     //else if (dl_1==dm5) { if(dl_2==dm7)rg4=90; if(dl_2==dm8)rg4=45; if(dl_2==dm9)rg4=0; }
     //else if (dl_1==dm6) { if(dl_2==dm8)rg4=90; if(dl_2==dm9)rg4=45; if(dl_2==dm2)rg4=0; }
     //else if (dl_1==dm7) { if(dl_2==dm9)rg4=90; if(dl_2==dm2)rg4=45; if(dl_2==dm3)rg4=0; }
     //else if (dl_1==dm8) { if(dl_2==dm2)rg4=90; if(dl_2==dm3)rg4=45; if(dl_2==dm4)rg4=0; }
     //else if (dl_1==dm9) { if(dl_2==dm3)rg4=90; if(dl_2==dm4)rg4=45; if(dl_2==dm5)rg4=0; }
     // dl2 и dl1 величины смещения маски по входящим или выходящим точкам пересечения фокальные линии с маской. //
 
    
    if (dl_1==dm2) { if(dl_2==dm4)rg4=90; if(dl_2==dm5)rg4=45; if(dl_2==dm6)rg4=0; if(dl_2==dm7)rg4=-45; if(dl_2==dm8)rg4=-90; }
    else if (dl_1==dm3) { if(dl_2==dm5)rg4=90; if(dl_2==dm6)rg4=45; if(dl_2==dm7)rg4=0; if(dl_2==dm8)rg4=-45; if(dl_2==dm9)rg4=-90; }
    else if (dl_1==dm4) { if(dl_2==dm6)rg4=90; if(dl_2==dm7)rg4=45; if(dl_2==dm8)rg4=0; if(dl_2==dm9)rg4=-45; if(dl_2==dm2)rg4=-90; }
    else if (dl_1==dm5) { if(dl_2==dm7)rg4=90; if(dl_2==dm8)rg4=45; if(dl_2==dm9)rg4=0; if(dl_2==dm2)rg4=-45; if(dl_2==dm3)rg4=-90; }
    else if (dl_1==dm6) { if(dl_2==dm8)rg4=90; if(dl_2==dm9)rg4=45; if(dl_2==dm2)rg4=0; if(dl_2==dm3)rg4=-45; if(dl_2==dm4)rg4=-90; }
    else if (dl_1==dm7) { if(dl_2==dm9)rg4=90; if(dl_2==dm2)rg4=45; if(dl_2==dm3)rg4=0; if(dl_2==dm4)rg4=-45; if(dl_2==dm5)rg4=-90; }
    else if (dl_1==dm8) { if(dl_2==dm2)rg4=90; if(dl_2==dm3)rg4=45; if(dl_2==dm4)rg4=0; if(dl_2==dm5)rg4=-45; if(dl_2==dm6)rg4=-90; }
    else if (dl_1==dm9) { if(dl_2==dm3)rg4=90; if(dl_2==dm4)rg4=45; if(dl_2==dm5)rg4=0; if(dl_2==dm6)rg4=-45; if(dl_2==dm7)rg4=-90; }
    
    
     //if (dl_2==dm2) { if(dl_1==dm4)rg4=90; if(dl_1==dm5)rg4=45; if(dl_1==dm6)rg4=0; if(dl_1==dm7)rg4=-45; if(dl_1==dm8)rg4=-90; }
     //else if (dl_2==dm3) { if(dl_1==dm5)rg4=90; if(dl_1==dm6)rg4=45; if(dl_1==dm7)rg4=0; if(dl_1==dm8)rg4=-45; if(dl_1==dm9)rg4=-90; }
     //else if (dl_2==dm4) { if(dl_1==dm6)rg4=90; if(dl_1==dm7)rg4=45; if(dl_1==dm8)rg4=0; if(dl_1==dm9)rg4=-45; if(dl_1==dm2)rg4=-90; }
     //else if (dl_2==dm5) { if(dl_1==dm7)rg4=90; if(dl_1==dm8)rg4=45; if(dl_1==dm9)rg4=0; if(dl_1==dm2)rg4=-45; if(dl_1==dm3)rg4=-90; }
     //else if (dl_2==dm6) { if(dl_1==dm8)rg4=90; if(dl_1==dm9)rg4=45; if(dl_1==dm2)rg4=0; if(dl_1==dm3)rg4=-45; if(dl_1==dm4)rg4=-90; }
     //else if (dl_2==dm7) { if(dl_1==dm9)rg4=90; if(dl_1==dm2)rg4=45; if(dl_1==dm3)rg4=0; if(dl_1==dm4)rg4=-45; if(dl_1==dm5)rg4=-90; }
     //else if (dl_2==dm8) { if(dl_1==dm2)rg4=90; if(dl_1==dm3)rg4=45; if(dl_1==dm4)rg4=0; if(dl_1==dm5)rg4=-45; if(dl_1==dm6)rg4=-90; }
     //else if (dl_2==dm9) { if(dl_1==dm3)rg4=90; if(dl_1==dm4)rg4=45; if(dl_1==dm5)rg4=0; if(dl_1==dm6)rg4=-45; if(dl_1==dm7)rg4=-90; }
    
    table_4[index]=rg4;
     
    // в основнрй функции
     uint LengthLine90;  // длинна фокальной линии состоящая только из ортогональных pix.
     uint LengthLine45;  // длинна фокальной линии состоящая только из диаганальных pix.
     LengthLine90=1; LengthLine45=0; // первый pix особая точка // подумать почему LengthLine45=0 // SumLengthLine++;
     
     // длинна фокальной линии состоящая только из ортогональных и диагональных pix.
     if ( dl_nl==1||dl_nl==-1||dl_nl==w||dl_nl==-w ) LengthLine90++;  else LengthLine45++; // (параметр функции focalLineRecDirect1)
     
     // Длинна фокальной линии состоящая только из ортогональных и только диагональных pix.
     // Параметр функции focalLineRecDirect1 и focalLineRecCircle2
     if ( dl0==1||dl0==-1||dl0==w||dl0==-w ) LengthLine90++; else LengthLine45++;
     
     //  Переменные для подпрограммы подсчета тангенциального угла:
     //int angl_t; // среднее значение тангенциального угла при движении вдоль одной фокальной линии.
     ///       int sign;   // знак тангенциального угла при движении вдоль одной фокальной линии равен +1 или -1.
     // Вычисление среднего значения тангенциального угла при движении вдоль одной фокальной линии.
     
     // dl2 и dl1 величины смещения маски по входящим или выходящим точкам пересечения фокальные линии с маской. //
     
     // координаты маски в следующей итерации в абсолютной линейной системе координат.
     if ( sl+dl1==sl_old ) { sl+=dl2; p0+=dl2; dl0=dl2; sign=-1;}  // это следующая стартовая точка.
     if ( sl+dl2==sl_old ) { sl+=dl1; p0+=dl1; dl0=dl1; sign=1;}   // или эта
     
     angl_t=0; // среднее значение тангенциального угла при движении вдоль одной фокальной линии.
     angl_t+=sign*table_4[rg0];
    */
    //--------------------------------------------------------------------------------------------------------------------------
    
    }//____________________________________________________________________________
    

    
    //*****************************************************************************
    
                /// Базовая версия - buildOCRAlphaTable() ///
    
    // Функция построения таблиц, использается для вычисления коэффициента корреляции уголов векторов.
    // Предназначена для построения таблиц, необходимых для функции сравнения двух кривых Безье CorrelationBezierA, (B).
    
    void GGraph::buildOCRAlphaTable(){
        
        // Функция создает 2 предпросчитанные таблици (заполняет 2 глобальных массива float ):
        // - таблицу для вычисления коэффициента корреляции уголов векторов tabAlpha_1. //
        // - таблицу для вычисления коэффициента корреляции уголов векторов tabAlpha_2. //

        // Вычисление коэффициента корреляции по предпросчитанным таблицам д.б. быстрее,
        // чем просчитывать коэффициента корреляции в теле основного цикла.

        
        
        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев и графиков)  if (GrafT) {  }
        if (GrafT) {
            cout<<endl<<"-----------------------------------------------------------------------------------"<<endl;
            cout<<"Функция построения таблиц для вычисления коэффициента корреляции уголов   buildOCRAlphaTable() "<<endl<<endl;
        }
        
        
        /// вспомогательные переменные.
        float deltaAlpha;   // Абсолютное значение разности углов между двух векторов.
        float CorAlpha;     // Коэффициент корреляции углов между векторами кривых Безье N1 и N2.
        float nr111=1.11111111; // 100.0/90.0
        // CorAlphaL=100-100*deltaAlpha/90;
        
        // Массивы для хранения таблиц коэффициента корреляции уголов глобальный и объявлен в GBitmap.h.
        //float tabAlpha_1[361];  // м.б. глобальным массивом.


        // Создание предпросчитанной таблицы коэффициента корреляции уголов tabAlpha_1. //
        // Цикл перебора всех возможных значений разностей входных углов.
        for (int index=0; index < 361; index++){

            // Абсолютное значение разности углов двух опорных линий.
            deltaAlpha=index;   // deltaAlpha=fabs(line1_alpha-line2_alpha);
            // Находим наименьший угол (<90°) между опорными линиями кривых Безье N1 и N2.
            if (deltaAlpha>180) deltaAlpha=360-deltaAlpha;
            
            // Коэффициент корреляции двух линий по углам. Без знаковый или знаковый.
            
            // разности углов: 0° 90° 180° 270° 360°, соответствует коэффициент корреляции: 100%  0  100%  0  100%.
            if (deltaAlpha>90) deltaAlpha=180-deltaAlpha;
            CorAlpha=100-nr111*deltaAlpha;
            /**/
            /*
            // разности углов: 0° 90° 180° 270° 360°, соответствует коэффициент корреляции: 100%  0 -100%  0  100%.
            if (deltaAlpha>90) {
                deltaAlpha=180-deltaAlpha; CorAlpha=-100+nr111*deltaAlpha;
            }  else {
                CorAlpha=100-nr111*deltaAlpha;
            }
            */

            tabAlpha_1[index]=CorAlpha;
            if(GrafT) {
                cout<<"Alpha="<< index<<"    Разность углов"<<"  deltaAlpha="<< deltaAlpha
                <<"    Коэффициент корреляции углов между векторами  CorAlpha="<<CorAlpha<<"%"<<endl<<endl;
            }
            
        } // for (index
        // Используется без знаковый коэффициент корреляции двух линий по углам, как не чуствительный к реверсу.
        
        
        // Без знаковый коэффициент корреляции двух линий по углам.
        //
        //  100%   *           *           *
        //           *       *   *       *
        //             *   *       *   *
        //   0%          *           *
        //
        //         0°   90°   180°  270°  360°
        
        
        // Знаковый коэффициент корреляции двух линий по углам.
        //
        //  100%   *                       *
        //           *                   *
        //             *               *
        //   0%          *           *
        //                 *       *
        //                   *   *
        // -100%               *
        //         0°   90°   180°  270°  360°

        
        /**/
        ///tabAlpha_1[index]=0; // заполнение таблиц нулями

        
    }//____________________________________________________________________________
    

    
 
}; //____________________________________________________________________________
    
    
 


