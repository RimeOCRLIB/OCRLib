// C-
// C- This software is subject to, and may be distributed under, the
// C- GNU General Public License, either Version 2 of the license,
// C- or (at your option) any later version. The license should have
// C- accompanied the software or you may obtain a copy of the license
// C- from the Free Software Foundation at http://www.fsf.org .
// C-
// C- This program is distributed in the hope that it will be useful,
// C- but WITHOUT ANY WARRANTY; without even the implied warranty of
// C- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// C- GNU General Public License for more details.
// C-
/*  Implemmentation  to GMemoryLib dynamic library  */

#include "OCRLib.h"
#include "../libocr/config.h"
#include <algorithm>
#include <errno.h>
#include <fcntl.h>
#include <sstream>
#include <stdio.h>
#include <string>
#include <sys/mman.h>
#include <sys/time.h>
#include <sys/types.h>
#include <vector>
#ifdef MACOS
   #include <malloc/malloc.h>
#endif

#include "../libocr/OCRTypes/OCRTypes.h"
#include "../libocr/GFontEditor/GFontEditor.h"
#include "../libocr/GImageEditor/GImageEditor.h"
#include "../libocr/GLogicProcessor/GLogicProcessor.h"
#include "../libocr/GMainEditor/GMainEditor.h"
#include "../libocr/GMemory/GMemory.h"
#include "../libocr/OCRString/php2stl.h"

#ifdef ESP
   #include "esp_command.h"
#endif

//#define DB_NAME "LIBRARY_CATALOG"
//#define DB_NAME "DHARMABOOK"

using namespace std;

#ifdef MAGICK
   #include <Magick++.h>
   using namespace Magick;
#endif

    //*****************************************************************************

    // эта версия перенесена в основную программу, 22 сентября 2019. //

    /*/
     ИЗМЕНЕНИЯ 9 апреля по 27 апреля 2019

     // Функция определения угла наклона текста с помощью быстрого преобразования
     Радона. maxAngle=7; //=7 компромисная величина максимально возможного
     определяемого угла в градусах.

     // Двухпороговая функция преобразования серого массива в битовый массив
     (адаптивный порог). // Если Tr2>1, то выполняем binarisationM, иначе
     binarisationF. // Изменена binarisationM

     // Функция реставрации сильно поврежденных штрихов букв с уменьшенным числом
     парамметров.
     // gHor=1 добавляет 1pix по горизонтали,  gVer=1 добавляет 1pix по вертикали
     (-1 убавляет).
     //int gHor1=0, gVer1=0, gHor2=0, gVer2=0;   // gHorizontal1, gVertical1,
     gHorizontal2, gVertical2;
     //*/

    // Функция комплексной обработки графического текста.
    void *imageAdaptiveFiltration(void *img_) {
        // Перепродумать это описание функции, д.б. много шире. //

        // задачи.
        // Функция получает на вход серый (цветной) графический текст. Иногда
        // технически низкого качества, а именно: шумы на светлом фоне - шумовые
        // точки, мусор. шумы на темном фоне - дырки и разрывы штрихов, вплоть до
        // распада штрихов на отдельные точки. сплошной шумовой серый или цветной фон.
        // низкий динамический диапазон яркостей графического текста, вплоть до потери
        // частей штрихов. низкое исходное разрешение текстов. не оправдано высокое и
        // не нужное исходное разрешение текстов. грубая бинаризация для ч.б.текстов
        // на малое число pix. сильно зашумленные контура для ч.б текстов из-за не
        // качественной бинаризации.

        // Возможны различные Афинные деформации текстов, а именно:
        // поворот.
        // продольный изгиб для для вытянутых по горизонтали текстов.

        // На выходе функциии получаем оптимально обработанный и бинаризованный
        // графический текст для дальнейшего распознования.

        int GrafT=0;  // 1 - вывод отладочной информации (цифр, таблиц, комментариев
                        // и графиков)

        TIME_START
        
        GBitmap *img=GBitmap::create((GBitmap *)img_);

        //----------------------------------------------------------------------------------------------------------------

        // ОБЩИЕ ЗАМЕЧАНИЯ.
        // Для всех функций: если параметр функции нулевой, то она не запускается.
        // Кроме lineH=0, которое запускает автоматическое определение высоты строки.

        // РАСШИРЕННЫЙ (ПОЛНЫЙ) НАБОР ПАРАМЕТРОВ запуска функции. Все параметры не
        // активные //

        float lineH=0;  // "0" (исключение) запускает автоматическое измерения высоты строки.
        // Если lineH>1, то высоту строки можно примерно оценить и задать вручную,
        // например lineH=24. lineH м.б. модифицированна функцией грубого
        // предварительного уменьшения размеров больших файлов и основной функцией
        // масштабирования. pageStringDetector   // Функция выделения строк,
        // вычисление средней высоты строки в pix по всему битмапу.

        float lineH_St=31.3;  // стандартная (желательная) высота строки в pix.
                                // Изменять только синхронно с lineH_St в JavaScript
        // bicubicGrayScale();  // Функция бикубического масштабирования в верх.
        // bilinearScale();     // Функция билинейного масштабирования в низ. По
        // необходимости запускается вместо bicubicGrayScale.

        // БЛОК ФУНКЦИЙ ДЛЯ ПРЕДВАРИТЕЛЬНОЙ НОРМИРОВКИ ИЗОБРАЖЕНИЙ. //

        // bilinearScale        // Функция грубого предварительного уменьшения
        // размеров больших файлов до 10048 pix
        int negative=0;  // > 0 Функция определения и инверсии негативного
                           // изображения в сером графическом тексте.
        // memcpy(bytes_data_1, bytes_data, w_h); // Сохранение исходной картинки
        // bytes_data.

        // БЛОК ФУНКЦИЙ N1 ДЛЯ ПОВОРОТА ИЗОБРАЖЕНИЙ И ВЫЧИСЛЕНИЯ СРЕДНЕЙ ВЫСОТЫ СТРОКИ
        // //

        int maxAngle=7;  //=7 компромисная величина максимально возможного
                           // определяемого угла в градусах.
        // Чем больше максимально возможный определяемый угол maxAngle, тем прямо
        // пропорционально ниже быстродействие. При maxAngle=7 градусов это доли
        // секунды, при maxAngle=45 градусов уже секунды. detectPageAngle(maxAngle) //
        // Функция измерения угла наклона текста N1. rotateFast(rotation)         //
        // Вращение битовой картинки на измереннай угол rotation. pageStringDetector()
        // // Вычисление средней высоты строки по всему тексту.
        // memcpy(img->bytes_data, bytes_data_1, w_h); // Восстановление bytes_data.
        // Получение не поврежденной поворотом картинкой.

        // БЛОК ФУНКЦИЙ N2 ДЛЯ МАСШТАБИРОВАНИЯ И ПОВОРОТА ИЗОБРАЖЕНИЙ //
        // с опорой на высоту строки на первом прогоне и с опорой на Тибетскую букву
        // "B" и на втором прогоне.

        // bicubicGrayScale(scale2); или bilinearScale(scale2) // Масштабирование
        // исходной (не поврежденной поворотом) картинки. detectPageAngle(maxAngle) //
        // Функция измерения угла наклона текста N2. BilinearGrayRotate(rotation) //
        // Вращение битовой картинки на измереннай угол rotation.

        // ОБЩИЙ БЛОК ФУНКЦИЙ ДЛЯ ОБРАБОТКИ И КОРРЕКЦИИ СЕРОГО И Ч.Б. ИЗОБРАЖЕНИЯ //

        // Функции размытия (blur) N1, применяется до бинаризации. Выбираем
        // FilterIntegral или gaussianF.
        int FilterIntegral1=0;  //=4 восстановление поврежденных штрихов, не большая
                                  // фильтрация белого шума.
        // FilterIntegral(FilterIntegral1)
        int FilterGauss1=0;  //=3 восстановление сильно поврежденных штрихов
                               // (медленнее в 3 раза чем FilterIntegral).
        // gaussianF(FilterGauss1)

        // DetectGradations     // Автоопределение наличие серого или черно-белого в
        // битмапе. // time=0.006 crop32               // Функция нормализации массива
        // bytes_data по размеру ncolumns кратным 32.//

        // Двухпороговая функция преобразования серого массива в битовый массив
        // (адаптивный порог). // Если Tr2>1, то выполняется binarisationM, иначе
        // binarisationF. binarisationM(Tr1, Tr2, BASE) binarisationF(Tr1, BASE)
        int BASE=14;  //=14 Размер области BASE*BASE по которой вычисляется среднея
                        //яркость для вычисления адаптивного порога.
        // Tr - число процентов, от этого вычисленного адаптивного порога. Оптимально
        // BASE=14 и мало влияет на результат (по старому BASE=4).
        int Tr1=98;  //=98 Обычно Tr1=92-98, оптимально 98. Если Tr1 выбирать меньше
                       //- то получаются более тонкие линии (штрихи),
        // если Tr1 больше - более толстые линии и бледные штрихи лучше проработаны.
        // Однако при максимальном увеличении Tr1 близким к 98 вместе с лучшей
        // проработкой бледных и тонких штрихов проявляется шумовой мусор от фона. По
        // этому становится необходим Tr2.
        int Tr2=92;  //=92 Для отсечения шумового мусора применяется порог Tr2.
                       //Обычно Tr2 выбирают в диапазоне
        // 76-92 (оптимально 92), по минимому фоновых шумов. Здесь и происходит
        // основная фильтрация шума. Если Tr2>1, то выполняется binarisationM, иначе
        // binarisationF.

        // variationBorder(t, bord) // Создание белого бордюра шириной в 4 pix по
        // всему периметру графического текста.

        // Основное удаляние шумовых черных структур размер 1-2 pix  1<dlt<4. Правда
        // при этом удаляются и мелкие детали.
        int dltNoise=0;  //=2
        // dotGain( 0, 0, 0, 0, -dlt);   dotGain(0, 0, 0, 0, dlt);
        // dltNoise=1 // убираем 1pix*1pix точки, 1pix вертикальные и горизонтальные
        // линии. Применять осторожно. dltNoise=2 // убираем 1pix*1pix и 2pix*2pix
        // точки, 1pix и 2pix вертикальные и горизонтальные линии.

        // Функция реставрации сильно поврежденных штрихов букв.
        // Может закрывать  1-2 pix дырки и разрывы в черном. Может удалять 1-2 pix
        // точки и детали (линии).
        int gHor1=0, gVer1=0, gHor2=0, gVer2=0;  // gHorizontal1, gVertical1, gHorizontal2, gVertical2;
        // gHor=1 добавляет 1pix по горизонтали,  gVer=1 добавляет 1pix по вертикали
        // (-1 убавляет). Примеры фильтров: gHor1=1,  gVer1=0,  gHor2=0,  gVer2=0; //
        // утолщение по горизонтали. gHor1=-2, gVer1=-2,  gHor2=2,  gVer2=2;  //
        // убираем 2pix*2pix точки, 2pix вертикальные и горизонтальные линии gHor1=2,
        // gVer1=2,   gHor2=-2, gVer2=-2; // закрываем 2pix*2pix (и меньшие) дырки в
        // черном.

        // Функция выравнивания толщины штриха с помощью удаляемых-дабавляемых слоев.
        // Это не быстрая и редко применяемая функция. Замедляется при наличии
        // пиксельных шумов. Однако сохраняет шумовые точки и затем увеличивает их в
        // размере.
        int n_RemovLayers=0;  //=1 число удаляемых (аккуратно удаляемых, с
                                // сохранение 1 pix конструкций) и дабавляемых слоев.
        // focalLine(n_RemovLayers); dotGain(0, 0, 0, 0, n_RemovLayers*2);

        // Функции размытия (blur) N2, применяется после бинаризации. Выбираем
        // FilterIntegral или gaussianF.
        int FilterIntegral2=0;  //=4 восстановление поврежденных штрихов, не большая
                                  // фильтрация белого шума.
        // FilterIntegral(FilterIntegral2)
        int FilterGauss2=0;  //=3 восстановление сильно поврежденных штрихов
                               // (медленнее в 3 раза чем FilterIntegral).
        // gaussianF(FilterGauss2)
        // binarisationF(Tr1, BASE); // Адаптивная функция N2 преобразования серого
        // массива в ч.б.

        // Функция автоматического переформирования Тибетского графического текста по
        // вертикали.
        int Orient=0;  //=1 вертикальное зеркальное отражение графического текста,
                         //=2 поворот текста на +180°.
        // textVerticalRotation( Orient, &lnOrient, &lnHeight )

        //---------------------------------------------------------------------------------------------------------------

        /*
         // БАЗОВЫЙ НАБОР ПАРАМЕТРОВ для предобработки технически качественных
         графических текстов //

         // Основная функция преобразования серого массива в битовый массив
         (адаптивный порог). //
         // Если Tr2>1, то выподняем binarisationM, иначе binarisationF.
         BASE=14; //=14 Размер области BASE*BASE по которой вычисляется среднея
         яркость для вычисления адаптивного порога.
         // Tr - число процентов, от этого вычисленного адаптивного порога. Оптимально
         BASE=14 и мало влияет на результат (по старому BASE=4). Tr1=98;  //=98 Обычно
         Tr1=92-98, оптимально 98. Если Tr1 выбирать меньше - то получаются более
         тонкие линии (штрихи),
         // если Tr1 больше - более толстые линии и бледные штрихи лучше проработаны.
         Однако при максимальном увеличении Tr1 близким к 98
         // вместе с лучшей проработкой бледных и тонких штрихов проявляется шумовой
         мусор от фона. По этому становится необходим Tr2. Tr2=92;  //=92 Для
         отсечения шумового мусора применяется порог Tr2. Обычно Tr2 выбирают в
         диапазоне 76-92 (оптимально 92).
         // по минимому фоновых шумов. Здесь и происходит основная фильтрация шума.
         //*/

        //---------------------------------------------------------------------------------------------------------------

        // Инициализация параметров значениями переданными GUI,
        // общие управляющие переменные.

        if(inputData.data["ocrData"] !="") {
            string maxAngle_=inputData.data["maxAngle"];
            string lineH_=inputData.data["lineH"];
            string lineH_St_=inputData.data["lineH_St"];
            string negative_=inputData.data["negative"];
            string FilterGauss1_=inputData.data["FilterGauss1"];
            string FilterIntegral1_=inputData.data["FilterIntegral1"];
            string Tr1_=inputData.data["Tr1"];
            string Tr2_=inputData.data["Tr2"];
            string BASE_=inputData.data["BASE"];
            string dltNoise_=inputData.data["dltNoise"];
            string gHor1_=inputData.data["gHor1"];
            string gVer1_=inputData.data["gVer1"];
            string gHor2_=inputData.data["gHor2"];
            string gVer2_=inputData.data["gVer2"];
            string dGain1_=inputData.data["d_gain1"];
            string dGain2_=inputData.data["d_gain2"];
            string n_RemovLayers_=inputData.data["n_RemovLayers"];
            string FilterGauss2_=inputData.data["FilterGauss2"];
            string FilterIntegral2_=inputData.data["FilterIntegral2"];
            string Orient_=inputData.data["Orient"];
            string mode=inputData.data["mode"];

            if(maxAngle_ !="") maxAngle=atoi(maxAngle_.c_str());
            if(lineH_ !="") lineH=(float)atoi(lineH_.c_str())/1000;
            if(lineH_St_ !="") lineH_St=atoi(lineH_St_.c_str());
            if(negative_ !="") negative=atoi(negative_.c_str());
            if(FilterGauss1_ !="") FilterGauss1=atoi(FilterGauss1_.c_str());
            if(FilterIntegral1_ !="") FilterIntegral1=atoi(FilterIntegral1_.c_str());
            if(Tr1_ !="") Tr1=atoi(Tr1_.c_str());
            if(Tr2_ !="") Tr2=atoi(Tr2_.c_str());
            if(BASE_ !="") BASE=atoi(BASE_.c_str());
            if(dltNoise_ !="") dltNoise=atoi(dltNoise_.c_str());
            if(gHor1_ !="") gHor1=atoi(gHor1_.c_str());
            if(gVer1_ !="") gVer1=atoi(gVer1_.c_str());
            if(gHor2_ !="") gHor2=atoi(gHor2_.c_str());
            if(gVer2_ !="") gVer2=atoi(gVer2_.c_str());
            if(dGain1_ !="0" && dGain1_ !="") {gHor1=atoi(dGain1_.c_str()); gVer1_=atoi(dGain1_.c_str());}
            if(dGain2_ !="0" && dGain2_ !="") {gHor2=atoi(dGain2_.c_str()); gVer2_=atoi(dGain2_.c_str());}
            if(n_RemovLayers_ !="") n_RemovLayers=atoi(n_RemovLayers_.c_str());
            if(FilterGauss2_ !="") FilterGauss2=atoi(FilterGauss2_.c_str());
            if(FilterIntegral2_ !="") FilterIntegral2=atoi(FilterIntegral2_.c_str());
            if(Orient_ !="") Orient=atoi(Orient_.c_str());
        }

        //----------------------------------------------------------------------------------------------------------------

        // ПОЛНЫЙ НАБОР ПАРАМЕТРОВ ПОЛУЧЕННЫХ ОТ ИНТЕРФЕЙСА.
        // Технически качественный текст использует автоматически получаемые параметры
        // и параметы по умолчанию. Технически поврежденный текст требует рестоврации
        // и задания 5-12 ручных параметров, из них 4-10 dotGain.

        // Путь файла.
        // 00 inputPath="/_Image2OCR/___WORK_DATA/_TEST_BINARY/__sl1_704x352.jpg";

        // 01 float lineH=0          // "0" (исключение) запускает автоматическое
        // измерения высоты строки. Если lineH>1,
        // то высоту строки можно измерить и задать вручную, например lineH=24 и она
        // также автоматически смасштабируется до 32.

        // 02 int negative=0;        // > 0 Функция определения и инверсии негативного
        // изображения в сером графическом тексте.

        // 03 int FilterIntegral1=0; //=6 параметр размытия (blur) N1 массива
        // bytes_data. Выбираем FilterInt или gaussianF. 04 int FilterGauss1=0;    //
        //=3 параметр размытия (blur) N1 массива bytes_data (медленнее в 3 раза чем
        // FilterIntegral).

        //  Основная адаптивная функция преобразования серого массива в битовый
        //  массив. //
        // 05 int BASE=14; //=14 Оптимально BASE=14 и мало влияет на результат (по
        // старому BASE=4). 06 int Tr1=98;  //=98 Обычно Tr1=92-98, оптимально 98. При
        // максимальном увеличении Tr1 близким к 98 проявляется шумовой мусор от фона.
        // 07 int Tr2=92;  //=92 Для отсечения шумового мусора применяется порог Tr2.
        // Обычно Tr2 выбирают в диапазоне 76-92 (оптимально 92)
        // Если Tr2>1, то выподняем binarisationM, иначе binarisationF.

        // 08 int dltNoise=0;    //=2 основное удаляние шумовых черных структур
        // размера в 1-2 pix,  1<dlt<4.

        // Функция реставрации сильно поврежденных штрихов букв.
        // 09-12 int gHor1=0, gVer1=0, gHor2=0, gVer2=0; //=1 добавляет 1pix по
        // горизонтали (вертикали),=-1 убавляет.

        // Функция выравнивания толщины штриха с помощью удаляемых-дабавляемых слоев.
        // 13 int n_RemovLayers=0; //=1 число удаляемых и дабавляемых слоев.
        // Выравнивание толщины штриха (запускается медленная focalLine).

        // 14 int FilterIntegral2=0; //=6 параметр размытия (blur) N2 массива
        // bytes_data. Выбираем FilterInt или gaussianF. 15 int FilterGauss2=0;    //
        //=3 параметр размытия (blur) N2 массива bytes_data (медленнее в 3 раза чем
        // FilterIntegral).

        // 16 int Orient=0;          //=1 вертикальное зеркальное отражение
        // графического текста,=2 поворот текста на +180°.

        //----------------------------------------------------------------------------------------------------------------

        //*/

        //----------------------------------------------------------------------------------------------------------------

        // обычный вызов, для отладки отдельных функций. //

        //*******************************************************************

        // img-> optimizationSkew(8);
        // img-> variationBorder(0, 2);
        // img-> eraseBorder(2, 2);
        // img-> VerticalMirror();
        // img->crop32();
        // img-> binarisationM(99, 92, 14);
        // int lnOrient_=0;
        // int lnHeight_=0;
        // img->textVerticalRotation( &lnOrient_, &lnHeight_ );
        // img->BilinearGrayRotate(5.0); //double angle
        // img->textNegative();
        /// return (void*)img;

        //----------------------------------------------------------------------------------------------------------------

        if(GrafT) {
            cout<<"// Функция комплексной обработки графического текста "
                    "imageAdaptiveFiltration //."<<endl;
        }

        // конкретные значения этих вспомогательных параметров задаются в самой
        // функции, в нескольких местах.

        int   flagL=0;      // флаг управления набором функций flagL=0 это первый прогон,
                            // flagL=1 второй прогон.
        uint  bord;         // ширина бордюра 2.
        uint  t;            // цвет бордюра, 255 белое.
        int   graduation;   // параметр наличия серого или черно-белого в битмапе.
        float rotation=0;   // угол поворота текста в градусах.
        float scale1;       // масштаб функции предварительного уменьшения размеров больших
                            // файлов.
        float scale2;       // масштаб основной функции.
        float Df;           // среднея толщина штриха по всей исходной картинке.
        int   lnOrient=0;   // Возвращает параметр вертикальной ориентации от функции
                            // вертикального поворота.
        int lnHeight=0;     // Возвращает оценку средней высоты строки от функции
                            // вертикального поворота.

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // lineH приходит с интерфейса и по умолчанию lineH=0 это первый прогон, и
        // если находотся в рабочем диапазоне - второй прогон.
        if(lineH > 1.0 && (lineH < 4.0 || lineH > 256.0))
            lineH=0;  // Ограничение высоты строки полученной от интерфейса.
        // lineH это float, поэтому никогда не проверяем lineH==0;

        // флаг управления набором функций flagL=0 это первый прогон, flagL=1 второй
        // прогон.
        if(lineH <=1.0)
            flagL=0;
        else
            flagL=1;
        if(GrafT) cout<<"  lineH="<<lineH<<"  flagL="<<flagL<<endl;

        // На первом прогоне flagL=0 определяется высота строки (средне по всем
        // строкам) lineH=(float)DeltaNstrI. С помощью масштаба scale1*scale2
        // полученная высота строки lineH=lineH_St/(scale1*scale2); приводится к
        // lineH_St=31.3; pix. Первый прогон подготавливает графическую картинку
        // текста к ручному измерению на втором прогоне. На втором прогоне flagL=1 на
        // уровне интерфейса на JavaScript вручную определяется высота Тибетской буквы
        // "B" которая передается на вход данной функции и аналогичным способом
        // приводится к lineH_St=31.3; pix. Измеренная вручную высота Тибетская буква
        // "B" позволяет более точно смасштабировать текст для дальнейшего
        // распознавания, чем высота высоты строки полученная автоматически с помощью
        // функции pageStringDetector. "Вручную" высота Тибетской буквы "B" измеряется
        // графически с помощью специальной интерфейсной функции написанной на
        // JavaScript.

        // Функции которые не работают на втором прогоне:
        // bilinearScale(scale1)
        // textNegative // работает на всех прогонах
        // memcpy(bytes_data_1, img->bytes_data, w_h);
        // detectPageAngle(maxAngle); N1
        // rotateFast(rotation); N1
        // pageStringDetector(strArray,1)
        // memcpy(img->bytes_data, bytes_data_1, w_h);

        // БЛОК ФУНКЦИЙ ДЛЯ ПРЕДВАРИТЕЛЬНОЙ НОРМИРОВКИ ИЗОБРАЖЕНИЙ. //

        //*
        // Функция грубого предварительного уменьшения размеров больших файлов.
        // Ограничения необходимы для массива интегральных сумм выполенном на uint.
        int w=img->columns();  // ширина массива   IMAGE_WIDTH.
        int h=img->rows();     // высота массива   IMAGE_HEIGHT.
        int w_h=w * h;           // размер массива   IMAGE_SIZE
        // ограничение максимального линейного размера в 10 048 pix по наибольшей из
        // сторон.
        float maxL=10048;  // максимальный линейный размер любой стороны картинки pix
                             // (maxL за одно кратно 64).
        float scale_L=maxL/h;  // масштаб, если картинка высокая.
        if(w > h) scale_L=maxL/w;  // масштаб, если картинка длинная.
        // ограничение максимально возможной площади картинки величиной в 25 000 000
        // pix. Реальный предел не менее 115 000 000.
        float scale_S=sqrt((float)25000000/w_h);  // масштаб ограничивающий максимальную
                                                      // площадь картинки 5 000*5 000 pix.
        // минимум из scale_L и scale_S.
        if(scale_S < scale_L)
            scale1=scale_S;
        else
            scale1=scale_L;
        // Практические измерения для картинки __page_0011.jpg  с размерами w=24960
        // h=4620 scale1=0.4 порог 0.45 белое "255"  w=9984, h=1848 scale1=0.4  // 1.0
        // порог 1.0 белое "0" w=24960 h=4620 scale1=1.0
        /// if (GrafT) cout<<"  w="<<w<<"  h="<<h<<"  scale_L="<<scale_L<<"
        /// scale_S="<<scale_S<<"  scale1="<<scale1<<endl;
      

        // если масштаб меньше единицы, то запускаем билинейное масштабирование в низ.
        if(flagL < 1 && scale1 < 1.0) {
            img->bilinearScale(scale1);
            lineH=lineH * scale1;  // модификация высоты строки после предварительного
                                     // уменьшения размеров больших файлов.
            if(GrafT) {
                cout<<"||Функция грубого предварительного уменьшения размеров больших "
                        "файлов до 10048 pix, масштаб="
                    <<scale1<<endl;
                cout<<"  w="<<w<<"  h="<<h<<"  img->columns()="<<img->columns()
                    <<"  img->rows()="<<img->rows()<<"  scale1="<<scale1<<endl;
            }
        } else
            scale1=1.0;

        // img->bicubicGrayScale(2.0); // если высота строки меньше 8 pix, то высота
        // строки на первом прогоне отределится не правильно и только на втором
        // прогоне, после ручного определения высоты Тибетской буквы "B", исходная
        // картинки попадет в правильный размер 32 pix. Или после принудительного
        // задания высоты строки

        // Функция определяет и ивертирует негативное изображение в сером графическом
        // тексте. time=0.05
        if(negative > 0) {  // (flagL<1 && negative>0)
            int ng=img->textNegative();
            if(GrafT) {
                cout<<"||Функция определения и инверсии негативного изображения в "
                        "сером графическом тексте. Инверсия="<<ng<<endl;
            }
            if(ng > 0) cout<<"  Выполнена инверсия негативного изображения."<<endl;
        }

        // Сохранение исходной картинки bytes_data.
        GBitmap *imgCopy=NULL;  // инициализация переменной
        if(flagL < 1) imgCopy=GBitmap::create(img);

        // БЛОК ФУНКЦИЙ N1 ДЛЯ ПОВОРОТА ИЗОБРАЖЕНИЙ И ВЫЧИСЛЕНИЯ СРЕДНЕЙ ВЫСОТЫ СТРОКИ
        // //

        // Блок функций N1 для определения угла наклона текста и поворота изображений.
        // // Использается только для определения средней высоты строки. Перед
        // функцией определения угла наклона текста нельзя ставить функцию создания
        // белого бордюра.//
        if(flagL < 1 && maxAngle) {
            // Если перед -maxAngle поставить минус, то на выходе функции останется
            // бинаризованная bytes_data, что полезно для функции вычисления высоты
            // строки.
            rotation=img->detectPageAngleB(-maxAngle,
                                             Tr1,
                                             BASE);  // угол поворота текста в градусах.
            // По умолчанию максимально возможный определяемый угол в градусах
            // maxAngle=7.
            if((maxAngle * GrafT) > 0)
                cout<<"|Функция  N1 определения угла наклона текста  detectPageAngleB  "
                        "rotation="<<rotation<<endl;
            // Вращение битовой картинки на угол rotation. Коррекция угла наклона
            // текста.
            if(fabs(rotation) >=0.05) {
                img->rotateFast(rotation);
                // img->BilinearGrayRotate((double)rotation);
                if(GrafT > 0)
                    cout<<"|Вращение N1 битовой картинки rotateFast(rotation) на угол "
                            "rotation="<<rotation<<endl;
            }
        }
        // return (void*)img;

        // Вычисление средней высоты строки по всему тексту. //
        if(flagL < 1) {  // предусмотрен ручной ввод масштаба // lineH<1.0
            GBitset *         setBit=GBitset::createResize(img, 1, 1, 1);
            vector<stringOCR> strArray;
            setBit->pageStringDetector(strArray,
                                       1);  // Подпрограмма выделения строк pageStringDetector.
            int DeltaNstrI=setBit->DeltaNstr;  // Получили среднею высоту строки из
                                                 // глобальной переменной DeltaNstr.
            lineH=(float)DeltaNstrI;
            if(lineH < 4.0) lineH=4.0;
            if(lineH > 256.0) lineH=256.0;
            if(GrafT)
                cout<<"|Функция выделения строк, средняя высота строки в pix по всему "
                        "битмапу lineH="<<lineH<<endl;
        }
        // Можно получить среднею высоту строки прямо здесь. Вычисленная, с учетом
        // статистики, высота каждой строки по отдельности. DeltaNstr=
        // strArray[0][Nstr].y1-strArray[0][Nstr].y0; cout<<"  lineH="<<lineH<<endl;

        // Восстановление bytes_data. Получение не поврежденной поворотом картинки.
        if(flagL < 1) {
            img->destroy();
            img=imgCopy;
            if(GrafT)
                cout<<"|Восстановление не поврежденной поворотом картинки из bytes_data"<<endl;
        }
        // отдельно проверить освобождение памяти

        // БЛОК ФУНКЦИЙ N2 ДЛЯ МАСШТАБИРОВАНИЯ И ПОВОРОТА ИЗОБРАЖЕНИЙ //
        // с опорой на высоту строки на первом прогоне и с опорой на Тибетскую букву
        // "B" и на втором прогоне.

        // Масштабирование исходной (не поврежденной поворотом) картинки до размера
        // средней высоты строки, примерно в lineH_St=32 pix. В верх масштабируем
        // бикубиком, в низ билинейным методом масштабирования.
        scale2=lineH_St/lineH;          // scale2=1.0;
        if(fabs(lineH_St - lineH) > 0.2) {  // lineH=lineH*scale2; // 0.2 pix
            if(scale2 > 1.0) {
                img->bicubicGrayScale(scale2);
                if(GrafT) {
                    cout<<"|Функция бикубического масштабирования до размера высоты "
                            "строки в 32 pix, масштаб="<<scale2<<endl;
                }
            } else {
                img->bilinearScale(scale2);
                if(GrafT) {
                    cout<<"|Функция билинейного масштабирования до размера высоты строки "
                            "в 32 pix, масштаб="<<scale2<<endl;
                }
            }
        }
        // Блок функций N2 для определения угла наклона текста и поворота исходного
        // изображения. // Работает с чистой смасштабированной бикубиком исходной
        // картинкой, не поврежденной поворотом. Перед функцией определения угла
        // наклона текста нельзя ставить функцию создания белого бордюра.//
        rotation=img->detectPageAngleB(maxAngle,
                                         Tr1,
                                         BASE);  // угол поворота текста в градусах.
        // По умолчанию максимально возможный определяемый угол в градусах maxAngle=7.
        if((maxAngle * GrafT) > 0)
            cout<<"|Функция  N2 определения угла наклона исходной картинки  "
                    "detectPageAngleB  rotation="
                <<rotation<<endl;
        // Вращение N2 битовой картинки на угол rotation. Коррекция угла наклона
        // текста.
        if(fabs(rotation) >=0.05) {
            /// img->rotateFast(rotation);
            img->BilinearGrayRotate((double)rotation);  // double angle
            if(GrafT > 0)
                cout<<"|Вращение N2 битовой исходной картинки "
                        "BilinearGrayRotate(rotation) на угол rotation="
                    <<rotation<<endl;
        }

        // ОБЩИЙ БЛОК ФУНКЦИЙ ДЛЯ ОБРАБОТКИ И КОРРЕКЦИИ СЕРОГО И Ч.Б. ИЗОБРАЖЕНИЯ //

        // Функции размытия (blur) N1 серого или битового массива bytes_data. //
        img->FilterIntegral(FilterIntegral1);  // восстановление поврежденных штрихов,
                                               // не большая фильтрация белого шума. 3
        if((FilterIntegral1 * GrafT) > 0)
            cout<<"Функция размытия (blur) усредняющим квадратом FilterIntegral1="
                <<FilterIntegral1<<endl;
        img->gaussianF(FilterGauss1);  // восстановление поврежденных и сильно поврежденных
                                       // штрихов (медленнее в 3 раза чем FilterIntal).5
        if((FilterGauss1 * GrafT) > 0)
            cout<<"Функция размытия (blur) массива bytes_data Гауссианом FilterGauss1="
                <<FilterGauss1<<endl;

        // Функция нормализации массива bytes_data по размеру ncolumns кратным 32.//
        // Нужна перед применением многопороговой функция бинаризации binarisationM и
        // сдвиговых функций типа focalLine, dotGain. Если ncolumns не кратно 32, то
        // меняем размер массива так чтобы новый ncolumns был кратен 32 и был не
        // больше прежнего.
        w=img->columns();
        if(w % 32 !=0) {
            img->crop32();
            if(GrafT)
                cout<<"||Функция нормализации crop32 массива bytes_data: старый columns="
                    <<w<<", новый columns="<<img->columns()<<endl;
        }

        // Tr2=0; // ТЕСТ
        ///  Основная адаптивная функция преобразования серого массива в битовый
        ///  массив. ///
        if(Tr2 > 1) {  // если Tr2 указывается, то выподняем binarisationM, иначе
                       // binarisationF.
            // Многопороговая функция преобразования серого массива в битовый массив
            // (адаптивный порог).
            Df=img->binarisationM(Tr1, Tr2, BASE);  // Непосредственно перед применением
                                                      // нужна функция нормализации crop32
            if((graduation * GrafT) > 0) {
                cout<<"Адаптивная функция преобразования серого в ч.б. массив "
                        "binarisationM, Tr1="<<Tr1<<", Tr2="<<Tr2<<", BASE="<<BASE<<endl;
                cout<<"   Функция возвращает среднею толщину штриха по всей исходной "
                        "картинке (float) pix,  Df="<<Df<<endl;
            }
        } else {
            // Функция преобразования серого массива в битовый массив (адаптивный
            // порог).
            img->binarisationF(Tr1, BASE);
            if((graduation * GrafT) > 0)
                cout<<"Адаптивная функция преобразования серого в ч.б. массив "
                        "binarisationF, Tr1="<<Tr1<<", BASE="<<BASE<<endl;
        }

        // Создание белого бордюра шириной в 4 pix по всему периметру графического
        // текста.// Обязательно выполняем перед применением любой из функций типа
        // focalLine. ПРОБЛЕМА если переферия графического текста залита черным, то
        // функция рисует на черном белую рамку, по которой Радон и считает нулевой
        // угол поворота.
        bord=4;
        t=255;  // 255 белое // bord завязать на толщину штриха Df. // bord=Df;    if
                     // ( bord<2 ) bord=2;   if ( bord>16 ) bord=16;
        img->variationBorder(t, bord);  // Функция заполняет значением "uchar t" бордер
                                        // с краев скана. Величина бордер "uchar bord".
        if((bord * GrafT) > 0)
            cout<<"||Функция создания белого бордюра по всему периметру битмапа "
                    "текста, ширина в pix bord="<<(short)bord<<endl;

        // Здесь очень желательно использовать истинное удаление изолированных шумовых
        // черных структур. Существующее удаление 1-2 pix шумовых черных структур
        // удаляет в том числе и 1-2 pix тонкие штрихи.

        // Удаление 1-2 pix шумовых черных структур.
        // Имитация полиграфического растискивания.
        img->dotGain(0, 0, 0, 0, -dltNoise);
        img->dotGain(0, 0, 0, 0, dltNoise);
        if((dltNoise * dltNoise * GrafT) > 0)
            cout<<"Удаление 1-2 pix шумовых черных структур  dltNoise="<<dltNoise<<endl;

        // Функция реставрации сильно поврежденных штрихов букв с уменьшенным числом
        // парамметров: gHor=1 добавляет 1pix по горизонтали,  gVer=1 добавляет 1pix
        // по вертикали (-1 убавляет).
        if(gHor1 || gVer1 || gHor2 ||
           gVer2) {  // проверка отличия любого параметра от нуля с учетом знака.
            // Пересчет горизонтальных и вертикальных параметров растискивания с шагом в
            // 1 pix, в количество поочередно применяемых однопиксельных слоев.
            int gLf1=gHor1/2 + gHor1%2;  int gRg1=gHor1/2;  int gHg1=gVer1/2 + gVer1%2;  int gLw1=gVer1/2;
            int gLf2=gHor2/2 + gHor2%2;  int gRg2=gHor2/2;  int gHg2=gVer2/2 + gVer2%2;  int gLw2=gVer2/2;
            img->dotGain(gLf1, gRg1, gHg1, gLw1, 0);
            img->dotGain(gLf2, gRg2, gHg2, gLw2, 0);
            if(GrafT) {
                cout<<"Функция реставрации сильно поврежденных штрихов букв:"<<endl;
                cout<<"  gLf1="<<gLf1<<"  gRg1="<<gRg1<<"  gHg1="<<gHg1<<"  gLw1="<<gLw1;
                cout<<"      gLf2="<<gLf2<<"  gRg2="<<gRg2<<"  gHg2="<<gHg2<<"  gLw2="<<gLw2<<endl;
            }
        }

        // Функция выравнивания толщины штриха с помощью удаляемых-дабавляемых слоев.
        // Однако сохраняет шумовые точки и затем увеличивает их в размере.
        // Это не быстрая и редко применяемая функция. Замедляется при наличии
        // пиксельных шумов. n_RemovLayers это число удаляемых (аккуратно удаляемых, с
        // сохранение 1 pix конструкций) - дабавляемых слоев.
        img->focalLine(n_RemovLayers);  // одна единица в параметре функции удаляет по одному
                                        // пикселю с каждой стороны т.е. два пикселя, слой.
        img->dotGain(0, 0, 0, 0, (n_RemovLayers * 2));
        if((n_RemovLayers * GrafT) > 0) {
            if(GrafT)
                cout<<"Функция выравнивания толщины штриха с помощью "
                        "удаляемых-дабавляемых слоев  n_RemovLayers="<<n_RemovLayers<<endl;
        }
        // Один удаленный слой (слой это периметр символа т.е. 2 pix) и это 2 единици
        // толщины штриха.

        // Функции размытия (blur) N2 серого или битового массива bytes_data. //
        // синхронизировать с общим списком в 2 местах
        img->FilterIntegral(FilterIntegral2);  // восстановление поврежденных штрихов,
                                               // не большая фильтрация белого шума. 3
        if((FilterIntegral2 * GrafT) > 0)
            cout<<"Функция размытия (blur) N2 скользящим квадратом FilterIntl2="<<FilterIntegral2<<endl;
        img->gaussianF(FilterGauss2);  // восстановление поврежденных и сильно поврежденных
                                       // штрихов (медленнее в 3 раза чем FilterIntal). 5
        if((FilterGauss2 * GrafT) > 0)
            cout<<"Функция размытия (blur) N2 массива bytes_data Гауссианом "
                    "FilterGauss2="<<FilterGauss2<<endl;
        if((FilterGauss2 + FilterIntegral2) > 0) {
            img->binarisationF(Tr1 - 2, BASE);
            if(GrafT)
                cout<<"Адаптивная функция N2 преобразования серого массива в ч.б. "
                        "binarisationF, Tr1="<<Tr1<<", BASE="<<BASE<<endl;
        }

        // Функция вертикального поворота Тибетского графического текста. Меняем
        // местами верх и низ графического текста. mirrorFlag=0 вертикальное
        // зеркальное отражение графического текста, 1 поворот текста на +180°. //
        // time=0.049 Orient=1 вертикальное зеркальное отражение графического текста,
        // 2 поворот текста на +180°.
        img->textVerticalRotation(Orient, &lnOrient, &lnHeight);
        if((Orient * GrafT) > 0) {
            cout<<"Функция вертикального поворота Тибетского графического текста "
                    "lnHeight="<<lnHeight;
            cout<<", lnOrient="<<lnOrient<<endl;
            if(lnOrient==-1)
                cout<<"Функция textVerticalRotation повернула графический текст по "
                        "вертикали"<<endl;
        }

        // Создание белого бордюра шириной в 2 pix по всему периметру графического
        // текста.//

        // БЛОК ВЫХОДНЫХ ФУНКЦИЙ //

        // Приведенная ко входу высота строки.
        // На выходе функции высоты строки lineH приводится к lineH_St с помощью
        // масштаба scale1 и scale2.
        lineH=lineH_St/(scale1 * scale2);  // где lineH_St=31.3 стандартная
                                               // (желательная) высота строки в pix.
        // Применяется для измерения высоты строки с помощью Тибетской буквы "B" уже в
        // JavaScript и полученный масштаб используется для запуска основного batch
        // всех страниц книги.

        // Сохраняем значение высоты строки, приведенной ко входу.
        int  s=(int)(lineH * 1000);
        char buf[10];
        sprintf(buf, "%d", s);
        inputData.data["lineH"]=buf;
        img->colorModeOut=1;

        if(GrafT)
            cout<<"Выходные значения   img->columns()="<<img->columns()
                <<"  img->rows()="<<img->rows()<<"  lineH="<<lineH<<endl;
        //*
        // На выходе функциии получаем оптимально обработанный и бинаризованный
        // графический текст для дальнейшего распознования.
        //*/

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        if(GrafT) { TIME_PRINT_ }

        return (void *)img;
    }


//----------------------------------------------------------------------------------

/*
 // для отладки.
 // Вычисление "D" необходимого количества слоев растискивания для получения защитной маски.
 int Dg=3; // где 3 эмпирический коэффициент.
 int gRateLefts, gRateRight, gRateHighs, gRateLower;
 // Пересчет толщины штриха "D" в количество поочередно применяемых однопиксельных слоев с шагом в 1 pix.
 gRateLefts=Dg/2 + Dg%2;         gRateHighs=gRateLefts;
 gRateRight=Dg/2;                gRateLower=gRateRight;
 img->dotGain(gRateLefts, gRateRight, gRateHighs, gRateLower, 0);
 cout<<"gRateLefts="<<gRateLefts<<"   gRateRight="<<gRateRight<<"   gRateHighs="<<gRateHighs<<"   gRateLower="<<gRateLower<<endl;
 Dg=-2; // где 3 эмпирический коэффициент.
 // Пересчет толщины штриха "D" в количество поочередно применяемых однопиксельных слоев с шагом в 1 pix.
 gRateLefts=Dg/2 + Dg%2;         gRateHighs=gRateLefts;
 gRateRight=Dg/2;                gRateLower=gRateRight;
 img->dotGain(gRateLefts, gRateRight, gRateHighs, gRateLower, 0);
 cout<<"gRateLefts="<<gRateLefts<<"   gRateRight="<<gRateRight<<"   gRateHighs="<<gRateHighs<<"   gRateLower="<<gRateLower<<endl;
 //*/

//---------------

/*
 // БОЛЬШОЙ БЛОК для отладка взаимодействия функции dotGain() с 1-2 pix шумовыми структурами.
 // Работает с картинкой test_1-2pix.tif тестовые черные шумовые pix на белом фоне, картинка 150х200.
 
 img->binarisation64();
 
 // Функция нормализации массива bytes_data по размеру ncolumns кратным 32.//
 // Нужна перед применением многопороговой функция бинаризации binarisationM и сдвиговых функций типа focalLine, dotGain.
 // Если ncolumns не кратно 32, то меняем размер массива так чтобы новый ncolumns был кратен 32 и был не больше прежнего.
 int w_=img->columns();
 if(w_%32 != 0) {
 img->crop32();
 if (GrafT) cout<<"||Функция нормализации crop32 массива bytes_data: старый columns="<<w_<<", новый columns="<<img->columns()<<endl;
 }
 
 // Удаление 1-2 pix шумовых черных структур.
 // Имитация полиграфического растискивания.
 img->dotGain( 0, 0, 0, 0, -dltNoise );
 img->dotGain( 0, 0, 0, 0,  dltNoise );
 if ((dltNoise*dltNoise*GrafT)>0) cout<<"Удаление 1-2 pix шумовых черных структур  dltNoise="<<dltNoise<<endl;
 
 // Функция реставрации сильно поврежденных штрихов букв с уменьшенным числом парамметров:
 // может закрывать  1-2 pix дырки и разрывы в черном
 // gHor=1 добавляет 1pix по горизонтали,  gVer=1 добавляет 1pix по вертикали (-1 убавляет).
 if(gHor1 || gVer1 || gHor2 || gVer2) { // проверка отличия любого параметра от нуля с учетом знака.
 // Пересчет горизонтальных и вертикальных параметров растискивания с шагом в 1 pix,
 // в количество поочередно применяемых однопиксельных слоев.
 int gLf1=gHor1/2 + gHor1%2;    int gRg1=gHor1/2;    int gHg1=gVer1/2 + gVer1%2;    int gLw1=gVer1/2;
 int gLf2=gHor2/2 + gHor2%2;    int gRg2=gHor2/2;    int gHg2=gVer2/2 + gVer2%2;    int gLw2=gVer2/2;
 img->dotGain(gLf1, gRg1, gHg1, gLw1, 0);
 img->dotGain(gLf2, gRg2, gHg2, gLw2, 0);
 if(GrafT){ cout<<"Функция реставрации сильно поврежденных штрихов букв:"<<endl;
 cout<<"  gLf1="<<gLf1<<"  gRg1="<<gRg1<<"  gHg1="<<gHg1<<"  gLw1="<<gLw1;
 cout<<"      gLf2="<<gLf2<<"  gRg2="<<gRg2<<"  gHg2="<<gHg2<<"  gLw2="<<gLw2<<endl;
 }
 }
 //*/
//---------------


//----------------------------------------------------------------------------------

// ВСЕ ОТЛАЖЕННЫЕ И ПРОВЕРЕНЫЕ ТЕСТЫ НАХОДЯТСЯ ТОЛЬКО В workCode.h
// то что ниже - это материал для тестов отдельных функций.

/*
 
 /// исходники
 // СЕРЫЕ ТЕСТЫ.
 
 ////inputPath="/_Image2OCR/___WORK_DATA/_TEST_BINARY/__Page_09___.png";
 //        Tr1=99; Tr2=96; BASE=14; // Комментарии: time=3 // 4 печа, блекло и сильный блюр, перетяжки сильно размыты.
 
 ////inputPath="/_Image2OCR/___WORK_DATA/_TEST_BINARY/ri_rdzong_tshul_khrims_nyi_ma'i_rnam_thar_R1451681842.jpg";
 //        Tr1=92; Tr2=88; BASE=14;   gLf1=1, gRg1=1, gHg1=2, gLw1=2, d_gain1=0;    gLf2=-1, gRg2=-1, gHg2=-1, gLw2=-1, d_gain2=0;
 // Комментарии: bicubicGrayScale(2.0); Tr2=86-92; // Фон, буквы не равномерно и сильно повр, эррозия штрихов, вплоть до отдельных точек.
 
 ////inputPath="/_Image2OCR/___WORK_DATA/_TEST_BINARY/ras_chung_rdo_rje_grags_pa'i_rnam_thar_rags_bsdus_mgur_rnam_R1451688988.jpg";
 //        Tr1=98; Tr2=76; BASE=14;    gLf1=1, gRg1=1, gHg1=2, gLw1=2, d_gain1=0;    gLf2=-1, gRg2=-1, gHg2=-1, gLw2=-1, d_gain2=0;
 // Комментарии: time=0.93  // Серый фон, буквы не равномерно и сильно повреждены, эррозия штрихов, вплоть до отдельных точек.
 
 /////inputPath="/_Image2OCR/___WORK_DATA/_TEST_BINARY/brag_dgon_mchog_dga'_gling_gi_lo_rgyus_dkar_chag_R1451636538.jpg";
 //        Tr1=99; Tr2=68; BASE=14;    gLf1=0, gRg1=0, gHg1=2, gLw1=2, d_gain1=0;    gLf2=-0, gRg2=0, gHg2=-1, gLw2=-1, d_gain2=0;
 // Комментарии: Scale(4.0); time=0.84 // Сильный фон, маленькие буквы, перетяжки в 1-2 pix почти сливаются с фоном.
 
 ///inputPath="/_Image2OCR/___WORK_DATA/_TEST_BINARY/rgya_mtsho_mtha'_yas_skor_jpg.jpg";
 //        Tr1=99; Tr2=92; BASE=14;    gLf1=1, gRg1=1, gHg1=2, gLw1=2, d_gain1=0;    gLf2=-1, gRg2=-1, gHg2=-1, gLw2=-1, d_gain2=0;
 // Комментарии: bicubicGrayScale(2.0); Tr2=97-98;   time=1.08 // Очень сильный фон, очень маленькие буквы
 
 
 // Ч.Б. ТЕСТЫ. исходники
 
 ///inputPath="/_Image2OCR/___WORK_DATA/_TEST_BINARY/rdo_rje_nyi_ma'i_gnas_yig_gsang_ba'i_dkar_chag.tif";
 //        Tr1=98; Tr2=90; BASE=14;    gLf1=0, gRg1=0, gHg1=0, gLw1=0, d_gain1=-2;  dlt=1;   gLf2=0, gRg2=0, gHg2=0, gLw2=0, d_gain2=2;
 // Комментарии: Tr2=97-92;  time=1.16
 
 ///inputPath="/_Image2OCR/___WORK_DATA/_TEST_BINARY/rdo_rje_nag_po_chen_po'i_gtor_ma'i_zab_tig.tif";
 //        FilterGauss1=3; Tr1=98; Tr2=25; BASE=14;  dlt=1;
 //        gLf1=0, gRg1=0, gHg1=0, gLw1=0, d_gain1=2;    gLf2=0, gRg2=0, gHg2=0, gLw2=0, d_gain2=-2;
 // Комментарии:  time=2.7
 
 ///inputPath="/_Image2OCR/___WORK_DATA/_TEST_BINARY/rgyud_bzhi_zung_cu_ze_par_ma.tif";
 //        FilterGauss1=3; Tr1=98; Tr2=85; BASE=14;  dlt=1;
 //        gLf1=0, gRg1=0, gHg1=2, gLw1=2, d_gain1=0;    gLf2=0, gRg2=0, gHg2=0, gLw2=0, d_gain2=-1;  n_RemovLayers=1;
 // Комментарии: bicubicGrayScale(2.0); time=1.88
 
 
 
 ///    param="fileList=/_Image2OCR/rang_nyid_ngo_sprod_.tif ocrData=preview"; ///////////////////////////////////
 // Комментарии: тест буквы "B". Немного наклоненный, большои и качественный текст. Масштабируется с уменьшением.
 
 
 //----------------------------------------------------------------------------------
 
 /// ТЕКУЩИЕ РАБОЧИЕ ТЕСТЫ ДЛЯ ОТЛАДКИ ОТДЕЛЬНЫХ ФУНКЦИЙ исходники ///
 
 //if(TEST)inputPath="/_Image2OCR/_1Draw_pix1.jpg";      // 1024*1024 pixels
 //if(!TEST)inputPath="/_Image2OCR/_1Draw_text.jpg";
 //inputPath="/_Image2OCR/_2Draw_focal_lines_text.tif";        // точка , картинка 16*16
 //////inputPath="/_Image2OCR/_1Draw_pix32.jpg";                 // 1 pix точка координаты 16*16, картинка 32*64//////
 //////    inputPath="/_Image2OCR/_1pix line_32*32.jpg";               // 1 pix горизонтальная линия, картинка 32*32//////
 //inputPath="/_Image2OCR/_2Draw_start_line.jpg";        // текст
 //inputPath="/_Image2OCR/_1Draw_pix32_.jpg";            // прямоугольного размера
 ///inputPath="/_Image2OCR/__DOT_Page_074.jpg";       // 618 × 880 pixels сер // 4, 4 binarisationG 97, 6 // жесткий вар 99, 3
 //////inputPath="/_Image2OCR/__Page_09___.png"; // ПОРОГ адаптивная яркость // 0, 0 binarisationG 97, 4 // жесткий вар 99, 3 TEST ////////////@
 //inputPath="/_Image2OCR/__Page_09___ no_line.png"; // ПОРОГ адаптивная яркость // 0, 0 binarisationG 97, 4 // без рамок 3 //////
 //inputPath="/_Image2OCR/__sl1.tif";                            // адаптивная яркость tif разворот //////
 
 /////    inputPath="/_Image2OCR/_1Draw_text.jpg";                   // много случайных точек
 //inputPath="/_Image2OCR/__invaders_03_input.jpg";          // рога
 //inputPath="/_Image2OCR/_1Draw_letter.jpg";                // лямбда 192x192 pixels
 
 //inputPath="/_Image2OCR/_1Draw_pix32.jpg";      // 32*64        1pix 16*16
 ///string inputPath="/_Image2OCR/_1Draw_pix32_2.jpg";   // 32*64        2pix 16*16 и 12*10 // x*y
 //inputPath="/_Image2OCR/_2Draw_start_line_197*197.jpg";                   // w_h=197*197  не кратный 8
 //inputPath="/_Image2OCR/_2Draw_start_line_193*193.jpg";                   // w_h=193*193  не кратный 8
 //inputPath="/_Image2OCR/_2Draw_start_line_195*195.jpg";                   // w_h=195*195  не кратный 8
 //inputPath="/_Image2OCR/_2Draw_start_line_190*190.jpg";                   // w_h=190*190  не кратный 8
 //inputPath="/_TEST_OCR_graf_/_bon.jpg";                  // качественный текст
 //inputPath="/_TEST_OCR_graf_/_TEST_LINE/___ocr.tif";     // 3 тиб буквы к
 //inputPath="/_TEST_OCR_graf_/_TEST_LINE/___ocr1.jpg";         // толщиной в один пиксел
 //inputPath="/_Image2OCR/page_0002.tif";                  // обложка
 //inputPath="/_Image2OCR/_2Draw_5.jpg";                 // длинная кривая толщиной в несколько пикселей
 //////    inputPath="/_Image2OCR/33.tif";                       // прямоугольник толщиной в несколько пикселей
 //////inputPath="/_Image2OCR/___1Draw_bicubic++.jpg";                      // весь текст толщиной в 1 пиксель по новому алгоритму //////
 //inputPath="/_Image2OCR/page_0000001_img_test_draw.jpeg";          // тест макета
 
 //*/

//----------------------------------------------------------------------------------

